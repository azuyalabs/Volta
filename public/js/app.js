webpackJsonp([22],{

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/apexcharts/dist/apexcharts.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(setImmediate, module) {/*!
 * ApexCharts v3.8.2
 * (c) 2018-2019 Juned Chhipa
 * Released under the MIT License.
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/*
 ** Generic functions which are not dependent on ApexCharts
 */
var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, [{
    key: "shadeRGBColor",
    value: function shadeRGBColor(percent, color) {
      var f = color.split(','),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = parseInt(f[0].slice(4)),
          G = parseInt(f[1]),
          B = parseInt(f[2]);
      return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';
    }
  }, {
    key: "shadeHexColor",
    value: function shadeHexColor(percent, color) {
      var f = parseInt(color.slice(1), 16),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = f >> 16,
          G = f >> 8 & 0x00ff,
          B = f & 0x0000ff;
      return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
    } // beautiful color shading blending code
    // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors

  }, {
    key: "shadeColor",
    value: function shadeColor(p, color) {
      if (color.length > 7) return this.shadeRGBColor(p, color);else return this.shadeHexColor(p, color);
    }
  }], [{
    key: "bind",
    value: function bind(fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    }
  }, {
    key: "isObject",
    value: function isObject(item) {
      return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;
    }
  }, {
    key: "listToArray",
    value: function listToArray(list) {
      var i,
          array = [];

      for (i = 0; i < list.length; i++) {
        array[i] = list[i];
      }

      return array;
    } // to extend defaults with user options
    // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873

  }, {
    key: "extend",
    value: function extend(target, source) {
      var _this = this;

      if (typeof Object.assign !== 'function') {

        (function () {
          Object.assign = function (target) {

            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              var _source = arguments[index];

              if (_source !== undefined && _source !== null) {
                for (var nextKey in _source) {
                  if (_source.hasOwnProperty(nextKey)) {
                    output[nextKey] = _source[nextKey];
                  }
                }
              }
            }

            return output;
          };
        })();
      }

      var output = Object.assign({}, target);

      if (this.isObject(target) && this.isObject(source)) {
        Object.keys(source).forEach(function (key) {
          if (_this.isObject(source[key])) {
            if (!(key in target)) {
              Object.assign(output, _defineProperty({}, key, source[key]));
            } else {
              output[key] = _this.extend(target[key], source[key]);
            }
          } else {
            Object.assign(output, _defineProperty({}, key, source[key]));
          }
        });
      }

      return output;
    }
  }, {
    key: "extendArray",
    value: function extendArray(arrToExtend, resultArr) {
      var extendedArr = [];
      arrToExtend.map(function (item) {
        extendedArr.push(Utils.extend(resultArr, item));
      });
      arrToExtend = extendedArr;
      return arrToExtend;
    } // If month counter exceeds 12, it starts again from 1

  }, {
    key: "monthMod",
    value: function monthMod(month) {
      return month % 12;
    }
  }, {
    key: "addProps",
    value: function addProps(obj, arr, val) {
      if (typeof arr === 'string') {
        arr = arr.split('.');
      }

      obj[arr[0]] = obj[arr[0]] || {};
      var tmpObj = obj[arr[0]];

      if (arr.length > 1) {
        arr.shift();
        this.addProps(tmpObj, arr, val);
      } else {
        obj[arr[0]] = val;
      }

      return obj;
    }
  }, {
    key: "clone",
    value: function clone(source) {
      if (Object.prototype.toString.call(source) === '[object Array]') {
        var cloneResult = [];

        for (var i = 0; i < source.length; i++) {
          cloneResult[i] = this.clone(source[i]);
        }

        return cloneResult;
      } else if (_typeof(source) === 'object') {
        var _cloneResult = {};

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            _cloneResult[prop] = this.clone(source[prop]);
          }
        }

        return _cloneResult;
      } else {
        return source;
      }
    }
  }, {
    key: "log10",
    value: function log10(x) {
      return Math.log(x) / Math.LN10;
    }
  }, {
    key: "roundToBase10",
    value: function roundToBase10(x) {
      return Math.pow(10, Math.floor(Math.log10(x)));
    }
  }, {
    key: "roundToBase",
    value: function roundToBase(x, base) {
      return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));
    }
  }, {
    key: "parseNumber",
    value: function parseNumber(val) {
      if (val === null) return val;
      return parseFloat(val);
    }
  }, {
    key: "noExponents",
    value: function noExponents(val) {
      var data = String(val).split(/[eE]/);
      if (data.length == 1) return data[0];
      var z = '',
          sign = val < 0 ? '-' : '',
          str = data[0].replace('.', ''),
          mag = Number(data[1]) + 1;

      if (mag < 0) {
        z = sign + '0.';

        while (mag++) {
          z += '0';
        }

        return z + str.replace(/^\-/, '');
      }

      mag -= str.length;

      while (mag--) {
        z += '0';
      }

      return str + z;
    }
  }, {
    key: "getDimensions",
    value: function getDimensions(el) {
      var computedStyle = getComputedStyle(el);
      var ret = [];
      var elementHeight = el.clientHeight;
      var elementWidth = el.clientWidth;
      elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
      elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
      ret.push(elementWidth);
      ret.push(elementHeight);
      return ret;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var rect = element.getBoundingClientRect();
      return {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      };
    } // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275

  }, {
    key: "hexToRgba",
    value: function hexToRgba() {
      var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';
      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;

      if (hex.substring(0, 1) !== '#') {
        hex = '#999999';
      }

      var h = hex.replace('#', '');
      h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));

      for (var i = 0; i < h.length; i++) {
        h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);
      }

      if (typeof opacity !== 'undefined') h.push(opacity);
      return 'rgba(' + h.join(',') + ')';
    }
  }, {
    key: "getOpacityFromRGBA",
    value: function getOpacityFromRGBA(rgba) {
      rgba = rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgba[3];
    }
  }, {
    key: "rgb2hex",
    value: function rgb2hex(rgb) {
      rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
    }
  }, {
    key: "isColorHex",
    value: function isColorHex(color) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    }
  }, {
    key: "polarToCartesian",
    value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
      };
    }
  }, {
    key: "escapeString",
    value: function escapeString(str) {
      var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var newStr = str.toString().slice();
      newStr = newStr.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, escapeWith);
      return newStr;
    }
  }, {
    key: "negToZero",
    value: function negToZero(val) {
      return val < 0 ? 0 : val;
    }
  }, {
    key: "moveIndexInArray",
    value: function moveIndexInArray(arr, old_index, new_index) {
      if (new_index >= arr.length) {
        var k = new_index - arr.length + 1;

        while (k--) {
          arr.push(undefined);
        }
      }

      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
      return arr;
    }
  }, {
    key: "extractNumber",
    value: function extractNumber(s) {
      return parseFloat(s.replace(/[^\d\.]*/g, ''));
    }
  }, {
    key: "randomString",
    value: function randomString(len) {
      var text = '';
      var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

      for (var i = 0; i < len; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }

      return text;
    }
  }, {
    key: "findAncestor",
    value: function findAncestor(el, cls) {
      while ((el = el.parentElement) && !el.classList.contains(cls)) {
      }

      return el;
    }
  }, {
    key: "setELstyles",
    value: function setELstyles(el, styles) {
      for (var key in styles) {
        if (styles.hasOwnProperty(key)) {
          el.style.key = styles[key];
        }
      }
    }
  }, {
    key: "isNumber",
    value: function isNumber(value) {
      return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));
    }
  }, {
    key: "isFloat",
    value: function isFloat(n) {
      return Number(n) === n && n % 1 !== 0;
    }
  }, {
    key: "isSafari",
    value: function isSafari() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
  }, {
    key: "isFirefox",
    value: function isFirefox() {
      return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    }
  }, {
    key: "isIE11",
    value: function isIE11() {
      if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) {
        return true;
      }
    }
  }, {
    key: "isIE",
    value: function isIE() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf('MSIE ');

      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('Trident/');

      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('Edge/');

      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      } // other browser


      return false;
    }
  }]);

  return Utils;
}();

/**
 * ApexCharts Filters Class for setting hover/active states on the paths.
 *
 * @module Formatters
 **/

var Filters =
/*#__PURE__*/
function () {
  function Filters(ctx) {
    _classCallCheck(this, Filters);

    this.ctx = ctx;
    this.w = ctx.w;
  } // create a re-usable filter which can be appended other filter effects and applied to multiple elements


  _createClass(Filters, [{
    key: "getDefaultFilter",
    value: function getDefaultFilter(el, i) {
      var w = this.w;
      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');

      if (w.config.states.normal.filter !== 'none') {
        this.applyFilter(el, i, w.config.states.normal.filter.type, w.config.states.normal.filter.value);
      } else {
        if (w.config.chart.dropShadow.enabled) {
          this.dropShadow(el, w.config.chart.dropShadow, i);
        }
      }
    }
  }, {
    key: "addNormalFilter",
    value: function addNormalFilter(el, i) {
      var w = this.w;

      if (w.config.chart.dropShadow.enabled) {
        this.dropShadow(el, w.config.chart.dropShadow, i);
      }
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addLightenFilter",
    value: function addLightenFilter(el, i, attrs) {
      var _this = this;

      var w = this.w;
      var intensity = attrs.intensity;

      if (Utils.isFirefox()) {
        return;
      }

      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowAttr = w.config.chart.dropShadow;

        if (shadowAttr.enabled) {
          filter = _this.addShadow(add, i, shadowAttr);
        } else {
          filter = add;
        }

        filter.componentTransfer({
          rgb: {
            type: 'linear',
            slope: 1.5,
            intercept: intensity
          }
        });
      });
      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addDarkenFilter",
    value: function addDarkenFilter(el, i, attrs) {
      var _this2 = this;

      var w = this.w;
      var intensity = attrs.intensity;

      if (Utils.isFirefox()) {
        return;
      }

      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowAttr = w.config.chart.dropShadow;

        if (shadowAttr.enabled) {
          filter = _this2.addShadow(add, i, shadowAttr);
        } else {
          filter = add;
        }

        filter.componentTransfer({
          rgb: {
            type: 'linear',
            slope: intensity
          }
        });
      });
      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
    }
  }, {
    key: "applyFilter",
    value: function applyFilter(el, i, filter) {
      var intensity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;

      switch (filter) {
        case 'none':
          {
            this.addNormalFilter(el, i);
            break;
          }

        case 'lighten':
          {
            this.addLightenFilter(el, i, {
              intensity: intensity
            });
            break;
          }

        case 'darken':
          {
            this.addDarkenFilter(el, i, {
              intensity: intensity
            });
            break;
          }

        default:
          // do nothing
          break;
      }
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addShadow",
    value: function addShadow(add, i, attrs) {
      var blur = attrs.blur,
          top = attrs.top,
          left = attrs.left,
          color = attrs.color,
          opacity = attrs.opacity;
      var shadowBlur = add.flood(Array.isArray(color) ? color[i] : color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);
      return add.blend(add.source, shadowBlur);
    } // directly adds dropShadow to the element and returns the same element.
    // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow

  }, {
    key: "dropShadow",
    value: function dropShadow(el, attrs) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var top = attrs.top,
          left = attrs.left,
          blur = attrs.blur,
          color = attrs.color,
          opacity = attrs.opacity,
          noUserSpaceOnUse = attrs.noUserSpaceOnUse;
      var w = this.w;
      el.unfilter(true);

      if (Utils.isIE() && w.config.chart.type === 'radialBar') {
        // in radialbar charts, dropshadow is clipping actual drawing in IE
        return el;
      }

      color = Array.isArray(color) ? color[i] : color;
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowBlur = null;

        if (Utils.isSafari() || Utils.isFirefox() || Utils.isIE()) {
          // safari/firefox has some alternative way to use this filter
          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur);
        } else {
          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);
        }

        add.blend(add.source, shadowBlur);
      });

      if (!noUserSpaceOnUse) {
        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
      }

      return el;
    }
  }, {
    key: "setSelectionFilter",
    value: function setSelectionFilter(el, realIndex, dataPointIndex) {
      var w = this.w;

      if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {
        if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {
          el.node.setAttribute('selected', true);
          var activeFilter = w.config.states.active.filter;

          if (activeFilter !== 'none') {
            this.applyFilter(el, realIndex, activeFilter.type, activeFilter.value);
          }
        }
      }
    }
  }]);

  return Filters;
}();

/**
 * ApexCharts Animation Class.
 *
 * @module Animations
 **/

var Animations =
/*#__PURE__*/
function () {
  function Animations(ctx) {
    _classCallCheck(this, Animations);

    this.ctx = ctx;
    this.w = ctx.w;
    this.setEasingFunctions();
  }

  _createClass(Animations, [{
    key: "setEasingFunctions",
    value: function setEasingFunctions() {
      var easing;
      var userDefinedEasing = this.w.config.chart.animations.easing;

      switch (userDefinedEasing) {
        case 'linear':
          {
            easing = '-';
            break;
          }

        case 'easein':
          {
            easing = '<';
            break;
          }

        case 'easeout':
          {
            easing = '>';
            break;
          }

        case 'easeinout':
          {
            easing = '<>';
            break;
          }

        case 'swing':
          {
            easing = function easing(pos) {
              var s = 1.70158;
              return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
            };

            break;
          }

        case 'bounce':
          {
            easing = function easing(pos) {
              if (pos < 1 / 2.75) {
                return 7.5625 * pos * pos;
              } else if (pos < 2 / 2.75) {
                return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
              } else if (pos < 2.5 / 2.75) {
                return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
              } else {
                return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
              }
            };

            break;
          }

        case 'elastic':
          {
            easing = function easing(pos) {
              if (pos === !!pos) return pos;
              return Math.pow(2, -10 * pos) * Math.sin((pos - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };

            break;
          }

        default:
          {
            easing = '<>';
          }
      }

      this.w.globals.easing = easing;
    }
  }, {
    key: "animateLine",
    value: function animateLine(el, from, to, speed) {
      el.attr(from).animate(speed).attr(to);
    }
    /*
     ** Animate radius of a circle element
     */

  }, {
    key: "animateCircleRadius",
    value: function animateCircleRadius(el, from, to, speed, easing) {
      if (!from) from = 0;
      el.attr({
        r: from
      }).animate(speed, easing).attr({
        r: to
      });
    }
    /*
     ** Animate radius and position of a circle element
     */

  }, {
    key: "animateCircle",
    value: function animateCircle(el, from, to, speed, easing) {
      el.attr({
        r: from.r,
        cx: from.cx,
        cy: from.cy
      }).animate(speed, easing).attr({
        r: to.r,
        cx: to.cx,
        cy: to.cy
      });
    }
    /*
     ** Animate rect properties
     */

  }, {
    key: "animateRect",
    value: function animateRect(el, from, to, speed, fn) {
      el.attr(from).animate(speed).attr(to).afterAll(function () {
        fn();
      });
    }
  }, {
    key: "animatePathsGradually",
    value: function animatePathsGradually(params) {
      var el = params.el,
          j = params.j,
          pathFrom = params.pathFrom,
          pathTo = params.pathTo,
          speed = params.speed,
          delay = params.delay,
          strokeWidth = params.strokeWidth;
      var me = this;
      var w = this.w;
      var delayFactor = 0;

      if (w.config.chart.animations.animateGradually.enabled) {
        delayFactor = w.config.chart.animations.animateGradually.delay;
      }

      if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged) {
        delayFactor = 0;
      }

      me.morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay * delayFactor);
    }
  }, {
    key: "showDelayedElements",
    value: function showDelayedElements() {
      this.w.globals.delayedElements.forEach(function (d) {
        var ele = d.el;
        ele.classList.remove('hidden');
      });
    } // SVG.js animation for morphing one path to another

  }, {
    key: "morphSVG",
    value: function morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay) {
      var _this = this;

      var w = this.w;

      if (!pathFrom) {
        pathFrom = el.attr('pathFrom');
      }

      if (!pathTo) {
        pathTo = el.attr('pathTo');
      }

      if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {
        pathFrom = "M 0 ".concat(w.globals.gridHeight);
        speed = 1;
      }

      if (pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {
        pathTo = "M 0 ".concat(w.globals.gridHeight);
        speed = 1;
      }

      if (!w.globals.shouldAnimate) {
        speed = 1;
      }

      el.plot(pathFrom).animate(1, w.globals.easing, delay).plot(pathFrom).animate(speed, w.globals.easing, delay).plot(pathTo).afterAll(function () {
        // a flag to indicate that the original mount function can return true now as animation finished here
        if (Utils.isNumber(j)) {
          if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {
            w.globals.animationEnded = true;
          }
        } else if (w.globals.shouldAnimate) {
          w.globals.animationEnded = true;

          if (typeof w.config.chart.events.animationEnd === 'function') {
            w.config.chart.events.animationEnd(_this.ctx, w);
          }
        }

        _this.showDelayedElements();
      });
    }
  }]);

  return Animations;
}();

/**
 * ApexCharts Graphics Class for all drawing operations.
 *
 * @module Graphics
 **/

var Graphics =
/*#__PURE__*/
function () {
  function Graphics(ctx) {
    _classCallCheck(this, Graphics);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Graphics, [{
    key: "drawLine",
    value: function drawLine(x1, y1, x2, y2) {
      var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';
      var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var w = this.w;
      var line = w.globals.dom.Paper.line().attr({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        stroke: lineColor,
        'stroke-dasharray': dashArray,
        'stroke-width': strokeWidth
      });
      return line;
    }
  }, {
    key: "drawRect",
    value: function drawRect() {
      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';
      var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
      var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
      var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var w = this.w;
      var rect = w.globals.dom.Paper.rect();
      rect.attr({
        x: x1,
        y: y1,
        width: x2 > 0 ? x2 : 0,
        height: y2 > 0 ? y2 : 0,
        rx: radius,
        ry: radius,
        fill: color,
        opacity: opacity,
        'stroke-width': strokeWidth !== null ? strokeWidth : 0,
        stroke: strokeColor !== null ? strokeColor : 'none',
        'stroke-dasharray': strokeDashArray
      });
      return rect;
    }
  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonString) {
      var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';
      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';
      var w = this.w;
      var polygon = w.globals.dom.Paper.polygon(polygonString).attr({
        fill: fill,
        stroke: stroke
      });
      return polygon;
    }
  }, {
    key: "drawCircle",
    value: function drawCircle(radius) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var w = this.w;
      var c = w.globals.dom.Paper.circle(radius * 2);

      if (attrs !== null) {
        c.attr(attrs);
      }

      return c;
    }
  }, {
    key: "drawPath",
    value: function drawPath(_ref) {
      var _ref$d = _ref.d,
          d = _ref$d === void 0 ? '' : _ref$d,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
          fill = _ref.fill,
          _ref$fillOpacity = _ref.fillOpacity,
          fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          classes = _ref.classes,
          _ref$strokeLinecap = _ref.strokeLinecap,
          strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,
          _ref$strokeDashArray = _ref.strokeDashArray,
          strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;
      var w = this.w;

      if (strokeLinecap === null) {
        strokeLinecap = w.config.stroke.lineCap;
      }

      if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {
        d = "M 0 ".concat(w.globals.gridHeight);
      }

      var p = w.globals.dom.Paper.path(d).attr({
        fill: fill,
        'fill-opacity': fillOpacity,
        stroke: stroke,
        'stroke-opacity': strokeOpacity,
        'stroke-linecap': strokeLinecap,
        'stroke-width': strokeWidth,
        'stroke-dasharray': strokeDashArray,
        class: classes
      });
      return p;
    }
  }, {
    key: "group",
    value: function group() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var w = this.w;
      var g = w.globals.dom.Paper.group();

      if (attrs !== null) {
        g.attr(attrs);
      }

      return g;
    }
  }, {
    key: "move",
    value: function move(x, y) {
      var move = ['M', x, y].join(' ');
      return move;
    }
  }, {
    key: "line",
    value: function line(x, y) {
      var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var line = null;

      if (hORv === null) {
        line = ['L', x, y].join(' ');
      } else if (hORv === 'H') {
        line = ['H', x].join(' ');
      } else if (hORv === 'V') {
        line = ['V', y].join(' ');
      }

      return line;
    }
  }, {
    key: "curve",
    value: function curve(x1, y1, x2, y2, x, y) {
      var curve = ['C', x1, y1, x2, y2, x, y].join(' ');
      return curve;
    }
  }, {
    key: "quadraticCurve",
    value: function quadraticCurve(x1, y1, x, y) {
      var curve = ['Q', x1, y1, x, y].join(' ');
      return curve;
    }
  }, {
    key: "arc",
    value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {
      var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      var coord = 'A';
      if (relative) coord = 'a';
      var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');
      return arc;
    }
    /**
     * @memberof Graphics
     * @param {object}
     *  i = series's index
     *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating "i" may change in loops, but realIndex doesn't
     *  pathFrom = existing pathFrom to animateTo
     *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo
     *  stroke = line Color
     *  strokeWidth = width of path Line
     *  fill = it can be gradient, single color, pattern or image
     *  animationDelay = how much to delay when starting animation (in milliseconds)
     *  dataChangeSpeed = for dynamic animations, when data changes
     *  className = class attribute to add
     * @return {object} svg.js path object
     **/

  }, {
    key: "renderPaths",
    value: function renderPaths(_ref2) {
      var i = _ref2.i,
          j = _ref2.j,
          realIndex = _ref2.realIndex,
          pathFrom = _ref2.pathFrom,
          pathTo = _ref2.pathTo,
          stroke = _ref2.stroke,
          strokeWidth = _ref2.strokeWidth,
          strokeLinecap = _ref2.strokeLinecap,
          fill = _ref2.fill,
          animationDelay = _ref2.animationDelay,
          initialSpeed = _ref2.initialSpeed,
          dataChangeSpeed = _ref2.dataChangeSpeed,
          className = _ref2.className,
          id = _ref2.id,
          _ref2$shouldClipToGri = _ref2.shouldClipToGrid,
          shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,
          _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,
          bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat,
          _ref2$drawShadow = _ref2.drawShadow,
          drawShadow = _ref2$drawShadow === void 0 ? true : _ref2$drawShadow;
      var w = this.w;
      var filters = new Filters(this.ctx);
      var anim = new Animations(this.ctx);
      var initialAnim = this.w.config.chart.animations.enabled;
      var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      var d;
      var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);

      if (shouldAnimate) {
        d = pathFrom;
      } else {
        d = pathTo;
        this.w.globals.animationEnded = true;
      }

      var strokeDashArrayOpt = w.config.stroke.dashArray;
      var strokeDashArray = 0;

      if (Array.isArray(strokeDashArrayOpt)) {
        strokeDashArray = strokeDashArrayOpt[realIndex];
      } else {
        strokeDashArray = w.config.stroke.dashArray;
      }

      var el = this.drawPath({
        d: d,
        stroke: stroke,
        strokeWidth: strokeWidth,
        fill: fill,
        fillOpacity: 1,
        classes: className,
        strokeLinecap: strokeLinecap,
        strokeDashArray: strokeDashArray
      });
      el.attr('id', "".concat(id, "-").concat(i));
      el.attr('index', realIndex);

      if (shouldClipToGrid) {
        el.attr({
          'clip-path': "url(#gridRectMask".concat(w.globals.cuid, ")")
        });
      } // const defaultFilter = el.filterer


      if (w.config.states.normal.filter.type !== 'none') {
        filters.getDefaultFilter(el, realIndex);
      } else {
        if (w.config.chart.dropShadow.enabled && drawShadow) {
          if (!w.config.chart.dropShadow.enabledSeries || w.config.chart.dropShadow.enabledSeries && w.config.chart.dropShadow.enabledSeries.indexOf(realIndex) !== -1) {
            var shadow = w.config.chart.dropShadow;
            filters.dropShadow(el, shadow, realIndex);
          }
        }
      }

      if (bindEventsOnPaths) {
        el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));
        el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));
        el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));
      }

      el.attr({
        pathTo: pathTo,
        pathFrom: pathFrom
      });
      var defaultAnimateOpts = {
        el: el,
        j: j,
        pathFrom: pathFrom,
        pathTo: pathTo,
        strokeWidth: strokeWidth
      };

      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {
          speed: initialSpeed,
          delay: animationDelay
        }));
      } else {
        if (w.globals.resized || !w.globals.dataChanged) {
          anim.showDelayedElements();
        }
      }

      if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {
        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {
          speed: dataChangeSpeed
        }));
      }

      return el;
    }
  }, {
    key: "drawPattern",
    value: function drawPattern(style, width, height) {
      var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';
      var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var w = this.w;
      var p = w.globals.dom.Paper.pattern(width, height, function (add) {
        if (style === 'horizontalLines') {
          add.line(0, 0, height, 0).stroke({
            color: stroke,
            width: strokeWidth + 1
          });
        } else if (style === 'verticalLines') {
          add.line(0, 0, 0, width).stroke({
            color: stroke,
            width: strokeWidth + 1
          });
        } else if (style === 'slantedLines') {
          add.line(0, 0, width, height).stroke({
            color: stroke,
            width: strokeWidth
          });
        } else if (style === 'squares') {
          add.rect(width, height).fill('none').stroke({
            color: stroke,
            width: strokeWidth
          });
        } else if (style === 'circles') {
          add.circle(width).fill('none').stroke({
            color: stroke,
            width: strokeWidth
          });
        }
      });
      return p;
    }
  }, {
    key: "drawGradient",
    value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {
      var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var w = this.w;
      var g;
      gfrom = Utils.hexToRgba(gfrom, opacityFrom);
      gto = Utils.hexToRgba(gto, opacityTo);
      var stop1 = 0;
      var stop2 = 1;
      var stop3 = 1;
      var stop4 = null;

      if (stops !== null) {
        stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;
        stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;
        stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;
        stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;
      }

      var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'bubble');

      if (colorStops === null || colorStops.length === 0) {
        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {
          stop.at(stop1, gfrom, opacityFrom);
          stop.at(stop2, gto, opacityTo);
          stop.at(stop3, gto, opacityTo);

          if (stop4 !== null) {
            stop.at(stop4, gfrom, opacityFrom);
          }
        });
      } else {
        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {
          var stops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;
          stops.forEach(function (s) {
            stop.at(s.offset / 100, s.color, s.opacity);
          });
        });
      }

      if (!radial) {
        if (style === 'vertical') {
          g.from(0, 0).to(0, 1);
        } else if (style === 'diagonal') {
          g.from(0, 0).to(1, 1);
        } else if (style === 'horizontal') {
          g.from(0, 1).to(1, 1);
        } else if (style === 'diagonal2') {
          g.from(0, 1).to(2, 2);
        }
      } else {
        var offx = w.globals.gridWidth / 2;
        var offy = w.globals.gridHeight / 2;

        if (w.config.chart.type !== 'bubble') {
          g.attr({
            gradientUnits: 'userSpaceOnUse',
            cx: offx,
            cy: offy,
            r: size
          });
        } else {
          g.attr({
            cx: 0.5,
            cy: 0.5,
            r: 0.8,
            fx: 0.2,
            fy: 0.2
          });
        }
      }

      return g;
    }
  }, {
    key: "drawText",
    value: function drawText(opts) {
      var w = this.w;
      var x = opts.x,
          y = opts.y,
          text = opts.text,
          textAnchor = opts.textAnchor,
          fontSize = opts.fontSize,
          fontFamily = opts.fontFamily,
          foreColor = opts.foreColor,
          opacity = opts.opacity;
      if (typeof text === 'undefined') text = '';

      if (!textAnchor) {
        textAnchor = 'start';
      }

      if (!foreColor) {
        foreColor = w.config.chart.foreColor;
      }

      fontFamily = fontFamily || w.config.chart.fontFamily;
      var elText;

      if (Array.isArray(text)) {
        elText = w.globals.dom.Paper.text(function (add) {
          for (var i = 0; i < text.length; i++) {
            add.tspan(text[i]);
          }
        });
      } else {
        elText = w.globals.dom.Paper.plain(text);
      }

      elText.attr({
        x: x,
        y: y,
        'text-anchor': textAnchor,
        'dominant-baseline': 'auto',
        'font-size': fontSize,
        'font-family': fontFamily,
        fill: foreColor,
        class:  true ? opts.cssClass : ''
      });
      elText.node.style.fontFamily = fontFamily;
      elText.node.style.opacity = opacity;
      return elText;
    }
  }, {
    key: "addTspan",
    value: function addTspan(textEl, text, fontFamily) {
      var tspan = textEl.tspan(text);

      if (!fontFamily) {
        fontFamily = this.w.config.chart.fontFamily;
      }

      tspan.node.style.fontFamily = fontFamily;
    }
  }, {
    key: "drawMarker",
    value: function drawMarker(x, y, opts) {
      x = x || 0;
      var size = opts.pSize || 0;
      var elPoint = null;

      if (opts.shape === 'square') {
        var radius = opts.pRadius === undefined ? size / 2 : opts.pRadius;

        if (y === null) {
          size = 0;
          radius = 0;
        }

        var nSize = size * 1.2 + radius;
        var p = this.drawRect(nSize, nSize, nSize, nSize, radius);
        p.attr({
          x: x - nSize / 2,
          y: y - nSize / 2,
          cx: x,
          cy: y,
          class: opts.class ? opts.class : '',
          fill: opts.pointFillColor,
          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,
          stroke: opts.pointStrokeColor,
          'stroke-width': opts.pWidth ? opts.pWidth : 0,
          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1
        });
        elPoint = p;
      } else if (opts.shape === 'circle') {
        if (!Utils.isNumber(y)) {
          size = 0;
          y = 0;
        } // let nSize = size - opts.pRadius / 2 < 0 ? 0 : size - opts.pRadius / 2


        elPoint = this.drawCircle(size, {
          cx: x,
          cy: y,
          class: opts.class ? opts.class : '',
          stroke: opts.pointStrokeColor,
          fill: opts.pointFillColor,
          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,
          'stroke-width': opts.pWidth ? opts.pWidth : 0,
          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1
        });
      }

      return elPoint;
    }
  }, {
    key: "pathMouseEnter",
    value: function pathMouseEnter(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));

      if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {
        w.config.chart.events.dataPointMouseEnter(e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      this.ctx.fireEvent('dataPointMouseEnter', [e, this.ctx, {
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      }]);

      if (w.config.states.active.filter.type !== 'none') {
        if (path.node.getAttribute('selected') === 'true') {
          return;
        }
      }

      if (w.config.states.hover.filter.type !== 'none') {
        if (w.config.states.active.filter.type !== 'none' && !w.globals.isTouchDevice) {
          var hoverFilter = w.config.states.hover.filter;
          filters.applyFilter(path, i, hoverFilter.type, hoverFilter.value);
        }
      }
    }
  }, {
    key: "pathMouseLeave",
    value: function pathMouseLeave(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));

      if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {
        w.config.chart.events.dataPointMouseLeave(e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      this.ctx.fireEvent('dataPointMouseLeave', [e, this.ctx, {
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      }]);

      if (w.config.states.active.filter.type !== 'none') {
        if (path.node.getAttribute('selected') === 'true') {
          return;
        }
      }

      if (w.config.states.hover.filter.type !== 'none') {
        filters.getDefaultFilter(path, i);
      }
    }
  }, {
    key: "pathMouseDown",
    value: function pathMouseDown(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));
      var selected = 'false';

      if (path.node.getAttribute('selected') === 'true') {
        path.node.setAttribute('selected', 'false');

        if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {
          var index = w.globals.selectedDataPoints[i].indexOf(j);
          w.globals.selectedDataPoints[i].splice(index, 1);
        }
      } else {
        if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {
          w.globals.selectedDataPoints = [];
          var elPaths = w.globals.dom.Paper.select('.apexcharts-series path').members;
          var elCircles = w.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members;
          elPaths.forEach(function (elPath) {
            elPath.node.setAttribute('selected', 'false');
            filters.getDefaultFilter(elPath, i);
          });
          elCircles.forEach(function (circle) {
            circle.node.setAttribute('selected', 'false');
            filters.getDefaultFilter(circle, i);
          });
        }

        path.node.setAttribute('selected', 'true');
        selected = 'true';

        if (typeof w.globals.selectedDataPoints[i] === 'undefined') {
          w.globals.selectedDataPoints[i] = [];
        }

        w.globals.selectedDataPoints[i].push(j);
      }

      if (selected === 'true') {
        var activeFilter = w.config.states.active.filter;

        if (activeFilter !== 'none') {
          filters.applyFilter(path, i, activeFilter.type, activeFilter.value);
        }
      } else {
        if (w.config.states.active.filter.type !== 'none') {
          filters.getDefaultFilter(path, i);
        }
      }

      if (typeof w.config.chart.events.dataPointSelection === 'function') {
        w.config.chart.events.dataPointSelection(e, this.ctx, {
          selectedDataPoints: w.globals.selectedDataPoints,
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      if (e) {
        this.ctx.fireEvent('dataPointSelection', [e, this.ctx, {
          selectedDataPoints: w.globals.selectedDataPoints,
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        }]);
      }
    }
  }, {
    key: "rotateAroundCenter",
    value: function rotateAroundCenter(el) {
      var coord = el.getBBox();
      var x = coord.x + coord.width / 2;
      var y = coord.y + coord.height / 2;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "getTextRects",
    value: function getTextRects(text, fontSize, fontFamily, transform) {
      var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var w = this.w;
      var virtualText = this.drawText({
        x: -200,
        y: -200,
        text: text,
        textAnchor: 'start',
        fontSize: fontSize,
        fontFamily: fontFamily,
        foreColor: '#fff',
        opacity: 0
      });

      if (transform) {
        virtualText.attr('transform', transform);
      }

      w.globals.dom.Paper.add(virtualText);
      var rect = virtualText.bbox();

      if (!useBBox) {
        rect = virtualText.node.getBoundingClientRect();
      }

      virtualText.remove();
      return {
        width: rect.width,
        height: rect.height
      };
    }
    /**
     * append ... to long text
     * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg
     * @memberof Graphics
     **/

  }, {
    key: "placeTextWithEllipsis",
    value: function placeTextWithEllipsis(textObj, textString, width) {
      textObj.textContent = textString;

      if (textString.length > 0) {
        // ellipsis is needed
        if (textObj.getComputedTextLength() >= width) {
          for (var x = textString.length - 3; x > 0; x -= 3) {
            if (textObj.getSubStringLength(0, x) <= width) {
              textObj.textContent = textString.substring(0, x) + '...';
              return;
            }
          }

          textObj.textContent = '...'; // can't place at all
        }
      }
    }
  }], [{
    key: "setAttrs",
    value: function setAttrs(el, attrs) {
      for (var key in attrs) {
        if (attrs.hasOwnProperty(key)) {
          el.setAttribute(key, attrs[key]);
        }
      }
    }
  }]);

  return Graphics;
}();

const name = "en";
const options = {
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	toolbar: {
		exportToSVG: "Download SVG",
		exportToPNG: "Download PNG",
		menu: "Menu",
		selection: "Selection",
		selectionZoom: "Selection Zoom",
		zoomIn: "Zoom In",
		zoomOut: "Zoom Out",
		pan: "Panning",
		reset: "Reset Zoom"
	}
};
var en = {
	name: name,
	options: options
};

var Options =
/*#__PURE__*/
function () {
  function Options() {
    _classCallCheck(this, Options);

    this.yAxis = {
      show: true,
      showAlways: false,
      seriesName: undefined,
      opposite: false,
      reversed: false,
      logarithmic: false,
      tickAmount: undefined,
      forceNiceScale: false,
      max: undefined,
      min: undefined,
      floating: false,
      decimalsInFloat: undefined,
      labels: {
        show: true,
        minWidth: 0,
        maxWidth: 160,
        offsetX: 0,
        offsetY: 0,
        align: undefined,
        rotate: 0,
        padding: 20,
        style: {
          colors: [],
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: ''
        },
        formatter: undefined
      },
      axisBorder: {
        show: false,
        color: '#78909C',
        offsetX: 0,
        offsetY: 0
      },
      axisTicks: {
        show: false,
        color: '#78909C',
        width: 6,
        offsetX: 0,
        offsetY: 0
      },
      title: {
        text: undefined,
        rotate: 90,
        offsetY: 0,
        offsetX: 0,
        style: {
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: ''
        }
      },
      tooltip: {
        enabled: false,
        offsetX: 0
      },
      crosshairs: {
        show: true,
        position: 'front',
        stroke: {
          color: '#b6b6b6',
          width: 1,
          dashArray: 0
        }
      }
    };
    this.xAxisAnnotation = {
      x: 0,
      x2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'middle',
        orientation: 'vertical',
        position: 'top',
        offsetX: 0,
        offsetY: 0,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    };
    this.yAxisAnnotation = {
      y: 0,
      y2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      yAxisIndex: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'end',
        position: 'right',
        offsetX: 0,
        offsetY: -3,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 0,
            bottom: 2
          }
        }
      }
    };
    this.pointAnnotation = {
      x: 0,
      y: null,
      yAxisIndex: 0,
      seriesIndex: 0,
      marker: {
        size: 4,
        fillColor: '#fff',
        strokeWidth: 2,
        strokeColor: '#333',
        shape: 'circle',
        offsetX: 0,
        offsetY: 0,
        radius: 2,
        cssClass: ''
      },
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'middle',
        offsetX: 0,
        offsetY: -15,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 0,
            bottom: 2
          }
        }
      },
      customSVG: {
        SVG: undefined,
        cssClass: undefined,
        offsetX: 0,
        offsetY: 0
      }
    };
  }

  _createClass(Options, [{
    key: "init",
    value: function init() {
      return {
        annotations: {
          position: 'front',
          yaxis: [this.yAxisAnnotation],
          xaxis: [this.xAxisAnnotation],
          points: [this.pointAnnotation]
        },
        chart: {
          animations: {
            enabled: true,
            easing: 'easeinout',
            // linear, easeout, easein, easeinout, swing, bounce, elastic
            speed: 800,
            animateGradually: {
              delay: 150,
              enabled: true
            },
            dynamicAnimation: {
              enabled: true,
              speed: 350
            }
          },
          background: 'transparent',
          locales: [en],
          defaultLocale: 'en',
          dropShadow: {
            enabled: false,
            enabledSeries: undefined,
            top: 2,
            left: 2,
            blur: 4,
            color: '#000',
            opacity: 0.35
          },
          events: {
            animationEnd: undefined,
            beforeMount: undefined,
            mounted: undefined,
            updated: undefined,
            click: undefined,
            legendClick: undefined,
            markerClick: undefined,
            selection: undefined,
            dataPointSelection: undefined,
            dataPointMouseEnter: undefined,
            dataPointMouseLeave: undefined,
            beforeZoom: undefined,
            zoomed: undefined,
            scrolled: undefined
          },
          foreColor: '#373d3f',
          fontFamily: 'Helvetica, Arial, sans-serif',
          height: 'auto',
          parentHeightOffset: 15,
          id: undefined,
          group: undefined,
          offsetX: 0,
          offsetY: 0,
          selection: {
            enabled: false,
            type: 'x',
            // selectedPoints: undefined, // default datapoints that should be selected automatically
            fill: {
              color: '#24292e',
              opacity: 0.1
            },
            stroke: {
              width: 1,
              color: '#24292e',
              opacity: 0.4,
              dashArray: 3
            },
            xaxis: {
              min: undefined,
              max: undefined
            },
            yaxis: {
              min: undefined,
              max: undefined
            }
          },
          sparkline: {
            enabled: false
          },
          brush: {
            enabled: false,
            autoScaleYaxis: true,
            target: undefined
          },
          stacked: false,
          stackType: 'normal',
          toolbar: {
            show: true,
            tools: {
              download: true,
              selection: true,
              zoom: true,
              zoomin: true,
              zoomout: true,
              pan: true,
              reset: true,
              customIcons: []
            },
            autoSelected: 'zoom' // accepts -> zoom, pan, selection

          },
          type: 'line',
          width: '100%',
          zoom: {
            enabled: true,
            type: 'x',
            autoScaleYaxis: false,
            zoomedArea: {
              fill: {
                color: '#90CAF9',
                opacity: 0.4
              },
              stroke: {
                color: '#0D47A1',
                opacity: 0.4,
                width: 1
              }
            }
          }
        },
        plotOptions: {
          bar: {
            horizontal: false,
            columnWidth: '70%',
            // should be in percent 0 - 100
            barHeight: '70%',
            // should be in percent 0 - 100
            distributed: false,
            endingShape: 'flat',
            colors: {
              ranges: [],
              backgroundBarColors: [],
              backgroundBarOpacity: 1
            },
            dataLabels: {
              maxItems: 100,
              hideOverflowingLabels: true,
              position: 'top' // top, center, bottom
              // TODO: provide stackedLabels for stacked charts which gives additions of values

            }
          },
          candlestick: {
            colors: {
              upward: '#00B746',
              downward: '#EF403C'
            },
            wick: {
              useFillColor: true
            }
          },
          heatmap: {
            radius: 2,
            enableShades: true,
            shadeIntensity: 0.5,
            reverseNegativeShade: true,
            distributed: false,
            colorScale: {
              inverse: false,
              ranges: [],
              min: undefined,
              max: undefined
            }
          },
          radialBar: {
            size: undefined,
            inverseOrder: false,
            startAngle: 0,
            endAngle: 360,
            offsetX: 0,
            offsetY: 0,
            hollow: {
              margin: 5,
              size: '50%',
              background: 'transparent',
              image: undefined,
              imageWidth: 150,
              imageHeight: 150,
              imageOffsetX: 0,
              imageOffsetY: 0,
              imageClipped: true,
              position: 'front',
              dropShadow: {
                enabled: false,
                top: 0,
                left: 0,
                blur: 3,
                color: '#000',
                opacity: 0.5
              }
            },
            track: {
              show: true,
              startAngle: undefined,
              endAngle: undefined,
              background: '#f2f2f2',
              strokeWidth: '97%',
              opacity: 1,
              margin: 5,
              // margin is in pixels
              dropShadow: {
                enabled: false,
                top: 0,
                left: 0,
                blur: 3,
                color: '#000',
                opacity: 0.5
              }
            },
            dataLabels: {
              show: true,
              name: {
                show: true,
                fontSize: '16px',
                fontFamily: undefined,
                color: undefined,
                offsetY: 0
              },
              value: {
                show: true,
                fontSize: '14px',
                fontFamily: undefined,
                color: undefined,
                offsetY: 16,
                formatter: function formatter(val) {
                  return val + '%';
                }
              },
              total: {
                show: false,
                label: 'Total',
                color: undefined,
                formatter: function formatter(w) {
                  return w.globals.seriesTotals.reduce(function (a, b) {
                    return a + b;
                  }, 0) / w.globals.series.length + '%';
                }
              }
            }
          },
          rangeBar: {},
          pie: {
            size: undefined,
            customScale: 1,
            offsetX: 0,
            offsetY: 0,
            expandOnClick: true,
            dataLabels: {
              // These are the percentage values which are displayed on slice
              offset: 0,
              // offset by which labels will move outside
              minAngleToShowLabel: 10
            },
            donut: {
              size: '65%',
              background: 'transparent',
              labels: {
                // These are the inner labels appearing inside donut
                show: false,
                name: {
                  show: true,
                  fontSize: '16px',
                  fontFamily: undefined,
                  color: undefined,
                  offsetY: -10
                },
                value: {
                  show: true,
                  fontSize: '20px',
                  fontFamily: undefined,
                  color: undefined,
                  offsetY: 10,
                  formatter: function formatter(val) {
                    return val;
                  }
                },
                total: {
                  show: false,
                  label: 'Total',
                  color: undefined,
                  formatter: function formatter(w) {
                    return w.globals.seriesTotals.reduce(function (a, b) {
                      return a + b;
                    }, 0);
                  }
                }
              }
            }
          },
          radar: {
            size: undefined,
            offsetX: 0,
            offsetY: 0,
            polygons: {
              // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2
              strokeColors: '#e8e8e8',
              connectorColors: '#e8e8e8',
              fill: {
                colors: undefined
              }
            }
          }
        },
        colors: undefined,
        dataLabels: {
          enabled: true,
          enabledOnSeries: undefined,
          formatter: function formatter(val) {
            return val !== null ? val : '';
          },
          textAnchor: 'middle',
          offsetX: 0,
          offsetY: 0,
          style: {
            fontSize: '12px',
            fontFamily: undefined,
            colors: undefined
          },
          dropShadow: {
            enabled: false,
            top: 1,
            left: 1,
            blur: 1,
            color: '#000',
            opacity: 0.45
          }
        },
        fill: {
          type: 'solid',
          colors: undefined,
          // array of colors
          opacity: 0.85,
          gradient: {
            shade: 'dark',
            type: 'horizontal',
            shadeIntensity: 0.5,
            gradientToColors: undefined,
            inverseColors: true,
            opacityFrom: 1,
            opacityTo: 1,
            stops: [0, 50, 100],
            colorStops: []
          },
          image: {
            src: [],
            width: undefined,
            // optional
            height: undefined // optional

          },
          pattern: {
            style: 'sqaures',
            // String | Array of Strings
            width: 6,
            height: 6,
            strokeWidth: 2
          }
        },
        grid: {
          show: true,
          borderColor: '#e0e0e0',
          strokeDashArray: 0,
          position: 'back',
          xaxis: {
            lines: {
              show: false,
              animate: false
            }
          },
          yaxis: {
            lines: {
              show: true,
              animate: false
            }
          },
          row: {
            colors: undefined,
            // takes as array which will be repeated on rows
            opacity: 0.5
          },
          column: {
            colors: undefined,
            // takes an array which will be repeated on columns
            opacity: 0.5
          },
          padding: {
            top: 0,
            right: 10,
            bottom: 0,
            left: 12
          }
        },
        labels: [],
        legend: {
          show: true,
          showForSingleSeries: false,
          showForNullSeries: true,
          showForZeroSeries: true,
          floating: false,
          position: 'bottom',
          // whether to position legends in 1 of 4
          // direction - top, bottom, left, right
          horizontalAlign: 'center',
          // when position top/bottom, you can specify whether to align legends left, right or center
          fontSize: '12px',
          fontFamily: undefined,
          width: undefined,
          height: undefined,
          formatter: undefined,
          offsetX: -20,
          offsetY: 0,
          labels: {
            colors: undefined,
            useSeriesColors: false
          },
          markers: {
            width: 12,
            height: 12,
            strokeWidth: 0,
            strokeColor: '#fff',
            radius: 12,
            customHTML: undefined,
            offsetX: 0,
            offsetY: 0,
            onClick: undefined
          },
          itemMargin: {
            horizontal: 0,
            vertical: 5
          },
          onItemClick: {
            toggleDataSeries: true
          },
          onItemHover: {
            highlightDataSeries: true
          }
        },
        markers: {
          discrete: [],
          size: 0,
          colors: undefined,
          //strokeColor: '#fff', // TODO: deprecate in major version 4.0
          strokeColors: '#fff',
          strokeWidth: 2,
          strokeOpacity: 0.9,
          fillOpacity: 1,
          shape: 'circle',
          radius: 2,
          offsetX: 0,
          offsetY: 0,
          onClick: undefined,
          onDblClick: undefined,
          hover: {
            size: undefined,
            sizeOffset: 3
          }
        },
        noData: {
          text: undefined,
          align: 'center',
          verticalAlign: 'middle',
          offsetX: 0,
          offsetY: 0,
          style: {
            color: undefined,
            fontSize: '14px',
            fontFamily: undefined
          }
        },
        responsive: [],
        // breakpoints should follow ascending order 400, then 700, then 1000
        series: undefined,
        states: {
          normal: {
            filter: {
              type: 'none',
              value: 0
            }
          },
          hover: {
            filter: {
              type: 'lighten',
              value: 0.15
            }
          },
          active: {
            allowMultipleDataPointsSelection: false,
            filter: {
              type: 'darken',
              value: 0.65
            }
          }
        },
        title: {
          text: undefined,
          align: 'left',
          margin: 10,
          offsetX: 0,
          offsetY: 0,
          floating: false,
          style: {
            fontSize: '14px',
            fontFamily: undefined,
            color: undefined
          }
        },
        subtitle: {
          text: undefined,
          align: 'left',
          margin: 10,
          offsetX: 0,
          offsetY: 30,
          floating: false,
          style: {
            fontSize: '12px',
            fontFamily: undefined,
            color: undefined
          }
        },
        stroke: {
          show: true,
          curve: 'smooth',
          // "smooth" / "straight" / "stepline"
          lineCap: 'butt',
          // round, butt , square
          width: 2,
          colors: undefined,
          // array of colors
          dashArray: 0 // single value or array of values

        },
        tooltip: {
          enabled: true,
          enabledOnSeries: undefined,
          shared: true,
          followCursor: false,
          // when disabled, the tooltip will show on top of the series instead of mouse position
          intersect: false,
          // when enabled, tooltip will only show when user directly hovers over point
          inverseOrder: false,
          custom: undefined,
          fillSeriesColor: false,
          theme: 'light',
          style: {
            fontSize: '12px',
            fontFamily: undefined
          },
          onDatasetHover: {
            highlightDataSeries: false
          },
          x: {
            // x value
            show: true,
            format: 'dd MMM',
            // dd/MM, dd MMM yy, dd MMM yyyy
            formatter: undefined // a custom user supplied formatter function

          },
          y: {
            formatter: undefined,
            title: {
              formatter: function formatter(seriesName) {
                return seriesName;
              }
            }
          },
          z: {
            formatter: undefined,
            title: 'Size: '
          },
          marker: {
            show: true
          },
          items: {
            display: 'flex'
          },
          fixed: {
            enabled: false,
            position: 'topRight',
            // topRight, topLeft, bottomRight, bottomLeft
            offsetX: 0,
            offsetY: 0
          }
        },
        xaxis: {
          type: 'category',
          categories: [],
          offsetX: 0,
          offsetY: 0,
          labels: {
            show: true,
            rotate: -45,
            rotateAlways: false,
            hideOverlappingLabels: true,
            trim: true,
            minHeight: undefined,
            maxHeight: 120,
            showDuplicates: true,
            style: {
              colors: [],
              fontSize: '12px',
              fontFamily: undefined,
              cssClass: ''
            },
            offsetX: 0,
            offsetY: 0,
            format: undefined,
            formatter: undefined,
            // custom formatter function which will override format
            datetimeFormatter: {
              year: 'yyyy',
              month: "MMM 'yy",
              day: 'dd MMM',
              hour: 'HH:mm',
              minute: 'HH:mm:ss'
            }
          },
          axisBorder: {
            show: true,
            color: '#78909C',
            width: '100%',
            height: 1,
            offsetX: 0,
            offsetY: 0
          },
          axisTicks: {
            show: true,
            color: '#78909C',
            height: 6,
            offsetX: 0,
            offsetY: 0
          },
          tickAmount: undefined,
          tickPlacement: 'on',
          min: undefined,
          max: undefined,
          range: undefined,
          floating: false,
          position: 'bottom',
          title: {
            text: undefined,
            offsetX: 0,
            offsetY: 0,
            style: {
              color: undefined,
              fontSize: '12px',
              fontFamily: undefined,
              cssClass: ''
            }
          },
          crosshairs: {
            show: true,
            width: 1,
            // tickWidth/barWidth or an integer
            position: 'back',
            opacity: 0.9,
            stroke: {
              color: '#b6b6b6',
              width: 1,
              dashArray: 3
            },
            fill: {
              type: 'solid',
              // solid, gradient
              color: '#B1B9C4',
              gradient: {
                colorFrom: '#D8E3F0',
                colorTo: '#BED1E6',
                stops: [0, 100],
                opacityFrom: 0.4,
                opacityTo: 0.5
              }
            },
            dropShadow: {
              enabled: false,
              left: 0,
              top: 0,
              blur: 1,
              opacity: 0.4
            }
          },
          tooltip: {
            enabled: true,
            offsetY: 0,
            formatter: undefined,
            style: {
              fontSize: '12px',
              fontFamily: undefined
            }
          }
        },
        yaxis: this.yAxis,
        theme: {
          mode: 'light',
          palette: 'palette1',
          // If defined, it will overwrite globals.colors variable
          monochrome: {
            // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)
            enabled: false,
            color: '#008FFB',
            shadeTo: 'light',
            shadeIntensity: 0.65
          }
        }
      };
    }
  }]);

  return Options;
}();

/**
 * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.
 *
 * @module Annotations
 **/

var Annotations =
/*#__PURE__*/
function () {
  function Annotations(ctx) {
    _classCallCheck(this, Annotations);

    this.ctx = ctx;
    this.w = ctx.w;
    this.graphics = new Graphics(this.ctx);

    if (this.w.globals.isBarHorizontal) {
      this.invertAxis = true;
    }

    this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }

  _createClass(Annotations, [{
    key: "drawAnnotations",
    value: function drawAnnotations() {
      var w = this.w;

      if (w.globals.axisCharts) {
        var yAnnotations = this.drawYAxisAnnotations();
        var xAnnotations = this.drawXAxisAnnotations();
        var pointAnnotations = this.drawPointAnnotations();
        var initialAnim = w.config.chart.animations.enabled;
        var annoArray = [yAnnotations, xAnnotations, pointAnnotations];
        var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];

        for (var i = 0; i < 3; i++) {
          w.globals.dom.elGraphical.add(annoArray[i]);

          if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
            annoElArray[i].classList.add('hidden');
          }

          w.globals.delayedElements.push({
            el: annoElArray[i],
            index: 0
          });
        } // background sizes needs to be calculated after text is drawn, so calling them last


        this.annotationsBackground();
      }
    }
  }, {
    key: "getStringX",
    value: function getStringX(x) {
      var w = this.w;
      var rX = x;
      var catIndex = w.globals.labels.indexOf(x);
      var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');

      if (xLabel) {
        rX = parseFloat(xLabel.getAttribute('x'));
      }

      return rX;
    }
  }, {
    key: "addXaxisAnnotation",
    value: function addXaxisAnnotation(anno, parent, index) {
      var w = this.w;
      var min = this.invertAxis ? w.globals.minY : w.globals.minX;
      var range = this.invertAxis ? w.globals.yRange[0] : w.globals.xRange;
      var x1 = (anno.x - min) / (range / w.globals.gridWidth);
      var text = anno.label.text;

      if ((w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) && !this.invertAxis && !w.globals.isXNumeric) {
        x1 = this.getStringX(anno.x);
      }

      var strokeDashArray = anno.strokeDashArray;
      if (x1 < 0 || x1 > w.globals.gridWidth) return;

      if (anno.x2 === null) {
        var line = this.graphics.drawLine(x1 + anno.offsetX, // x1
        0 + anno.offsetY, // y1
        x1 + anno.offsetX, // x2
        w.globals.gridHeight + anno.offsetY, // y2
        anno.borderColor, // lineColor
        strokeDashArray //dashArray
        );
        parent.appendChild(line.node);
      } else {
        var x2 = (anno.x2 - min) / (range / w.globals.gridWidth);

        if ((w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) && !this.invertAxis && !w.globals.isXNumeric) {
          x2 = this.getStringX(anno.x2);
        }

        if (x2 < x1) {
          var temp = x1;
          x1 = x2;
          x2 = temp;
        }

        if (text) {
          var rect = this.graphics.drawRect(x1 + anno.offsetX, // x1
          0 + anno.offsetY, // y1
          x2 - x1, // x2
          w.globals.gridHeight + anno.offsetY, // y2
          0, // radius
          anno.fillColor, // color
          anno.opacity, // opacity,
          1, // strokeWidth
          anno.borderColor, // strokeColor
          strokeDashArray // stokeDashArray
          );
          parent.appendChild(rect.node);
        }
      }

      var textY = anno.label.position === 'top' ? -3 : w.globals.gridHeight;
      var elText = this.graphics.drawText({
        x: x1 + anno.label.offsetX,
        y: textY + anno.label.offsetY,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-xaxis-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node); // after placing the annotations on svg, set any vertically placed annotations

      this.setOrientations(anno, index);
    }
  }, {
    key: "drawXAxisAnnotations",
    value: function drawXAxisAnnotations() {
      var _this = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-xaxis-annotations'
      });
      w.config.annotations.xaxis.map(function (anno, index) {
        _this.addXaxisAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "addYaxisAnnotation",
    value: function addYaxisAnnotation(anno, parent, index) {
      var w = this.w;
      var strokeDashArray = anno.strokeDashArray;
      var y1;
      var y2;

      if (this.invertAxis) {
        var catIndex = w.globals.labels.indexOf(anno.y);
        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');

        if (xLabel) {
          y1 = parseFloat(xLabel.getAttribute('y'));
        }
      } else {
        y1 = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {
          y1 = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      }

      var text = anno.label.text;

      if (anno.y2 === null) {
        var line = this.graphics.drawLine(0 + anno.offsetX, // x1
        y1 + anno.offsetY, // y1
        w.globals.gridWidth + anno.offsetX, // x2
        y1 + anno.offsetY, // y2
        anno.borderColor, // lineColor
        strokeDashArray // dashArray
        );
        parent.appendChild(line.node);
      } else {
        if (this.invertAxis) {
          var _catIndex = w.globals.labels.indexOf(anno.y2);

          var _xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (_catIndex + 1) + ')');

          if (_xLabel) {
            y2 = parseFloat(_xLabel.getAttribute('y'));
          }
        } else {
          y2 = w.globals.gridHeight - (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

          if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {
            y2 = (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
          }
        }

        if (y2 > y1) {
          var temp = y1;
          y1 = y2;
          y2 = temp;
        }

        if (text) {
          var rect = this.graphics.drawRect(0 + anno.offsetX, // x1
          y2 + anno.offsetY, // y1
          w.globals.gridWidth + anno.offsetX, // x2
          y1 - y2, // y2
          0, // radius
          anno.fillColor, // color
          anno.opacity, // opacity,
          1, // strokeWidth
          anno.borderColor, // strokeColor
          strokeDashArray // stokeDashArray
          );
          parent.appendChild(rect.node);
        }
      }

      var textX = anno.label.position === 'right' ? w.globals.gridWidth : 0;
      var elText = this.graphics.drawText({
        x: textX + anno.label.offsetX,
        y: (y2 || y1) + anno.label.offsetY - 3,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-yaxis-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node);
    }
  }, {
    key: "drawYAxisAnnotations",
    value: function drawYAxisAnnotations() {
      var _this2 = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-yaxis-annotations'
      });
      w.config.annotations.yaxis.map(function (anno, index) {
        _this2.addYaxisAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "clearAnnotations",
    value: function clearAnnotations(ctx) {
      var w = ctx.w;
      var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations');
      annos = Utils.listToArray(annos);
      annos.forEach(function (a) {
        while (a.firstChild) {
          a.removeChild(a.firstChild);
        }
      });
    }
  }, {
    key: "addPointAnnotation",
    value: function addPointAnnotation(anno, parent, index) {
      var w = this.w;
      var x = 0;
      var y = 0;
      var pointY = 0;

      if (this.invertAxis) {
        console.warn('Point annotation is not supported in horizontal bar charts.');
      }

      if (typeof anno.x === 'string') {
        var catIndex = w.globals.labels.indexOf(anno.x);
        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');
        var xPos = parseFloat(xLabel.getAttribute('x'));
        x = xPos;
        var annoY = anno.y;

        if (anno.y === null) {
          annoY = w.globals.series[anno.seriesIndex][catIndex];
        }

        y = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
        pointY = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {
          y = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) + parseInt(anno.label.style.fontSize) + anno.marker.size;
          pointY = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      } else {
        x = (anno.x - w.globals.minX) / (w.globals.xRange / w.globals.gridWidth);
        y = w.globals.gridHeight - (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
        pointY = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {
          y = (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
          pointY = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      }

      if (x < 0 || x > w.globals.gridWidth) return;
      var optsPoints = {
        pSize: anno.marker.size,
        pWidth: anno.marker.strokeWidth,
        pointFillColor: anno.marker.fillColor,
        pointStrokeColor: anno.marker.strokeColor,
        shape: anno.marker.shape,
        radius: anno.marker.radius,
        class: 'apexcharts-point-annotation-marker ' + anno.marker.cssClass
      };
      var point = this.graphics.drawMarker(x + anno.marker.offsetX, pointY + anno.marker.offsetY, optsPoints);
      parent.appendChild(point.node);
      var text = anno.label.text ? anno.label.text : '';
      var elText = this.graphics.drawText({
        x: x + anno.label.offsetX,
        y: y + anno.label.offsetY,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-point-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node);

      if (anno.customSVG.SVG) {
        var g = this.graphics.group({
          class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass
        });
        g.attr({
          transform: "translate(".concat(x + anno.customSVG.offsetX, ", ").concat(y + anno.customSVG.offsetY, ")")
        });
        g.node.innerHTML = anno.customSVG.SVG;
        parent.appendChild(g.node);
      }
    }
  }, {
    key: "drawPointAnnotations",
    value: function drawPointAnnotations() {
      var _this3 = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-point-annotations'
      });
      w.config.annotations.points.map(function (anno, index) {
        _this3.addPointAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "setOrientations",
    value: function setOrientations(anno) {
      var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var w = this.w;

      if (anno.label.orientation === 'vertical') {
        var i = annoIndex !== null ? annoIndex : 0;
        var xAnno = w.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(i, "']"));

        if (xAnno !== null) {
          var xAnnoCoord = xAnno.getBoundingClientRect();
          xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);

          if (anno.label.position === 'top') {
            xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + xAnnoCoord.width);
          } else {
            xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) - xAnnoCoord.width);
          }

          var annoRotatingCenter = this.graphics.rotateAroundCenter(xAnno);
          var x = annoRotatingCenter.x;
          var y = annoRotatingCenter.y;
          xAnno.setAttribute('transform', "rotate(-90 ".concat(x, " ").concat(y, ")"));
        }
      }
    }
  }, {
    key: "addBackgroundToAnno",
    value: function addBackgroundToAnno(annoEl, anno) {
      var w = this.w;
      if (!anno.label.text || anno.label.text && !anno.label.text.trim()) return null;
      var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();
      var coords = annoEl.getBoundingClientRect();
      var pleft = anno.label.style.padding.left;
      var pright = anno.label.style.padding.right;
      var ptop = anno.label.style.padding.top;
      var pbottom = anno.label.style.padding.bottom;

      if (anno.label.orientation === 'vertical') {
        ptop = anno.label.style.padding.left;
        pbottom = anno.label.style.padding.right;
        pleft = anno.label.style.padding.top;
        pright = anno.label.style.padding.bottom;
      }

      var x1 = coords.left - elGridRect.left - pleft;
      var y1 = coords.top - elGridRect.top - ptop;
      var elRect = this.graphics.drawRect(x1, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, 0, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);
      return elRect;
    }
  }, {
    key: "annotationsBackground",
    value: function annotationsBackground() {
      var _this4 = this;

      var w = this.w;

      var add = function add(anno, i, type) {
        var annoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(i, "']"));

        if (annoLabel) {
          var parent = annoLabel.parentNode;

          var elRect = _this4.addBackgroundToAnno(annoLabel, anno);

          if (elRect) {
            parent.insertBefore(elRect.node, annoLabel);
          }
        }
      };

      w.config.annotations.xaxis.map(function (anno, i) {
        add(anno, i, 'xaxis');
      });
      w.config.annotations.yaxis.map(function (anno, i) {
        add(anno, i, 'yaxis');
      });
      w.config.annotations.points.map(function (anno, i) {
        add(anno, i, 'point');
      });
    }
  }, {
    key: "addText",
    value: function addText(params, pushToMemory, context) {
      var x = params.x,
          y = params.y,
          text = params.text,
          textAnchor = params.textAnchor,
          _params$appendTo = params.appendTo,
          appendTo = _params$appendTo === void 0 ? '.apexcharts-inner' : _params$appendTo,
          foreColor = params.foreColor,
          fontSize = params.fontSize,
          fontFamily = params.fontFamily,
          cssClass = params.cssClass,
          backgroundColor = params.backgroundColor,
          borderWidth = params.borderWidth,
          strokeDashArray = params.strokeDashArray,
          radius = params.radius,
          borderColor = params.borderColor,
          _params$paddingLeft = params.paddingLeft,
          paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,
          _params$paddingRight = params.paddingRight,
          paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,
          _params$paddingBottom = params.paddingBottom,
          paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,
          _params$paddingTop = params.paddingTop,
          paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;
      var me = context;
      var w = me.w;
      var parentNode = w.globals.dom.baseEl.querySelector(appendTo);
      var elText = this.graphics.drawText({
        x: x,
        y: y,
        text: text,
        textAnchor: textAnchor || 'start',
        fontSize: fontSize || '12px',
        fontFamily: fontFamily || w.config.chart.fontFamily,
        foreColor: foreColor || w.config.chart.foreColor,
        cssClass:  true ? cssClass : ''
      });
      parentNode.appendChild(elText.node);
      var textRect = elText.bbox();

      if (text) {
        var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, radius, backgroundColor, 1, borderWidth, borderColor, strokeDashArray);
        elText.before(elRect);
      }

      if (pushToMemory) {
        w.globals.memory.methodsToExec.push({
          context: me,
          method: me.addText,
          params: {
            x: x,
            y: y,
            text: text,
            textAnchor: textAnchor,
            appendTo: appendTo,
            foreColor: foreColor,
            fontSize: fontSize,
            cssClass: cssClass,
            backgroundColor: backgroundColor,
            borderWidth: borderWidth,
            strokeDashArray: strokeDashArray,
            radius: radius,
            borderColor: borderColor,
            paddingLeft: paddingLeft,
            paddingRight: paddingRight,
            paddingBottom: paddingBottom,
            paddingTop: paddingTop
          }
        });
      }

      return context;
    }
  }, {
    key: "addPointAnnotationExternal",
    value: function addPointAnnotationExternal(params, pushToMemory, context) {
      if (typeof this.invertAxis === 'undefined') {
        this.invertAxis = context.w.globals.isBarHorizontal;
      }

      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'point',
        contextMethod: context.addPointAnnotation
      });
      return context;
    }
  }, {
    key: "addYaxisAnnotationExternal",
    value: function addYaxisAnnotationExternal(params, pushToMemory, context) {
      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'yaxis',
        contextMethod: context.addYaxisAnnotation
      });
      return context;
    } // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method

  }, {
    key: "addXaxisAnnotationExternal",
    value: function addXaxisAnnotationExternal(params, pushToMemory, context) {
      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'xaxis',
        contextMethod: context.addXaxisAnnotation
      });
      return context;
    }
  }, {
    key: "addAnnotationExternal",
    value: function addAnnotationExternal(_ref) {
      var params = _ref.params,
          pushToMemory = _ref.pushToMemory,
          context = _ref.context,
          type = _ref.type,
          contextMethod = _ref.contextMethod;
      var me = context;
      var w = me.w;
      var parent = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations"));
      var index = parent.childNodes.length + 1;
      var opt = new Options();
      var axesAnno = Object.assign({}, type === 'xaxis' ? opt.xAxisAnnotation : type === 'yaxis' ? opt.yAxisAnnotation : opt.pointAnnotation);
      var anno = Utils.extend(axesAnno, params);

      switch (type) {
        case 'xaxis':
          this.addXaxisAnnotation(anno, parent, index);
          break;

        case 'yaxis':
          this.addYaxisAnnotation(anno, parent, index);
          break;

        case 'point':
          this.addPointAnnotation(anno, parent, index);
          break;
      } // add background


      var axesAnnoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(index, "']"));
      var elRect = this.addBackgroundToAnno(axesAnnoLabel, anno);

      if (elRect) {
        parent.insertBefore(elRect.node, axesAnnoLabel);
      }

      if (pushToMemory) {
        w.globals.memory.methodsToExec.push({
          context: me,
          method: contextMethod,
          params: params
        });
      }

      return context;
    }
  }]);

  return Annotations;
}();

/**
 * DateTime Class to manipulate datetime values.
 *
 * @module DateTime
 **/

var DateTime =
/*#__PURE__*/
function () {
  function DateTime(ctx) {
    _classCallCheck(this, DateTime);

    this.ctx = ctx;
    this.w = ctx.w;
    this.months31 = [1, 3, 5, 7, 8, 10, 12];
    this.months30 = [2, 4, 6, 9, 11];
    this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }

  _createClass(DateTime, [{
    key: "isValidDate",
    value: function isValidDate(date) {
      return !isNaN(this.parseDate(date));
    }
  }, {
    key: "getUTCTimeStamp",
    value: function getUTCTimeStamp(dateStr) {
      if (!Date.parse(dateStr)) {
        return dateStr;
      }

      return new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();
    }
  }, {
    key: "parseDate",
    value: function parseDate(dateStr) {
      var parsed = Date.parse(dateStr);

      if (!isNaN(parsed)) {
        return this.getUTCTimeStamp(dateStr);
      }

      var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));
      output = this.getUTCTimeStamp(output);
      return output;
    } // https://stackoverflow.com/a/11252167/6495043

  }, {
    key: "treatAsUtc",
    value: function treatAsUtc(dateStr) {
      var result = new Date(dateStr);
      result.setMinutes(result.getMinutes() - result.getTimezoneOffset());
      return result;
    } // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191

  }, {
    key: "formatDate",
    value: function formatDate(date, format) {
      var utc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var convertToUTC = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var locale = this.w.globals.locale;
      var MMMM = ['\x00'].concat(_toConsumableArray(locale.months));
      var MMM = ['\x01'].concat(_toConsumableArray(locale.shortMonths));
      var dddd = ['\x02'].concat(_toConsumableArray(locale.days));
      var ddd = ['\x03'].concat(_toConsumableArray(locale.shortDays));

      function ii(i, len) {
        var s = i + '';
        len = len || 2;

        while (s.length < len) {
          s = '0' + s;
        }

        return s;
      }

      if (convertToUTC) {
        date = this.treatAsUtc(date);
      }

      var y = utc ? date.getUTCFullYear() : date.getFullYear();
      format = format.replace(/(^|[^\\])yyyy+/g, '$1' + y);
      format = format.replace(/(^|[^\\])yy/g, '$1' + y.toString().substr(2, 2));
      format = format.replace(/(^|[^\\])y/g, '$1' + y);
      var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
      format = format.replace(/(^|[^\\])MMMM+/g, '$1' + MMMM[0]);
      format = format.replace(/(^|[^\\])MMM/g, '$1' + MMM[0]);
      format = format.replace(/(^|[^\\])MM/g, '$1' + ii(M));
      format = format.replace(/(^|[^\\])M/g, '$1' + M);
      var d = utc ? date.getUTCDate() : date.getDate();
      format = format.replace(/(^|[^\\])dddd+/g, '$1' + dddd[0]);
      format = format.replace(/(^|[^\\])ddd/g, '$1' + ddd[0]);
      format = format.replace(/(^|[^\\])dd/g, '$1' + ii(d));
      format = format.replace(/(^|[^\\])d/g, '$1' + d);
      var H = utc ? date.getUTCHours() : date.getHours();
      format = format.replace(/(^|[^\\])HH+/g, '$1' + ii(H));
      format = format.replace(/(^|[^\\])H/g, '$1' + H);
      var h = H > 12 ? H - 12 : H === 0 ? 12 : H;
      format = format.replace(/(^|[^\\])hh+/g, '$1' + ii(h));
      format = format.replace(/(^|[^\\])h/g, '$1' + h);
      var m = utc ? date.getUTCMinutes() : date.getMinutes();
      format = format.replace(/(^|[^\\])mm+/g, '$1' + ii(m));
      format = format.replace(/(^|[^\\])m/g, '$1' + m);
      var s = utc ? date.getUTCSeconds() : date.getSeconds();
      format = format.replace(/(^|[^\\])ss+/g, '$1' + ii(s));
      format = format.replace(/(^|[^\\])s/g, '$1' + s);
      var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
      format = format.replace(/(^|[^\\])fff+/g, '$1' + ii(f, 3));
      f = Math.round(f / 10);
      format = format.replace(/(^|[^\\])ff/g, '$1' + ii(f));
      f = Math.round(f / 10);
      format = format.replace(/(^|[^\\])f/g, '$1' + f);
      var T = H < 12 ? 'AM' : 'PM';
      format = format.replace(/(^|[^\\])TT+/g, '$1' + T);
      format = format.replace(/(^|[^\\])T/g, '$1' + T.charAt(0));
      var t = T.toLowerCase();
      format = format.replace(/(^|[^\\])tt+/g, '$1' + t);
      format = format.replace(/(^|[^\\])t/g, '$1' + t.charAt(0));
      var tz = -date.getTimezoneOffset();
      var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';

      if (!utc) {
        tz = Math.abs(tz);
        var tzHrs = Math.floor(tz / 60);
        var tzMin = tz % 60;
        K += ii(tzHrs) + ':' + ii(tzMin);
      }

      format = format.replace(/(^|[^\\])K/g, '$1' + K);
      var day = (utc ? date.getUTCDay() : date.getDay()) + 1;
      format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);
      format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);
      format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);
      format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);
      format = format.replace(/\\(.)/g, '$1');
      return format;
    }
  }, {
    key: "getTimeUnitsfromTimestamp",
    value: function getTimeUnitsfromTimestamp(minX, maxX) {
      var w = this.w;

      if (w.config.xaxis.min !== undefined) {
        minX = w.config.xaxis.min;
      }

      if (w.config.xaxis.max !== undefined) {
        maxX = w.config.xaxis.max;
      }

      var minYear = new Date(minX).getFullYear();
      var maxYear = new Date(maxX).getFullYear();
      var minMonth = new Date(minX).getMonth();
      var maxMonth = new Date(maxX).getMonth();
      var minDate = new Date(minX).getDate();
      var maxDate = new Date(maxX).getDate();
      var minHour = new Date(minX).getHours();
      var maxHour = new Date(maxX).getHours();
      var minMinute = new Date(minX).getMinutes();
      var maxMinute = new Date(maxX).getMinutes();
      return {
        minMinute: minMinute,
        maxMinute: maxMinute,
        minHour: minHour,
        maxHour: maxHour,
        minDate: minDate,
        maxDate: maxDate,
        minMonth: minMonth,
        maxMonth: maxMonth,
        minYear: minYear,
        maxYear: maxYear
      };
    }
  }, {
    key: "isLeapYear",
    value: function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
  }, {
    key: "calculcateLastDaysOfMonth",
    value: function calculcateLastDaysOfMonth(month, year, subtract) {
      var days = this.determineDaysOfMonths(month, year); // whatever days we get, subtract the number of days asked

      return days - subtract;
    }
  }, {
    key: "determineDaysOfYear",
    value: function determineDaysOfYear(year) {
      var days = 365;

      if (this.isLeapYear(year)) {
        days = 366;
      }

      return days;
    }
  }, {
    key: "determineRemainingDaysOfYear",
    value: function determineRemainingDaysOfYear(year, month, date) {
      var dayOfYear = this.daysCntOfYear[month] + date;
      if (month > 1 && this.isLeapYear()) dayOfYear++;
      return dayOfYear;
    }
  }, {
    key: "determineDaysOfMonths",
    value: function determineDaysOfMonths(month, year) {
      var days = 30;
      month = Utils.monthMod(month);

      switch (true) {
        case this.months30.indexOf(month) > -1:
          if (month === 2) {
            if (this.isLeapYear(year)) {
              days = 29;
            } else {
              days = 28;
            }
          }

          break;

        case this.months31.indexOf(month) > -1:
          days = 31;
          break;

        default:
          days = 31;
          break;
      }

      return days;
    }
  }]);

  return DateTime;
}();

/**
 * ApexCharts Default Class for setting default options for all chart types.
 *
 * @module Defaults
 **/

var Defaults =
/*#__PURE__*/
function () {
  function Defaults(opts) {
    _classCallCheck(this, Defaults);

    this.opts = opts;
  }

  _createClass(Defaults, [{
    key: "line",
    value: function line() {
      return {
        chart: {
          animations: {
            easing: 'swing'
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          width: 5,
          curve: 'straight'
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "sparkline",
    value: function sparkline(defaults) {
      this.opts.yaxis[0].labels.show = false;
      this.opts.yaxis[0].floating = true;
      var ret = {
        grid: {
          show: false,
          padding: {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }
        },
        legend: {
          show: false
        },
        xaxis: {
          labels: {
            show: false
          },
          tooltip: {
            enabled: false
          },
          axisBorder: {
            show: false
          }
        },
        chart: {
          toolbar: {
            show: false
          },
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        }
      };
      return Utils.extend(defaults, ret);
    }
  }, {
    key: "bar",
    value: function bar() {
      return {
        chart: {
          stacked: false,
          animations: {
            easing: 'swing'
          }
        },
        plotOptions: {
          bar: {
            dataLabels: {
              position: 'center'
            }
          }
        },
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        stroke: {
          width: 0
        },
        fill: {
          opacity: 0.85
        },
        legend: {
          markers: {
            shape: 'square',
            radius: 2,
            size: 8
          }
        },
        tooltip: {
          shared: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          },
          crosshairs: {
            width: 'barWidth',
            position: 'back',
            fill: {
              type: 'gradient'
            },
            dropShadow: {
              enabled: false
            },
            stroke: {
              width: 0
            }
          }
        }
      };
    }
  }, {
    key: "candlestick",
    value: function candlestick() {
      return {
        stroke: {
          width: 1,
          colors: ['#333']
        },
        dataLabels: {
          enabled: false
        },
        tooltip: {
          shared: true,
          custom: function custom(_ref) {
            var seriesIndex = _ref.seriesIndex,
                dataPointIndex = _ref.dataPointIndex,
                w = _ref.w;
            var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];
            var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];
            var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];
            var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];
            return '<div class="apexcharts-tooltip-candlestick">' + '<div>Open: <span class="value">' + o + '</span></div>' + '<div>High: <span class="value">' + h + '</span></div>' + '<div>Low: <span class="value">' + l + '</span></div>' + '<div>Close: <span class="value">' + c + '</span></div>' + '</div>';
          }
        },
        states: {
          active: {
            filter: {
              type: 'none'
            }
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "rangeBar",
    value: function rangeBar() {
      return {
        stroke: {
          width: 0
        },
        plotOptions: {
          bar: {
            dataLabels: {
              position: 'center'
            }
          }
        },
        dataLabels: {
          enabled: false,
          formatter: function formatter(val, _ref2) {
            var ctx = _ref2.ctx,
                seriesIndex = _ref2.seriesIndex,
                dataPointIndex = _ref2.dataPointIndex,
                w = _ref2.w;
            var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];
            var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];
            return end - start;
          },
          style: {
            colors: ['#fff']
          }
        },
        tooltip: {
          shared: false,
          followCursor: true,
          custom: function custom(_ref3) {
            var ctx = _ref3.ctx,
                seriesIndex = _ref3.seriesIndex,
                dataPointIndex = _ref3.dataPointIndex,
                w = _ref3.w;
            var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];
            var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];
            var startVal = '';
            var endVal = '';
            var color = w.globals.colors[seriesIndex];

            if (w.config.tooltip.x.formatter === undefined) {
              if (w.config.xaxis.type === 'datetime') {
                var datetimeObj = new DateTime(ctx);
                startVal = datetimeObj.formatDate(new Date(start), w.config.tooltip.x.format, true, true);
                endVal = datetimeObj.formatDate(new Date(end), w.config.tooltip.x.format, true, true);
              } else {
                startVal = start;
                endVal = end;
              }
            } else {
              startVal = w.config.tooltip.x.formatter(start);
              endVal = w.config.tooltip.x.formatter(end);
            }

            var ylabel = w.globals.labels[dataPointIndex];
            return '<div class="apexcharts-tooltip-rangebar">' + '<div> <span class="series-name" style="color: ' + color + '">' + (w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : '') + '</span></div>' + '<div> <span class="category">' + ylabel + ': </span> <span class="value start-value">' + startVal + '</span> <span class="separator">-</span> <span class="value end-value">' + endVal + '</span></div>' + '</div>';
          }
        },
        xaxis: {
          tooltip: {
            enabled: false
          },
          crosshairs: {
            stroke: {
              width: 0
            }
          }
        }
      };
    }
  }, {
    key: "area",
    value: function area() {
      return {
        stroke: {
          width: 4
        },
        fill: {
          type: 'gradient',
          gradient: {
            inverseColors: false,
            shade: 'light',
            type: 'vertical',
            opacityFrom: 0.65,
            opacityTo: 0.5,
            stops: [0, 100, 100]
          }
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        tooltip: {
          followCursor: false
        }
      };
    }
  }, {
    key: "brush",
    value: function brush(defaults) {
      var ret = {
        chart: {
          toolbar: {
            autoSelected: 'selection',
            show: false
          },
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          width: 1
        },
        tooltip: {
          enabled: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          }
        }
      };
      return Utils.extend(defaults, ret);
    }
  }, {
    key: "stacked100",
    value: function stacked100() {
      var _this = this;

      this.opts.dataLabels = this.opts.dataLabels || {};
      this.opts.dataLabels.formatter = this.opts.dataLabels.formatter || undefined;
      var existingDataLabelFormatter = this.opts.dataLabels.formatter;
      this.opts.yaxis.forEach(function (yaxe, index) {
        _this.opts.yaxis[index].min = 0;
        _this.opts.yaxis[index].max = 100;
      });
      var isBar = this.opts.chart.type === 'bar';

      if (isBar) {
        this.opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {
          if (typeof val === 'number') {
            return val ? val.toFixed(0) + '%' : val;
          }

          return val;
        };
      }
    } // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area

  }, {
    key: "bubble",
    value: function bubble() {
      return {
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        tooltip: {
          shared: false,
          intersect: true
        },
        xaxis: {
          crosshairs: {
            width: 0
          }
        },
        fill: {
          type: 'solid',
          gradient: {
            shade: 'light',
            inverse: true,
            shadeIntensity: 0.55,
            opacityFrom: 0.4,
            opacityTo: 0.8
          }
        }
      };
    }
  }, {
    key: "scatter",
    value: function scatter() {
      return {
        dataLabels: {
          enabled: false
        },
        tooltip: {
          shared: false,
          intersect: true
        },
        markers: {
          size: 6,
          strokeWidth: 2,
          hover: {
            sizeOffset: 2
          }
        }
      };
    }
  }, {
    key: "heatmap",
    value: function heatmap() {
      return {
        chart: {
          stacked: false,
          zoom: {
            enabled: false
          }
        },
        fill: {
          opacity: 1
        },
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        stroke: {
          colors: ['#fff']
        },
        tooltip: {
          followCursor: true,
          marker: {
            show: false
          },
          x: {
            show: false
          }
        },
        legend: {
          position: 'top',
          markers: {
            shape: 'square',
            size: 10,
            offsetY: 2
          }
        },
        grid: {
          padding: {
            right: 20
          }
        }
      };
    }
  }, {
    key: "pie",
    value: function pie() {
      return {
        chart: {
          toolbar: {
            show: false
          }
        },
        plotOptions: {
          pie: {
            donut: {
              labels: {
                show: false
              }
            }
          }
        },
        dataLabels: {
          formatter: function formatter(val) {
            return val.toFixed(1) + '%';
          },
          style: {
            colors: ['#fff']
          },
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          colors: ['#fff']
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.35,
            inverseColors: false,
            stops: [0, 100, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        tooltip: {
          theme: 'dark',
          fillSeriesColor: true
        },
        legend: {
          position: 'right'
        }
      };
    }
  }, {
    key: "donut",
    value: function donut() {
      return {
        chart: {
          toolbar: {
            show: false
          }
        },
        dataLabels: {
          formatter: function formatter(val) {
            return val.toFixed(1) + '%';
          },
          style: {
            colors: ['#fff']
          },
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          colors: ['#fff']
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.4,
            inverseColors: false,
            type: 'vertical',
            opacityFrom: 1,
            opacityTo: 1,
            stops: [70, 98, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        tooltip: {
          theme: 'dark',
          fillSeriesColor: true
        },
        legend: {
          position: 'right'
        }
      };
    }
  }, {
    key: "radar",
    value: function radar() {
      this.opts.yaxis[0].labels.style.fontSize = '13px';
      this.opts.yaxis[0].labels.offsetY = 6;
      return {
        dataLabels: {
          enabled: true,
          style: {
            colors: ['#a8a8a8'],
            fontSize: '11px'
          }
        },
        stroke: {
          width: 2
        },
        markers: {
          size: 3,
          strokeWidth: 1,
          strokeOpacity: 1
        },
        fill: {
          opacity: 0.2
        },
        tooltip: {
          shared: false,
          intersect: true,
          followCursor: true
        },
        grid: {
          show: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          },
          crosshairs: {
            show: false
          }
        }
      };
    }
  }, {
    key: "radialBar",
    value: function radialBar() {
      return {
        chart: {
          animations: {
            dynamicAnimation: {
              enabled: true,
              speed: 800
            }
          },
          toolbar: {
            show: false
          }
        },
        fill: {
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.4,
            inverseColors: false,
            type: 'diagonal2',
            opacityFrom: 1,
            opacityTo: 1,
            stops: [70, 98, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        legend: {
          show: false,
          position: 'right'
        },
        tooltip: {
          enabled: false,
          fillSeriesColor: true
        }
      };
    }
  }], [{
    key: "convertCatToNumeric",
    value: function convertCatToNumeric(opts) {
      opts.xaxis.type = 'numeric';
      opts.xaxis.convertedCatToNumeric = true;
      opts.xaxis.labels = opts.xaxis.labels || {};

      opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {
        return val;
      };

      opts.chart = opts.chart || {};
      opts.chart.zoom = opts.chart.zoom || window.Apex.chart && window.Apex.chart.zoom || {};
      var defaultFormatter = opts.xaxis.labels.formatter;
      var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;

      if (labels && labels.length) {
        opts.xaxis.labels.formatter = function (val) {
          return defaultFormatter(labels[val - 1]);
        };
      }

      opts.xaxis.categories = [];
      opts.labels = [];
      opts.chart.zoom.enabled = opts.chart.zoom.enabled || false;
      return opts;
    }
  }]);

  return Defaults;
}();

/*
 ** Util functions which are dependent on ApexCharts instance
 */
var CoreUtils =
/*#__PURE__*/
function () {
  function CoreUtils(ctx) {
    _classCallCheck(this, CoreUtils);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(CoreUtils, [{
    key: "getStackedSeriesTotals",

    /**
     * @memberof CoreUtils
     * returns the sum of all individual values in a multiple stacked series
     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
     *  @return [34,36,48,13]
     **/
    value: function getStackedSeriesTotals() {
      var w = this.w;
      var total = [];
      if (w.globals.series.length === 0) return total;

      for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {
        var t = 0;

        for (var j = 0; j < w.globals.series.length; j++) {
          t += w.globals.series[j][i];
        }

        total.push(t);
      }

      w.globals.stackedSeriesTotals = total;
      return total;
    } // get total of the all values inside all series

  }, {
    key: "getSeriesTotalByIndex",
    value: function getSeriesTotalByIndex() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (index === null) {
        // non-plot chart types - pie / donut / circle
        return this.w.config.series.reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
      } else {
        // axis charts - supporting multiple series
        return this.w.globals.series[index].reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
      }
    }
  }, {
    key: "isSeriesNull",
    value: function isSeriesNull() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var r = [];

      if (index === null) {
        // non-plot chart types - pie / donut / circle
        r = this.w.config.series.filter(function (d) {
          return d !== null;
        });
      } else {
        // axis charts - supporting multiple series
        r = this.w.globals.series[index].filter(function (d) {
          return d !== null;
        });
      }

      return r.length === 0;
    }
  }, {
    key: "seriesHaveSameValues",
    value: function seriesHaveSameValues(index) {
      return this.w.globals.series[index].every(function (val, i, arr) {
        return val === arr[0];
      });
    } // maxValsInArrayIndex is the index of series[] which has the largest number of items

  }, {
    key: "getLargestSeries",
    value: function getLargestSeries() {
      var w = this.w;
      w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {
        return a.length;
      }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {
        return a.length;
      })));
    }
  }, {
    key: "getLargestMarkerSize",
    value: function getLargestMarkerSize() {
      var w = this.w;
      var size = 0;
      w.globals.markers.size.forEach(function (m) {
        size = Math.max(size, m);
      });
      w.globals.markers.largestSize = size;
      return size;
    }
    /**
     * @memberof Core
     * returns the sum of all values in a series
     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
     *  @return [120, 11]
     **/

  }, {
    key: "getSeriesTotals",
    value: function getSeriesTotals() {
      var w = this.w;
      w.globals.seriesTotals = w.globals.series.map(function (ser, index) {
        var total = 0;

        if (Array.isArray(ser)) {
          for (var j = 0; j < ser.length; j++) {
            total += ser[j];
          }
        } else {
          // for pie/donuts/gauges
          total += ser;
        }

        return total;
      });
    }
  }, {
    key: "getSeriesTotalsXRange",
    value: function getSeriesTotalsXRange(minX, maxX) {
      var w = this.w;
      var seriesTotalsXRange = w.globals.series.map(function (ser, index) {
        var total = 0;

        for (var j = 0; j < ser.length; j++) {
          if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {
            total += ser[j];
          }
        }

        return total;
      });
      return seriesTotalsXRange;
    }
    /**
     * @memberof CoreUtils
     * returns the percentage value of all individual values which can be used in a 100% stacked series
     * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]
     *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]
     **/

  }, {
    key: "getPercentSeries",
    value: function getPercentSeries() {
      var w = this.w;
      w.globals.seriesPercent = w.globals.series.map(function (ser, index) {
        var seriesPercent = [];

        if (Array.isArray(ser)) {
          for (var j = 0; j < ser.length; j++) {
            var total = w.globals.stackedSeriesTotals[j];
            var percent = 100 * ser[j] / total;
            seriesPercent.push(percent);
          }
        } else {
          var _total = w.globals.seriesTotals.reduce(function (acc, val) {
            return acc + val;
          }, 0);

          var _percent = 100 * ser / _total;

          seriesPercent.push(_percent);
        }

        return seriesPercent;
      });
    }
  }, {
    key: "getCalculatedRatios",
    value: function getCalculatedRatios() {
      var gl = this.w.globals;
      var yRatio = [];
      var invertedYRatio = 0;
      var xRatio = 0;
      var initialXRatio = 0;
      var invertedXRatio = 0;
      var zRatio = 0;
      var baseLineY = [];
      var baseLineInvertedY = 0.1;
      var baseLineX = 0;
      gl.yRange = [];

      if (gl.isMultipleYAxis) {
        for (var i = 0; i < gl.minYArr.length; i++) {
          gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));
          baseLineY.push(0);
        }
      } else {
        gl.yRange.push(Math.abs(gl.minY - gl.maxY));
      }

      gl.xRange = Math.abs(gl.maxX - gl.minX);
      gl.zRange = Math.abs(gl.maxZ - gl.minZ); // multiple y axis

      for (var _i = 0; _i < gl.yRange.length; _i++) {
        yRatio.push(gl.yRange[_i] / gl.gridHeight);
      }

      xRatio = gl.xRange / gl.gridWidth;
      initialXRatio = Math.abs(gl.initialmaxX - gl.initialminX) / gl.gridWidth;
      invertedYRatio = gl.yRange / gl.gridWidth;
      invertedXRatio = gl.xRange / gl.gridHeight;
      zRatio = gl.zRange / gl.gridHeight * 16;

      if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
        // Negative numbers present in series
        gl.hasNegs = true;
      }

      if (gl.isMultipleYAxis) {
        baseLineY = []; // baseline variables is the 0 of the yaxis which will be needed when there are negatives

        for (var _i2 = 0; _i2 < yRatio.length; _i2++) {
          baseLineY.push(-gl.minYArr[_i2] / yRatio[_i2]);
        }
      } else {
        baseLineY.push(-gl.minY / yRatio[0]);

        if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
          baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart

          baseLineX = gl.minX / xRatio;
        }
      }

      return {
        yRatio: yRatio,
        invertedYRatio: invertedYRatio,
        zRatio: zRatio,
        xRatio: xRatio,
        initialXRatio: initialXRatio,
        invertedXRatio: invertedXRatio,
        baseLineInvertedY: baseLineInvertedY,
        baseLineY: baseLineY,
        baseLineX: baseLineX
      };
    }
  }, {
    key: "getLogSeries",
    value: function getLogSeries(series) {
      var w = this.w;
      w.globals.seriesLog = series.map(function (s, i) {
        if (w.config.yaxis[i] && w.config.yaxis[i].logarithmic) {
          return s.map(function (d) {
            if (d === null) return null;
            var logVal = (Math.log(d) - Math.log(w.globals.minYArr[i])) / (Math.log(w.globals.maxYArr[i]) - Math.log(w.globals.minYArr[i]));
            return logVal;
          });
        } else {
          return s;
        }
      });
      return w.globals.seriesLog;
    }
  }, {
    key: "getLogYRatios",
    value: function getLogYRatios(yRatio) {
      var _this = this;

      var w = this.w;
      var gl = this.w.globals;
      gl.yLogRatio = yRatio.slice();
      gl.logYRange = gl.yRange.map(function (yRange, i) {
        if (w.config.yaxis[i] && _this.w.config.yaxis[i].logarithmic) {
          var maxY = -Number.MAX_VALUE;
          var minY = Number.MIN_VALUE;
          var range = 1;
          gl.seriesLog.forEach(function (s, si) {
            s.forEach(function (v) {
              if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {
                maxY = Math.max(v, maxY);
                minY = Math.min(v, minY);
              }
            });
          });
          range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);
          gl.yLogRatio[i] = range / gl.gridHeight;
          return range;
        }
      });
      return gl.yLogRatio;
    } // Some config objects can be array - and we need to extend them correctly

  }], [{
    key: "checkComboSeries",
    value: function checkComboSeries(series) {
      var comboCharts = false;
      var comboChartsHasBars = false; // if user specified a type in series too, turn on comboCharts flag

      if (series.length && typeof series[0].type !== 'undefined') {
        comboCharts = true;
        series.forEach(function (s) {
          if (s.type === 'bar' || s.type === 'column') {
            comboChartsHasBars = true;
          }
        });
      }

      return {
        comboCharts: comboCharts,
        comboChartsHasBars: comboChartsHasBars
      };
    }
  }, {
    key: "extendArrayProps",
    value: function extendArrayProps(configInstance, options) {
      if (options.yaxis) {
        options = configInstance.extendYAxis(options);
      }

      if (options.annotations) {
        if (options.annotations.yaxis) {
          options = configInstance.extendYAxisAnnotations(options);
        }

        if (options.annotations.xaxis) {
          options = configInstance.extendXAxisAnnotations(options);
        }

        if (options.annotations.points) {
          options = configInstance.extendPointAnnotations(options);
        }
      }

      return options;
    }
  }]);

  return CoreUtils;
}();

/**
 * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.
 *
 * @module Config
 **/

var Config =
/*#__PURE__*/
function () {
  function Config(opts) {
    _classCallCheck(this, Config);

    this.opts = opts;
  }

  _createClass(Config, [{
    key: "init",
    value: function init() {
      var opts = this.opts;
      var options = new Options();
      var defaults = new Defaults(opts);
      this.chartType = opts.chart.type;

      if (this.chartType === 'histogram') {
        // technically, a histogram can be drawn by a column chart with no spaces in between
        opts.chart.type = 'bar';
        opts = Utils.extend({
          plotOptions: {
            bar: {
              columnWidth: '99.99%'
            }
          }
        }, opts);
      }

      opts = this.extendYAxis(opts);
      opts = this.extendAnnotations(opts);
      var config = options.init();
      var newDefaults = {};

      if (opts && _typeof(opts) === 'object') {
        var chartDefaults = {};

        switch (this.chartType) {
          case 'line':
            chartDefaults = defaults.line();
            break;

          case 'area':
            chartDefaults = defaults.area();
            break;

          case 'bar':
            chartDefaults = defaults.bar();
            break;

          case 'candlestick':
            chartDefaults = defaults.candlestick();
            break;

          case 'rangeBar':
            chartDefaults = defaults.rangeBar();
            break;

          case 'histogram':
            chartDefaults = defaults.bar();
            break;

          case 'bubble':
            chartDefaults = defaults.bubble();
            break;

          case 'scatter':
            chartDefaults = defaults.scatter();
            break;

          case 'heatmap':
            chartDefaults = defaults.heatmap();
            break;

          case 'pie':
            chartDefaults = defaults.pie();
            break;

          case 'donut':
            chartDefaults = defaults.donut();
            break;

          case 'radar':
            chartDefaults = defaults.radar();
            break;

          case 'radialBar':
            chartDefaults = defaults.radialBar();
            break;

          default:
            chartDefaults = defaults.line();
        }

        if (opts.chart.brush && opts.chart.brush.enabled) {
          chartDefaults = defaults.brush(chartDefaults);
        }

        if (opts.chart.stacked && opts.chart.stackType === '100%') {
          defaults.stacked100();
        } // If user has specified a dark theme, make the tooltip dark too


        this.checkForDarkTheme(window.Apex); // check global window Apex options

        this.checkForDarkTheme(opts); // check locally passed options

        opts.xaxis = opts.xaxis || window.Apex.xaxis || {};
        var combo = CoreUtils.checkComboSeries(opts.series);

        if ((opts.chart.type === 'line' || opts.chart.type === 'area' || opts.chart.type === 'scatter') && !combo.comboChartsHasBars && opts.xaxis.type !== 'datetime' && opts.xaxis.type !== 'numeric' && opts.xaxis.tickPlacement !== 'between') {
          opts = Defaults.convertCatToNumeric(opts);
        }

        if (opts.chart.sparkline && opts.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) {
          chartDefaults = defaults.sparkline(chartDefaults);
        }

        newDefaults = Utils.extend(config, chartDefaults);
      } // config should cascade in this fashion
      // default-config < global-apex-variable-config < user-defined-config
      // get GLOBALLY defined options and merge with the default config


      var mergedWithDefaultConfig = Utils.extend(newDefaults, window.Apex); // get the merged config and extend with user defined config

      config = Utils.extend(mergedWithDefaultConfig, opts); // some features are not supported. those mismatches should be handled

      config = this.handleUserInputErrors(config);
      return config;
    }
  }, {
    key: "extendYAxis",
    value: function extendYAxis(opts) {
      var options = new Options();

      if (typeof opts.yaxis === 'undefined') {
        opts.yaxis = {};
      } // extend global yaxis config (only if object is provided / not an array)


      if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {
        opts.yaxis = Utils.extend(opts.yaxis, window.Apex.yaxis);
      } // as we can't extend nested object's array with extend, we need to do it first
      // user can provide either an array or object in yaxis config


      if (opts.yaxis.constructor !== Array) {
        // convert the yaxis to array if user supplied object
        opts.yaxis = [Utils.extend(options.yAxis, opts.yaxis)];
      } else {
        opts.yaxis = Utils.extendArray(opts.yaxis, options.yAxis);
      }

      return opts;
    } // annotations also accepts array, so we need to extend them manually

  }, {
    key: "extendAnnotations",
    value: function extendAnnotations(opts) {
      if (typeof opts.annotations === 'undefined') {
        opts.annotations = {};
        opts.annotations.yaxis = [];
        opts.annotations.xaxis = [];
        opts.annotations.points = [];
      }

      opts = this.extendYAxisAnnotations(opts);
      opts = this.extendXAxisAnnotations(opts);
      opts = this.extendPointAnnotations(opts);
      return opts;
    }
  }, {
    key: "extendYAxisAnnotations",
    value: function extendYAxisAnnotations(opts) {
      var options = new Options();
      opts.annotations.yaxis = Utils.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);
      return opts;
    }
  }, {
    key: "extendXAxisAnnotations",
    value: function extendXAxisAnnotations(opts) {
      var options = new Options();
      opts.annotations.xaxis = Utils.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);
      return opts;
    }
  }, {
    key: "extendPointAnnotations",
    value: function extendPointAnnotations(opts) {
      var options = new Options();
      opts.annotations.points = Utils.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);
      return opts;
    }
  }, {
    key: "checkForDarkTheme",
    value: function checkForDarkTheme(opts) {
      if (opts.theme && opts.theme.mode === 'dark') {
        if (!opts.tooltip) {
          opts.tooltip = {};
        }

        if (opts.tooltip.theme !== 'light') {
          opts.tooltip.theme = 'dark';
        }

        if (!opts.chart.foreColor) {
          opts.chart.foreColor = '#f6f7f8';
        }

        if (!opts.theme.palette) {
          opts.theme.palette = 'palette4';
        }
      }
    }
  }, {
    key: "handleUserInputErrors",
    value: function handleUserInputErrors(opts) {
      var config = opts; // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it

      if (config.tooltip.shared && config.tooltip.intersect) {
        throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');
      }

      if (config.chart.scroller) {
        console.warn('Scroller has been deprecated since v2.0.0. Please remove the configuration for chart.scroller');
      }

      if ((config.chart.type === 'bar' || config.chart.type === 'rangeBar') && config.plotOptions.bar.horizontal) {
        // No multiple yaxis for bars
        if (config.yaxis.length > 1) {
          throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');
        } // if yaxis is reversed in horizontal bar chart, you should draw the y-axis on right side


        if (config.yaxis[0].reversed) {
          config.yaxis[0].opposite = true;
        }

        config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar

        config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar

        config.chart.zoom.enabled = false; // no zooming for horz bars
      }

      if (config.chart.type === 'bar' || config.chart.type === 'rangeBar') {
        if (config.tooltip.shared) {
          if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {
            console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.');
            config.xaxis.crosshairs.width = 'tickWidth';
          }

          if (config.plotOptions.bar.horizontal) {
            config.states.hover.type = 'none';
            config.tooltip.shared = false;
          }

          if (!config.tooltip.followCursor) {
            console.warn('followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true', 'color: blue;');
            config.tooltip.followCursor = true;
          }
        }
      }

      if (config.chart.type === 'candlestick') {
        if (config.yaxis[0].reversed) {
          console.warn('Reversed y-axis in candlestick chart is not supported.');
          config.yaxis[0].reversed = false;
        }
      }

      if (config.chart.group && config.yaxis[0].labels.minWidth === 0) {
        console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.');
      } // if user supplied array for stroke width, it will only be applicable to line/area charts, for any other charts, revert back to Number


      if (Array.isArray(config.stroke.width)) {
        if (config.chart.type !== 'line' && config.chart.type !== 'area') {
          console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number');
          config.stroke.width = config.stroke.width[0];
        }
      }

      return config;
    }
  }]);

  return Config;
}();

var Globals =
/*#__PURE__*/
function () {
  function Globals() {
    _classCallCheck(this, Globals);
  }

  _createClass(Globals, [{
    key: "globalVars",
    value: function globalVars(config) {
      return {
        chartID: null,
        // chart ID - apexcharts-cuid
        cuid: null,
        // chart ID - random numbers excluding "apexcharts" part
        events: {
          beforeMount: [],
          mounted: [],
          updated: [],
          clicked: [],
          selection: [],
          dataPointSelection: [],
          zoomed: [],
          scrolled: []
        },
        colors: [],
        clientX: null,
        clientY: null,
        fill: {
          colors: []
        },
        stroke: {
          colors: []
        },
        dataLabels: {
          style: {
            colors: []
          }
        },
        radarPolygons: {
          fill: {
            colors: []
          }
        },
        markers: {
          colors: [],
          size: config.markers.size,
          largestSize: 0
        },
        animationEnded: false,
        isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,
        isDirty: false,
        // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update
        isExecCalled: false,
        // whether user updated the chart through the exec method
        initialConfig: null,
        // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it
        lastXAxis: [],
        lastYAxis: [],
        series: [],
        // the MAIN series array (y values)
        seriesRangeStart: [],
        // the clone of series becomes the start in range
        seriesRangeEnd: [],
        // the end values in range chart
        seriesPercent: [],
        // the percentage values of the given series
        seriesTotals: [],
        stackedSeriesTotals: [],
        seriesX: [],
        // store the numeric x values in this array (x values)
        seriesZ: [],
        // The 3rd "Z" dimension for bubbles chart (z values)
        labels: [],
        // store the text to draw on x axis
        // Don't mutate the labels, many things including tooltips depends on it!
        timelineLabels: [],
        // store the timeline Labels in another variable
        invertedTimelineLabels: [],
        // for rangebar timeline
        seriesNames: [],
        // same as labels, used in non axis charts
        noLabelsProvided: false,
        // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...
        allSeriesCollapsed: false,
        collapsedSeries: [],
        // when user collapses a series, it goes into this array
        collapsedSeriesIndices: [],
        // this stores the index of the collapsedSeries instead of whole object for quick access
        ancillaryCollapsedSeries: [],
        // when user collapses an "alwaysVisible" series, it goes into this array
        ancillaryCollapsedSeriesIndices: [],
        // this stores the index of the ancillaryCollapsedSeries whose y-axis is always visible
        risingSeries: [],
        // when user re-opens a collapsed series, it goes here
        dataFormatXNumeric: false,
        // boolean value to indicate user has passed numeric x values
        selectedDataPoints: [],
        ignoreYAxisIndexes: [],
        // when series are being collapsed in multiple y axes, ignore certain index
        yAxisSameScaleIndices: [],
        padHorizontal: 0,
        maxValsInArrayIndex: 0,
        radialSize: 0,
        zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,
        panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,
        selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,
        yaxis: null,
        minY: Number.MIN_VALUE,
        //  is 5e-324, i.e. the smallest positive number
        // NOTE: If there are multiple y axis, the first yaxis array element will be considered for all y values calculations. Rest all will be calculated based on that
        maxY: -Number.MAX_VALUE,
        // is -1.7976931348623157e+308
        // NOTE: The above note for minY applies here as well
        minYArr: [],
        maxYArr: [],
        maxX: -Number.MAX_VALUE,
        // is -1.7976931348623157e+308
        initialmaxX: -Number.MAX_VALUE,
        minX: Number.MIN_VALUE,
        //  is 5e-324, i.e. the smallest positive number
        initialminX: Number.MIN_VALUE,
        minZ: Number.MIN_VALUE,
        // Max Z value in charts with Z axis
        maxZ: -Number.MAX_VALUE,
        // Max Z value in charts with Z axis
        minXDiff: Number.MAX_VALUE,
        mousedown: false,
        lastClientPosition: {},
        // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning
        visibleXRange: undefined,
        yRange: [],
        // this property is the absolute sum of positive and negative values [eg (-100 + 200 = 300)] - yAxis
        zRange: 0,
        // zAxis Range (for bubble charts)
        xRange: 0,
        // xAxis range
        yValueDecimal: 0,
        // are there floating numbers in the series. If yes, this represent the len of the decimals
        total: 0,
        SVGNS: 'http://www.w3.org/2000/svg',
        // svg namespace
        svgWidth: 0,
        // the whole svg width
        svgHeight: 0,
        // the whole svg height
        noData: false,
        // whether there is any data to display or not
        locale: {},
        // the current locale values will be preserved here for global access
        dom: {},
        // for storing all dom nodes in this particular property
        // elWrap: null, // the element that wraps everything
        // elGraphical: null, // this contains lines/areas/bars/pies
        // elGridRect: null, // paths going outside this area will be clipped
        // elGridRectMask: null, // clipping will happen with this mask
        // elGridRectMarkerMask: null, // clipping will happen with this mask
        // elLegendWrap: null, // the whole legend area
        // elDefs: null, // [defs] element
        memory: {
          methodsToExec: []
        },
        shouldAnimate: true,
        skipLastTimelinelabel: false,
        // when last label is cropped, skip drawing it
        delayedElements: [],
        // element which appear after animation has finished
        axisCharts: true,
        // chart type = line or area or bar
        // (refer them also as plot charts in the code)
        isXNumeric: false,
        // bool: data was provided in a {[x,y], [x,y]} pattern
        isDataXYZ: false,
        // bool: data was provided in a {[x,y,z]} pattern
        resized: false,
        // bool: user has resized
        resizeTimer: null,
        // timeout function to make a small delay before
        // drawing when user resized
        comboCharts: false,
        // bool: whether it's a combination of line/column
        comboChartsHasBars: false,
        // bool: whether it's a combination of line/column
        dataChanged: false,
        // bool: has data changed dynamically
        previousPaths: [],
        // array: when data is changed, it will animate from
        // previous paths
        seriesXvalues: [],
        // we will need this in tooltip (it's x position)
        // when we will have unequal x values, we will need
        // some way to get x value depending on mouse pointer
        seriesYvalues: [],
        // we will need this when deciding which series
        // user hovered on
        seriesCandleO: [],
        // candle stick open values
        seriesCandleH: [],
        // candle stick high values
        seriesCandleL: [],
        // candle stick low values
        seriesCandleC: [],
        // candle stick close values
        allSeriesHasEqualX: true,
        dataPoints: 0,
        // the longest series length
        pointsArray: [],
        // store the points positions here to draw later on hover
        // format is - [[x,y],[x,y]... [x,y]]
        dataLabelsRects: [],
        // store the positions of datalabels to prevent collision
        lastDrawnDataLabelsIndexes: [],
        hasNullValues: false,
        // bool: whether series contains null values
        easing: null,
        // function: animation effect to apply
        zoomed: false,
        // whether user has zoomed or not
        gridWidth: 0,
        // drawable width of actual graphs (series paths)
        gridHeight: 0,
        // drawable height of actual graphs (series paths)
        yAxisScale: [],
        xAxisScale: null,
        xAxisTicksPositions: [],
        timescaleTicks: [],
        rotateXLabels: false,
        defaultLabels: false,
        xLabelFormatter: undefined,
        // formatter for x axis labels
        yLabelFormatters: [],
        xaxisTooltipFormatter: undefined,
        // formatter for x axis tooltip
        ttKeyFormatter: undefined,
        ttVal: undefined,
        ttZFormatter: undefined,
        LINE_HEIGHT_RATIO: 1.618,
        xAxisLabelsHeight: 0,
        yAxisLabelsWidth: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateYAxisX: [],
        yLabelsCoords: [],
        yTitleCoords: [],
        yAxisWidths: [],
        translateXAxisY: 0,
        translateXAxisX: 0,
        tooltip: null,
        tooltipOpts: null
      };
    }
  }, {
    key: "init",
    value: function init(config) {
      var globals = this.globalVars(config);
      globals.initialConfig = Utils.extend({}, config);
      globals.initialSeries = JSON.parse(JSON.stringify(globals.initialConfig.series));
      globals.lastXAxis = JSON.parse(JSON.stringify(globals.initialConfig.xaxis));
      globals.lastYAxis = JSON.parse(JSON.stringify(globals.initialConfig.yaxis));
      return globals;
    }
  }]);

  return Globals;
}();

/**
 * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.
 *
 * @module Base
 **/

var Base =
/*#__PURE__*/
function () {
  function Base(opts) {
    _classCallCheck(this, Base);

    this.opts = opts;
  }

  _createClass(Base, [{
    key: "init",
    value: function init() {
      var config = new Config(this.opts).init();
      var globals = new Globals().init(config);
      var w = {
        config: config,
        globals: globals
      };
      return w;
    }
  }]);

  return Base;
}();

/**
 * ApexCharts Fill Class for setting fill options of the paths.
 *
 * @module Fill
 **/

var Fill =
/*#__PURE__*/
function () {
  function Fill(ctx) {
    _classCallCheck(this, Fill);

    this.ctx = ctx;
    this.w = ctx.w;
    this.opts = null;
    this.seriesIndex = 0;
  }

  _createClass(Fill, [{
    key: "clippedImgArea",
    value: function clippedImgArea(params) {
      var w = this.w;
      var cnf = w.config;
      var svgW = parseInt(w.globals.gridWidth);
      var svgH = parseInt(w.globals.gridHeight);
      var size = svgW > svgH ? svgW : svgH;
      var fillImg = params.image;
      var imgWidth = 0;
      var imgHeight = 0;

      if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {
        if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {
          imgWidth = cnf.fill.image.width + 1;
          imgHeight = cnf.fill.image.height;
        } else {
          imgWidth = size + 1;
          imgHeight = size;
        }
      } else {
        imgWidth = params.width;
        imgHeight = params.height;
      }

      var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');
      Graphics.setAttrs(elPattern, {
        id: params.patternID,
        patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',
        width: imgWidth + 'px',
        height: imgHeight + 'px'
      });
      var elImage = document.createElementNS(w.globals.SVGNS, 'image');
      elPattern.appendChild(elImage);
      elImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', fillImg);
      Graphics.setAttrs(elImage, {
        x: 0,
        y: 0,
        preserveAspectRatio: 'none',
        width: imgWidth + 'px',
        height: imgHeight + 'px'
      });
      elImage.style.opacity = params.opacity;
      w.globals.dom.elDefs.node.appendChild(elPattern);
    }
  }, {
    key: "getSeriesIndex",
    value: function getSeriesIndex(opts) {
      var w = this.w;

      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap') {
        this.seriesIndex = opts.seriesNumber;
      } else {
        this.seriesIndex = opts.seriesNumber % w.globals.series.length;
      }

      return this.seriesIndex;
    }
  }, {
    key: "fillPath",
    value: function fillPath(opts) {
      var w = this.w;
      this.opts = opts;
      var cnf = this.w.config;
      var pathFill;
      var patternFill, gradientFill;
      this.seriesIndex = this.getSeriesIndex(opts);
      var fillColors = this.getFillColors();
      var fillColor = fillColors[this.seriesIndex];

      if (typeof fillColor === 'function') {
        fillColor = fillColor({
          seriesIndex: this.seriesIndex,
          value: opts.value,
          w: w
        });
      }

      var fillType = this.getFillType(this.seriesIndex);
      var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;
      var defaultColor = fillColor;

      if (opts.color) {
        fillColor = opts.color;
      }

      if (fillColor.indexOf('rgb') === -1) {
        defaultColor = Utils.hexToRgba(fillColor, fillOpacity);
      } else {
        if (fillColor.indexOf('rgba') > -1) {
          fillOpacity = 0 + '.' + Utils.getOpacityFromRGBA(fillColor);
        }
      }

      if (fillType === 'pattern') {
        patternFill = this.handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor);
      }

      if (fillType === 'gradient') {
        gradientFill = this.handleGradientFill(gradientFill, fillColor, fillOpacity, this.seriesIndex);
      }

      if (cnf.fill.image.src.length > 0 && fillType === 'image') {
        if (opts.seriesNumber < cnf.fill.image.src.length) {
          this.clippedImgArea({
            opacity: fillOpacity,
            image: cnf.fill.image.src[opts.seriesNumber],
            patternUnits: opts.patternUnits,
            patternID: "pattern".concat(w.globals.cuid).concat(opts.seriesNumber + 1)
          });
          pathFill = "url(#pattern".concat(w.globals.cuid).concat(opts.seriesNumber + 1, ")");
        } else {
          pathFill = defaultColor;
        }
      } else if (fillType === 'gradient') {
        pathFill = gradientFill;
      } else if (fillType === 'pattern') {
        pathFill = patternFill;
      } else {
        pathFill = defaultColor;
      } // override pattern/gradient if opts.solid is true


      if (opts.solid) {
        pathFill = defaultColor;
      }

      return pathFill;
    }
  }, {
    key: "getFillType",
    value: function getFillType(seriesIndex) {
      var w = this.w;

      if (Array.isArray(w.config.fill.type)) {
        return w.config.fill.type[seriesIndex];
      } else {
        return w.config.fill.type;
      }
    }
  }, {
    key: "getFillColors",
    value: function getFillColors() {
      var w = this.w;
      var cnf = w.config;
      var opts = this.opts;
      var fillColors = [];

      if (w.globals.comboCharts) {
        if (w.config.series[this.seriesIndex].type === 'line') {
          if (w.globals.stroke.colors instanceof Array) {
            fillColors = w.globals.stroke.colors;
          } else {
            fillColors.push(w.globals.stroke.colors);
          }
        } else {
          if (w.globals.fill.colors instanceof Array) {
            fillColors = w.globals.fill.colors;
          } else {
            fillColors.push(w.globals.fill.colors);
          }
        }
      } else {
        if (cnf.chart.type === 'line') {
          if (w.globals.stroke.colors instanceof Array) {
            fillColors = w.globals.stroke.colors;
          } else {
            fillColors.push(w.globals.stroke.colors);
          }
        } else {
          if (w.globals.fill.colors instanceof Array) {
            fillColors = w.globals.fill.colors;
          } else {
            fillColors.push(w.globals.fill.colors);
          }
        }
      } // colors passed in arguments


      if (typeof opts.fillColors !== 'undefined') {
        fillColors = [];

        if (opts.fillColors instanceof Array) {
          fillColors = opts.fillColors.slice();
        } else {
          fillColors.push(opts.fillColors);
        }
      }

      return fillColors;
    }
  }, {
    key: "handlePatternFill",
    value: function handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor) {
      var cnf = this.w.config;
      var opts = this.opts;
      var graphics = new Graphics(this.ctx);
      var patternStrokeWidth = cnf.fill.pattern.strokeWidth === undefined ? Array.isArray(cnf.stroke.width) ? cnf.stroke.width[this.seriesIndex] : cnf.stroke.width : Array.isArray(cnf.fill.pattern.strokeWidth) ? cnf.fill.pattern.strokeWidth[this.seriesIndex] : cnf.fill.pattern.strokeWidth;
      var patternLineColor = fillColor;

      if (cnf.fill.pattern.style instanceof Array) {
        if (typeof cnf.fill.pattern.style[opts.seriesNumber] !== 'undefined') {
          var pf = graphics.drawPattern(cnf.fill.pattern.style[opts.seriesNumber], cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
          patternFill = pf;
        } else {
          patternFill = defaultColor;
        }
      } else {
        patternFill = graphics.drawPattern(cnf.fill.pattern.style, cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
      }

      return patternFill;
    }
  }, {
    key: "handleGradientFill",
    value: function handleGradientFill(gradientFill, fillColor, fillOpacity, i) {
      var cnf = this.w.config;
      var opts = this.opts;
      var graphics = new Graphics(this.ctx);
      var utils = new Utils();
      var type = cnf.fill.gradient.type;
      var gradientFrom, gradientTo;
      var opacityFrom = cnf.fill.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityFrom) ? cnf.fill.gradient.opacityFrom[i] : cnf.fill.gradient.opacityFrom;
      var opacityTo = cnf.fill.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityTo) ? cnf.fill.gradient.opacityTo[i] : cnf.fill.gradient.opacityTo;
      gradientFrom = fillColor;

      if (cnf.fill.gradient.gradientToColors === undefined || cnf.fill.gradient.gradientToColors.length === 0) {
        if (cnf.fill.gradient.shade === 'dark') {
          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity) * -1, fillColor);
        } else {
          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity), fillColor);
        }
      } else {
        gradientTo = cnf.fill.gradient.gradientToColors[opts.seriesNumber];
      }

      if (cnf.fill.gradient.inverseColors) {
        var t = gradientFrom;
        gradientFrom = gradientTo;
        gradientTo = t;
      }

      gradientFill = graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, cnf.fill.gradient.stops, cnf.fill.gradient.colorStops, i);
      return gradientFill;
    }
  }]);

  return Fill;
}();

/**
 * ApexCharts Markers Class for drawing points on y values in axes charts.
 *
 * @module Markers
 **/

var Markers =
/*#__PURE__*/
function () {
  function Markers(ctx, opts) {
    _classCallCheck(this, Markers);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Markers, [{
    key: "setGlobalMarkerSize",
    value: function setGlobalMarkerSize() {
      var w = this.w;
      w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];

      if (w.globals.markers.size.length > 0) {
        if (w.globals.markers.size.length < w.globals.series.length + 1) {
          for (var i = 0; i <= w.globals.series.length; i++) {
            if (typeof w.globals.markers.size[i] === 'undefined') {
              w.globals.markers.size.push(w.globals.markers.size[0]);
            }
          }
        }
      } else {
        w.globals.markers.size = w.config.series.map(function (s) {
          return w.config.markers.size;
        });
      }
    }
  }, {
    key: "plotChartMarkers",
    value: function plotChartMarkers(pointsPos, seriesIndex, j) {
      var w = this.w;
      var i = seriesIndex;
      var p = pointsPos;
      var elPointsWrap = null;
      var graphics = new Graphics(this.ctx);
      var point;

      if (w.globals.markers.size[seriesIndex] > 0) {
        elPointsWrap = graphics.group({
          class: 'apexcharts-series-markers'
        });
        elPointsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));
      }

      if (p.x instanceof Array) {
        for (var q = 0; q < p.x.length; q++) {
          var dataPointIndex = j; // a small hack as we have 2 points for the first val to connect it

          if (j === 1 && q === 0) dataPointIndex = 0;
          if (j === 1 && q === 1) dataPointIndex = 1;
          var PointClasses = 'apexcharts-marker';

          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
            PointClasses += ' no-pointer-events';
          }

          var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;

          if (shouldMarkerDraw) {
            if (Utils.isNumber(p.y[q])) {
              PointClasses += " w".concat((Math.random() + 1).toString(36).substring(4));
            } else {
              PointClasses = 'apexcharts-nullpoint';
            }

            var opts = this.getMarkerConfig(PointClasses, seriesIndex, dataPointIndex);

            if (w.config.series[i].data[j]) {
              if (w.config.series[i].data[j].fillColor) {
                opts.pointFillColor = w.config.series[i].data[j].fillColor;
              }

              if (w.config.series[i].data[j].strokeColor) {
                opts.pointStrokeColor = w.config.series[i].data[j].strokeColor;
              }
            }

            point = graphics.drawMarker(p.x[q], p.y[q], opts);
            point.attr('rel', dataPointIndex);
            point.attr('j', dataPointIndex);
            point.attr('index', seriesIndex);
            point.node.setAttribute('default-marker-size', opts.pSize);
            var filters = new Filters(this.ctx);
            filters.setSelectionFilter(point, seriesIndex, dataPointIndex);
            this.addEvents(point);

            if (elPointsWrap) {
              elPointsWrap.add(point);
            }
          } else {
            // dynamic array creation - multidimensional
            if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];
            w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);
          }
        }
      }

      return elPointsWrap;
    }
  }, {
    key: "getMarkerConfig",
    value: function getMarkerConfig(cssClass, seriesIndex) {
      var dataPointIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var w = this.w;
      var pStyle = this.getMarkerStyle(seriesIndex);
      var pSize = w.globals.markers.size[seriesIndex]; // discrete markers is an option where user can specify a particular marker with different size and color

      if (dataPointIndex !== null && w.config.markers.discrete.length) {
        w.config.markers.discrete.map(function (marker) {
          if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {
            pStyle.pointStrokeColor = marker.strokeColor;
            pStyle.pointFillColor = marker.fillColor;
            pSize = marker.size;
          }
        });
      }

      return {
        pSize: pSize,
        pRadius: w.config.markers.radius,
        pWidth: w.config.markers.strokeWidth,
        pointStrokeColor: pStyle.pointStrokeColor,
        pointFillColor: pStyle.pointFillColor,
        shape: w.config.markers.shape instanceof Array ? w.config.markers.shape[seriesIndex] : w.config.markers.shape,
        class: cssClass,
        pointStrokeOpacity: w.config.markers.strokeOpacity,
        pointFillOpacity: w.config.markers.fillOpacity,
        seriesIndex: seriesIndex
      };
    }
  }, {
    key: "addEvents",
    value: function addEvents(circle) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      circle.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, circle));
      circle.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, circle));
      circle.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, circle));
      circle.node.addEventListener('click', w.config.markers.onClick);
      circle.node.addEventListener('dblclick', w.config.markers.onDblClick);
      circle.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, circle), {
        passive: true
      });
    }
  }, {
    key: "getMarkerStyle",
    value: function getMarkerStyle(seriesIndex) {
      var w = this.w;
      var colors = w.globals.markers.colors;
      var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;
      var pointStrokeColor = strokeColors instanceof Array ? strokeColors[seriesIndex] : strokeColors;
      var pointFillColor = colors instanceof Array ? colors[seriesIndex] : colors;
      return {
        pointStrokeColor: pointStrokeColor,
        pointFillColor: pointFillColor
      };
    }
  }]);

  return Markers;
}();

/**
 * ApexCharts Scatter Class.
 * This Class also handles bubbles chart as currently there is no major difference in drawing them,
 * @module Scatter
 **/

var Scatter =
/*#__PURE__*/
function () {
  function Scatter(ctx) {
    _classCallCheck(this, Scatter);

    this.ctx = ctx;
    this.w = ctx.w;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; // this array will help in centering the label in bubbles

    this.radiusSizes = [];
  }

  _createClass(Scatter, [{
    key: "draw",
    value: function draw(elSeries, j, opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var realIndex = opts.realIndex;
      var pointsPos = opts.pointsPos;
      var zRatio = opts.zRatio;
      var elPointsMain = opts.elParent;
      var elPointsWrap = graphics.group({
        class: "apexcharts-series-markers apexcharts-series-".concat(w.config.chart.type)
      });
      elPointsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));

      if (pointsPos.x instanceof Array) {
        for (var q = 0; q < pointsPos.x.length; q++) {
          var dataPointIndex = j + 1;
          var shouldDraw = true; // a small hack as we have 2 points for the first val to connect it

          if (j === 0 && q === 0) dataPointIndex = 0;
          if (j === 0 && q === 1) dataPointIndex = 1;
          var radius = 0;
          var finishRadius = w.globals.markers.size[realIndex];

          if (zRatio !== Infinity) {
            // means we have a bubble
            finishRadius = w.globals.seriesZ[realIndex][dataPointIndex] / zRatio;

            if (typeof this.radiusSizes[realIndex] === 'undefined') {
              this.radiusSizes.push([]);
            }

            this.radiusSizes[realIndex].push(finishRadius);
          }

          if (!w.config.chart.animations.enabled) {
            radius = finishRadius;
          }

          var x = pointsPos.x[q];
          var y = pointsPos.y[q];
          radius = radius || 0;

          if (x === 0 && y === 0 || y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {
            shouldDraw = false;
          }

          if (shouldDraw) {
            var circle = this.drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j);
            elPointsWrap.add(circle);
          }

          elPointsMain.add(elPointsWrap);
        }
      }
    }
  }, {
    key: "drawPoint",
    value: function drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j) {
      var w = this.w;
      var i = realIndex;
      var anim = new Animations(this.ctx);
      var filters = new Filters(this.ctx);
      var fill = new Fill(this.ctx);
      var markers = new Markers(this.ctx);
      var graphics = new Graphics(this.ctx);
      var markerConfig = markers.getMarkerConfig('apexcharts-marker', i);
      var pathFillCircle = fill.fillPath({
        seriesNumber: realIndex,
        patternUnits: 'objectBoundingBox',
        value: w.globals.series[realIndex][j]
      });
      var circle = graphics.drawCircle(radius);

      if (w.config.series[i].data[dataPointIndex]) {
        if (w.config.series[i].data[dataPointIndex].fillColor) {
          pathFillCircle = w.config.series[i].data[dataPointIndex].fillColor;
        }
      }

      circle.attr({
        cx: x,
        cy: y,
        fill: pathFillCircle,
        stroke: markerConfig.pointStrokeColor,
        strokeWidth: markerConfig.pWidth
      });

      if (w.config.chart.dropShadow.enabled) {
        var dropShadow = w.config.chart.dropShadow;
        filters.dropShadow(circle, dropShadow, realIndex);
      }

      if (this.initialAnim && !w.globals.dataChanged) {
        var speed = 1;

        if (!w.globals.resized) {
          speed = w.config.chart.animations.speed;
        }

        anim.animateCircleRadius(circle, 0, finishRadius, speed, w.globals.easing);
      }

      if (w.globals.dataChanged) {
        if (this.dynamicAnim) {
          var _speed = w.config.chart.animations.dynamicAnimation.speed;
          var prevX, prevY, prevR;
          var prevPathJ = null;
          prevPathJ = w.globals.previousPaths[realIndex] && w.globals.previousPaths[realIndex][j];

          if (typeof prevPathJ !== 'undefined' && prevPathJ !== null) {
            // series containing less elements will ignore these values and revert to 0
            prevX = prevPathJ.x;
            prevY = prevPathJ.y;
            prevR = typeof prevPathJ.r !== 'undefined' ? prevPathJ.r : finishRadius;
          }

          for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {
            if (w.globals.collapsedSeries[cs].index === realIndex) {
              _speed = 1;
              finishRadius = 0;
            }
          }

          if (x === 0 && y === 0) finishRadius = 0;
          anim.animateCircle(circle, {
            cx: prevX,
            cy: prevY,
            r: prevR
          }, {
            cx: x,
            cy: y,
            r: finishRadius
          }, _speed, w.globals.easing);
        } else {
          circle.attr({
            r: finishRadius
          });
        }
      }

      circle.attr({
        rel: dataPointIndex,
        j: dataPointIndex,
        index: realIndex,
        'default-marker-size': finishRadius
      });
      filters.setSelectionFilter(circle, realIndex, dataPointIndex);
      markers.addEvents(circle);
      circle.node.classList.add('apexcharts-marker');
      return circle;
    }
  }, {
    key: "centerTextInBubble",
    value: function centerTextInBubble(y) {
      var w = this.w;
      y = y + parseInt(w.config.dataLabels.style.fontSize) / 4;
      return {
        y: y
      };
    }
  }]);

  return Scatter;
}();

/**
 * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.
 *
 * @module DataLabels
 **/

var DataLabels =
/*#__PURE__*/
function () {
  function DataLabels(ctx) {
    _classCallCheck(this, DataLabels);

    this.ctx = ctx;
    this.w = ctx.w;
  } // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that
  // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again


  _createClass(DataLabels, [{
    key: "dataLabelsCorrection",
    value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var drawnextLabel = false; //

      var textRects = graphics.getTextRects(val, fontSize);
      var width = textRects.width;
      var height = textRects.height; // first value in series, so push an empty array

      if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = []; // then start pushing actual rects in that sub-array

      w.globals.dataLabelsRects[i].push({
        x: x,
        y: y,
        width: width,
        height: height
      });
      var len = w.globals.dataLabelsRects[i].length - 2;
      var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;

      if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {
        var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];

        if ( // next label forward and x not intersecting
        x > lastDataLabelRect.x + lastDataLabelRect.width + 2 || y > lastDataLabelRect.y + lastDataLabelRect.height + 2 || x + width < lastDataLabelRect.x // next label is going to be drawn backwards
        ) {
            // the 2 indexes don't override, so OK to draw next label
            drawnextLabel = true;
          }
      }

      if (dataPointIndex === 0 || alwaysDrawDataLabel) {
        drawnextLabel = true;
      }

      return {
        x: x,
        y: y,
        drawnextLabel: drawnextLabel
      };
    }
  }, {
    key: "drawDataLabel",
    value: function drawDataLabel(pos, i, j) {
      var align = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';
      // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions
      // all other charts like bars / heatmaps will define their own drawDataLabel routine
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var dataLabelsConfig = w.config.dataLabels;
      var x = 0;
      var y = 0;
      var dataPointIndex = j;
      var elDataLabelsWrap = null;

      if (!dataLabelsConfig.enabled || pos.x instanceof Array !== true) {
        return elDataLabelsWrap;
      }

      elDataLabelsWrap = graphics.group({
        class: 'apexcharts-data-labels'
      });
      elDataLabelsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));

      for (var q = 0; q < pos.x.length; q++) {
        x = pos.x[q] + dataLabelsConfig.offsetX;
        y = pos.y[q] + dataLabelsConfig.offsetY - w.globals.markers.size[i] - 5;

        if (align === 'bottom') {
          y = y + w.globals.markers.size[i] * 2 + parseInt(dataLabelsConfig.style.fontSize) * 1.4;
        }

        if (!isNaN(x)) {
          // a small hack as we have 2 points for the first val to connect it
          if (j === 1 && q === 0) dataPointIndex = 0;
          if (j === 1 && q === 1) dataPointIndex = 1;
          var val = w.globals.series[i][dataPointIndex];
          var text = '';

          if (w.config.chart.type === 'bubble') {
            text = w.globals.seriesZ[i][dataPointIndex];
            y = pos.y[q] + w.config.dataLabels.offsetY;
            var scatter = new Scatter(this.ctx);
            var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);
            y = centerTextInBubbleCoords.y;
          } else {
            if (typeof val !== 'undefined') {
              text = w.config.dataLabels.formatter(val, {
                ctx: this.ctx,
                seriesIndex: i,
                dataPointIndex: dataPointIndex,
                w: w
              });
            }
          }

          this.plotDataLabelsText({
            x: x,
            y: y,
            text: text,
            i: i,
            j: dataPointIndex,
            parent: elDataLabelsWrap,
            offsetCorrection: true,
            dataLabelsConfig: w.config.dataLabels
          });
        }
      }

      return elDataLabelsWrap;
    }
  }, {
    key: "plotDataLabelsText",
    value: function plotDataLabelsText(opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var x = opts.x,
          y = opts.y,
          i = opts.i,
          j = opts.j,
          text = opts.text,
          textAnchor = opts.textAnchor,
          parent = opts.parent,
          dataLabelsConfig = opts.dataLabelsConfig,
          alwaysDrawDataLabel = opts.alwaysDrawDataLabel,
          offsetCorrection = opts.offsetCorrection;

      if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {
        if (w.config.dataLabels.enabledOnSeries.indexOf(i) > -1) {
          return;
        }
      }

      var correctedLabels = {
        x: x,
        y: y,
        drawnextLabel: true
      };

      if (offsetCorrection) {
        correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize));
      } // when zoomed, we don't need to correct labels offsets,
      // but if normally, labels get cropped, correct them


      if (!w.globals.zoomed) {
        x = correctedLabels.x;
        y = correctedLabels.y;
      }

      if (correctedLabels.drawnextLabel) {
        var dataLabelText = graphics.drawText({
          width: 100,
          height: parseInt(dataLabelsConfig.style.fontSize),
          x: x,
          y: y,
          foreColor: w.globals.dataLabels.style.colors[i],
          textAnchor: textAnchor || dataLabelsConfig.textAnchor,
          text: text,
          fontSize: dataLabelsConfig.style.fontSize,
          fontFamily: dataLabelsConfig.style.fontFamily
        });
        dataLabelText.attr({
          class: 'apexcharts-datalabel',
          cx: x,
          cy: y
        });

        if (dataLabelsConfig.dropShadow.enabled) {
          var textShadow = dataLabelsConfig.dropShadow;
          var filters = new Filters(this.ctx);
          filters.dropShadow(dataLabelText, textShadow);
        }

        parent.add(dataLabelText);

        if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {
          w.globals.lastDrawnDataLabelsIndexes[i] = [];
        }

        w.globals.lastDrawnDataLabelsIndexes[i].push(j);
      }
    }
  }]);

  return DataLabels;
}();

/**
 * ApexCharts Bar Class responsible for drawing both Columns and Bars.
 *
 * @module Bar
 **/

var Bar =
/*#__PURE__*/
function () {
  function Bar(ctx, xyRatios) {
    _classCallCheck(this, Bar);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.barOptions = w.config.plotOptions.bar;
    this.isHorizontal = this.barOptions.horizontal;
    this.strokeWidth = w.config.stroke.width;
    this.isNullValue = false;
    this.xyRatios = xyRatios;

    if (this.xyRatios !== null) {
      this.xRatio = xyRatios.xRatio;
      this.yRatio = xyRatios.yRatio;
      this.invertedXRatio = xyRatios.invertedXRatio;
      this.invertedYRatio = xyRatios.invertedYRatio;
      this.baseLineY = xyRatios.baseLineY;
      this.baseLineInvertedY = xyRatios.baseLineInvertedY;
    }

    this.yaxisIndex = 0;
    this.seriesLen = 0;
  }
  /** primary draw method which is called on bar object
   * @memberof Bar
   * @param {array} series - user supplied series values
   * @param {int} seriesIndex - the index by which series will be drawn on the svg
   * @return {node} element which is supplied to parent chart draw method for appending
   **/


  _createClass(Bar, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var coreUtils = new CoreUtils(this.ctx, w);
      series = coreUtils.getLogSeries(series);
      this.series = series;
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.initVariables(series);
      var ret = graphics.group({
        class: 'apexcharts-bar-series apexcharts-plot-series'
      });

      if (w.config.dataLabels.enabled) {
        if (this.totalItems > w.config.plotOptions.bar.dataLabels.maxItems) {
          console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.');
        }
      }

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        var pathTo = void 0,
            pathFrom = void 0;
        var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
        yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
        zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
        zeroW = void 0; // zeroW is the baseline where 0 meets x axis

        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series

        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series",
          rel: i + 1,
          seriesName: Utils.escapeString(w.globals.seriesNames[realIndex]),
          'data:realIndex': realIndex
        });
        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);

        if (series[i].length > 0) {
          this.visibleI = this.visibleI + 1;
        }

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        if (this.yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;
        var initPositions = this.initialPositions();
        y = initPositions.y;
        barHeight = initPositions.barHeight;
        yDivision = initPositions.yDivision;
        zeroW = initPositions.zeroW;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;

        if (!this.horizontal) {
          xArrj.push(x + barWidth / 2);
        } // eldatalabels


        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });

        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {
          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {
            this.isNullValue = true;
          } else {
            this.isNullValue = false;
          }

          if (w.config.stroke.show) {
            if (this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
            }
          }

          var paths = null;

          if (this.isHorizontal) {
            paths = this.drawBarPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              barHeight: barHeight,
              strokeWidth: strokeWidth,
              pathTo: pathTo,
              pathFrom: pathFrom,
              zeroW: zeroW,
              x: x,
              y: y,
              yDivision: yDivision,
              elSeries: elSeries
            });
            barWidth = this.series[i][j] / this.invertedYRatio;
          } else {
            paths = this.drawColumnPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              x: x,
              y: y,
              xDivision: xDivision,
              pathTo: pathTo,
              pathFrom: pathFrom,
              barWidth: barWidth,
              zeroH: zeroH,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            });
            barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];
          }

          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x; // push current X

          if (j > 0) {
            xArrj.push(x + barWidth / 2);
          }

          yArrj.push(y);
          var pathFill = this.getPathFillColor(series, i, j, realIndex);
          elSeries = this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            visibleSeries: this.visibleI,
            type: 'bar'
          });
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj;
        ret.add(elSeries);
      }

      return ret;
    }
  }, {
    key: "getPathFillColor",
    value: function getPathFillColor(series, i, j, realIndex) {
      var w = this.w;
      var fill = new Fill(this.ctx);
      var fillColor = null;
      var seriesNumber = this.barOptions.distributed ? j : i;

      if (this.barOptions.colors.ranges.length > 0) {
        var colorRange = this.barOptions.colors.ranges;
        colorRange.map(function (range) {
          if (series[i][j] >= range.from && series[i][j] <= range.to) {
            fillColor = range.color;
          }
        });
      }

      if (w.config.series[i].data[j] && w.config.series[i].data[j].fillColor) {
        fillColor = w.config.series[i].data[j].fillColor;
      }

      var pathFill = fill.fillPath({
        seriesNumber: this.barOptions.distributed ? seriesNumber : realIndex,
        color: fillColor,
        value: series[i][j]
      });
      return pathFill;
    }
  }, {
    key: "renderSeries",
    value: function renderSeries(_ref) {
      var realIndex = _ref.realIndex,
          pathFill = _ref.pathFill,
          lineFill = _ref.lineFill,
          j = _ref.j,
          i = _ref.i,
          pathFrom = _ref.pathFrom,
          pathTo = _ref.pathTo,
          strokeWidth = _ref.strokeWidth,
          elSeries = _ref.elSeries,
          x = _ref.x,
          y = _ref.y,
          series = _ref.series,
          barHeight = _ref.barHeight,
          barWidth = _ref.barWidth,
          elDataLabelsWrap = _ref.elDataLabelsWrap,
          visibleSeries = _ref.visibleSeries,
          type = _ref.type;
      var w = this.w;
      var graphics = new Graphics(this.ctx);

      if (!lineFill) {
        /* fix apexcharts#341 */
        lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : w.globals.stroke.colors[realIndex];
      }

      if (w.config.series[i].data[j] && w.config.series[i].data[j].strokeColor) {
        lineFill = w.config.series[i].data[j].strokeColor;
      }

      if (this.isNullValue) {
        pathFill = 'none';
      }

      var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;
      var renderedPath = graphics.renderPaths({
        i: i,
        j: j,
        realIndex: realIndex,
        pathFrom: pathFrom,
        pathTo: pathTo,
        stroke: lineFill,
        strokeWidth: strokeWidth,
        strokeLineCap: w.config.stroke.lineCap,
        fill: pathFill,
        animationDelay: delay,
        initialSpeed: w.config.chart.animations.speed,
        dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
        className: "apexcharts-".concat(type, "-area")
      });
      renderedPath.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));
      var filters = new Filters(this.ctx);
      filters.setSelectionFilter(renderedPath, realIndex, j);
      elSeries.add(renderedPath);
      var dataLabels = this.calculateDataLabelsPos({
        x: x,
        y: y,
        i: i,
        j: j,
        series: series,
        realIndex: realIndex,
        barHeight: barHeight,
        barWidth: barWidth,
        renderedPath: renderedPath,
        visibleSeries: visibleSeries
      });

      if (dataLabels !== null) {
        elDataLabelsWrap.add(dataLabels);
      }

      elSeries.add(elDataLabelsWrap);
      return elSeries;
    }
  }, {
    key: "initVariables",
    value: function initVariables(series) {
      var w = this.w;
      this.series = series;
      this.totalItems = 0;
      this.seriesLen = 0;
      this.visibleI = -1;
      this.visibleItems = 1; // number of visible bars after user zoomed in/out

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length > 0) {
          this.seriesLen = this.seriesLen + 1;
          this.totalItems += series[sl].length;
        }

        if (w.globals.isXNumeric) {
          // get max visible items
          for (var j = 0; j < series[sl].length; j++) {
            if (w.globals.seriesX[sl][j] > w.globals.minX && w.globals.seriesX[sl][j] < w.globals.maxX) {
              this.visibleItems++;
            }
          }
        } else {
          this.visibleItems = w.globals.dataPoints;
        }
      }

      if (this.seriesLen === 0) {
        // A small adjustment when combo charts are used
        this.seriesLen = 1;
      }
    }
  }, {
    key: "initialPositions",
    value: function initialPositions() {
      var w = this.w;
      var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;

      if (this.isHorizontal) {
        // height divided into equal parts
        yDivision = w.globals.gridHeight / w.globals.dataPoints;
        barHeight = yDivision / this.seriesLen;

        if (w.globals.isXNumeric) {
          yDivision = w.globals.gridHeight / this.totalItems;
          barHeight = yDivision / this.seriesLen;
        }

        barHeight = barHeight * parseInt(this.barOptions.barHeight) / 100;
        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0);
        y = (yDivision - barHeight * this.seriesLen) / 2;
      } else {
        // width divided into equal parts
        xDivision = w.globals.gridWidth / this.visibleItems;
        barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;

        if (w.globals.isXNumeric) {
          // max barwidth should be equal to minXDiff to avoid overlap
          xDivision = w.globals.minXDiff / this.xRatio;
          barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;
        }

        zeroH = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0);
        x = w.globals.padHorizontal + (xDivision - barWidth * this.seriesLen) / 2;
      }

      return {
        x: x,
        y: y,
        yDivision: yDivision,
        xDivision: xDivision,
        barHeight: barHeight,
        barWidth: barWidth,
        zeroH: zeroH,
        zeroW: zeroW
      };
    }
  }, {
    key: "drawBarPaths",
    value: function drawBarPaths(_ref2) {
      var indexes = _ref2.indexes,
          barHeight = _ref2.barHeight,
          strokeWidth = _ref2.strokeWidth,
          pathTo = _ref2.pathTo,
          pathFrom = _ref2.pathFrom,
          zeroW = _ref2.zeroW,
          x = _ref2.x,
          y = _ref2.y,
          yDivision = _ref2.yDivision,
          elSeries = _ref2.elSeries;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;
      }

      var barYPosition = y + barHeight * this.visibleI;
      pathTo = graphics.move(zeroW, barYPosition);
      pathFrom = graphics.move(zeroW, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j);
      }

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        x = zeroW;
      } else {
        x = zeroW + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;
      }

      var endingShapeOpts = {
        barHeight: barHeight,
        strokeWidth: strokeWidth,
        barYPosition: barYPosition,
        x: x,
        zeroW: zeroW
      };
      var endingShape = this.barEndingShape(w, endingShapeOpts, this.series, i, j);
      pathTo = pathTo + graphics.line(endingShape.newX, barYPosition) + endingShape.path + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);
      pathFrom = pathFrom + graphics.line(zeroW, barYPosition) + endingShape.ending_p_from + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);

      if (!w.globals.isXNumeric) {
        y = y + yDivision;
      }

      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= this.barOptions.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = this.barOptions.colors.backgroundBarColors[bc];
        var rect = graphics.drawRect(0, barYPosition - barHeight * this.visibleI, w.globals.gridWidth, barHeight * this.seriesLen, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y,
        barYPosition: barYPosition
      };
    }
  }, {
    key: "drawColumnPaths",
    value: function drawColumnPaths(_ref3) {
      var indexes = _ref3.indexes,
          x = _ref3.x,
          y = _ref3.y,
          xDivision = _ref3.xDivision,
          pathTo = _ref3.pathTo,
          pathFrom = _ref3.pathFrom,
          barWidth = _ref3.barWidth,
          zeroH = _ref3.zeroH,
          strokeWidth = _ref3.strokeWidth,
          elSeries = _ref3.elSeries;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x + barWidth * this.visibleI;
      pathTo = graphics.move(barXPosition, zeroH);
      pathFrom = graphics.move(barXPosition, zeroH);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j);
      }

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        y = zeroH;
      } else {
        y = zeroH - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;
      }

      var endingShapeOpts = {
        barWidth: barWidth,
        strokeWidth: strokeWidth,
        barXPosition: barXPosition,
        y: y,
        zeroH: zeroH
      };
      var endingShape = this.barEndingShape(w, endingShapeOpts, this.series, i, j);
      pathTo = pathTo + graphics.line(barXPosition, endingShape.newY) + endingShape.path + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition - strokeWidth / 2, zeroH);
      pathFrom = pathFrom + graphics.line(barXPosition, zeroH) + endingShape.ending_p_from + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition - strokeWidth / 2, zeroH);

      if (!w.globals.isXNumeric) {
        x = x + xDivision;
      }

      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= this.barOptions.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = this.barOptions.colors.backgroundBarColors[bc];
        var rect = graphics.drawRect(barXPosition - barWidth * this.visibleI, 0, barWidth * this.seriesLen, w.globals.gridHeight, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y,
        barXPosition: barXPosition
      };
    }
    /** getPathFrom is a common function for bars/columns which is used to get previous paths when data changes.
     * @memberof Bar
     * @param {int} realIndex - current iterating i
     * @param {int} j - current iterating series's j index
     * @return {string} pathFrom is the string which will be appended in animations
     **/

  }, {
    key: "getPathFrom",
    value: function getPathFrom(realIndex, j) {
      var w = this.w;
      var pathFrom;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {
            pathFrom = w.globals.previousPaths[pp].paths[j].d;
          }
        }
      }

      return pathFrom;
    }
    /** calculateBarDataLabels is used to calculate the positions for the data-labels
     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()
     * @memberof Bar
     * @param {object} {barProps} most of the bar properties used throughout the bar
     * drawing function
     * @return {object} dataLabels node-element which you can append later
     **/

  }, {
    key: "calculateDataLabelsPos",
    value: function calculateDataLabelsPos(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          i = _ref4.i,
          j = _ref4.j,
          realIndex = _ref4.realIndex,
          series = _ref4.series,
          barHeight = _ref4.barHeight,
          barWidth = _ref4.barWidth,
          visibleSeries = _ref4.visibleSeries,
          renderedPath = _ref4.renderedPath;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
      var bcx = x + parseFloat(barWidth * visibleSeries);
      var bcy = y + parseFloat(barHeight * visibleSeries);

      if (w.globals.isXNumeric && !w.globals.isBarHorizontal) {
        bcx = x + parseFloat(barWidth * (visibleSeries + 1)) - strokeWidth;
        bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;
      }

      var dataLabels = null;
      var dataLabelsX = x;
      var dataLabelsY = y;
      var dataLabelsPos = {};
      var dataLabelsConfig = w.config.dataLabels;
      var barDataLabelsConfig = this.barOptions.dataLabels;
      var offX = dataLabelsConfig.offsetX;
      var offY = dataLabelsConfig.offsetY;
      var textRects = {
        width: 0,
        height: 0
      };

      if (w.config.dataLabels.enabled) {
        textRects = graphics.getTextRects(w.globals.yLabelFormatters[0](w.globals.maxY), parseInt(dataLabelsConfig.style.fontSize));
      }

      if (this.isHorizontal) {
        dataLabelsPos = this.calculateBarsDataLabelsPosition({
          x: x,
          y: y,
          i: i,
          j: j,
          renderedPath: renderedPath,
          bcy: bcy,
          barHeight: barHeight,
          barWidth: barWidth,
          textRects: textRects,
          strokeWidth: strokeWidth,
          dataLabelsX: dataLabelsX,
          dataLabelsY: dataLabelsY,
          barDataLabelsConfig: barDataLabelsConfig,
          offX: offX,
          offY: offY
        });
      } else {
        dataLabelsPos = this.calculateColumnsDataLabelsPosition({
          x: x,
          y: y,
          i: i,
          j: j,
          renderedPath: renderedPath,
          realIndex: realIndex,
          bcx: bcx,
          bcy: bcy,
          barHeight: barHeight,
          barWidth: barWidth,
          textRects: textRects,
          strokeWidth: strokeWidth,
          dataLabelsY: dataLabelsY,
          barDataLabelsConfig: barDataLabelsConfig,
          offX: offX,
          offY: offY
        });
      }

      renderedPath.attr({
        cy: dataLabelsPos.bcy,
        cx: dataLabelsPos.bcx,
        j: j,
        val: series[i][j],
        barHeight: barHeight,
        barWidth: barWidth
      });
      dataLabels = this.drawCalculatedDataLabels({
        x: dataLabelsPos.dataLabelsX,
        y: dataLabelsPos.dataLabelsY,
        val: series[i][j],
        i: realIndex,
        j: j,
        barWidth: barWidth,
        barHeight: barHeight,
        textRects: textRects,
        dataLabelsConfig: dataLabelsConfig
      });
      return dataLabels;
    }
  }, {
    key: "calculateColumnsDataLabelsPosition",
    value: function calculateColumnsDataLabelsPosition(opts) {
      var w = this.w;
      var i = opts.i,
          j = opts.j,
          y = opts.y,
          bcx = opts.bcx,
          barWidth = opts.barWidth,
          barHeight = opts.barHeight,
          textRects = opts.textRects,
          dataLabelsY = opts.dataLabelsY,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          strokeWidth = opts.strokeWidth,
          offX = opts.offX,
          offY = opts.offY;
      var dataLabelsX;
      var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;
      bcx = bcx - strokeWidth / 2;

      if (w.globals.isXNumeric) {
        dataLabelsX = bcx - barWidth / 2 + offX;
      } else {
        dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;
      }

      var valIsNegative = this.series[i][j] <= 0;

      if (this.isReversed) {
        y = y - barHeight;
      }

      switch (barDataLabelsConfig.position) {
        case 'center':
          if (valIsNegative) {
            dataLabelsY = y + barHeight / 2 + textRects.height / 2 + offY;
          } else {
            dataLabelsY = y + barHeight / 2 + textRects.height / 2 - offY;
          }

          break;

        case 'bottom':
          if (valIsNegative) {
            dataLabelsY = y + barHeight + textRects.height + strokeWidth + offY;
          } else {
            dataLabelsY = y + barHeight - textRects.height / 2 + strokeWidth - offY;
          }

          break;

        case 'top':
          if (valIsNegative) {
            dataLabelsY = y - textRects.height / 2 - offY;
          } else {
            dataLabelsY = y + textRects.height + offY;
          }

          break;
      }

      if (!w.config.chart.stacked) {
        if (dataLabelsY < 0) {
          dataLabelsY = 0 + strokeWidth;
        } else if (dataLabelsY + textRects.height / 3 > w.globals.gridHeight) {
          dataLabelsY = w.globals.gridHeight - strokeWidth;
        }
      }

      return {
        bcx: bcx,
        bcy: y,
        dataLabelsX: dataLabelsX,
        dataLabelsY: dataLabelsY
      };
    }
  }, {
    key: "calculateBarsDataLabelsPosition",
    value: function calculateBarsDataLabelsPosition(opts) {
      var w = this.w;
      var x = opts.x,
          i = opts.i,
          j = opts.j,
          bcy = opts.bcy,
          barHeight = opts.barHeight,
          barWidth = opts.barWidth,
          textRects = opts.textRects,
          dataLabelsX = opts.dataLabelsX,
          strokeWidth = opts.strokeWidth,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          offX = opts.offX,
          offY = opts.offY;
      var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
      var dataLabelsY = bcy - dataPointsDividedHeight + barHeight / 2 + textRects.height / 2 + offY - 3;
      var valIsNegative = this.series[i][j] <= 0;

      if (this.isReversed) {
        x = x + barWidth;
      }

      switch (barDataLabelsConfig.position) {
        case 'center':
          if (valIsNegative) {
            dataLabelsX = x - barWidth / 2 - offX;
          } else {
            dataLabelsX = x - barWidth / 2 + offX;
          }

          break;

        case 'bottom':
          if (valIsNegative) {
            dataLabelsX = x - barWidth - strokeWidth - Math.round(textRects.width / 2) - offX;
          } else {
            dataLabelsX = x - barWidth + strokeWidth + Math.round(textRects.width / 2) + offX;
          }

          break;

        case 'top':
          if (valIsNegative) {
            dataLabelsX = x - strokeWidth + Math.round(textRects.width / 2) - offX;
          } else {
            dataLabelsX = x - strokeWidth - Math.round(textRects.width / 2) + offX;
          }

          break;
      }

      if (!w.config.chart.stacked) {
        if (dataLabelsX < 0) {
          dataLabelsX = dataLabelsX + textRects.width + strokeWidth;
        } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {
          dataLabelsX = w.globals.gridWidth - textRects.width - strokeWidth;
        }
      }

      return {
        bcx: x,
        bcy: bcy,
        dataLabelsX: dataLabelsX,
        dataLabelsY: dataLabelsY
      };
    }
  }, {
    key: "drawCalculatedDataLabels",
    value: function drawCalculatedDataLabels(_ref5) {
      var x = _ref5.x,
          y = _ref5.y,
          val = _ref5.val,
          i = _ref5.i,
          j = _ref5.j,
          textRects = _ref5.textRects,
          barHeight = _ref5.barHeight,
          barWidth = _ref5.barWidth,
          dataLabelsConfig = _ref5.dataLabelsConfig;
      var w = this.w;
      var dataLabels = new DataLabels(this.ctx);
      var graphics = new Graphics(this.ctx);
      var formatter = dataLabelsConfig.formatter;
      var elDataLabelsWrap = null;
      var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;

      if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {
        elDataLabelsWrap = graphics.group({
          class: 'apexcharts-data-labels'
        });
        var text = '';

        if (typeof val !== 'undefined') {
          text = formatter(val, {
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }

        if (val === 0 && w.config.chart.stacked) {
          // in a stacked bar/column chart, 0 value should be neglected as it will overlap on the next element
          text = '';
        }

        if (w.config.chart.stacked && this.barOptions.dataLabels.hideOverflowingLabels) {
          // if there is not enough space to draw the label in the bar/column rect, check hideOverflowingLabels property to prevent overflowing on wrong rect
          // Note: This issue is only seen in stacked charts
          if (this.isHorizontal) {
            barWidth = this.series[i][j] / this.yRatio[this.yaxisIndex]; // FIXED: Don't always hide the stacked negative side label
            // A negative value will result in a negative bar width
            // Only hide the text when the width is smaller (a higher negative number) than the negative bar width.

            if (barWidth > 0 && textRects.width / 1.6 > barWidth || barWidth < 0 && textRects.width / 1.6 < barWidth) {
              text = '';
            }
          } else {
            barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];

            if (textRects.height / 1.6 > barHeight) {
              text = '';
            }
          }
        }

        var modifiedDataLabelsConfig = _objectSpread({}, dataLabelsConfig);

        if (this.isHorizontal) {
          if (val < 0) {
            if (dataLabelsConfig.textAnchor === 'start') {
              modifiedDataLabelsConfig.textAnchor = 'end';
            } else if (dataLabelsConfig.textAnchor === 'end') {
              modifiedDataLabelsConfig.textAnchor = 'start';
            }
          }
        }

        dataLabels.plotDataLabelsText({
          x: x,
          y: y,
          text: text,
          i: i,
          j: j,
          parent: elDataLabelsWrap,
          dataLabelsConfig: modifiedDataLabelsConfig,
          alwaysDrawDataLabel: true,
          offsetCorrection: true
        });
      }

      return elDataLabelsWrap;
    }
    /** barEndingShape draws the various shapes on top of bars/columns
     * @memberof Bar
     * @param {object} w - chart context
     * @param {object} opts - consists several properties like barHeight/barWidth
     * @param {array} series - global primary series
     * @param {int} i - current iterating series's index
     * @param {int} j - series's j of i
     * @return {object} path - ending shape whether round/arrow
     *         ending_p_from - similar to pathFrom
     *         newY - which is calculated from existing y and new shape's top
     **/

  }, {
    key: "barEndingShape",
    value: function barEndingShape(w, opts, series, i, j) {
      var graphics = new Graphics(this.ctx);

      if (this.isHorizontal) {
        var endingShape = null;
        var endingShapeFrom = '';
        var x = opts.x;

        if (typeof series[i][j] !== 'undefined' || series[i][j] !== null) {
          var inverse = series[i][j] < 0;
          var eX = opts.barHeight / 2 - opts.strokeWidth;
          if (inverse) eX = -opts.barHeight / 2 - opts.strokeWidth;

          if (!w.config.chart.stacked) {
            if (this.barOptions.endingShape === 'rounded') {
              x = opts.x - eX / 2;
            }
          }

          switch (this.barOptions.endingShape) {
            case 'flat':
              endingShape = graphics.line(x, opts.barYPosition + opts.barHeight - opts.strokeWidth);
              break;

            case 'rounded':
              endingShape = graphics.quadraticCurve(x + eX, opts.barYPosition + (opts.barHeight - opts.strokeWidth) / 2, x, opts.barYPosition + opts.barHeight - opts.strokeWidth);
              break;
          }
        }

        return {
          path: endingShape,
          ending_p_from: endingShapeFrom,
          newX: x
        };
      } else {
        var _endingShape = null;
        var _endingShapeFrom = '';
        var y = opts.y;

        if (typeof series[i][j] !== 'undefined' || series[i][j] !== null) {
          var _inverse = series[i][j] < 0;

          var eY = opts.barWidth / 2 - opts.strokeWidth;
          if (_inverse) eY = -opts.barWidth / 2 - opts.strokeWidth;

          if (!w.config.chart.stacked) {
            // the shape exceeds the chart height, hence reduce y
            if (this.barOptions.endingShape === 'rounded') {
              y = y + eY / 2;
            }
          }

          switch (this.barOptions.endingShape) {
            case 'flat':
              _endingShape = graphics.line(opts.barXPosition + opts.barWidth - opts.strokeWidth, y);
              break;

            case 'rounded':
              _endingShape = graphics.quadraticCurve(opts.barXPosition + (opts.barWidth - opts.strokeWidth) / 2, y - eY, opts.barXPosition + opts.barWidth - opts.strokeWidth, y);
              break;
          }
        }

        return {
          path: _endingShape,
          ending_p_from: _endingShapeFrom,
          newY: y
        };
      }
    }
  }]);

  return Bar;
}();

/**
 * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.
 *
 * @module BarStacked
 * The whole calculation for stacked bar/column is different from normal bar/column,
 * hence it makes sense to derive a new class for it extending most of the props of Parent Bar
 **/

var BarStacked =
/*#__PURE__*/
function (_Bar) {
  _inherits(BarStacked, _Bar);

  function BarStacked() {
    _classCallCheck(this, BarStacked);

    return _possibleConstructorReturn(this, _getPrototypeOf(BarStacked).apply(this, arguments));
  }

  _createClass(BarStacked, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var w = this.w;
      this.graphics = new Graphics(this.ctx);
      this.fill = new Fill(this.ctx);
      this.bar = new Bar(this.ctx, this.xyRatios);
      var coreUtils = new CoreUtils(this.ctx, w);
      series = coreUtils.getLogSeries(series);
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.initVariables(series);

      if (w.config.chart.stackType === '100%') {
        series = w.globals.seriesPercent.slice();
      }

      this.series = series;
      this.totalItems = 0;
      this.prevY = []; // y position on chart

      this.prevX = []; // x position on chart

      this.prevYF = []; // y position including shapes on chart

      this.prevXF = []; // x position including shapes on chart

      this.prevYVal = []; // y values (series[i][j]) in columns

      this.prevXVal = []; // x values (series[i][j]) in bars

      this.xArrj = []; // xj indicates x position on graph in bars

      this.xArrjF = []; // xjF indicates bar's x position + endingshape's positions in bars

      this.xArrjVal = []; // x val means the actual series's y values in horizontal/bars

      this.yArrj = []; // yj indicates y position on graph in columns

      this.yArrjF = []; // yjF indicates bar's y position + endingshape's positions in columns

      this.yArrjVal = []; // y val means the actual series's y values in columns

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length > 0) {
          this.totalItems += series[sl].length;
        }
      }

      var ret = this.graphics.group({
        class: 'apexcharts-bar-series apexcharts-plot-series'
      });
      var x = 0;
      var y = 0;

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        var pathTo = void 0,
            pathFrom = void 0;
        var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)

        var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)

        var zeroH = void 0; // zeroH is the baseline where 0 meets y axis

        var zeroW = void 0; // zeroW is the baseline where 0 meets x axis

        var xArrValues = [];
        var yArrValues = [];
        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;

        if (this.yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed; // el to which series will be drawn

        var elSeries = this.graphics.group({
          class: "apexcharts-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[realIndex]),
          rel: i + 1,
          'data:realIndex': realIndex
        }); // eldatalabels

        var elDataLabelsWrap = this.graphics.group({
          class: 'apexcharts-datalabels'
        });
        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;
        var initPositions = this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW);
        y = initPositions.y;
        barHeight = initPositions.barHeight;
        yDivision = initPositions.yDivision;
        zeroW = initPositions.zeroW;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;
        this.yArrj = [];
        this.yArrjF = [];
        this.yArrjVal = [];
        this.xArrj = [];
        this.xArrjF = [];
        this.xArrjVal = []; // if (!this.horizontal) {
        // this.xArrj.push(x + barWidth / 2)
        // }

        for (var j = 0; j < w.globals.dataPoints; j++) {
          if (w.config.stroke.show) {
            if (this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
            }
          }

          var paths = null;

          if (this.isHorizontal) {
            paths = this.drawBarPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              barHeight: barHeight,
              strokeWidth: strokeWidth,
              pathTo: pathTo,
              pathFrom: pathFrom,
              zeroW: zeroW,
              x: x,
              y: y,
              yDivision: yDivision,
              elSeries: elSeries
            });
            barWidth = this.series[i][j] / this.invertedYRatio;
          } else {
            paths = this.drawColumnPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              x: x,
              y: y,
              xDivision: xDivision,
              pathTo: pathTo,
              pathFrom: pathFrom,
              barWidth: barWidth,
              zeroH: zeroH,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            });
            barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];
          }

          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x;
          xArrValues.push(x);
          yArrValues.push(y);
          var pathFill = this.bar.getPathFillColor(series, i, j, realIndex);
          elSeries = this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            type: 'bar',
            visibleSeries: 0
          });
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrValues;
        w.globals.seriesYvalues[realIndex] = yArrValues; // push all current y values array to main PrevY Array

        this.prevY.push(this.yArrj);
        this.prevYF.push(this.yArrjF);
        this.prevYVal.push(this.yArrjVal);
        this.prevX.push(this.xArrj);
        this.prevXF.push(this.xArrjF);
        this.prevXVal.push(this.xArrjVal);
        ret.add(elSeries);
      }

      return ret;
    }
  }, {
    key: "initialPositions",
    value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW) {
      var w = this.w;
      var barHeight, barWidth;

      if (this.isHorizontal) {
        // height divided into equal parts
        yDivision = w.globals.gridHeight / w.globals.dataPoints;
        barHeight = yDivision;
        barHeight = barHeight * parseInt(w.config.plotOptions.bar.barHeight) / 100;
        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0); // initial y position is half of barHeight * half of number of Bars

        y = (yDivision - barHeight) / 2;
      } else {
        // width divided into equal parts
        xDivision = w.globals.gridWidth / w.globals.dataPoints;
        barWidth = xDivision;

        if (w.globals.isXNumeric) {
          xDivision = w.globals.minXDiff / this.xRatio;
          barWidth = xDivision * parseInt(this.barOptions.columnWidth) / 100;
        } else {
          barWidth = barWidth * parseInt(w.config.plotOptions.bar.columnWidth) / 100;
        }

        zeroH = this.baseLineY[this.yaxisIndex] + (this.isReversed ? w.globals.gridHeight : 0) - (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0); // initial x position is one third of barWidth

        x = w.globals.padHorizontal + (xDivision - barWidth) / 2;
      }

      return {
        x: x,
        y: y,
        yDivision: yDivision,
        xDivision: xDivision,
        barHeight: barHeight,
        barWidth: barWidth,
        zeroH: zeroH,
        zeroW: zeroW
      };
    }
  }, {
    key: "drawBarPaths",
    value: function drawBarPaths(_ref) {
      var indexes = _ref.indexes,
          barHeight = _ref.barHeight,
          strokeWidth = _ref.strokeWidth,
          pathTo = _ref.pathTo,
          pathFrom = _ref.pathFrom,
          zeroW = _ref.zeroW,
          x = _ref.x,
          y = _ref.y,
          yDivision = _ref.yDivision,
          elSeries = _ref.elSeries;
      var w = this.w;
      var barYPosition = y;
      var barXPosition;
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;
      var prevBarW = 0;

      for (var k = 0; k < this.prevXF.length; k++) {
        prevBarW = prevBarW + this.prevXF[k][j];
      }

      if (i > 0) {
        var bXP = zeroW;

        if (this.prevXVal[i - 1][j] < 0) {
          if (this.series[i][j] >= 0) {
            bXP = this.prevX[i - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2;
          } else {
            bXP = this.prevX[i - 1][j];
          }
        } else if (this.prevXVal[i - 1][j] >= 0) {
          if (this.series[i][j] >= 0) {
            bXP = this.prevX[i - 1][j];
          } else {
            bXP = this.prevX[i - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;
          }
        }

        barXPosition = bXP;
      } else {
        // the first series will not have prevX values
        barXPosition = zeroW;
      }

      if (this.series[i][j] === null) {
        x = barXPosition;
      } else {
        x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;
      }

      var endingShapeOpts = {
        barHeight: barHeight,
        strokeWidth: strokeWidth,
        invertedYRatio: this.invertedYRatio,
        barYPosition: barYPosition,
        x: x
      };
      var endingShape = this.bar.barEndingShape(w, endingShapeOpts, this.series, i, j);

      if (this.series.length > 1 && i !== this.endingShapeOnSeriesNumber) {
        // revert back to flat shape if not last series
        endingShape.path = this.graphics.line(endingShape.newX, barYPosition + barHeight - strokeWidth);
      }

      this.xArrj.push(endingShape.newX);
      this.xArrjF.push(Math.abs(barXPosition - endingShape.newX));
      this.xArrjVal.push(this.series[i][j]);
      pathTo = this.graphics.move(barXPosition, barYPosition);
      pathFrom = this.graphics.move(barXPosition, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.bar.getPathFrom(realIndex, j, false);
      }

      pathTo = pathTo + this.graphics.line(endingShape.newX, barYPosition) + endingShape.path + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);
      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);

      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];
        var rect = this.graphics.drawRect(0, barYPosition, w.globals.gridWidth, barHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      y = y + yDivision;
      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y
      };
    }
  }, {
    key: "drawColumnPaths",
    value: function drawColumnPaths(_ref2) {
      var indexes = _ref2.indexes,
          x = _ref2.x,
          y = _ref2.y,
          xDivision = _ref2.xDivision,
          pathTo = _ref2.pathTo,
          pathFrom = _ref2.pathFrom,
          barWidth = _ref2.barWidth,
          zeroH = _ref2.zeroH,
          strokeWidth = _ref2.strokeWidth,
          elSeries = _ref2.elSeries;
      var w = this.w;
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        var seriesVal = w.globals.seriesX[i][j];
        if (!seriesVal) seriesVal = 0;
        x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x;
      var barYPosition;
      var prevBarH = 0;

      for (var k = 0; k < this.prevYF.length; k++) {
        prevBarH = prevBarH + this.prevYF[k][j];
      }

      if (i > 0 && !w.globals.isXNumeric || i > 0 && w.globals.isXNumeric && w.globals.seriesX[i - 1][j] === w.globals.seriesX[i][j]) {
        var bYP;
        var prevYValue = this.prevY[i - 1][j];

        if (this.prevYVal[i - 1][j] < 0) {
          if (this.series[i][j] >= 0) {
            bYP = prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2;
          } else {
            bYP = prevYValue;
          }
        } else {
          if (this.series[i][j] >= 0) {
            bYP = prevYValue;
          } else {
            bYP = prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2;
          }
        }

        barYPosition = bYP;
      } else {
        // the first series will not have prevY values, also if the prev index's series X doesn't matches the current index's series X, then start from zero
        barYPosition = w.globals.gridHeight - zeroH;
      }

      y = barYPosition - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;
      var endingShapeOpts = {
        barWidth: barWidth,
        strokeWidth: strokeWidth,
        yRatio: this.yRatio[this.yaxisIndex],
        barXPosition: barXPosition,
        y: y
      };
      var endingShape = this.bar.barEndingShape(w, endingShapeOpts, this.series, i, j);
      this.yArrj.push(endingShape.newY);
      this.yArrjF.push(Math.abs(barYPosition - endingShape.newY));
      this.yArrjVal.push(this.series[i][j]);
      pathTo = this.graphics.move(barXPosition, barYPosition);
      pathFrom = this.graphics.move(barXPosition, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.bar.getPathFrom(realIndex, j, false);
      }

      pathTo = pathTo + this.graphics.line(barXPosition, endingShape.newY) + endingShape.path + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition - strokeWidth / 2, barYPosition);
      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition - strokeWidth / 2, barYPosition);

      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];
        var rect = this.graphics.drawRect(barXPosition, 0, barWidth, w.globals.gridHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      x = x + xDivision;
      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: w.globals.isXNumeric ? x - xDivision : x,
        y: y
      };
    }
    /*
     * When user clicks on legends, the collapsed series will be filled with [0,0,0,...,0]
     * We need to make sure, that the last series is not [0,0,0,...,0]
     * as we need to draw shapes on the last series (for stacked bars/columns only)
     * Hence, we are collecting all inner arrays in series which has [0,0,0...,0]
     **/

  }, {
    key: "checkZeroSeries",
    value: function checkZeroSeries(_ref3) {
      var series = _ref3.series;
      var w = this.w;

      for (var zs = 0; zs < series.length; zs++) {
        var total = 0;

        for (var zsj = 0; zsj < series[w.globals.maxValsInArrayIndex].length; zsj++) {
          total += series[zs][zsj];
        }

        if (total === 0) {
          this.zeroSerieses.push(zs);
        }
      } // After getting all zeroserieses, we need to ensure whether endingshapeonSeries is not in that zeroseries array


      for (var s = series.length - 1; s >= 0; s--) {
        if (this.zeroSerieses.indexOf(s) > -1 && s === this.endingShapeOnSeriesNumber) {
          this.endingShapeOnSeriesNumber -= 1;
        }
      }
    }
  }]);

  return BarStacked;
}(Bar);

/**
 * ApexCharts CandleStick Class responsible for drawing both Stacked Columns and Bars.
 *
 * @module CandleStick
 **/

var CandleStick =
/*#__PURE__*/
function (_Bar) {
  _inherits(CandleStick, _Bar);

  function CandleStick() {
    _classCallCheck(this, CandleStick);

    return _possibleConstructorReturn(this, _getPrototypeOf(CandleStick).apply(this, arguments));
  }

  _createClass(CandleStick, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick;
      var coreUtils = new CoreUtils(this.ctx, w);
      series = coreUtils.getLogSeries(series);
      this.series = series;
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.initVariables(series);
      var ret = graphics.group({
        class: 'apexcharts-candlestick-series apexcharts-plot-series'
      });

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        var pathTo = void 0,
            pathFrom = void 0;
        var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
        zeroH = void 0; // zeroH is the baseline where 0 meets y axis

        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series

        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[realIndex]),
          rel: i + 1,
          'data:realIndex': realIndex
        });

        if (series[i].length > 0) {
          this.visibleI = this.visibleI + 1;
        }

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        if (this.yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        var initPositions = this.initialPositions();
        y = initPositions.y;
        barHeight = initPositions.barHeight;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;
        xArrj.push(x + barWidth / 2); // eldatalabels

        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });

        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {
          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {
            this.isNullValue = true;
          } else {
            this.isNullValue = false;
          }

          if (w.config.stroke.show) {
            if (this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
            }
          }

          var color = void 0;
          var paths = this.drawCandleStickPaths({
            indexes: {
              i: i,
              j: j,
              realIndex: realIndex,
              bc: bc
            },
            x: x,
            y: y,
            xDivision: xDivision,
            pathTo: pathTo,
            pathFrom: pathFrom,
            barWidth: barWidth,
            zeroH: zeroH,
            strokeWidth: strokeWidth,
            elSeries: elSeries
          });
          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x;
          color = paths.color; // push current X

          if (j > 0) {
            xArrj.push(x + barWidth / 2);
          }

          yArrj.push(y);
          var pathFill = fill.fillPath({
            seriesNumber: realIndex,
            color: color,
            value: series[i][j]
          });
          var lineFill = this.candlestickOptions.wick.useFillColor ? color : undefined;
          elSeries = this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            lineFill: lineFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            visibleSeries: this.visibleI,
            type: 'candlestick'
          });
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj;
        ret.add(elSeries);
      }

      return ret;
    }
  }, {
    key: "drawCandleStickPaths",
    value: function drawCandleStickPaths(_ref) {
      var indexes = _ref.indexes,
          x = _ref.x,
          y = _ref.y,
          xDivision = _ref.xDivision,
          pathTo = _ref.pathTo,
          pathFrom = _ref.pathFrom,
          barWidth = _ref.barWidth,
          zeroH = _ref.zeroH,
          strokeWidth = _ref.strokeWidth;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var isPositive = true;
      var colorPos = w.config.plotOptions.candlestick.colors.upward;
      var colorNeg = w.config.plotOptions.candlestick.colors.downward;
      var yRatio = this.yRatio[this.yaxisIndex];
      var realIndex = indexes.realIndex;
      var ohlc = this.getOHLCValue(realIndex, j);
      var l1 = zeroH;
      var l2 = zeroH;

      if (ohlc.o > ohlc.c) {
        isPositive = false;
      }

      var y1 = Math.min(ohlc.o, ohlc.c);
      var y2 = Math.max(ohlc.o, ohlc.c);

      if (w.globals.isXNumeric) {
        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x + barWidth * this.visibleI;

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        y1 = zeroH;
      } else {
        y1 = zeroH - y1 / yRatio;
        y2 = zeroH - y2 / yRatio;
        l1 = zeroH - ohlc.h / yRatio;
        l2 = zeroH - ohlc.l / yRatio;
      }

      pathTo = graphics.move(barXPosition, zeroH);
      pathFrom = graphics.move(barXPosition, y1);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j, true);
      }

      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);
      pathFrom = pathFrom + graphics.move(barXPosition, y1);

      if (!w.globals.isXNumeric) {
        x = x + xDivision;
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y2,
        barXPosition: barXPosition,
        color: isPositive ? colorPos : colorNeg
      };
    }
  }, {
    key: "getOHLCValue",
    value: function getOHLCValue(i, j) {
      var w = this.w;
      return {
        o: w.globals.seriesCandleO[i][j],
        h: w.globals.seriesCandleH[i][j],
        l: w.globals.seriesCandleL[i][j],
        c: w.globals.seriesCandleC[i][j]
      };
    }
  }]);

  return CandleStick;
}(Bar);

var Crosshairs =
/*#__PURE__*/
function () {
  function Crosshairs(ctx) {
    _classCallCheck(this, Crosshairs);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Crosshairs, [{
    key: "drawXCrosshairs",
    value: function drawXCrosshairs() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var filters = new Filters(this.ctx);
      var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;
      var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;
      var fillType = w.config.xaxis.crosshairs.fill.type;
      var gradientFrom = crosshairGradient.colorFrom;
      var gradientTo = crosshairGradient.colorTo;
      var opacityFrom = crosshairGradient.opacityFrom;
      var opacityTo = crosshairGradient.opacityTo;
      var stops = crosshairGradient.stops;
      var shadow = 'none';
      var dropShadow = crosshairShadow.enabled;
      var shadowLeft = crosshairShadow.left;
      var shadowTop = crosshairShadow.top;
      var shadowBlur = crosshairShadow.blur;
      var shadowColor = crosshairShadow.color;
      var shadowOpacity = crosshairShadow.opacity;
      var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;

      if (w.config.xaxis.crosshairs.show) {
        if (fillType === 'gradient') {
          xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);
        }

        var xcrosshairs = graphics.drawRect();

        if (w.config.xaxis.crosshairs.width === 1) {
          // to prevent drawing 2 lines, convert rect to line
          xcrosshairs = graphics.drawLine();
        }

        xcrosshairs.attr({
          class: 'apexcharts-xcrosshairs',
          x: 0,
          y: 0,
          y2: w.globals.gridHeight,
          width: Utils.isNumber(w.config.xaxis.crosshairs.width) ? w.config.xaxis.crosshairs.width : 0,
          height: w.globals.gridHeight,
          fill: xcrosshairsFill,
          filter: shadow,
          'fill-opacity': w.config.xaxis.crosshairs.opacity,
          stroke: w.config.xaxis.crosshairs.stroke.color,
          'stroke-width': w.config.xaxis.crosshairs.stroke.width,
          'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray
        });

        if (dropShadow) {
          xcrosshairs = filters.dropShadow(xcrosshairs, {
            left: shadowLeft,
            top: shadowTop,
            blur: shadowBlur,
            color: shadowColor,
            opacity: shadowOpacity
          });
        }

        w.globals.dom.elGraphical.add(xcrosshairs);
      }
    }
  }, {
    key: "drawYCrosshairs",
    value: function drawYCrosshairs() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var crosshair = w.config.yaxis[0].crosshairs;

      if (w.config.yaxis[0].crosshairs.show) {
        var ycrosshairs = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);
        ycrosshairs.attr({
          class: 'apexcharts-ycrosshairs'
        });
        w.globals.dom.elGraphical.add(ycrosshairs);
      } // draw an invisible crosshair to help in positioning the yaxis tooltip


      var ycrosshairsHidden = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, 0, 0);
      ycrosshairsHidden.attr({
        class: 'apexcharts-ycrosshairs-hidden'
      });
      w.globals.dom.elGraphical.add(ycrosshairsHidden);
    }
  }]);

  return Crosshairs;
}();

/**
 * ApexCharts HeatMap Class.
 * @module HeatMap
 **/

var HeatMap =
/*#__PURE__*/
function () {
  function HeatMap(ctx, xyRatios) {
    _classCallCheck(this, HeatMap);

    this.ctx = ctx;
    this.w = ctx.w;
    this.xRatio = xyRatios.xRatio;
    this.yRatio = xyRatios.yRatio;
    this.negRange = false;
    this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;
    this.rectRadius = this.w.config.plotOptions.heatmap.radius;
    this.strokeWidth = this.w.config.stroke.width;
  }

  _createClass(HeatMap, [{
    key: "draw",
    value: function draw(series) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-heatmap'
      });
      ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")")); // width divided into equal parts

      var xDivision = w.globals.gridWidth / w.globals.dataPoints;
      var yDivision = w.globals.gridHeight / w.globals.series.length;
      var y1 = 0;
      var rev = false;
      this.checkColorRange();
      var heatSeries = series.slice();

      if (w.config.yaxis[0].reversed) {
        rev = true;
        heatSeries.reverse();
      }

      for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {
        // el to which series will be drawn
        var elSeries = graphics.group({
          class: "apexcharts-series apexcharts-heatmap-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[i]),
          rel: i + 1,
          'data:realIndex': i
        });

        if (w.config.chart.dropShadow.enabled) {
          var shadow = w.config.chart.dropShadow;
          var filters = new Filters(this.ctx);
          filters.dropShadow(elSeries, shadow, i);
        }

        var x1 = 0;

        for (var j = 0; j < heatSeries[i].length; j++) {
          var colorShadePercent = 1;
          var heatColorProps = this.determineHeatColor(i, j);

          if (w.globals.hasNegs || this.negRange) {
            var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;

            if (w.config.plotOptions.heatmap.reverseNegativeShade) {
              if (heatColorProps.percent < 0) {
                colorShadePercent = heatColorProps.percent / 100 * (shadeIntensity * 1.25);
              } else {
                colorShadePercent = (1 - heatColorProps.percent / 100) * (shadeIntensity * 1.25);
              }
            } else {
              if (heatColorProps.percent < 0) {
                colorShadePercent = 1 - (1 + heatColorProps.percent / 100) * shadeIntensity;
              } else {
                colorShadePercent = (1 - heatColorProps.percent / 100) * shadeIntensity;
              }
            }
          } else {
            colorShadePercent = 1 - heatColorProps.percent / 100;
          }

          var color = heatColorProps.color;

          if (w.config.plotOptions.heatmap.enableShades) {
            var utils = new Utils();
            color = Utils.hexToRgba(utils.shadeColor(colorShadePercent, heatColorProps.color), w.config.fill.opacity);
          }

          var radius = this.rectRadius;
          var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);
          rect.attr({
            cx: x1,
            cy: y1
          });
          rect.node.classList.add('apexcharts-heatmap-rect');
          elSeries.add(rect);
          rect.attr({
            fill: color,
            i: i,
            index: i,
            j: j,
            val: heatSeries[i][j],
            'stroke-width': this.strokeWidth,
            stroke: w.globals.stroke.colors[0],
            color: color
          });
          rect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, rect));
          rect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, rect));
          rect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, rect));

          if (w.config.chart.animations.enabled && !w.globals.dataChanged) {
            var speed = 1;

            if (!w.globals.resized) {
              speed = w.config.chart.animations.speed;
            }

            this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);
          }

          if (w.globals.dataChanged) {
            var _speed = 1;

            if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {
              _speed = this.dynamicAnim.speed;
              var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;
              if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';
              this.animateHeatColor(rect, Utils.isColorHex(colorFrom) ? colorFrom : Utils.rgb2hex(colorFrom), Utils.isColorHex(color) ? color : Utils.rgb2hex(color), _speed);
            }
          }

          var dataLabels = this.calculateHeatmapDataLabels({
            x: x1,
            y: y1,
            i: i,
            j: j,
            series: heatSeries,
            rectHeight: yDivision,
            rectWidth: xDivision
          });

          if (dataLabels !== null) {
            elSeries.add(dataLabels);
          }

          x1 = x1 + xDivision;
        }

        y1 = y1 + yDivision;
        ret.add(elSeries);
      } // adjust yaxis labels for heatmap


      var yAxisScale = w.globals.yAxisScale[0].result.slice();

      if (w.config.yaxis[0].reversed) {
        yAxisScale.unshift('');
      } else {
        yAxisScale.push('');
      }

      w.globals.yAxisScale[0].result = yAxisScale;
      var divisor = w.globals.gridHeight / w.globals.series.length;
      w.config.yaxis[0].labels.offsetY = -(divisor / 2);
      return ret;
    }
  }, {
    key: "checkColorRange",
    value: function checkColorRange() {
      var _this = this;

      var w = this.w;
      var heatmap = w.config.plotOptions.heatmap;

      if (heatmap.colorScale.ranges.length > 0) {
        heatmap.colorScale.ranges.map(function (range, index) {
          if (range.from < 0) {
            _this.negRange = true;
          }
        });
      }
    }
  }, {
    key: "determineHeatColor",
    value: function determineHeatColor(i, j) {
      var w = this.w;
      var val = w.globals.series[i][j];
      var heatmap = w.config.plotOptions.heatmap;
      var seriesNumber = heatmap.colorScale.inverse ? j : i;
      var color = w.globals.colors[seriesNumber];
      var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));
      var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));

      if (!heatmap.distributed) {
        min = w.globals.minY;
        max = w.globals.maxY;
      }

      if (typeof heatmap.colorScale.min !== 'undefined') {
        min = heatmap.colorScale.min < w.globals.minY ? heatmap.colorScale.min : w.globals.minY;
        max = heatmap.colorScale.max > w.globals.maxY ? heatmap.colorScale.max : w.globals.maxY;
      }

      var total = Math.abs(max) + Math.abs(min);
      var percent = 100 * val / (total === 0 ? total - 0.000001 : total);

      if (heatmap.colorScale.ranges.length > 0) {
        var colorRange = heatmap.colorScale.ranges;
        colorRange.map(function (range, index) {
          if (val >= range.from && val <= range.to) {
            color = range.color;
            min = range.from;
            max = range.to;

            var _total = Math.abs(max) + Math.abs(min);

            percent = 100 * val / (_total === 0 ? _total - 0.000001 : _total);
          }
        });
      }

      return {
        color: color,
        percent: percent
      };
    }
  }, {
    key: "calculateHeatmapDataLabels",
    value: function calculateHeatmapDataLabels(_ref) {
      var x = _ref.x,
          y = _ref.y,
          i = _ref.i,
          j = _ref.j,
          series = _ref.series,
          rectHeight = _ref.rectHeight,
          rectWidth = _ref.rectWidth;
      var w = this.w; // let graphics = new Graphics(this.ctx)

      var dataLabelsConfig = w.config.dataLabels;
      var graphics = new Graphics(this.ctx);
      var dataLabels = new DataLabels(this.ctx);
      var formatter = dataLabelsConfig.formatter;
      var elDataLabelsWrap = null;

      if (dataLabelsConfig.enabled) {
        elDataLabelsWrap = graphics.group({
          class: 'apexcharts-data-labels'
        });
        var offX = dataLabelsConfig.offsetX;
        var offY = dataLabelsConfig.offsetY;
        var dataLabelsX = x + rectWidth / 2 + offX;
        var dataLabelsY = y + rectHeight / 2 + parseInt(dataLabelsConfig.style.fontSize) / 3 + offY;
        var text = formatter(w.globals.series[i][j], {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
        dataLabels.plotDataLabelsText({
          x: dataLabelsX,
          y: dataLabelsY,
          text: text,
          i: i,
          j: j,
          parent: elDataLabelsWrap,
          dataLabelsConfig: dataLabelsConfig
        });
      }

      return elDataLabelsWrap;
    }
  }, {
    key: "animateHeatMap",
    value: function animateHeatMap(el, x, y, width, height, speed) {
      var _this2 = this;

      var animations = new Animations(this.ctx);
      animations.animateRect(el, {
        x: x + width / 2,
        y: y + height / 2,
        width: 0,
        height: 0
      }, {
        x: x,
        y: y,
        width: width,
        height: height
      }, speed, function () {
        _this2.w.globals.animationEnded = true;
      });
    }
  }, {
    key: "animateHeatColor",
    value: function animateHeatColor(el, colorFrom, colorTo, speed) {
      el.attr({
        fill: colorFrom
      }).animate(speed).attr({
        fill: colorTo
      });
    }
  }]);

  return HeatMap;
}();

/**
 * ApexCharts Pie Class for drawing Pie / Donut Charts.
 * @module Pie
 **/

var Pie =
/*#__PURE__*/
function () {
  function Pie(ctx) {
    _classCallCheck(this, Pie);

    this.ctx = ctx;
    this.w = ctx.w;
    this.chartType = this.w.config.chart.type;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    this.animBeginArr = [0];
    this.animDur = 0;
    this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;
    var w = this.w;
    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;
    this.centerY = this.defaultSize / 2;
    this.centerX = w.globals.gridWidth / 2;
    this.fullAngle = 360;
    this.donutSize = 0;
    this.sliceLabels = [];
    this.prevSectorAngleArr = []; // for dynamic animations
  }

  _createClass(Pie, [{
    key: "draw",
    value: function draw(series) {
      var self = this;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-pie'
      });
      if (w.globals.noData) return ret;
      var total = 0;

      for (var k = 0; k < series.length; k++) {
        // CALCULATE THE TOTAL
        total += Utils.negToZero(series[k]);
      }

      var sectorAngleArr = []; // el to which series will be drawn

      var elSeries = graphics.group(); // prevent division by zero error if there is no data

      if (total === 0) {
        total = 0.00001;
      }

      for (var i = 0; i < series.length; i++) {
        // CALCULATE THE ANGLES
        var angle = this.fullAngle * Utils.negToZero(series[i]) / total;
        sectorAngleArr.push(angle);
      }

      if (w.globals.dataChanged) {
        var prevTotal = 0;

        for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {
          // CALCULATE THE PREV TOTAL
          prevTotal += Utils.negToZero(w.globals.previousPaths[_k]);
        }

        var previousAngle;

        for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {
          // CALCULATE THE PREVIOUS ANGLES
          previousAngle = this.fullAngle * Utils.negToZero(w.globals.previousPaths[_i]) / prevTotal;
          this.prevSectorAngleArr.push(previousAngle);
        }
      }

      w.globals.radialSize = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;

      if (w.config.plotOptions.pie.size !== undefined) {
        w.globals.radialSize = w.config.plotOptions.pie.size;
      }

      this.donutSize = w.globals.radialSize * parseInt(w.config.plotOptions.pie.donut.size) / 100; // on small chart size after few count of resizes browser window donutSize can be negative

      if (this.donutSize < 0) {
        this.donutSize = 0;
      }

      var scaleSize = w.config.plotOptions.pie.customScale;
      var halfW = w.globals.gridWidth / 2;
      var halfH = w.globals.gridHeight / 2;
      var translateX = halfW - w.globals.gridWidth / 2 * scaleSize;
      var translateY = halfH - w.globals.gridHeight / 2 * scaleSize;

      if (this.donutDataLabels.show) {
        var dataLabels = this.renderInnerDataLabels(this.donutDataLabels, {
          hollowSize: this.donutSize,
          centerX: this.centerX,
          centerY: this.centerY,
          opacity: this.donutDataLabels.show,
          translateX: translateX,
          translateY: translateY
        });
        ret.add(dataLabels);
      }

      if (w.config.chart.type === 'donut') {
        // draw the inner circle and add some text to it
        var circle = graphics.drawCircle(this.donutSize);
        circle.attr({
          cx: this.centerX,
          cy: this.centerY,
          fill: w.config.plotOptions.pie.donut.background
        });
        elSeries.add(circle);
      }

      var elG = self.drawArcs(sectorAngleArr, series); // add slice dataLabels at the end

      this.sliceLabels.forEach(function (s) {
        elG.add(s);
      });
      elSeries.attr({
        transform: "translate(".concat(translateX, ", ").concat(translateY - 5, ") scale(").concat(scaleSize, ")")
      });
      ret.attr({
        'data:innerTranslateX': translateX,
        'data:innerTranslateY': translateY - 25
      });
      elSeries.add(elG);
      ret.add(elSeries);
      return ret;
    } // core function for drawing pie arcs

  }, {
    key: "drawArcs",
    value: function drawArcs(sectorAngleArr, series) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var g = graphics.group({
        class: 'apexcharts-slices'
      });
      var startAngle = 0;
      var prevStartAngle = 0;
      var endAngle = 0;
      var prevEndAngle = 0;
      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;

      for (var i = 0; i < sectorAngleArr.length; i++) {
        // if(sectorAngleArr[i]>0) {
        var elPieArc = graphics.group({
          class: "apexcharts-series apexcharts-pie-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[i]),
          rel: i + 1,
          'data:realIndex': i
        });
        g.add(elPieArc);
        startAngle = endAngle;
        prevStartAngle = prevEndAngle;
        endAngle = startAngle + sectorAngleArr[i];
        prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];
        var angle = endAngle - startAngle;
        var pathFill = fill.fillPath({
          seriesNumber: i,
          size: w.globals.radialSize,
          value: series[i]
        }); // additionaly, pass size for gradient drawing in the fillPath function

        var path = this.getChangedPath(prevStartAngle, prevEndAngle);
        var elPath = graphics.drawPath({
          d: path,
          stroke: this.lineColorArr instanceof Array ? this.lineColorArr[i] : this.lineColorArr,
          strokeWidth: this.strokeWidth,
          fill: pathFill,
          fillOpacity: w.config.fill.opacity,
          classes: "apexcharts-pie-area apexcharts-".concat(w.config.chart.type, "-slice-").concat(i)
        });
        elPath.attr({
          index: 0,
          j: i
        });

        if (w.config.chart.dropShadow.enabled) {
          var shadow = w.config.chart.dropShadow;
          filters.dropShadow(elPath, shadow, i);
        }

        this.addListeners(elPath, this.donutDataLabels);
        Graphics.setAttrs(elPath.node, {
          'data:angle': angle,
          'data:startAngle': startAngle,
          'data:strokeWidth': this.strokeWidth,
          'data:value': series[i]
        });
        var labelPosition = {
          x: 0,
          y: 0
        };

        if (w.config.chart.type === 'pie') {
          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, w.globals.radialSize / 1.25 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);
        } else if (w.config.chart.type === 'donut') {
          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, (w.globals.radialSize + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);
        }

        elPieArc.add(elPath); // Animation code starts

        var dur = 0;

        if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
          dur = (endAngle - startAngle) / this.fullAngle * w.config.chart.animations.speed;
          this.animDur = dur + this.animDur;
          this.animBeginArr.push(this.animDur);
        } else {
          this.animBeginArr.push(0);
        }

        if (this.dynamicAnim && w.globals.dataChanged) {
          this.animatePaths(elPath, {
            size: w.globals.radialSize,
            endAngle: endAngle,
            startAngle: startAngle,
            prevStartAngle: prevStartAngle,
            prevEndAngle: prevEndAngle,
            animateStartingPos: true,
            i: i,
            animBeginArr: this.animBeginArr,
            dur: w.config.chart.animations.dynamicAnimation.speed
          });
        } else {
          this.animatePaths(elPath, {
            size: w.globals.radialSize,
            endAngle: endAngle,
            startAngle: startAngle,
            i: i,
            totalItems: sectorAngleArr.length - 1,
            animBeginArr: this.animBeginArr,
            dur: dur
          });
        } // animation code ends


        if (w.config.plotOptions.pie.expandOnClick) {
          elPath.click(this.pieClicked.bind(this, i));
        }

        if (w.config.dataLabels.enabled) {
          var xPos = labelPosition.x;
          var yPos = labelPosition.y;
          var text = 100 * (endAngle - startAngle) / 360 + '%';

          if (angle !== 0 && w.config.plotOptions.pie.dataLabels.minAngleToShowLabel < sectorAngleArr[i]) {
            var formatter = w.config.dataLabels.formatter;

            if (formatter !== undefined) {
              text = formatter(w.globals.seriesPercent[i][0], {
                seriesIndex: i,
                w: w
              });
            }

            var foreColor = w.globals.dataLabels.style.colors[i];
            var elPieLabel = graphics.drawText({
              x: xPos,
              y: yPos,
              text: text,
              textAnchor: 'middle',
              fontSize: w.config.dataLabels.style.fontSize,
              fontFamily: w.config.dataLabels.style.fontFamily,
              foreColor: foreColor
            });

            if (w.config.dataLabels.dropShadow.enabled) {
              var textShadow = w.config.dataLabels.dropShadow;

              var _filters = new Filters(this.ctx);

              _filters.dropShadow(elPieLabel, textShadow);
            }

            elPieLabel.node.classList.add('apexcharts-pie-label');

            if (w.config.chart.animations.animate && w.globals.resized === false) {
              elPieLabel.node.classList.add('apexcharts-pie-label-delay');
              elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';
            }

            this.sliceLabels.push(elPieLabel);
          }
        } // }

      }

      return g;
    }
  }, {
    key: "addListeners",
    value: function addListeners(elPath, dataLabels) {
      var graphics = new Graphics(this.ctx); // append filters on mouseenter and mouseleave

      elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));
      elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
      elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));
      elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));
      elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));
      elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
    } // This function can be used for other circle charts too

  }, {
    key: "animatePaths",
    value: function animatePaths(el, opts) {
      var w = this.w;
      var me = this;
      var angle = opts.endAngle - opts.startAngle;
      var prevAngle = angle;
      var fromStartAngle = opts.startAngle;
      var toStartAngle = opts.startAngle;

      if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {
        fromStartAngle = opts.prevEndAngle;
        prevAngle = opts.prevEndAngle - opts.prevStartAngle;
      }

      if (opts.i === w.config.series.length - 1) {
        // some adjustments for the last overlapping paths
        if (angle + toStartAngle > this.fullAngle) {
          opts.endAngle = opts.endAngle - (angle + toStartAngle);
        } else if (angle + toStartAngle < this.fullAngle) {
          opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));
        }
      }

      if (angle === this.fullAngle) angle = this.fullAngle - 0.01;
      me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);
    }
  }, {
    key: "animateArc",
    value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {
      var me = this;
      var w = this.w;
      var size = opts.size;
      var path;

      if (isNaN(fromStartAngle) || isNaN(prevAngle)) {
        fromStartAngle = toStartAngle;
        prevAngle = angle;
        opts.dur = 0;
      }

      var currAngle = angle;
      var startAngle = toStartAngle;
      var fromAngle = fromStartAngle - toStartAngle;

      if (w.globals.dataChanged && opts.shouldSetPrevPaths) {
        // to avoid flickering, set prev path first and then we will animate from there
        path = me.getPiePath({
          me: me,
          startAngle: startAngle,
          angle: prevAngle,
          size: size
        });
        el.attr({
          d: path
        });
      }

      if (opts.dur !== 0) {
        el.animate(opts.dur, w.globals.easing, opts.animBeginArr[opts.i]).afterAll(function () {
          if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {
            this.animate(300).attr({
              'stroke-width': w.config.stroke.width
            });
          }

          w.globals.animationEnded = true;
        }).during(function (pos) {
          currAngle = fromAngle + (angle - fromAngle) * pos;

          if (opts.animateStartingPos) {
            currAngle = prevAngle + (angle - prevAngle) * pos;
            startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;
          }

          path = me.getPiePath({
            me: me,
            startAngle: startAngle,
            angle: currAngle,
            size: size
          });
          el.node.setAttribute('data:pathOrig', path);
          el.attr({
            d: path
          });
        });
      } else {
        path = me.getPiePath({
          me: me,
          startAngle: startAngle,
          angle: angle,
          size: size
        });

        if (!opts.isTrack) {
          w.globals.animationEnded = true;
        }

        el.node.setAttribute('data:pathOrig', path);
        el.attr({
          d: path
        });
      }
    }
  }, {
    key: "pieClicked",
    value: function pieClicked(i) {
      var w = this.w;
      var me = this;
      var path;
      var size = me.w.globals.radialSize + 4;
      var elPath = w.globals.dom.Paper.select(".apexcharts-".concat(w.config.chart.type.toLowerCase(), "-slice-").concat(i)).members[0];
      var pathFrom = elPath.attr('d');

      if (elPath.attr('data:pieClicked') === 'true') {
        elPath.attr({
          'data:pieClicked': 'false'
        });
        this.revertDataLabelsInner(elPath.node, this.donutDataLabels);
        var origPath = elPath.attr('data:pathOrig');
        elPath.attr({
          d: origPath
        });
        return;
      } else {
        // reset all elems
        var allEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area');
        Array.prototype.forEach.call(allEls, function (pieSlice) {
          pieSlice.setAttribute('data:pieClicked', 'false');
          var origPath = pieSlice.getAttribute('data:pathOrig');
          pieSlice.setAttribute('d', origPath);
        });
        elPath.attr('data:pieClicked', 'true');
      }

      var startAngle = parseInt(elPath.attr('data:startAngle'));
      var angle = parseInt(elPath.attr('data:angle'));
      path = me.getPiePath({
        me: me,
        startAngle: startAngle,
        angle: angle,
        size: size
      });
      if (angle === 360) return;
      elPath.plot(path).animate(1).plot(pathFrom).animate(100).plot(path);
    }
  }, {
    key: "getChangedPath",
    value: function getChangedPath(prevStartAngle, prevEndAngle) {
      var path = '';

      if (this.dynamicAnim && this.w.globals.dataChanged) {
        path = this.getPiePath({
          me: this,
          startAngle: prevStartAngle,
          angle: prevEndAngle - prevStartAngle,
          size: this.size
        });
      }

      return path;
    }
  }, {
    key: "getPiePath",
    value: function getPiePath(_ref) {
      var me = _ref.me,
          startAngle = _ref.startAngle,
          angle = _ref.angle,
          size = _ref.size;
      var w = this.w;
      var path;
      var startDeg = startAngle;
      var startRadians = Math.PI * (startDeg - 90) / 180;
      var endDeg = angle + startAngle;
      if (Math.ceil(endDeg) >= 360) endDeg = 359.99;
      var endRadians = Math.PI * (endDeg - 90) / 180;
      var x1 = me.centerX + size * Math.cos(startRadians);
      var y1 = me.centerY + size * Math.sin(startRadians);
      var x2 = me.centerX + size * Math.cos(endRadians);
      var y2 = me.centerY + size * Math.sin(endRadians);
      var startInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);
      var endInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);
      var largeArc = angle > 180 ? 1 : 0;

      if (w.config.chart.type === 'donut') {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z'].join(' ');
      } else if (w.config.chart.type === 'pie') {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', me.centerX, me.centerY, 'L', x1, y1].join(' ');
      } else {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2].join(' ');
      }

      return path;
    }
  }, {
    key: "renderInnerDataLabels",
    value: function renderInnerDataLabels(dataLabelsConfig, opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var g = graphics.group({
        class: 'apexcharts-datalabels-group',
        transform: "translate(".concat(opts.translateX ? opts.translateX : 0, ", ").concat(opts.translateY ? opts.translateY : 0, ")")
      });
      var showTotal = dataLabelsConfig.total.show;
      g.node.style.opacity = opts.opacity;
      var x = opts.centerX;
      var y = opts.centerY;
      var labelColor, valueColor;

      if (dataLabelsConfig.name.color === undefined) {
        labelColor = w.globals.colors[0];
      } else {
        labelColor = dataLabelsConfig.name.color;
      }

      if (dataLabelsConfig.value.color === undefined) {
        valueColor = w.config.chart.foreColor;
      } else {
        valueColor = dataLabelsConfig.value.color;
      }

      var lbFormatter = dataLabelsConfig.value.formatter;
      var val = '';
      var name = '';

      if (showTotal) {
        labelColor = dataLabelsConfig.total.color;
        name = dataLabelsConfig.total.label;
        val = dataLabelsConfig.total.formatter(w);
      } else {
        if (w.globals.series.length === 1) {
          val = lbFormatter(w.globals.series[0], w);
          name = w.globals.seriesNames[0];
        }
      }

      if (dataLabelsConfig.name.show) {
        var elLabel = graphics.drawText({
          x: x,
          y: y + parseInt(dataLabelsConfig.name.offsetY),
          text: name,
          textAnchor: 'middle',
          foreColor: labelColor,
          fontSize: dataLabelsConfig.name.fontSize,
          fontFamily: dataLabelsConfig.name.fontFamily
        });
        elLabel.node.classList.add('apexcharts-datalabel-label');
        g.add(elLabel);
      }

      if (dataLabelsConfig.value.show) {
        var valOffset = dataLabelsConfig.name.show ? parseInt(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;
        var elValue = graphics.drawText({
          x: x,
          y: y + valOffset,
          text: val,
          textAnchor: 'middle',
          foreColor: valueColor,
          fontSize: dataLabelsConfig.value.fontSize,
          fontFamily: dataLabelsConfig.value.fontFamily
        });
        elValue.node.classList.add('apexcharts-datalabel-value');
        g.add(elValue);
      } // for a multi-series circle chart, we need to show total value instead of first series labels


      return g;
    }
    /**
     *
     * @param {string} name - The name of the series
     * @param {string} val - The value of that series
     * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total
     */

  }, {
    key: "printInnerLabels",
    value: function printInnerLabels(labelsConfig, name, val, el) {
      var w = this.w;
      var labelColor;

      if (el) {
        if (labelsConfig.name.color === undefined) {
          labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel')) - 1];
        } else {
          labelColor = labelsConfig.name.color;
        }
      } else {
        if (w.globals.series.length > 1 && labelsConfig.total.show) {
          labelColor = labelsConfig.total.color;
        }
      }

      var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');
      var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');
      var lbFormatter = labelsConfig.value.formatter;
      val = lbFormatter(val, w); // we need to show Total Val - so get the formatter of it

      if (!el && typeof labelsConfig.total.formatter === 'function') {
        val = labelsConfig.total.formatter(w);
      }

      if (elLabel !== null) {
        elLabel.textContent = name;
      }

      if (elValue !== null) {
        elValue.textContent = val;
      }

      if (elLabel !== null) {
        elLabel.style.fill = labelColor;
      }
    }
  }, {
    key: "printDataLabelsInner",
    value: function printDataLabelsInner(el, dataLabelsConfig) {
      var w = this.w;
      var val = el.getAttribute('data:value');
      var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel')) - 1];

      if (w.globals.series.length > 1) {
        this.printInnerLabels(dataLabelsConfig, name, val, el);
      }

      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');

      if (dataLabelsGroup !== null) {
        dataLabelsGroup.style.opacity = 1;
      }
    }
  }, {
    key: "revertDataLabelsInner",
    value: function revertDataLabelsInner(el, dataLabelsConfig, event) {
      var _this = this;

      var w = this.w;
      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');

      if (dataLabelsConfig.total.show && w.globals.series.length > 1) {
        var pie = new Pie(this.ctx);
        pie.printInnerLabels(dataLabelsConfig, dataLabelsConfig.total.label, dataLabelsConfig.total.formatter(w));
      } else {
        var slices = document.querySelectorAll(".apexcharts-pie-area");
        var sliceOut = false;
        Array.prototype.forEach.call(slices, function (s) {
          if (s.getAttribute('data:pieClicked') === 'true') {
            sliceOut = true;

            _this.printDataLabelsInner(s, dataLabelsConfig);
          }
        });

        if (!sliceOut) {
          if (w.globals.selectedDataPoints.length && w.globals.series.length > 1) {
            if (w.globals.selectedDataPoints[0].length > 0) {
              var index = w.globals.selectedDataPoints[0];

              var _el = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(w.config.chart.type.toLowerCase(), "-slice-").concat(index));

              this.printDataLabelsInner(_el, dataLabelsConfig);
            } else if (dataLabelsGroup && w.globals.selectedDataPoints.length && w.globals.selectedDataPoints[0].length === 0) {
              dataLabelsGroup.style.opacity = 0;
            }
          } else {
            if (dataLabelsGroup && w.globals.series.length > 1) {
              dataLabelsGroup.style.opacity = 0;
            }
          }
        }
      }
    }
  }]);

  return Pie;
}();

/**
 * ApexCharts Radar Class for Spider/Radar Charts.
 * @module Radar
 **/

var Radar =
/*#__PURE__*/
function () {
  function Radar(ctx) {
    _classCallCheck(this, Radar);

    this.ctx = ctx;
    this.w = ctx.w;
    this.chartType = this.w.config.chart.type;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    this.animDur = 0;
    var w = this.w;
    this.graphics = new Graphics(this.ctx);
    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;
    this.maxValue = this.w.globals.maxY;
    this.polygons = w.config.plotOptions.radar.polygons;
    this.maxLabelWidth = 20;
    var longestLabel = w.globals.labels.slice().sort(function (a, b) {
      return b.length - a.length;
    })[0];
    var labelWidth = this.graphics.getTextRects(longestLabel, w.config.dataLabels.style.fontSize);
    this.size = this.defaultSize / 2.1 - w.config.stroke.width - w.config.chart.dropShadow.blur - labelWidth.width / 1.75;

    if (w.config.plotOptions.radar.size !== undefined) {
      this.size = w.config.plotOptions.radar.size;
    }

    this.dataRadiusOfPercent = [];
    this.dataRadius = [];
    this.angleArr = [];
    this.yaxisLabelsTextsPos = [];
  }

  _createClass(Radar, [{
    key: "draw",
    value: function draw(series) {
      var _this = this;

      var w = this.w;
      var fill = new Fill(this.ctx);
      var allSeries = [];

      if (series.length) {
        this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;
      }

      this.disAngle = Math.PI * 2 / this.dataPointsLen;
      var halfW = w.globals.gridWidth / 2;
      var halfH = w.globals.gridHeight / 2;
      var translateX = halfW;
      var translateY = halfH;
      var ret = this.graphics.group({
        class: 'apexcharts-radar-series',
        'data:innerTranslateX': translateX,
        'data:innerTranslateY': translateY - 25,
        transform: "translate(".concat(translateX || 0, ", ").concat(translateY || 0, ")")
      });
      var dataPointsPos = [];
      var elPointsMain = null;
      this.yaxisLabels = this.graphics.group({
        class: 'apexcharts-yaxis'
      });
      series.forEach(function (s, i) {
        // el to which series will be drawn
        var elSeries = _this.graphics.group().attr({
          class: "apexcharts-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[i]),
          rel: i + 1,
          'data:realIndex': i
        });

        _this.dataRadiusOfPercent[i] = [];
        _this.dataRadius[i] = [];
        _this.angleArr[i] = [];
        s.forEach(function (dv, j) {
          _this.dataRadiusOfPercent[i][j] = dv / _this.maxValue;
          _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;
          _this.angleArr[i][j] = j * _this.disAngle;
        });
        dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);

        var paths = _this.createPaths(dataPointsPos, {
          x: 0,
          y: 0
        }); // points


        elPointsMain = _this.graphics.group({
          class: 'apexcharts-series-markers-wrap hidden'
        });
        w.globals.delayedElements.push({
          el: elPointsMain.node,
          index: i
        });
        var defaultRenderedPathOptions = {
          i: i,
          realIndex: i,
          animationDelay: i,
          initialSpeed: w.config.chart.animations.speed,
          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-radar",
          shouldClipToGrid: false,
          bindEventsOnPaths: false,
          stroke: w.globals.stroke.colors[i],
          strokeLineCap: w.config.stroke.lineCap
        };
        var pathFrom = null;

        if (w.globals.previousPaths.length > 0) {
          pathFrom = _this.getPathFrom(i);
        }

        for (var p = 0; p < paths.linePathsTo.length; p++) {
          var renderedLinePath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
            pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,
            pathTo: paths.linePathsTo[p],
            strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width,
            fill: 'none',
            drawShadow: false
          }));

          elSeries.add(renderedLinePath);
          var pathFill = fill.fillPath({
            seriesNumber: i
          });

          var renderedAreaPath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
            pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,
            pathTo: paths.areaPathsTo[p],
            strokeWidth: 0,
            fill: pathFill,
            drawShadow: false
          }));

          if (w.config.chart.dropShadow.enabled) {
            var filters = new Filters(_this.ctx);
            var shadow = w.config.chart.dropShadow;
            filters.dropShadow(renderedAreaPath, Object.assign({}, shadow, {
              noUserSpaceOnUse: true
            }), i);
          }

          elSeries.add(renderedAreaPath);
        }

        s.forEach(function (sj, j) {
          var markers = new Markers(_this.ctx);
          var opts = markers.getMarkerConfig('apexcharts-marker', i, j);

          var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);

          point.attr('rel', j);
          point.attr('j', j);
          point.attr('index', i);
          point.node.setAttribute('default-marker-size', opts.pSize);

          var elPointsWrap = _this.graphics.group({
            class: 'apexcharts-series-markers'
          });

          if (elPointsWrap) {
            elPointsWrap.add(point);
          }

          elPointsMain.add(elPointsWrap);
          elSeries.add(elPointsMain);
        });
        allSeries.push(elSeries);
      });
      this.drawPolygons({
        parent: ret
      });

      if (w.config.dataLabels.enabled) {
        var dataLabels = this.drawLabels();
        ret.add(dataLabels);
      }

      ret.add(this.yaxisLabels);
      allSeries.forEach(function (elS) {
        ret.add(elS);
      });
      return ret;
    }
  }, {
    key: "drawPolygons",
    value: function drawPolygons(opts) {
      var _this2 = this;

      var w = this.w;
      var parent = opts.parent;
      var yaxisTexts = w.globals.yAxisScale[0].result.reverse();
      var layers = yaxisTexts.length;
      var radiusSizes = [];
      var layerDis = this.size / (layers - 1);

      for (var i = 0; i < layers; i++) {
        radiusSizes[i] = layerDis * i;
      }

      radiusSizes.reverse();
      var polygonStrings = [];
      var lines = [];
      radiusSizes.forEach(function (radiusSize, r) {
        var polygon = _this2.getPolygonPos(radiusSize);

        var string = '';
        polygon.forEach(function (p, i) {
          if (r === 0) {
            var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);

            lines.push(line);
          }

          if (i === 0) {
            _this2.yaxisLabelsTextsPos.push({
              x: p.x,
              y: p.y
            });
          }

          string += p.x + ',' + p.y + ' ';
        });
        polygonStrings.push(string);
      });
      polygonStrings.forEach(function (p, i) {
        var strokeColors = _this2.polygons.strokeColors;

        var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, w.globals.radarPolygons.fill.colors[i]);

        parent.add(polygon);
      });
      lines.forEach(function (l) {
        parent.add(l);
      });

      if (w.config.yaxis[0].show) {
        this.yaxisLabelsTextsPos.forEach(function (p, i) {
          var yText = _this2.drawYAxisText(p.x, p.y, i, yaxisTexts[i]);

          _this2.yaxisLabels.add(yText);
        });
      }
    }
  }, {
    key: "drawYAxisText",
    value: function drawYAxisText(x, y, i, text) {
      var w = this.w;
      var yaxisConfig = w.config.yaxis[0];
      var formatter = w.globals.yLabelFormatters[0];
      var yaxisLabel = this.graphics.drawText({
        x: x + yaxisConfig.labels.offsetX,
        y: y + yaxisConfig.labels.offsetY,
        text: formatter(text, i),
        textAnchor: 'middle',
        fontSize: yaxisConfig.labels.style.fontSize,
        fontFamily: yaxisConfig.labels.style.fontFamily,
        foreColor: yaxisConfig.labels.style.color
      });
      return yaxisLabel;
    }
  }, {
    key: "drawLabels",
    value: function drawLabels() {
      var _this3 = this;

      var w = this.w;
      var limit = 10;
      var textAnchor = 'middle';
      var dataLabelsConfig = w.config.dataLabels;
      var elDataLabelsWrap = this.graphics.group({
        class: 'apexcharts-datalabels'
      });
      var polygonPos = this.getPolygonPos(this.size);
      var currPosX = 0;
      var currPosY = 0;
      w.globals.labels.forEach(function (label, i) {
        var formatter = dataLabelsConfig.formatter;
        var dataLabels = new DataLabels(_this3.ctx);

        if (polygonPos[i]) {
          currPosX = polygonPos[i].x;
          currPosY = polygonPos[i].y;

          if (Math.abs(polygonPos[i].x) >= limit) {
            if (polygonPos[i].x > 0) {
              textAnchor = 'start';
              currPosX += 10;
            } else if (polygonPos[i].x < 0) {
              textAnchor = 'end';
              currPosX -= 10;
            }
          } else {
            textAnchor = 'middle';
          }

          if (Math.abs(polygonPos[i].y) >= _this3.size - limit) {
            if (polygonPos[i].y < 0) {
              currPosY -= 10;
            } else if (polygonPos[i].y > 0) {
              currPosY += 10;
            }
          }

          var text = formatter(label, {
            seriesIndex: -1,
            dataPointIndex: i,
            w: w
          });
          dataLabels.plotDataLabelsText({
            x: currPosX,
            y: currPosY,
            text: text,
            textAnchor: textAnchor,
            i: i,
            j: i,
            parent: elDataLabelsWrap,
            dataLabelsConfig: dataLabelsConfig,
            offsetCorrection: false
          });
        }
      });
      return elDataLabelsWrap;
    }
  }, {
    key: "createPaths",
    value: function createPaths(pos, origin) {
      var _this4 = this;

      var linePathsTo = [];
      var linePathsFrom = [];
      var areaPathsTo = [];
      var areaPathsFrom = [];

      if (pos.length) {
        linePathsFrom = [this.graphics.move(origin.x, origin.y)];
        areaPathsFrom = [this.graphics.move(origin.x, origin.y)];
        var linePathTo = this.graphics.move(pos[0].x, pos[0].y);
        var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);
        pos.forEach(function (p, i) {
          linePathTo += _this4.graphics.line(p.x, p.y);
          areaPathTo += _this4.graphics.line(p.x, p.y);

          if (i === pos.length - 1) {
            linePathTo += 'Z';
            areaPathTo += 'Z';
          }
        });
        linePathsTo.push(linePathTo);
        areaPathsTo.push(areaPathTo);
      }

      return {
        linePathsFrom: linePathsFrom,
        linePathsTo: linePathsTo,
        areaPathsFrom: areaPathsFrom,
        areaPathsTo: areaPathsTo
      };
    }
  }, {
    key: "getPathFrom",
    value: function getPathFrom(realIndex) {
      var w = this.w;
      var pathFrom = null;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {
            pathFrom = w.globals.previousPaths[pp].paths[0].d;
          }
        }
      }

      return pathFrom;
    }
  }, {
    key: "getDataPointsPos",
    value: function getDataPointsPos(dataRadiusArr, angleArr) {
      var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;
      dataRadiusArr = dataRadiusArr || [];
      angleArr = angleArr || [];
      var dataPointsPosArray = [];

      for (var j = 0; j < dataPointsLen; j++) {
        var curPointPos = {};
        curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);
        curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);
        dataPointsPosArray.push(curPointPos);
      }

      return dataPointsPosArray;
    }
  }, {
    key: "getPolygonPos",
    value: function getPolygonPos(size) {
      var dotsArray = [];
      var angle = Math.PI * 2 / this.dataPointsLen;

      for (var i = 0; i < this.dataPointsLen; i++) {
        var curPos = {};
        curPos.x = size * Math.sin(i * angle);
        curPos.y = -size * Math.cos(i * angle);
        dotsArray.push(curPos);
      }

      return dotsArray;
    }
  }]);

  return Radar;
}();

/**
 * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.
 * @module Radial
 **/

var Radial =
/*#__PURE__*/
function (_Pie) {
  _inherits(Radial, _Pie);

  function Radial(ctx) {
    var _this;

    _classCallCheck(this, Radial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Radial).call(this, ctx));
    _this.ctx = ctx;
    _this.w = ctx.w;
    _this.animBeginArr = [0];
    _this.animDur = 0;
    var w = _this.w;
    _this.startAngle = w.config.plotOptions.radialBar.startAngle;
    _this.endAngle = w.config.plotOptions.radialBar.endAngle;
    _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;
    _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;
    _this.radialDataLabels = w.config.plotOptions.radialBar.dataLabels;
    if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;
    if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;
    if (_this.endAngle === 360) _this.endAngle = 359.99;
    _this.fullAngle = 360 - w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle;
    _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin);
    return _this;
  }

  _createClass(Radial, [{
    key: "draw",
    value: function draw(series) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-radialbar'
      });
      if (w.globals.noData) return ret;
      var elSeries = graphics.group();
      var centerY = this.defaultSize / 2;
      var centerX = w.globals.gridWidth / 2;
      var size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;

      if (w.config.plotOptions.radialBar.size !== undefined) {
        size = w.config.plotOptions.radialBar.size;
      }

      var colorArr = w.globals.fill.colors;

      if (w.config.plotOptions.radialBar.track.show) {
        var elTracks = this.drawTracks({
          size: size,
          centerX: centerX,
          centerY: centerY,
          colorArr: colorArr,
          series: series
        });
        elSeries.add(elTracks);
      }

      var elG = this.drawArcs({
        size: size,
        centerX: centerX,
        centerY: centerY,
        colorArr: colorArr,
        series: series
      });
      var totalAngle = 360;

      if (w.config.plotOptions.radialBar.startAngle < 0) {
        totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle);
      }

      w.globals.radialSize = size - size / (360 / (360 - totalAngle)) + 10;
      elSeries.add(elG.g);

      if (w.config.plotOptions.radialBar.hollow.position === 'front') {
        elG.g.add(elG.elHollow);

        if (elG.dataLabels) {
          elG.g.add(elG.dataLabels);
        }
      }

      ret.add(elSeries);
      return ret;
    }
  }, {
    key: "drawTracks",
    value: function drawTracks(opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var g = graphics.group({
        class: 'apexcharts-tracks'
      });
      var filters = new Filters(this.ctx);
      var fill = new Fill(this.ctx);
      var strokeWidth = this.getStrokeWidth(opts);
      opts.size = opts.size - strokeWidth / 2;

      for (var i = 0; i < opts.series.length; i++) {
        var elRadialBarTrack = graphics.group({
          class: 'apexcharts-radialbar-track apexcharts-track'
        });
        g.add(elRadialBarTrack);
        elRadialBarTrack.attr({
          rel: i + 1
        });
        opts.size = opts.size - strokeWidth - this.margin;
        var trackConfig = w.config.plotOptions.radialBar.track;
        var pathFill = fill.fillPath({
          seriesNumber: 0,
          size: opts.size,
          fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,
          solid: true
        });
        var startAngle = this.trackStartAngle;
        var endAngle = this.trackEndAngle;
        if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;
        var elPath = graphics.drawPath({
          d: '',
          stroke: pathFill,
          strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth) / 100,
          fill: 'none',
          strokeOpacity: trackConfig.opacity,
          classes: 'apexcharts-radialbar-area'
        });

        if (trackConfig.dropShadow.enabled) {
          var shadow = trackConfig.dropShadow;
          filters.dropShadow(elPath, shadow);
        }

        elRadialBarTrack.add(elPath);
        elPath.attr('id', 'apexcharts-radialbarTrack-' + i);
        this.animatePaths(elPath, {
          centerX: opts.centerX,
          centerY: opts.centerY,
          endAngle: endAngle,
          startAngle: startAngle,
          size: opts.size,
          i: i,
          totalItems: 2,
          animBeginArr: 0,
          dur: 0,
          isTrack: true,
          easing: w.globals.easing
        });
      }

      return g;
    }
  }, {
    key: "drawArcs",
    value: function drawArcs(opts) {
      var w = this.w; // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series

      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var filters = new Filters(this.ctx);
      var g = graphics.group();
      var strokeWidth = this.getStrokeWidth(opts);
      opts.size = opts.size - strokeWidth / 2;
      var hollowFillID = w.config.plotOptions.radialBar.hollow.background;
      var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth) / 100 / 2;
      var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;

      if (w.config.plotOptions.radialBar.hollow.image !== undefined) {
        hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);
      }

      var elHollow = this.drawHollow({
        size: hollowRadius,
        centerX: opts.centerX,
        centerY: opts.centerY,
        fill: hollowFillID
      });

      if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;
        filters.dropShadow(elHollow, shadow);
      }

      var shown = 1;

      if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {
        shown = 0;
      }

      var dataLabels = null;

      if (this.radialDataLabels.show) {
        dataLabels = this.renderInnerDataLabels(this.radialDataLabels, {
          hollowSize: hollowSize,
          centerX: opts.centerX,
          centerY: opts.centerY,
          opacity: shown
        });
      }

      if (w.config.plotOptions.radialBar.hollow.position === 'back') {
        g.add(elHollow);

        if (dataLabels) {
          g.add(dataLabels);
        }
      }

      var reverseLoop = false;

      if (w.config.plotOptions.radialBar.inverseOrder) {
        reverseLoop = true;
      }

      for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {
        var elRadialBarArc = graphics.group({
          class: "apexcharts-series apexcharts-radial-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[i])
        });
        g.add(elRadialBarArc);
        elRadialBarArc.attr({
          rel: i + 1,
          'data:realIndex': i
        });
        this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);
        opts.size = opts.size - strokeWidth - this.margin;
        var pathFill = fill.fillPath({
          seriesNumber: i,
          size: opts.size,
          value: opts.series[i]
        });
        var startAngle = this.startAngle;
        var prevStartAngle = void 0;
        var totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle); // if data exceeds 100, make it 100

        var dataValue = Utils.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;
        var endAngle = Math.round(totalAngle * dataValue) + this.startAngle;
        var prevEndAngle = void 0;

        if (w.globals.dataChanged) {
          prevStartAngle = this.startAngle;
          prevEndAngle = Math.round(totalAngle * Utils.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;
        }

        var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);

        if (currFullAngle >= 360) {
          endAngle = endAngle - 0.01;
        }

        var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);

        if (prevFullAngle >= 360) {
          prevEndAngle = prevEndAngle - 0.01;
        }

        var angle = endAngle - startAngle;
        var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;
        var elPath = graphics.drawPath({
          d: '',
          stroke: pathFill,
          strokeWidth: strokeWidth,
          fill: 'none',
          fillOpacity: w.config.fill.opacity,
          classes: 'apexcharts-radialbar-area apexcharts-radialbar-slice-' + i,
          strokeDashArray: dashArray
        });
        Graphics.setAttrs(elPath.node, {
          'data:angle': angle,
          'data:value': opts.series[i]
        });

        if (w.config.chart.dropShadow.enabled) {
          var _shadow = w.config.chart.dropShadow;
          filters.dropShadow(elPath, _shadow, i);
        }

        this.addListeners(elPath, this.radialDataLabels);
        elRadialBarArc.add(elPath);
        elPath.attr({
          index: 0,
          j: i
        });
        var dur = 0;

        if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.speed;
          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;
          this.animBeginArr.push(this.animDur);
        }

        if (w.globals.dataChanged) {
          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.dynamicAnimation.speed;
          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;
          this.animBeginArr.push(this.animDur);
        }

        this.animatePaths(elPath, {
          centerX: opts.centerX,
          centerY: opts.centerY,
          endAngle: endAngle,
          startAngle: startAngle,
          prevEndAngle: prevEndAngle,
          prevStartAngle: prevStartAngle,
          size: opts.size,
          i: i,
          totalItems: 2,
          animBeginArr: this.animBeginArr,
          dur: dur,
          shouldSetPrevPaths: true,
          easing: w.globals.easing
        });
      }

      return {
        g: g,
        elHollow: elHollow,
        dataLabels: dataLabels
      };
    }
  }, {
    key: "drawHollow",
    value: function drawHollow(opts) {
      var graphics = new Graphics(this.ctx);
      var circle = graphics.drawCircle(opts.size * 2);
      circle.attr({
        class: 'apexcharts-radialbar-hollow',
        cx: opts.centerX,
        cy: opts.centerY,
        r: opts.size,
        fill: opts.fill
      });
      return circle;
    }
  }, {
    key: "drawHollowImage",
    value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {
      var w = this.w;
      var fill = new Fill(this.ctx);
      var randID = (Math.random() + 1).toString(36).substring(4);
      var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;

      if (w.config.plotOptions.radialBar.hollow.imageClipped) {
        fill.clippedImgArea({
          width: hollowSize,
          height: hollowSize,
          image: hollowFillImg,
          patternID: "pattern".concat(w.globals.cuid).concat(randID)
        });
        hollowFillID = "url(#pattern".concat(w.globals.cuid).concat(randID, ")");
      } else {
        var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;
        var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;

        if (imgWidth === undefined && imgHeight === undefined) {
          var image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {
            this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          g.add(image);
        } else {
          var _image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {
            this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
            this.size(imgWidth, imgHeight);
          });

          g.add(_image);
        }
      }

      return hollowFillID;
    }
  }, {
    key: "getStrokeWidth",
    value: function getStrokeWidth(opts) {
      var w = this.w;
      return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size)) / 100 / (opts.series.length + 1) - this.margin;
    }
  }]);

  return Radial;
}(Pie);

/**
 * ApexCharts RangeBar Class responsible for drawing Range/Timeline Bars.
 *
 * @module RangeBar
 **/

var RangeBar =
/*#__PURE__*/
function (_Bar) {
  _inherits(RangeBar, _Bar);

  function RangeBar() {
    _classCallCheck(this, RangeBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(RangeBar).apply(this, arguments));
  }

  _createClass(RangeBar, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar;
      this.series = series;
      this.seriesRangeStart = w.globals.seriesRangeStart;
      this.seriesRangeEnd = w.globals.seriesRangeEnd;
      this.initVariables(series);
      var ret = graphics.group({
        class: 'apexcharts-rangebar-series apexcharts-plot-series'
      });

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        var pathTo = void 0,
            pathFrom = void 0;
        var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
        yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
        zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
        zeroW = void 0; // zeroW is the baseline where 0 meets x axis

        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series

        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[realIndex]),
          rel: i + 1,
          'data:realIndex': realIndex
        });

        if (series[i].length > 0) {
          this.visibleI = this.visibleI + 1;
        }

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        if (this.yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        var initPositions = this.initialPositions();
        y = initPositions.y;
        yDivision = initPositions.yDivision;
        barHeight = initPositions.barHeight;
        zeroW = initPositions.zeroW;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;
        xArrj.push(x + barWidth / 2); // eldatalabels

        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });

        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {
          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {
            this.isNullValue = true;
          } else {
            this.isNullValue = false;
          }

          if (w.config.stroke.show) {
            if (this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
            }
          }

          var paths = null;

          if (this.isHorizontal) {
            paths = this.drawRangeBarPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              barHeight: barHeight,
              strokeWidth: strokeWidth,
              pathTo: pathTo,
              pathFrom: pathFrom,
              zeroW: zeroW,
              x: x,
              y: y,
              yDivision: yDivision,
              elSeries: elSeries
            });
            barWidth = paths.barWidth;
          } else {
            paths = this.drawRangeColumnPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              x: x,
              y: y,
              xDivision: xDivision,
              pathTo: pathTo,
              pathFrom: pathFrom,
              barWidth: barWidth,
              zeroH: zeroH,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            });
            barHeight = paths.barHeight;
          }

          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x; // push current X

          if (j > 0) {
            xArrj.push(x + barWidth / 2);
          }

          yArrj.push(y);
          var pathFill = fill.fillPath({
            seriesNumber: realIndex
          });
          var lineFill = w.globals.stroke.colors[realIndex];
          elSeries = this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            lineFill: lineFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            visibleSeries: this.visibleI,
            type: 'rangebar'
          });
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj;
        ret.add(elSeries);
      }

      return ret;
    }
  }, {
    key: "drawRangeColumnPaths",
    value: function drawRangeColumnPaths(_ref) {
      var indexes = _ref.indexes,
          x = _ref.x,
          y = _ref.y,
          strokeWidth = _ref.strokeWidth,
          xDivision = _ref.xDivision,
          pathTo = _ref.pathTo,
          pathFrom = _ref.pathFrom,
          barWidth = _ref.barWidth,
          zeroH = _ref.zeroH;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var yRatio = this.yRatio[this.yaxisIndex];
      var realIndex = indexes.realIndex;
      var range = this.getRangeValue(realIndex, j);
      var y1 = Math.min(range.start, range.end);
      var y2 = Math.max(range.start, range.end);

      if (w.globals.isXNumeric) {
        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x + barWidth * this.visibleI;

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        y1 = zeroH;
      } else {
        y1 = zeroH - y1 / yRatio;
        y2 = zeroH - y2 / yRatio;
      }

      var barHeight = Math.abs(y2 - y1);
      pathTo = graphics.move(barXPosition, zeroH);
      pathFrom = graphics.move(barXPosition, y1);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j, true);
      }

      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);
      pathFrom = pathFrom + graphics.move(barXPosition, y1) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition, y1);

      if (!w.globals.isXNumeric) {
        x = x + xDivision;
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        barHeight: barHeight,
        x: x,
        y: y2,
        barXPosition: barXPosition
      };
    }
  }, {
    key: "drawRangeBarPaths",
    value: function drawRangeBarPaths(_ref2) {
      var indexes = _ref2.indexes,
          x = _ref2.x,
          y = _ref2.y,
          yDivision = _ref2.yDivision,
          pathTo = _ref2.pathTo,
          pathFrom = _ref2.pathFrom,
          barHeight = _ref2.barHeight,
          zeroW = _ref2.zeroW;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var x1 = zeroW;
      var x2 = zeroW;

      if (w.globals.isXNumeric) {
        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;
      }

      var barYPosition = y + barHeight * this.visibleI;

      if (typeof this.series[i][j] !== 'undefined' && this.series[i][j] !== null) {
        x1 = zeroW + this.seriesRangeStart[i][j] / this.invertedYRatio;
        x2 = zeroW + this.seriesRangeEnd[i][j] / this.invertedYRatio;
      }

      pathTo = graphics.move(zeroW, barYPosition);
      pathFrom = graphics.move(zeroW, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j);
      }

      var barWidth = Math.abs(x2 - x1);
      pathTo = graphics.move(x1, barYPosition) + graphics.line(x2, barYPosition) + graphics.line(x2, barYPosition + barHeight) + graphics.line(x1, barYPosition + barHeight) + graphics.line(x1, barYPosition);
      pathFrom = pathFrom + graphics.line(x1, barYPosition) + graphics.line(x1, barYPosition + barHeight) + graphics.line(x1, barYPosition + barHeight) + graphics.line(x1, barYPosition);

      if (!w.globals.isXNumeric) {
        y = y + yDivision;
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        barWidth: barWidth,
        x: x2,
        y: y,
        barYPosition: barYPosition
      };
    }
  }, {
    key: "getRangeValue",
    value: function getRangeValue(i, j) {
      var w = this.w;
      return {
        start: w.globals.seriesRangeStart[i][j],
        end: w.globals.seriesRangeEnd[i][j]
      };
    }
  }]);

  return RangeBar;
}(Bar);

/**
 * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.
 *
 * @module Formatters
 **/

var Formatters =
/*#__PURE__*/
function () {
  function Formatters(ctx) {
    _classCallCheck(this, Formatters);

    this.ctx = ctx;
    this.w = ctx.w;
    this.tooltipKeyFormat = 'dd MMM';
  }

  _createClass(Formatters, [{
    key: "xLabelFormat",
    value: function xLabelFormat(fn, val, timestamp) {
      var w = this.w;

      if (w.config.xaxis.type === 'datetime') {
        if (w.config.xaxis.labels.formatter === undefined) {
          // if user has not specified a custom formatter, use the default tooltip.x.format
          if (w.config.tooltip.x.formatter === undefined) {
            var datetimeObj = new DateTime(this.ctx);
            return datetimeObj.formatDate(new Date(val), w.config.tooltip.x.format, true, true);
          }
        }
      }

      return fn(val, timestamp);
    }
  }, {
    key: "setLabelFormatters",
    value: function setLabelFormatters() {
      var w = this.w;

      w.globals.xLabelFormatter = function (val) {
        return val;
      };

      w.globals.xaxisTooltipFormatter = function (val) {
        return val;
      };

      w.globals.ttKeyFormatter = function (val) {
        return val;
      };

      w.globals.ttZFormatter = function (val) {
        return val;
      };

      w.globals.legendFormatter = function (val) {
        return val;
      }; // formatter function will always overwrite format property


      if (w.config.xaxis.labels.formatter !== undefined) {
        w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;
      } else {
        w.globals.xLabelFormatter = function (val) {
          if (Utils.isNumber(val)) {
            // numeric xaxis may have smaller range, so defaulting to 1 decimal
            if (w.config.xaxis.type === 'numeric' && w.globals.dataPoints < 50) {
              return val.toFixed(1);
            }

            return val.toFixed(0);
          }

          return val;
        };
      }

      if (typeof w.config.tooltip.x.formatter === 'function') {
        w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;
      } else {
        w.globals.ttKeyFormatter = w.globals.xLabelFormatter;
      }

      if (typeof w.config.xaxis.tooltip.formatter === 'function') {
        w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;
      }

      if (Array.isArray(w.config.tooltip.y)) {
        w.globals.ttVal = w.config.tooltip.y;
      } else {
        if (w.config.tooltip.y.formatter !== undefined) {
          w.globals.ttVal = w.config.tooltip.y;
        }
      }

      if (w.config.tooltip.z.formatter !== undefined) {
        w.globals.ttZFormatter = w.config.tooltip.z.formatter;
      } // legend formatter - if user wants to append any global values of series to legend text


      if (w.config.legend.formatter !== undefined) {
        w.globals.legendFormatter = w.config.legend.formatter;
      } // formatter function will always overwrite format property


      w.config.yaxis.forEach(function (yaxe, i) {
        if (yaxe.labels.formatter !== undefined) {
          w.globals.yLabelFormatters[i] = yaxe.labels.formatter;
        } else {
          w.globals.yLabelFormatters[i] = function (val) {
            if (Utils.isNumber(val)) {
              if (w.globals.yValueDecimal !== 0) {
                return val.toFixed(yaxe.decimalsInFloat !== undefined ? yaxe.decimalsInFloat : w.globals.yValueDecimal);
              } else if (w.globals.maxYArr[i] - w.globals.minYArr[i] < 10) {
                return val.toFixed(1);
              } else {
                return val.toFixed(0);
              }
            }

            return val;
          };
        }
      });
      return w.globals;
    }
  }, {
    key: "heatmapLabelFormatters",
    value: function heatmapLabelFormatters() {
      var w = this.w;

      if (w.config.chart.type === 'heatmap') {
        w.globals.yAxisScale[0].result = w.globals.seriesNames.slice(); //  get the longest string from the labels array and also apply label formatter to it

        var longest = w.globals.seriesNames.reduce(function (a, b) {
          return a.length > b.length ? a : b;
        }, 0);
        w.globals.yAxisScale[0].niceMax = longest;
        w.globals.yAxisScale[0].niceMin = longest;
      }
    }
  }]);

  return Formatters;
}();

var AxesUtils =
/*#__PURE__*/
function () {
  function AxesUtils(ctx) {
    _classCallCheck(this, AxesUtils);

    this.ctx = ctx;
    this.w = ctx.w;
  } // Based on the formatter function, get the label text and position


  _createClass(AxesUtils, [{
    key: "getLabel",
    value: function getLabel(labels, timelineLabels, x, i) {
      var drawnLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      var w = this.w;
      var rawLabel = typeof labels[i] === 'undefined' ? '' : labels[i];
      var label;
      var xlbFormatter = w.globals.xLabelFormatter;
      var customFormatter = w.config.xaxis.labels.formatter;
      var xFormat = new Formatters(this.ctx);
      var timestamp = rawLabel;
      label = xFormat.xLabelFormat(xlbFormatter, rawLabel, timestamp);

      if (customFormatter !== undefined) {
        label = customFormatter(rawLabel, labels[i], i);
      }

      if (timelineLabels.length > 0) {
        x = timelineLabels[i].position;
        label = timelineLabels[i].value;
      } else {
        if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {
          label = '';
        }
      }

      if (typeof label === 'undefined') label = '';
      label = label.toString();

      if (label.indexOf('NaN') === 0 || label.toLowerCase().indexOf('invalid') === 0 || label.toLowerCase().indexOf('infinity') >= 0 || drawnLabels.indexOf(label) >= 0 && !w.config.xaxis.labels.showDuplicates) {
        label = '';
      }

      return {
        x: x,
        text: label
      };
    }
  }, {
    key: "drawYAxisTicks",
    value: function drawYAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {
      var w = this.w;
      var graphics = new Graphics(this.ctx); // initial label position = 0;

      var t = w.globals.translateY;

      if (axisTicks.show) {
        if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;

        for (var i = tickAmount; i >= 0; i--) {
          var tY = t + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY - 1;

          if (w.globals.isBarHorizontal) {
            tY = labelsDivider * i;
          }

          var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisBorder.color);
          elYaxis.add(elTick);
          t = t + labelsDivider;
        }
      }
    }
  }]);

  return AxesUtils;
}();

/**
 * ApexCharts YAxis Class for drawing Y-Axis.
 *
 * @module YAxis
 **/

var YAxis =
/*#__PURE__*/
function () {
  function YAxis(ctx) {
    _classCallCheck(this, YAxis);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;
    this.axisFontFamily = w.config.xaxis.labels.style.fontFamily;
    this.xaxisForeColors = w.config.xaxis.labels.style.colors;
    this.xAxisoffX = 0;

    if (w.config.xaxis.position === 'bottom') {
      this.xAxisoffX = w.globals.gridHeight;
    }

    this.drawnLabels = [];
    this.axesUtils = new AxesUtils(ctx);
  }

  _createClass(YAxis, [{
    key: "drawYaxis",
    value: function drawYaxis(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var yaxisFontSize = w.config.yaxis[realIndex].labels.style.fontSize;
      var yaxisFontFamily = w.config.yaxis[realIndex].labels.style.fontFamily;
      var elYaxis = graphics.group({
        class: 'apexcharts-yaxis',
        rel: realIndex,
        transform: 'translate(' + w.globals.translateYAxisX[realIndex] + ', 0)'
      });

      if (!w.config.yaxis[realIndex].show) {
        return elYaxis;
      }

      var elYaxisTexts = graphics.group({
        class: 'apexcharts-yaxis-texts-g'
      });
      elYaxis.add(elYaxisTexts);
      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg height/number of ticks

      var labelsDivider = w.globals.gridHeight / tickAmount + 0.1; // initial label position = 0;

      var l = w.globals.translateY;
      var lbFormatter = w.globals.yLabelFormatters[realIndex];
      var labels = w.globals.yAxisScale[realIndex].result.slice();

      if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].reversed) {
        labels.reverse();
      }

      if (w.config.yaxis[realIndex].labels.show) {
        for (var i = tickAmount; i >= 0; i--) {
          var val = labels[i];
          val = lbFormatter(val, i);
          var xPad = w.config.yaxis[realIndex].labels.padding;

          if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) {
            xPad = xPad * -1;
          }

          var label = graphics.drawText({
            x: xPad,
            y: l + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY + 1,
            text: val,
            textAnchor: w.config.yaxis[realIndex].opposite ? 'start' : 'end',
            fontSize: yaxisFontSize,
            fontFamily: yaxisFontFamily,
            foreColor: w.config.yaxis[realIndex].labels.style.color,
            cssClass: 'apexcharts-yaxis-label ' + w.config.yaxis[realIndex].labels.style.cssClass
          });
          elYaxisTexts.add(label);
          var labelRotatingCenter = graphics.rotateAroundCenter(label.node);

          if (w.config.yaxis[realIndex].labels.rotate !== 0) {
            label.node.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].labels.rotate, " ").concat(labelRotatingCenter.x, " ").concat(labelRotatingCenter.y, ")"));
          }

          l = l + labelsDivider;
        }
      }

      if (w.config.yaxis[realIndex].title.text !== undefined) {
        var elYaxisTitle = graphics.group({
          class: 'apexcharts-yaxis-title'
        });
        var x = 0;

        if (w.config.yaxis[realIndex].opposite) {
          x = w.globals.translateYAxisX[realIndex];
        }

        var elYAxisTitleText = graphics.drawText({
          x: x,
          y: w.globals.gridHeight / 2 + w.globals.translateY,
          text: w.config.yaxis[realIndex].title.text,
          textAnchor: 'end',
          foreColor: w.config.yaxis[realIndex].title.style.color,
          fontSize: w.config.yaxis[realIndex].title.style.fontSize,
          fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,
          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[realIndex].title.style.cssClass
        });
        elYaxisTitle.add(elYAxisTitleText);
        elYaxis.add(elYaxisTitle);
      }

      var axisBorder = w.config.yaxis[realIndex].axisBorder;

      if (axisBorder.show) {
        var _x = 31 + axisBorder.offsetX;

        if (w.config.yaxis[realIndex].opposite) {
          _x = -31 - axisBorder.offsetX;
        }

        var elVerticalLine = graphics.drawLine(_x, w.globals.translateY + axisBorder.offsetY - 2, _x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color);
        elYaxis.add(elVerticalLine);
        this.axesUtils.drawYAxisTicks(_x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);
      }

      return elYaxis;
    } // This actually becomes horizonal axis (for bar charts)

  }, {
    key: "drawYaxisInversed",
    value: function drawYaxisInversed(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var elXaxis = graphics.group({
        class: 'apexcharts-xaxis apexcharts-yaxis-inversed'
      });
      var elXaxisTexts = graphics.group({
        class: 'apexcharts-xaxis-texts-g',
        transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
      });
      elXaxis.add(elXaxisTexts);
      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg width/number of ticks

      var labelsDivider = w.globals.gridWidth / tickAmount + 0.1; // initial label position;

      var l = labelsDivider + w.config.xaxis.labels.offsetX;
      var lbFormatter = w.globals.xLabelFormatter;
      var labels = w.globals.yAxisScale[realIndex].result.slice();
      var timelineLabels = w.globals.invertedTimelineLabels;

      if (timelineLabels.length > 0) {
        this.xaxisLabels = timelineLabels.slice();
        labels = timelineLabels.slice();
        tickAmount = labels.length;
      }

      if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].reversed) {
        labels.reverse();
      }

      var tl = timelineLabels.length;

      if (w.config.xaxis.labels.show) {
        for (var i = tl ? 0 : tickAmount; tl ? i < tl - 1 : i >= 0; tl ? i++ : i--) {
          var val = labels[i];
          val = lbFormatter(val, i);
          var x = w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX);

          if (timelineLabels.length) {
            var label = this.axesUtils.getLabel(labels, timelineLabels, x, i, this.drawnLabels);
            x = label.x;
            val = label.text;
            this.drawnLabels.push(label.text);
          }

          var elTick = graphics.drawText({
            x: x,
            y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30,
            text: '',
            textAnchor: 'middle',
            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,
            fontSize: this.xaxisFontSize,
            fontFamily: this.xaxisFontFamily,
            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass
          });
          elXaxisTexts.add(elTick);
          elTick.tspan(val);
          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
          elTooltipTitle.textContent = val;
          elTick.node.appendChild(elTooltipTitle);
          l = l + labelsDivider;
        }
      }

      if (w.config.xaxis.title.text !== undefined) {
        var elYaxisTitle = graphics.group({
          class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'
        });
        var elYAxisTitleText = graphics.drawText({
          x: w.globals.gridWidth / 2,
          y: this.xAxisoffX + parseInt(this.xaxisFontSize) + parseInt(w.config.xaxis.title.style.fontSize) + 20,
          text: w.config.xaxis.title.text,
          textAnchor: 'middle',
          fontSize: w.config.xaxis.title.style.fontSize,
          fontFamily: w.config.xaxis.title.style.fontFamily,
          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass
        });
        elYaxisTitle.add(elYAxisTitleText);
        elXaxis.add(elYaxisTitle);
      }

      var axisBorder = w.config.yaxis[realIndex].axisBorder;

      if (axisBorder.show) {
        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color);
        elXaxis.add(elVerticalLine);
      }

      return elXaxis;
    }
  }, {
    key: "yAxisTitleRotate",
    value: function yAxisTitleRotate(realIndex, yAxisOpposite) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var yAxisLabelsCoord = {
        width: 0,
        height: 0
      };
      var yAxisTitleCoord = {
        width: 0,
        height: 0
      };
      var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-texts-g"));

      if (elYAxisLabelsWrap !== null) {
        yAxisLabelsCoord = elYAxisLabelsWrap.getBoundingClientRect();
      }

      var yAxisTitle = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-title text"));

      if (yAxisTitle !== null) {
        yAxisTitleCoord = yAxisTitle.getBoundingClientRect();
      }

      if (yAxisTitle !== null) {
        var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);
        yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));
      }

      if (yAxisTitle !== null) {
        var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);

        if (!yAxisOpposite) {
          yAxisTitle.setAttribute('transform', "rotate(-".concat(w.config.yaxis[realIndex].title.rotate, " ").concat(titleRotatingCenter.x, " ").concat(titleRotatingCenter.y, ")"));
        } else {
          yAxisTitle.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].title.rotate, " ").concat(titleRotatingCenter.x, " ").concat(titleRotatingCenter.y, ")"));
        }
      }
    }
  }, {
    key: "xPaddingForYAxisTitle",
    value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {
      var w = this.w;
      var oppositeAxisCount = 0;
      var x = 0;
      var padd = 10;

      if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {
        return {
          xPos: x,
          padd: 0
        };
      }

      if (yAxisOpposite) {
        x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;
        oppositeAxisCount += 1;

        if (oppositeAxisCount === 0) {
          x = x - padd / 2;
        }
      } else {
        x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;

        if (w.globals.isBarHorizontal) {
          padd = 25;
          x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;
        }
      }

      return {
        xPos: x,
        padd: padd
      };
    } // sets the x position of the y-axis by counting the labels width, title width and any offset

  }, {
    key: "setYAxisXPosition",
    value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {
      var w = this.w;
      var xLeft = 0;
      var xRight = 0;
      var leftOffsetX = 21;
      var rightOffsetX = 1;

      if (w.config.yaxis.length > 1) {
        this.multipleYs = true;
      }

      w.config.yaxis.map(function (yaxe, index) {
        var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.indexOf(index) > -1 || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;
        var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;

        if (!yaxe.opposite) {
          xLeft = w.globals.translateX - leftOffsetX;

          if (!shouldNotDrawAxis) {
            leftOffsetX = leftOffsetX + axisWidth + 20;
          }

          w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;
        } else {
          if (w.globals.isBarHorizontal) {
            xRight = w.globals.gridWidth + w.globals.translateX - 1;
            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;
          } else {
            xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;

            if (!shouldNotDrawAxis) {
              rightOffsetX = rightOffsetX + axisWidth + 20;
            }

            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;
          }
        }
      });
    }
  }, {
    key: "setYAxisTextAlignments",
    value: function setYAxisTextAlignments() {
      var w = this.w;
      var yaxis = w.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis");
      yaxis = Utils.listToArray(yaxis);
      yaxis.forEach(function (y, index) {
        var yaxe = w.config.yaxis[index]; // proceed only if user has specified alignment

        if (yaxe.labels.align !== undefined) {
          var yAxisInner = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(index, "'] .apexcharts-yaxis-texts-g"));
          var yAxisTexts = w.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(index, "'] .apexcharts-yaxis-label"));
          yAxisTexts = Utils.listToArray(yAxisTexts);
          var rect = yAxisInner.getBoundingClientRect();

          if (yaxe.labels.align === 'left') {
            yAxisTexts.forEach(function (label, lI) {
              label.setAttribute('text-anchor', 'start');
            });

            if (!yaxe.opposite) {
              yAxisInner.setAttribute('transform', "translate(-".concat(rect.width, ", 0)"));
            }
          } else if (yaxe.labels.align === 'center') {
            yAxisTexts.forEach(function (label, lI) {
              label.setAttribute('text-anchor', 'middle');
            });
            yAxisInner.setAttribute('transform', "translate(".concat(rect.width / 2 * (!yaxe.opposite ? -1 : 1), ", 0)"));
          } else if (yaxe.labels.align === 'right') {
            yAxisTexts.forEach(function (label, lI) {
              label.setAttribute('text-anchor', 'end');
            });

            if (yaxe.opposite) {
              yAxisInner.setAttribute('transform', "translate(".concat(rect.width, ", 0)"));
            }
          }
        }
      });
    }
  }]);

  return YAxis;
}();

/**
 * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.
 *
 * @module Dimensions
 **/

var Dimensions =
/*#__PURE__*/
function () {
  function Dimensions(ctx) {
    _classCallCheck(this, Dimensions);

    this.ctx = ctx;
    this.w = ctx.w;
    this.lgRect = {};
    this.yAxisWidth = 0;
    this.xAxisHeight = 0;
    this.isSparkline = this.w.config.chart.sparkline.enabled;
    this.xPadRight = 0;
    this.xPadLeft = 0;
  }
  /**
   * @memberof Dimensions
   * @param {object} w - chart context
   **/


  _createClass(Dimensions, [{
    key: "plotCoords",
    value: function plotCoords() {
      var w = this.w;
      var gl = w.globals;
      var lgRect = this.getLegendsRect();

      if (gl.axisCharts) {
        // for line / area / scatter / column
        this.setGridCoordsForAxisCharts(lgRect);
      } else {
        // for pie / donuts / circle
        this.setGridCoordsForNonAxisCharts(lgRect);
      }

      this.titleSubtitleOffset(); // after calculating everything, apply padding set by user

      gl.gridHeight = gl.gridHeight - w.config.grid.padding.top - w.config.grid.padding.bottom;
      gl.gridWidth = gl.gridWidth - w.config.grid.padding.left - w.config.grid.padding.right - this.xPadRight - this.xPadLeft;
      gl.translateX = gl.translateX + w.config.grid.padding.left + this.xPadLeft;
      gl.translateY = gl.translateY + w.config.grid.padding.top;
    }
  }, {
    key: "conditionalChecksForAxisCoords",
    value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords) {
      var w = this.w;
      this.xAxisHeight = (xaxisLabelCoords.height + xtitleCoords.height) * w.globals.LINE_HEIGHT_RATIO + 15;
      this.xAxisWidth = xaxisLabelCoords.width;

      if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {
        this.xAxisHeight = w.config.xaxis.labels.maxHeight;
      }

      if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {
        this.xAxisHeight = w.config.xaxis.labels.minHeight;
      }

      if (w.config.xaxis.floating) {
        this.xAxisHeight = 0;
      }

      if (!w.globals.isBarHorizontal) {
        this.yAxisWidth = this.getTotalYAxisWidth();
      } else {
        this.yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;
      }

      var minYAxisWidth = 0;
      var maxYAxisWidth = 0;
      w.config.yaxis.forEach(function (y) {
        minYAxisWidth += y.labels.minWidth;
        maxYAxisWidth += y.labels.maxWidth;
      });

      if (this.yAxisWidth < minYAxisWidth) {
        this.yAxisWidth = minYAxisWidth;
      }

      if (this.yAxisWidth > maxYAxisWidth) {
        this.yAxisWidth = maxYAxisWidth;
      }
    }
  }, {
    key: "setGridCoordsForAxisCharts",
    value: function setGridCoordsForAxisCharts(lgRect) {
      var w = this.w;
      var gl = w.globals;
      var yaxisLabelCoords = this.getyAxisLabelsCoords();
      var xaxisLabelCoords = this.getxAxisLabelsCoords();
      var yTitleCoords = this.getyAxisTitleCoords();
      var xtitleCoords = this.getxAxisTitleCoords();
      w.globals.yLabelsCoords = [];
      w.globals.yTitleCoords = [];
      w.config.yaxis.map(function (yaxe, index) {
        // store the labels and titles coords in global vars
        w.globals.yLabelsCoords.push({
          width: yaxisLabelCoords[index].width,
          index: index
        });
        w.globals.yTitleCoords.push({
          width: yTitleCoords[index].width,
          index: index
        });
      });
      this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords);
      gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;
      gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;

      if (w.globals.isBarHorizontal) {
        gl.rotateXLabels = false;
        gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize) / 1.5);
      }

      gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;
      gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;
      var yAxisWidth = this.yAxisWidth;
      var xAxisHeight = this.xAxisHeight;
      gl.xAxisLabelsHeight = this.xAxisHeight;
      gl.xAxisHeight = this.xAxisHeight;
      var translateY = 10;

      if (!w.config.grid.show || w.config.chart.type === 'radar') {
        yAxisWidth = 0;
        xAxisHeight = 35;
      }

      if (this.isSparkline) {
        lgRect = {
          height: 0,
          width: 0
        };
        xAxisHeight = 0;
        yAxisWidth = 0;
        translateY = 0;
      }

      this.additionalPaddingXLabels(xaxisLabelCoords);

      switch (w.config.legend.position) {
        case 'bottom':
          gl.translateY = translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);
          gl.gridWidth = gl.svgWidth - yAxisWidth;
          break;

        case 'top':
          gl.translateY = lgRect.height + translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);
          gl.gridWidth = gl.svgWidth - yAxisWidth;
          break;

        case 'left':
          gl.translateY = translateY;
          gl.translateX = lgRect.width + yAxisWidth;
          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth;
          break;

        case 'right':
          gl.translateY = translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth - 5;
          break;

        default:
          throw new Error('Legend position not supported');
      }

      this.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords); // after drawing everything, set the Y axis positions

      var objyAxis = new YAxis(this.ctx);
      objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);
    }
  }, {
    key: "setGridCoordsForNonAxisCharts",
    value: function setGridCoordsForNonAxisCharts(lgRect) {
      var w = this.w;
      var gl = w.globals;
      var xPad = 0;

      if (w.config.legend.show && !w.config.legend.floating) {
        xPad = 20;
      }

      var offY = 10;
      var offX = 0;

      if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {
        offY = offY + w.config.plotOptions.pie.offsetY;
        offX = offX + w.config.plotOptions.pie.offsetX;
      } else if (w.config.chart.type === 'radialBar') {
        offY = offY + w.config.plotOptions.radialBar.offsetY;
        offX = offX + w.config.plotOptions.radialBar.offsetX;
      }

      if (!w.config.legend.show) {
        gl.gridHeight = gl.svgHeight - 35;
        gl.gridWidth = gl.gridHeight;
        gl.translateY = offY - 10;
        gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
        return;
      }

      switch (w.config.legend.position) {
        case 'bottom':
          gl.gridHeight = gl.svgHeight - lgRect.height - 35;
          gl.gridWidth = gl.gridHeight;
          gl.translateY = offY - 20;
          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
          break;

        case 'top':
          gl.gridHeight = gl.svgHeight - lgRect.height - 35;
          gl.gridWidth = gl.gridHeight;
          gl.translateY = lgRect.height + offY + 10;
          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
          break;

        case 'left':
          gl.gridWidth = gl.svgWidth - lgRect.width - xPad;
          gl.gridHeight = gl.gridWidth;
          gl.translateY = offY;
          gl.translateX = offX + lgRect.width + xPad;
          break;

        case 'right':
          gl.gridWidth = gl.svgWidth - lgRect.width - xPad - 5;
          gl.gridHeight = gl.gridWidth;
          gl.translateY = offY;
          gl.translateX = offX + 10;
          break;

        default:
          throw new Error('Legend position not supported');
      }
    }
  }, {
    key: "setGridXPosForDualYAxis",
    value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {
      var w = this.w;
      w.config.yaxis.map(function (yaxe, index) {
        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !w.config.yaxis[index].floating && w.config.yaxis[index].show) {
          if (yaxe.opposite) {
            w.globals.translateX = w.globals.translateX - (yaxisLabelCoords[index].width + yTitleCoords[index].width) - parseInt(w.config.yaxis[index].labels.style.fontSize) / 1.2 - 12;
          }
        }
      });
    } // Sometimes, the last labels gets cropped in category/numeric xaxis.
    // Hence, we add some additional padding based on the label length to avoid the last label being cropped.
    // NOTE: datetime x-axis won't have any effect with this as we don't know the label length there due to many constraints.

  }, {
    key: "additionalPaddingXLabels",
    value: function additionalPaddingXLabels(xaxisLabelCoords) {
      var _this = this;

      var w = this.w;

      if (w.config.xaxis.type === 'category' && w.globals.isBarHorizontal || w.config.xaxis.type === 'numeric' || w.config.xaxis.type === 'datetime') {
        var rightPad = function rightPad(labels) {
          if (_this.timescaleLabels) {
            // for timeline labels, we take the last label and check if it exceeds gridWidth
            var lastTimescaleLabel = _this.timescaleLabels[_this.timescaleLabels.length - 1];
            var labelPosition = lastTimescaleLabel.position + labels.width;

            if (labelPosition > w.globals.gridWidth) {
              w.globals.skipLastTimelinelabel = true;
            } else {
              // we have to make it false again in case of zooming/panning
              w.globals.skipLastTimelinelabel = false;
            }
          } else if (w.config.xaxis.type === 'datetime') {
            if (w.config.grid.padding.right < labels.width) {
              w.globals.skipLastTimelinelabel = true;
            }
          } else if (w.config.xaxis.type !== 'datetime') {
            if (w.config.grid.padding.right < labels.width) {
              _this.xPadRight = labels.width / 2 + 1;
            }
          }
        };

        var leftPad = function leftPad(labels) {
          if (w.config.grid.padding.left < labels.width) {
            _this.xPadLeft = labels.width / 2 + 1;
          }
        };

        var isXNumeric = w.globals.isXNumeric;
        w.config.yaxis.forEach(function (yaxe, i) {
          var shouldPad = !yaxe.show || yaxe.floating || w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || isXNumeric || yaxe.opposite && w.globals.isBarHorizontal;

          if (shouldPad) {
            if (isXNumeric && w.globals.isMultipleYAxis && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || w.globals.isBarHorizontal && yaxe.opposite) {
              leftPad(xaxisLabelCoords);
            }

            if (!w.globals.isBarHorizontal && yaxe.opposite && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || isXNumeric && !w.globals.isMultipleYAxis) {
              rightPad(xaxisLabelCoords);
            }
          }
        });
      }
    }
  }, {
    key: "titleSubtitleOffset",
    value: function titleSubtitleOffset() {
      var w = this.w;
      var gl = w.globals;
      var gridShrinkOffset = this.isSparkline || !w.globals.axisCharts ? 0 : 10;

      if (w.config.title.text !== undefined) {
        gridShrinkOffset += w.config.title.margin;
      } else {
        gridShrinkOffset += this.isSparkline || !w.globals.axisCharts ? 0 : 5;
      }

      if (w.config.subtitle.text !== undefined) {
        gridShrinkOffset += w.config.subtitle.margin;
      } else {
        gridShrinkOffset += this.isSparkline || !w.globals.axisCharts ? 0 : 5;
      }

      if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && (w.config.series.length > 1 || !w.globals.axisCharts || w.config.legend.showForSingleSeries)) {
        gridShrinkOffset += 10;
      }

      var titleCoords = this.getTitleSubtitleCoords('title');
      var subtitleCoords = this.getTitleSubtitleCoords('subtitle');
      gl.gridHeight = gl.gridHeight - titleCoords.height - subtitleCoords.height - gridShrinkOffset;
      gl.translateY = gl.translateY + titleCoords.height + subtitleCoords.height + gridShrinkOffset;
    }
  }, {
    key: "getTotalYAxisWidth",
    value: function getTotalYAxisWidth() {
      var w = this.w;
      var yAxisWidth = 0;
      var padding = 10;

      var isHiddenYAxis = function isHiddenYAxis(index) {
        return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;
      };

      w.globals.yLabelsCoords.map(function (yLabelCoord, index) {
        var floating = w.config.yaxis[index].floating;

        if (yLabelCoord.width > 0 && !floating) {
          yAxisWidth = yAxisWidth + yLabelCoord.width + padding;

          if (isHiddenYAxis(index)) {
            yAxisWidth = yAxisWidth - yLabelCoord.width - padding;
          }
        } else {
          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);
        }
      });
      w.globals.yTitleCoords.map(function (yTitleCoord, index) {
        var floating = w.config.yaxis[index].floating;
        padding = parseInt(w.config.yaxis[index].title.style.fontSize);

        if (yTitleCoord.width > 0 && !floating) {
          yAxisWidth = yAxisWidth + yTitleCoord.width + padding;

          if (isHiddenYAxis(index)) {
            yAxisWidth = yAxisWidth - yTitleCoord.width - padding;
          }
        } else {
          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);
        }
      });
      return yAxisWidth;
    }
  }, {
    key: "getxAxisTimeScaleLabelsCoords",
    value: function getxAxisTimeScaleLabelsCoords() {
      var w = this.w;
      var rect;
      this.timescaleLabels = w.globals.timelineLabels.slice();

      if (w.globals.isBarHorizontal && w.config.xaxis.type === 'datetime') {
        this.timescaleLabels = w.globals.invertedTimelineLabels.slice();
      }

      var labels = this.timescaleLabels.map(function (label) {
        return label.value;
      }); //  get the longest string from the labels array and also apply label formatter to it

      var val = labels.reduce(function (a, b) {
        // if undefined, maybe user didn't pass the datetime(x) values
        if (typeof a === 'undefined') {
          console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');
          return 0;
        } else {
          return a.length > b.length ? a : b;
        }
      }, 0);
      var graphics = new Graphics(this.ctx);
      rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
      var totalWidthRotated = rect.width * 1.05 * labels.length;

      if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {
        w.globals.overlappingXLabels = true;
      }

      return rect;
    }
    /**
     * Get X Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getxAxisLabelsCoords",
    value: function getxAxisLabelsCoords() {
      var w = this.w;
      var xaxisLabels = w.globals.labels.slice();
      var rect;

      if (w.globals.timelineLabels.length > 0) {
        var coords = this.getxAxisTimeScaleLabelsCoords();
        rect = {
          width: coords.width,
          height: coords.height
        };
      } else {
        var lgWidthForSideLegends = w.config.legend.position === 'left' && w.config.legend.position === 'right' && !w.config.legend.floating ? this.lgRect.width : 0; // get the longest string from the labels array and also apply label formatter

        var xlbFormatter = w.globals.xLabelFormatter; // prevent changing xaxisLabels to avoid issues in multi-yaxies - fix #522

        var val = xaxisLabels.reduce(function (a, b) {
          return a.length > b.length ? a : b;
        }, 0); // the labels gets changed for bar charts

        if (w.globals.isBarHorizontal) {
          val = w.globals.yAxisScale[0].result.reduce(function (a, b) {
            return a.length > b.length ? a : b;
          }, 0);
        }

        var xFormat = new Formatters(this.ctx);
        var timestamp = val;
        val = xFormat.xLabelFormat(xlbFormatter, val, timestamp);
        var graphics = new Graphics(this.ctx);
        var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
        rect = {
          width: xLabelrect.width,
          height: xLabelrect.height
        };

        if (rect.width * xaxisLabels.length > w.globals.svgWidth - lgWidthForSideLegends - this.yAxisWidth && w.config.xaxis.labels.rotate !== 0) {
          if (!w.globals.isBarHorizontal) {
            w.globals.rotateXLabels = true;
            xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, "rotate(".concat(w.config.xaxis.labels.rotate, " 0 0)"), false);
            rect.height = xLabelrect.height / 1.66;
          }
        } else {
          w.globals.rotateXLabels = false;
        }
      }

      if (!w.config.xaxis.labels.show) {
        rect = {
          width: 0,
          height: 0
        };
      }

      return {
        width: rect.width,
        height: rect.height
      };
    }
    /**
     * Get Y Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getyAxisLabelsCoords",
    value: function getyAxisLabelsCoords() {
      var _this2 = this;

      var w = this.w;
      var width = 0;
      var height = 0;
      var ret = [];
      var labelPad = 10;
      w.config.yaxis.map(function (yaxe, index) {
        if (yaxe.show && yaxe.labels.show && w.globals.yAxisScale[index].result.length) {
          var lbFormatter = w.globals.yLabelFormatters[index]; // the second parameter -1 is the index of tick which user can use in the formatter

          var val = lbFormatter(w.globals.yAxisScale[index].niceMax, -1); // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.

          if (typeof val === 'undefined' || val.length === 0) {
            val = w.globals.yAxisScale[index].niceMax;
          }

          if (w.globals.isBarHorizontal) {
            labelPad = 0;
            var barYaxisLabels = w.globals.labels.slice(); //  get the longest string from the labels array and also apply label formatter to it

            val = barYaxisLabels.reduce(function (a, b) {
              return a.length > b.length ? a : b;
            }, 0);
            val = lbFormatter(val, -1);
          }

          var graphics = new Graphics(_this2.ctx);
          var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize);
          ret.push({
            width: rect.width + labelPad,
            height: rect.height
          });
        } else {
          ret.push({
            width: width,
            height: height
          });
        }
      });
      return ret;
    }
    /**
     * Get X Axis Title Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getxAxisTitleCoords",
    value: function getxAxisTitleCoords() {
      var w = this.w;
      var width = 0;
      var height = 0;

      if (w.config.xaxis.title.text !== undefined) {
        var graphics = new Graphics(this.ctx);
        var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);
        width = rect.width;
        height = rect.height;
      }

      return {
        width: width,
        height: height
      };
    }
    /**
     * Get Y Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getyAxisTitleCoords",
    value: function getyAxisTitleCoords() {
      var _this3 = this;

      var w = this.w;
      var ret = [];
      w.config.yaxis.map(function (yaxe, index) {
        if (yaxe.show && yaxe.title.text !== undefined) {
          var graphics = new Graphics(_this3.ctx);
          var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, 'rotate(-90 0 0)', false);
          ret.push({
            width: rect.width,
            height: rect.height
          });
        } else {
          ret.push({
            width: 0,
            height: 0
          });
        }
      });
      return ret;
    }
    /**
     * Get Chart Title/Subtitle Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getTitleSubtitleCoords",
    value: function getTitleSubtitleCoords(type) {
      var w = this.w;
      var width = 0;
      var height = 0;
      var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;
      var el = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-text"));

      if (el !== null && !floating) {
        var coord = el.getBoundingClientRect();
        width = coord.width;
        height = w.globals.axisCharts ? coord.height + 5 : coord.height;
      }

      return {
        width: width,
        height: height
      };
    }
  }, {
    key: "getLegendsRect",
    value: function getLegendsRect() {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var lgRect = Object.assign({}, Utils.getBoundingClientRect(elLegendWrap));

      if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {
        this.lgRect = {
          x: lgRect.x,
          y: lgRect.y,
          height: lgRect.height,
          width: lgRect.height === 0 ? 0 : lgRect.width
        };
      } else {
        this.lgRect = {
          x: 0,
          y: 0,
          height: 0,
          width: 0
        };
      }

      return this.lgRect;
    }
  }]);

  return Dimensions;
}();

/**
 * ApexCharts Series Class for interation with the Series of the chart.
 *
 * @module Series
 **/

var Series =
/*#__PURE__*/
function () {
  function Series(ctx) {
    _classCallCheck(this, Series);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Series, [{
    key: "getAllSeriesEls",
    value: function getAllSeriesEls() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    }
  }, {
    key: "getSeriesByName",
    value: function getSeriesByName(seriesName) {
      return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(Utils.escapeString(seriesName), "']"));
    }
  }, {
    key: "addCollapsedClassToSeries",
    value: function addCollapsedClassToSeries(elSeries, index) {
      var w = this.w;

      function iterateOnAllCollapsedSeries(series) {
        for (var cs = 0; cs < series.length; cs++) {
          if (series[cs].index === index) {
            elSeries.node.classList.add('apexcharts-series-collapsed');
          }
        }
      }

      iterateOnAllCollapsedSeries(w.globals.collapsedSeries);
      iterateOnAllCollapsedSeries(w.globals.ancillaryCollapsedSeries);
    }
  }, {
    key: "resetSeries",
    value: function resetSeries() {
      var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var w = this.w;
      var series = w.globals.initialSeries.slice();
      w.config.series = series;
      w.globals.collapsedSeries = [];
      w.globals.ancillaryCollapsedSeries = [];
      w.globals.collapsedSeriesIndices = [];
      w.globals.ancillaryCollapsedSeriesIndices = [];
      w.globals.previousPaths = [];

      if (shouldUpdateChart) {
        this.ctx._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);
      }
    }
  }, {
    key: "toggleSeriesOnHover",
    value: function toggleSeriesOnHover(e, targetElement) {
      var w = this.w;
      var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series");

      if (e.type === 'mousemove') {
        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;
        var seriesEl = null;

        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
          if (w.globals.axisCharts) {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesCnt, "']"));
          } else {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "']"));
          }
        } else {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "'] path"));
        }

        for (var se = 0; se < allSeriesEls.length; se++) {
          allSeriesEls[se].classList.add('legend-mouseover-inactive');
        }

        if (seriesEl !== null) {
          if (!w.globals.axisCharts) {
            seriesEl.parentNode.classList.remove('legend-mouseover-inactive');
          }

          seriesEl.classList.remove('legend-mouseover-inactive');
        }
      } else if (e.type === 'mouseout') {
        for (var _se = 0; _se < allSeriesEls.length; _se++) {
          allSeriesEls[_se].classList.remove('legend-mouseover-inactive');
        }
      }
    }
  }, {
    key: "highlightRangeInSeries",
    value: function highlightRangeInSeries(e, targetElement) {
      var w = this.w;
      var allHeatMapElements = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect');

      var allActive = function allActive() {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          allHeatMapElements[i].classList.remove('legend-mouseover-inactive');
        }
      };

      var allInactive = function allInactive() {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          allHeatMapElements[i].classList.add('legend-mouseover-inactive');
        }
      };

      var selectedActive = function selectedActive(range) {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          var val = parseInt(allHeatMapElements[i].getAttribute('val'));

          if (val >= range.from && val <= range.to) {
            allHeatMapElements[i].classList.remove('legend-mouseover-inactive');
          }
        }
      };

      if (e.type === 'mousemove') {
        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;
        allActive();
        allInactive();
        var range = w.config.plotOptions.heatmap.colorScale.ranges[seriesCnt];
        selectedActive(range);
      } else if (e.type === 'mouseout') {
        allActive();
      }
    }
  }, {
    key: "getActiveSeriesIndex",
    value: function getActiveSeriesIndex() {
      var w = this.w;
      var activeIndex = 0;

      if (w.globals.series.length > 1) {
        // active series flag is required to know if user has not deactivated via legend click
        var firstActiveSeriesIndex = w.globals.series.map(function (series, index) {
          if (series.length > 0 && w.config.series[index].type !== 'bar' && w.config.series[index].type !== 'column') {
            return index;
          } else {
            return -1;
          }
        });

        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
          if (firstActiveSeriesIndex[a] !== -1) {
            activeIndex = firstActiveSeriesIndex[a];
            break;
          }
        }
      }

      return activeIndex;
    }
  }, {
    key: "getActiveConfigSeriesIndex",
    value: function getActiveConfigSeriesIndex() {
      var w = this.w;
      var activeIndex = 0;

      if (w.config.series.length > 1) {
        // active series flag is required to know if user has not deactivated via legend click
        var firstActiveSeriesIndex = w.config.series.map(function (series, index) {
          if (series.data && series.data.length > 0) {
            return index;
          } else {
            return -1;
          }
        });

        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
          if (firstActiveSeriesIndex[a] !== -1) {
            activeIndex = firstActiveSeriesIndex[a];
            break;
          }
        }
      }

      return activeIndex;
    }
  }, {
    key: "getPreviousPaths",
    value: function getPreviousPaths() {
      var w = this.w;
      w.globals.previousPaths = [];

      function pushPaths(seriesEls, i, type) {
        var paths = seriesEls[i].childNodes;
        var dArr = {
          type: type,
          paths: [],
          realIndex: seriesEls[i].getAttribute('data:realIndex')
        };

        for (var j = 0; j < paths.length; j++) {
          if (paths[j].hasAttribute('pathTo')) {
            var d = paths[j].getAttribute('pathTo');
            dArr.paths.push({
              d: d
            });
          }
        }

        w.globals.previousPaths.push(dArr);
      }

      var linePaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-series');

      if (linePaths.length > 0) {
        for (var p = linePaths.length - 1; p >= 0; p--) {
          pushPaths(linePaths, p, 'line');
        }
      }

      var areapaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-series');

      if (areapaths.length > 0) {
        for (var i = areapaths.length - 1; i >= 0; i--) {
          pushPaths(areapaths, i, 'area');
        }
      }

      var barPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series .apexcharts-series');

      if (barPaths.length > 0) {
        for (var _p = 0; _p < barPaths.length; _p++) {
          pushPaths(barPaths, _p, 'bar');
        }
      }

      var candlestickPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-candlestick-series .apexcharts-series');

      if (candlestickPaths.length > 0) {
        for (var _p2 = 0; _p2 < candlestickPaths.length; _p2++) {
          pushPaths(candlestickPaths, _p2, 'candlestick');
        }
      }

      var radarPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-radar-series .apexcharts-series');

      if (radarPaths.length > 0) {
        for (var _p3 = 0; _p3 < radarPaths.length; _p3++) {
          pushPaths(radarPaths, _p3, 'radar');
        }
      }

      var bubblepaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bubble-series .apexcharts-series');

      if (bubblepaths.length > 0) {
        for (var s = 0; s < bubblepaths.length; s++) {
          var seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-bubble-series .apexcharts-series[data\\:realIndex='".concat(s, "'] circle"));
          var dArr = [];

          for (var _i = 0; _i < seriesEls.length; _i++) {
            dArr.push({
              x: seriesEls[_i].getAttribute('cx'),
              y: seriesEls[_i].getAttribute('cy'),
              r: seriesEls[_i].getAttribute('r')
            });
          }

          w.globals.previousPaths.push(dArr);
        }
      }

      var scatterpaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-scatter-series .apexcharts-series');

      if (scatterpaths.length > 0) {
        for (var _s = 0; _s < scatterpaths.length; _s++) {
          var _seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-scatter-series .apexcharts-series[data\\:realIndex='".concat(_s, "'] circle"));

          var _dArr = [];

          for (var _i2 = 0; _i2 < _seriesEls.length; _i2++) {
            _dArr.push({
              x: _seriesEls[_i2].getAttribute('cx'),
              y: _seriesEls[_i2].getAttribute('cy'),
              r: _seriesEls[_i2].getAttribute('r')
            });
          }

          w.globals.previousPaths.push(_dArr);
        }
      }

      var heatmapColors = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series');

      if (heatmapColors.length > 0) {
        for (var h = 0; h < heatmapColors.length; h++) {
          var _seriesEls2 = w.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(h, "'] rect"));

          var _dArr2 = [];

          for (var _i3 = 0; _i3 < _seriesEls2.length; _i3++) {
            _dArr2.push({
              color: _seriesEls2[_i3].getAttribute('color')
            });
          }

          w.globals.previousPaths.push(_dArr2);
        }
      }

      if (!w.globals.axisCharts) {
        // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)
        w.globals.previousPaths = w.globals.series;
      }
    }
  }, {
    key: "handleNoData",
    value: function handleNoData() {
      var w = this.w;
      var me = this;
      var noDataOpts = w.config.noData;
      var graphics = new Graphics(me.ctx);
      var x = w.globals.svgWidth / 2;
      var y = w.globals.svgHeight / 2;
      var textAnchor = 'middle';
      w.globals.noData = true;
      w.globals.animationEnded = true;

      if (noDataOpts.align === 'left') {
        x = 10;
        textAnchor = 'start';
      } else if (noDataOpts.align === 'right') {
        x = w.globals.svgWidth - 10;
        textAnchor = 'end';
      }

      if (noDataOpts.verticalAlign === 'top') {
        y = 50;
      } else if (noDataOpts.verticalAlign === 'bottom') {
        y = w.globals.svgHeight - 50;
      }

      x = x + noDataOpts.offsetX;
      y = y + parseInt(noDataOpts.style.fontSize) + 2;

      if (noDataOpts.text !== undefined && noDataOpts.text !== '') {
        var titleText = graphics.drawText({
          x: x,
          y: y,
          text: noDataOpts.text,
          textAnchor: textAnchor,
          fontSize: noDataOpts.style.fontSize,
          fontFamily: noDataOpts.style.fontFamily,
          foreColor: noDataOpts.style.color,
          opacity: 1,
          class: 'apexcharts-text-nodata'
        });
        titleText.node.setAttribute('class', 'apexcharts-title-text');
        w.globals.dom.Paper.add(titleText);
      }
    } // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]
    // This is because we don't want to alter the series' length as it is used at many places

  }, {
    key: "setNullSeriesToZeroValues",
    value: function setNullSeriesToZeroValues(series) {
      var w = this.w;

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length === 0) {
          for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {
            series[sl].push(0);
          }
        }
      }

      return series;
    }
  }, {
    key: "hasAllSeriesEqualX",
    value: function hasAllSeriesEqualX() {
      var equalLen = true;
      var w = this.w;
      var filteredSerX = this.filteredSeriesX();

      for (var i = 0; i < filteredSerX.length - 1; i++) {
        if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {
          equalLen = false;
          break;
        }
      }

      w.globals.allSeriesHasEqualX = equalLen;
      return equalLen;
    }
  }, {
    key: "filteredSeriesX",
    value: function filteredSeriesX() {
      var w = this.w;
      var filteredSeriesX = w.globals.seriesX.map(function (ser, index) {
        if (ser.length > 0) {
          return ser;
        } else {
          return [];
        }
      });
      return filteredSeriesX;
    }
  }]);

  return Series;
}();

/**
 * ApexCharts Legend Class to draw legend.
 *
 * @module Legend
 **/

var Legend =
/*#__PURE__*/
function () {
  function Legend(ctx, opts) {
    _classCallCheck(this, Legend);

    this.ctx = ctx;
    this.w = ctx.w;
    this.onLegendClick = this.onLegendClick.bind(this);
    this.onLegendHovered = this.onLegendHovered.bind(this);
  }

  _createClass(Legend, [{
    key: "init",
    value: function init() {
      var w = this.w;
      var gl = w.globals;
      var cnf = w.config;
      var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || gl.series.length > 1;

      if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {
        while (gl.dom.elLegendWrap.firstChild) {
          gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);
        }

        this.drawLegends();

        if (!Utils.isIE11()) {
          this.appendToForeignObject();
        } else {
          // IE11 doesn't supports foreignObject, hence append it to <head>
          document.getElementsByTagName('head')[0].appendChild(this.getLegendStyles());
        }

        if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {
          this.legendAlignHorizontal();
        } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {
          this.legendAlignVertical();
        }
      }
    }
  }, {
    key: "appendToForeignObject",
    value: function appendToForeignObject() {
      var gl = this.w.globals;
      gl.dom.elLegendForeign = document.createElementNS(gl.SVGNS, 'foreignObject');
      var elForeign = gl.dom.elLegendForeign;
      elForeign.setAttribute('x', 0);
      elForeign.setAttribute('y', 0);
      elForeign.setAttribute('width', gl.svgWidth);
      elForeign.setAttribute('height', gl.svgHeight);
      gl.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
      elForeign.appendChild(gl.dom.elLegendWrap);
      elForeign.appendChild(this.getLegendStyles());
      gl.dom.Paper.node.insertBefore(elForeign, gl.dom.elGraphical.node);
    }
  }, {
    key: "drawLegends",
    value: function drawLegends() {
      var self = this;
      var w = this.w;
      var fontFamily = w.config.legend.fontFamily;
      var legendNames = w.globals.seriesNames;
      var fillcolor = w.globals.colors.slice();

      if (w.config.chart.type === 'heatmap') {
        var ranges = w.config.plotOptions.heatmap.colorScale.ranges;
        legendNames = ranges.map(function (colorScale) {
          return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;
        });
        fillcolor = ranges.map(function (color) {
          return color.color;
        });
      }

      var legendFormatter = w.globals.legendFormatter;

      for (var i = 0; i <= legendNames.length - 1; i++) {
        var text = legendFormatter(legendNames[i], {
          seriesIndex: i,
          w: w
        });
        var collapsedSeries = false;
        var ancillaryCollapsedSeries = false;

        if (w.globals.collapsedSeries.length > 0) {
          for (var c = 0; c < w.globals.collapsedSeries.length; c++) {
            if (w.globals.collapsedSeries[c].index === i) {
              collapsedSeries = true;
            }
          }
        }

        if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {
          for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {
            if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {
              ancillaryCollapsedSeries = true;
            }
          }
        }

        var elMarker = document.createElement('span');
        elMarker.classList.add('apexcharts-legend-marker');
        var mOffsetX = w.config.legend.markers.offsetX;
        var mOffsetY = w.config.legend.markers.offsetY;
        var mHeight = w.config.legend.markers.height;
        var mWidth = w.config.legend.markers.width;
        var mBorderWidth = w.config.legend.markers.strokeWidth;
        var mBorderColor = w.config.legend.markers.strokeColor;
        var mBorderRadius = w.config.legend.markers.radius;
        var mStyle = elMarker.style;
        mStyle.background = fillcolor[i];
        mStyle.color = fillcolor[i];
        mStyle.height = Array.isArray(mHeight) ? parseFloat(mHeight[i]) + 'px' : parseFloat(mHeight) + 'px';
        mStyle.width = Array.isArray(mWidth) ? parseFloat(mWidth[i]) + 'px' : parseFloat(mWidth) + 'px';
        mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX;
        mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY;
        mStyle.borderWidth = Array.isArray(mBorderWidth) ? mBorderWidth[i] : mBorderWidth;
        mStyle.borderColor = Array.isArray(mBorderColor) ? mBorderColor[i] : mBorderColor;
        mStyle.borderRadius = Array.isArray(mBorderRadius) ? parseFloat(mBorderRadius[i]) + 'px' : parseFloat(mBorderRadius) + 'px';

        if (w.config.legend.markers.customHTML) {
          if (Array.isArray(w.config.legend.markers.customHTML)) {
            elMarker.innerHTML = w.config.legend.markers.customHTML[i]();
          } else {
            elMarker.innerHTML = w.config.legend.markers.customHTML();
          }
        }

        Graphics.setAttrs(elMarker, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });

        if (collapsedSeries || ancillaryCollapsedSeries) {
          elMarker.classList.add('inactive-legend');
        }

        var elLegend = document.createElement('div');
        var elLegendText = document.createElement('span');
        elLegendText.classList.add('apexcharts-legend-text');
        elLegendText.innerHTML = text;
        var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : w.config.legend.labels.colors;

        if (!textColor) {
          textColor = w.config.chart.foreColor;
        }

        elLegendText.style.color = textColor;
        elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';
        elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;
        Graphics.setAttrs(elLegendText, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });
        elLegend.appendChild(elMarker);
        elLegend.appendChild(elLegendText);
        var coreUtils = new CoreUtils(this.ctx);

        if (!w.config.legend.showForZeroSeries) {
          var total = coreUtils.getSeriesTotalByIndex(i);

          if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
            elLegend.classList.add('apexcharts-hidden-zero-series');
          }
        }

        if (!w.config.legend.showForNullSeries) {
          if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
            elLegend.classList.add('apexcharts-hidden-null-series');
          }
        }

        w.globals.dom.elLegendWrap.appendChild(elLegend);
        w.globals.dom.elLegendWrap.classList.add(w.config.legend.horizontalAlign); // w.globals.dom.elLegendWrap.classList.add(w.config.legend.verticalAlign)

        w.globals.dom.elLegendWrap.classList.add('position-' + w.config.legend.position);
        elLegend.classList.add('apexcharts-legend-series');
        elLegend.style.margin = "".concat(w.config.legend.itemMargin.horizontal, "px ").concat(w.config.legend.itemMargin.vertical, "px");
        w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';
        w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';
        Graphics.setAttrs(elLegend, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });

        if (collapsedSeries || ancillaryCollapsedSeries) {
          elLegend.classList.add('inactive-legend');
        }

        if (!w.config.legend.onItemClick.toggleDataSeries) {
          elLegend.classList.add('no-click');
        }
      } // for now - just prevent click on heatmap legend - and allow hover only


      var clickAllowed = w.config.chart.type !== 'heatmap';

      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {
        w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true);
      }

      if (w.config.legend.onItemHover.highlightDataSeries) {
        w.globals.dom.elWrap.addEventListener('mousemove', self.onLegendHovered, true);
        w.globals.dom.elWrap.addEventListener('mouseout', self.onLegendHovered, true);
      }
    }
  }, {
    key: "getLegendBBox",
    value: function getLegendBBox() {
      var w = this.w;
      var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var currLegendsWrapRect = currLegendsWrap.getBoundingClientRect();
      var currLegendsWrapWidth = currLegendsWrapRect.width;
      var currLegendsWrapHeight = currLegendsWrapRect.height;
      return {
        clwh: currLegendsWrapHeight,
        clww: currLegendsWrapWidth
      };
    }
  }, {
    key: "setLegendWrapXY",
    value: function setLegendWrapXY(offsetX, offsetY) {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var legendRect = elLegendWrap.getBoundingClientRect();
      var x = 0;
      var y = 0;

      if (w.config.legend.position === 'bottom') {
        y = y + (w.globals.svgHeight - legendRect.height / 2);
      } else if (w.config.legend.position === 'top') {
        var dim = new Dimensions(this.ctx);
        var titleH = dim.getTitleSubtitleCoords('title').height;
        var subtitleH = dim.getTitleSubtitleCoords('subtitle').height;
        y = y + (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);
      }

      elLegendWrap.style.position = 'absolute';
      x = x + offsetX + w.config.legend.offsetX;
      y = y + offsetY + w.config.legend.offsetY;
      elLegendWrap.style.left = x + 'px';
      elLegendWrap.style.top = y + 'px';

      if (w.config.legend.position === 'bottom') {
        elLegendWrap.style.top = 'auto';
        elLegendWrap.style.bottom = 10 + w.config.legend.offsetY + 'px';
      } else if (w.config.legend.position === 'right') {
        elLegendWrap.style.left = 'auto';
        elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';
      }

      if (elLegendWrap.style.width) {
        elLegendWrap.style.width = parseInt(w.config.legend.width) + 'px';
      }

      if (elLegendWrap.style.height) {
        elLegendWrap.style.height = parseInt(w.config.legend.height) + 'px';
      }
    }
  }, {
    key: "legendAlignHorizontal",
    value: function legendAlignHorizontal() {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      elLegendWrap.style.right = 0;
      var lRect = this.getLegendBBox();
      var dimensions = new Dimensions(this.ctx);
      var titleRect = dimensions.getTitleSubtitleCoords('title');
      var subtitleRect = dimensions.getTitleSubtitleCoords('subtitle');
      var offsetX = 20;
      var offsetY = 0; // the whole legend box is set to bottom

      if (w.config.legend.position === 'bottom') {
        offsetY = -lRect.clwh / 1.8;
      } else if (w.config.legend.position === 'top') {
        offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 15;
      }

      this.setLegendWrapXY(offsetX, offsetY);
    }
  }, {
    key: "legendAlignVertical",
    value: function legendAlignVertical() {
      var w = this.w;
      var lRect = this.getLegendBBox();
      var offsetY = 20;
      var offsetX = 0;

      if (w.config.legend.position === 'left') {
        offsetX = 20;
      }

      if (w.config.legend.position === 'right') {
        offsetX = w.globals.svgWidth - lRect.clww - 10;
      }

      this.setLegendWrapXY(offsetX, offsetY);
    }
  }, {
    key: "onLegendHovered",
    value: function onLegendHovered(e) {
      var w = this.w;
      var hoverOverLegend = e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');

      if (w.config.chart.type !== 'heatmap') {
        if (!e.target.classList.contains('inactive-legend') && hoverOverLegend) {
          var series = new Series(this.ctx);
          series.toggleSeriesOnHover(e, e.target);
        }
      } else {
        // for heatmap handling
        if (hoverOverLegend) {
          var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;
          this.ctx.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);

          var _series = new Series(this.ctx);

          _series.highlightRangeInSeries(e, e.target);
        }
      }
    }
  }, {
    key: "onLegendClick",
    value: function onLegendClick(e) {
      if (e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {
        var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;
        var isHidden = e.target.getAttribute('data:collapsed') === 'true';
        var legendClick = this.w.config.chart.events.legendClick;

        if (typeof legendClick === 'function') {
          legendClick(this.ctx, seriesCnt, this.w);
        }

        this.ctx.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);
        var markerClick = this.w.config.legend.markers.onClick;

        if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {
          markerClick(this.ctx, seriesCnt, this.w);
          this.ctx.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);
        }

        this.toggleDataSeries(seriesCnt, isHidden);
      }
    }
  }, {
    key: "getLegendStyles",
    value: function getLegendStyles() {
      var stylesheet = document.createElement('style');
      stylesheet.setAttribute('type', 'text/css');
      var text = "\n    \n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n\n      .apexcharts-legend.position-bottom.left, .apexcharts-legend.position-top.left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        justify-content: flex-start;\n      }\n\n      .apexcharts-legend.position-bottom.center, .apexcharts-legend.position-top.center {\n        justify-content: center;  \n      }\n\n      .apexcharts-legend.position-bottom.right, .apexcharts-legend.position-top.right {\n        justify-content: flex-end;\n      }\n\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n      }\n      \n      .apexcharts-legend.right .apexcharts-legend-series, .apexcharts-legend.left .apexcharts-legend-series{\n        display: inline-block;\n      }\n\n      .apexcharts-legend-series.no-click {\n        cursor: auto;\n      }\n\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n\n      .inactive-legend {\n        opacity: 0.45;\n      }";
      var rules = document.createTextNode(text);
      stylesheet.appendChild(rules);
      return stylesheet;
    }
  }, {
    key: "toggleDataSeries",
    value: function toggleDataSeries(seriesCnt, isHidden) {
      var w = this.w;

      if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
        w.globals.resized = true; // we don't want initial animations again

        var seriesEl = null;
        var realIndex = null; // yes, make it null. 1 series will rise at a time

        w.globals.risingSeries = [];

        if (w.globals.axisCharts) {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesCnt, "']"));
          realIndex = parseInt(seriesEl.getAttribute('data:realIndex'));
        } else {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "']"));
          realIndex = parseInt(seriesEl.getAttribute('rel')) - 1;
        }

        if (isHidden) {
          this.riseCollapsedSeries(w.globals.collapsedSeries, w.globals.collapsedSeriesIndices, realIndex);
          this.riseCollapsedSeries(w.globals.ancillaryCollapsedSeries, w.globals.ancillaryCollapsedSeriesIndices, realIndex);
        } else {
          if (w.globals.axisCharts) {
            var shouldNotHideYAxis = false;

            if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].show && w.config.yaxis[realIndex].showAlways) {
              shouldNotHideYAxis = true;

              if (w.globals.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {
                w.globals.ancillaryCollapsedSeries.push({
                  index: realIndex,
                  data: w.config.series[realIndex].data.slice(),
                  type: seriesEl.parentNode.className.baseVal.split('-')[1]
                });
                w.globals.ancillaryCollapsedSeriesIndices.push(realIndex);
              }
            }

            if (!shouldNotHideYAxis) {
              w.globals.collapsedSeries.push({
                index: realIndex,
                data: w.config.series[realIndex].data.slice(),
                type: seriesEl.parentNode.className.baseVal.split('-')[1]
              });
              w.globals.collapsedSeriesIndices.push(realIndex);
              var removeIndexOfRising = w.globals.risingSeries.indexOf(realIndex);
              w.globals.risingSeries.splice(removeIndexOfRising, 1);
            } // TODO: AVOID mutating the user's config object below


            w.config.series[realIndex].data = [];
          } else {
            w.globals.collapsedSeries.push({
              index: realIndex,
              data: w.config.series[realIndex]
            });
            w.globals.collapsedSeriesIndices.push(realIndex);
            w.config.series[realIndex] = 0;
          }

          var seriesChildren = seriesEl.childNodes;

          for (var sc = 0; sc < seriesChildren.length; sc++) {
            if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {
              if (seriesChildren[sc].classList.contains('apexcharts-hide')) {
                seriesChildren[sc].classList.remove('apexcharts-hide');
              } else {
                seriesChildren[sc].classList.add('apexcharts-hide');
              }
            }
          }

          w.globals.allSeriesCollapsed = w.globals.collapsedSeries.length === w.globals.series.length;

          this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);
        }
      } else {
        // for non-axis charts i.e pie / donuts
        var _seriesEl = w.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(seriesCnt + 1, "'] path"));

        var type = w.config.chart.type;

        if (type === 'pie' || type === 'donut') {
          var dataLabels = w.config.plotOptions.pie.donut.labels;
          var graphics = new Graphics(this.ctx);
          var pie = new Pie(this.ctx);
          graphics.pathMouseDown(_seriesEl.members[0], null);
          pie.printDataLabelsInner(_seriesEl.members[0].node, dataLabels);
        }

        _seriesEl.fire('click');
      }
    }
  }, {
    key: "riseCollapsedSeries",
    value: function riseCollapsedSeries(series, seriesIndices, realIndex) {
      var w = this.w;

      if (series.length > 0) {
        for (var c = 0; c < series.length; c++) {
          if (series[c].index === realIndex) {
            if (w.globals.axisCharts) {
              w.config.series[realIndex].data = series[c].data.slice();
              series.splice(c, 1);
              seriesIndices.splice(c, 1);
              w.globals.risingSeries.push(realIndex);
            } else {
              w.config.series[realIndex] = series[c].data;
              series.splice(c, 1);
              seriesIndices.splice(c, 1);
              w.globals.risingSeries.push(realIndex);
            }

            this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);
          }
        }
      }
    }
  }]);

  return Legend;
}();

/**
 * ApexCharts Line Class responsible for drawing Line / Area Charts.
 * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions
 * @module Line
 **/

var Line =
/*#__PURE__*/
function () {
  function Line(ctx, xyRatios, isPointsChart) {
    _classCallCheck(this, Line);

    this.ctx = ctx;
    this.w = ctx.w;
    this.xyRatios = xyRatios;
    this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;
    this.scatter = new Scatter(this.ctx);
    this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;
    this.yaxisIndex = 0;
  }

  _createClass(Line, [{
    key: "draw",
    value: function draw(series, ptype, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var type = w.globals.comboCharts ? ptype : w.config.chart.type;
      var ret = graphics.group({
        class: "apexcharts-".concat(type, "-series apexcharts-plot-series")
      });
      var coreUtils = new CoreUtils(this.ctx, w);
      series = coreUtils.getLogSeries(series);
      var yRatio = this.xyRatios.yRatio;
      yRatio = coreUtils.getLogYRatios(yRatio);
      var zRatio = this.xyRatios.zRatio;
      var xRatio = this.xyRatios.xRatio;
      var baseLineY = this.xyRatios.baseLineY; // push all series in an array, so we can draw in reverse order (for stacked charts)

      var allSeries = [];
      var prevSeriesY = [];
      var categoryAxisCorrection = 0;

      for (var i = 0; i < series.length; i++) {
        // width divided into equal parts
        if (type === 'line' && (w.config.fill.type === 'gradient' || w.config.fill.type[i] === 'gradient')) {
          // a small adjustment to allow gradient line to draw correctly for all same values

          /* #fix https://github.com/apexcharts/apexcharts.js/issues/358 */
          if (coreUtils.seriesHaveSameValues(i)) {
            var gSeries = series[i].slice();
            gSeries[gSeries.length - 1] = gSeries[gSeries.length - 1] + 0.000001;
            series[i] = gSeries;
          }
        }

        var xDivision = w.globals.gridWidth / w.globals.dataPoints;
        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;

        if (yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;
        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series
        // zeroY is the 0 value in y series which can be used in negative charts

        var zeroY = w.globals.gridHeight - baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? baseLineY[this.yaxisIndex] * 2 : 0);
        var areaBottomY = zeroY;

        if (zeroY > w.globals.gridHeight) {
          areaBottomY = w.globals.gridHeight;
        }

        categoryAxisCorrection = xDivision / 2;
        var x = w.globals.padHorizontal + categoryAxisCorrection;
        var y = 1;

        if (w.globals.isXNumeric && w.globals.seriesX.length > 0) {
          x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio;
        }

        xArrj.push(x);
        var linePath = void 0,
            areaPath = void 0,
            pathFromLine = void 0,
            pathFromArea = void 0;
        var linePaths = [];
        var areaPaths = []; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series",
          seriesName: Utils.escapeString(w.globals.seriesNames[realIndex])
        }); // points

        var elPointsMain = graphics.group({
          class: 'apexcharts-series-markers-wrap'
        }); // eldatalabels

        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });
        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);
        var longestSeries = series[i].length === w.globals.dataPoints;
        elSeries.attr({
          'data:longestSeries': longestSeries,
          rel: i + 1,
          'data:realIndex': realIndex
        });
        this.appendPathFrom = true;
        var pX = x;
        var pY = void 0;
        var prevX = pX;
        var prevY = zeroY; // w.globals.svgHeight;

        var lineYPosition = 0; // the first value in the current series is not null or undefined

        var firstPrevY = this.determineFirstPrevY({
          i: i,
          series: series,
          yRatio: yRatio[this.yaxisIndex],
          zeroY: zeroY,
          prevY: prevY,
          prevSeriesY: prevSeriesY,
          lineYPosition: lineYPosition
        });
        prevY = firstPrevY.prevY;
        yArrj.push(prevY);
        pY = prevY;

        if (series[i][0] === null) {
          // when the first value itself is null, we need to move the pointer to a location where a null value is not found
          for (var s = 0; s < series[i].length; s++) {
            if (series[i][s] !== null) {
              prevX = xDivision * s;
              prevY = zeroY - series[i][s] / yRatio[this.yaxisIndex];
              linePath = graphics.move(prevX, prevY);
              areaPath = graphics.move(prevX, areaBottomY);
              break;
            }
          }
        } else {
          linePath = graphics.move(prevX, prevY);
          areaPath = graphics.move(prevX, areaBottomY) + graphics.line(prevX, prevY);
        }

        pathFromLine = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);
        pathFromArea = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);

        if (w.globals.previousPaths.length > 0) {
          var pathFrom = this.checkPreviousPaths({
            pathFromLine: pathFromLine,
            pathFromArea: pathFromArea,
            realIndex: realIndex
          });
          pathFromLine = pathFrom.pathFromLine;
          pathFromArea = pathFrom.pathFromArea;
        }

        var iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;

        for (var j = 0; j < iterations; j++) {
          if (w.globals.isXNumeric) {
            var sX = w.globals.seriesX[realIndex][j + 1];

            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {
              /* fix #374 */
              sX = w.globals.seriesX[realIndex][iterations - 1];
            }

            x = (sX - w.globals.minX) / xRatio;
          } else {
            x = x + xDivision;
          }

          var minY = Utils.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;

          if (w.config.chart.stacked) {
            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {
              lineYPosition = prevSeriesY[i - 1][j + 1];
            } else {
              // the first series will not have prevY values
              lineYPosition = zeroY;
            }

            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {
              y = lineYPosition - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;
            } else {
              y = lineYPosition - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;
            }
          } else {
            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {
              y = zeroY - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;
            } else {
              y = zeroY - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;
            }
          } // push current X


          xArrj.push(x); // push current Y that will be used as next series's bottom position

          yArrj.push(y);
          var calculatedPaths = this.createPaths({
            series: series,
            i: i,
            j: j,
            x: x,
            y: y,
            xDivision: xDivision,
            pX: pX,
            pY: pY,
            areaBottomY: areaBottomY,
            linePath: linePath,
            areaPath: areaPath,
            linePaths: linePaths,
            areaPaths: areaPaths,
            seriesIndex: seriesIndex
          });
          areaPaths = calculatedPaths.areaPaths;
          linePaths = calculatedPaths.linePaths;
          pX = calculatedPaths.pX;
          pY = calculatedPaths.pY;
          areaPath = calculatedPaths.areaPath;
          linePath = calculatedPaths.linePath;

          if (this.appendPathFrom) {
            pathFromLine = pathFromLine + graphics.line(x, zeroY);
            pathFromArea = pathFromArea + graphics.line(x, zeroY);
          }

          var pointsPos = this.calculatePoints({
            series: series,
            x: x,
            y: y,
            realIndex: realIndex,
            i: i,
            j: j,
            prevY: prevY,
            categoryAxisCorrection: categoryAxisCorrection,
            xRatio: xRatio
          });

          if (!this.pointsChart) {
            var markers = new Markers(this.ctx);

            if (w.globals.dataPoints > 1) {
              elPointsMain.node.classList.add('hidden');
            }

            var elPointsWrap = markers.plotChartMarkers(pointsPos, realIndex, j + 1);

            if (elPointsWrap !== null) {
              elPointsMain.add(elPointsWrap);
            }
          } else {
            // scatter / bubble chart points creation
            this.scatter.draw(elSeries, j, {
              realIndex: realIndex,
              pointsPos: pointsPos,
              zRatio: zRatio,
              elParent: elPointsMain
            });
          }

          var dataLabelAlign = !series[i][j + 1] || series[i][j + 1] > series[i][j] ? 'top' : 'bottom';
          var dataLabels = new DataLabels(this.ctx);
          var drawnLabels = dataLabels.drawDataLabel(pointsPos, realIndex, j + 1, null, dataLabelAlign);

          if (drawnLabels !== null) {
            elDataLabelsWrap.add(drawnLabels);
          }
        } // push all current y values array to main PrevY Array


        prevSeriesY.push(yArrj); // push all x val arrays into main xArr

        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj; // these elements will be shown after area path animation completes

        if (!this.pointsChart) {
          w.globals.delayedElements.push({
            el: elPointsMain.node,
            index: realIndex
          });
        }

        var defaultRenderedPathOptions = {
          i: i,
          realIndex: realIndex,
          animationDelay: i,
          initialSpeed: w.config.chart.animations.speed,
          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(type)
        };

        if (type === 'area') {
          var pathFill = fill.fillPath({
            seriesNumber: realIndex
          });

          for (var p = 0; p < areaPaths.length; p++) {
            var renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
              pathFrom: pathFromArea,
              pathTo: areaPaths[p],
              stroke: 'none',
              strokeWidth: 0,
              strokeLineCap: null,
              fill: pathFill
            }));
            elSeries.add(renderedPath);
          }
        }

        if (w.config.stroke.show && !this.pointsChart) {
          var lineFill = null;

          if (type === 'line') {
            // fillable lines only for lineChart
            lineFill = fill.fillPath({
              seriesNumber: realIndex,
              i: i
            });
          } else {
            lineFill = w.globals.stroke.colors[realIndex];
          }

          for (var _p = 0; _p < linePaths.length; _p++) {
            var _renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
              pathFrom: pathFromLine,
              pathTo: linePaths[_p],
              stroke: lineFill,
              strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width,
              strokeLineCap: w.config.stroke.lineCap,
              fill: 'none'
            }));

            elSeries.add(_renderedPath);
          }
        }

        elSeries.add(elPointsMain);
        elSeries.add(elDataLabelsWrap);
        allSeries.push(elSeries);
      }

      for (var _s = allSeries.length; _s > 0; _s--) {
        ret.add(allSeries[_s - 1]);
      }

      return ret;
    }
  }, {
    key: "createPaths",
    value: function createPaths(_ref) {
      var series = _ref.series,
          i = _ref.i,
          j = _ref.j,
          x = _ref.x,
          y = _ref.y,
          pX = _ref.pX,
          pY = _ref.pY,
          xDivision = _ref.xDivision,
          areaBottomY = _ref.areaBottomY,
          linePath = _ref.linePath,
          areaPath = _ref.areaPath,
          linePaths = _ref.linePaths,
          areaPaths = _ref.areaPaths,
          seriesIndex = _ref.seriesIndex;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var curve = w.config.stroke.curve;

      if (Array.isArray(w.config.stroke.curve)) {
        if (Array.isArray(seriesIndex)) {
          curve = w.config.stroke.curve[seriesIndex[i]];
        } else {
          curve = w.config.stroke.curve[i];
        }
      } // logic of smooth curve derived from chartist
      // CREDITS: https://gionkunz.github.io/chartist-js/


      if (curve === 'smooth') {
        var length = (x - pX) * 0.35;

        if (w.globals.hasNullValues) {
          if (series[i][j] !== null) {
            if (series[i][j + 1] !== null) {
              linePath = graphics.move(pX, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y);
              areaPath = graphics.move(pX + 1, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y) + graphics.line(x, areaBottomY) + graphics.line(pX, areaBottomY) + 'z';
            } else {
              linePath = graphics.move(pX, pY);
              areaPath = graphics.move(pX, pY) + 'z';
            }
          }

          linePaths.push(linePath);
          areaPaths.push(areaPath);
        } else {
          linePath = linePath + graphics.curve(pX + length, pY, x - length, y, x, y);
          areaPath = areaPath + graphics.curve(pX + length, pY, x - length, y, x, y);
        }

        pX = x;
        pY = y;

        if (j === series[i].length - 2) {
          // last loop, close path
          areaPath = areaPath + graphics.curve(pX, pY, x, y, x, areaBottomY) + graphics.move(x, y) + 'z';

          if (!w.globals.hasNullValues) {
            linePaths.push(linePath);
            areaPaths.push(areaPath);
          }
        }
      } else {
        if (series[i][j + 1] === null) {
          linePath = linePath + graphics.move(x, y);
          areaPath = areaPath + graphics.line(x - xDivision, areaBottomY) + graphics.move(x, y);
        }

        if (series[i][j] === null) {
          linePath = linePath + graphics.move(x, y);
          areaPath = areaPath + graphics.move(x, areaBottomY);
        }

        if (curve === 'stepline') {
          linePath = linePath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');
          areaPath = areaPath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');
        } else if (curve === 'straight') {
          linePath = linePath + graphics.line(x, y);
          areaPath = areaPath + graphics.line(x, y);
        }

        if (j === series[i].length - 2) {
          // last loop, close path
          areaPath = areaPath + graphics.line(x, areaBottomY) + graphics.move(x, y) + 'z';
          linePaths.push(linePath);
          areaPaths.push(areaPath);
        }
      }

      return {
        linePaths: linePaths,
        areaPaths: areaPaths,
        pX: pX,
        pY: pY,
        linePath: linePath,
        areaPath: areaPath
      };
    }
  }, {
    key: "calculatePoints",
    value: function calculatePoints(_ref2) {
      var series = _ref2.series,
          realIndex = _ref2.realIndex,
          x = _ref2.x,
          y = _ref2.y,
          i = _ref2.i,
          j = _ref2.j,
          prevY = _ref2.prevY,
          categoryAxisCorrection = _ref2.categoryAxisCorrection,
          xRatio = _ref2.xRatio;
      var w = this.w;
      var ptX = [];
      var ptY = [];

      if (j === 0) {
        var xPT1st = categoryAxisCorrection + w.config.markers.offsetX; // the first point for line series
        // we need to check whether it's not a time series, because a time series may
        // start from the middle of the x axis

        if (w.globals.isXNumeric) {
          xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio + w.config.markers.offsetX;
        } // push 2 points for the first data values


        ptX.push(xPT1st);
        ptY.push(Utils.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);
        ptX.push(x + w.config.markers.offsetX);
        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);
      } else {
        ptX.push(x + w.config.markers.offsetX);
        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);
      }

      var pointsPos = {
        x: ptX,
        y: ptY
      };
      return pointsPos;
    }
  }, {
    key: "checkPreviousPaths",
    value: function checkPreviousPaths(_ref3) {
      var pathFromLine = _ref3.pathFromLine,
          pathFromArea = _ref3.pathFromArea,
          realIndex = _ref3.realIndex;
      var w = this.w;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (gpp.type === 'line') {
            this.appendPathFrom = false;
            pathFromLine = w.globals.previousPaths[pp].paths[0].d;
          } else if (gpp.type === 'area') {
            this.appendPathFrom = false;
            pathFromArea = w.globals.previousPaths[pp].paths[0].d;

            if (w.config.stroke.show) {
              pathFromLine = w.globals.previousPaths[pp].paths[1].d;
            }
          }
        }
      }

      return {
        pathFromLine: pathFromLine,
        pathFromArea: pathFromArea
      };
    }
  }, {
    key: "determineFirstPrevY",
    value: function determineFirstPrevY(_ref4) {
      var i = _ref4.i,
          series = _ref4.series,
          yRatio = _ref4.yRatio,
          zeroY = _ref4.zeroY,
          prevY = _ref4.prevY,
          prevSeriesY = _ref4.prevSeriesY,
          lineYPosition = _ref4.lineYPosition;
      var w = this.w;

      if (typeof series[i][0] !== 'undefined') {
        if (w.config.chart.stacked) {
          if (i > 0) {
            // 1st y value of previous series
            lineYPosition = prevSeriesY[i - 1][0];
          } else {
            // the first series will not have prevY values
            lineYPosition = zeroY;
          }

          prevY = lineYPosition - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;
        } else {
          prevY = zeroY - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;
        }
      } else {
        // the first value in the current series is null
        if (w.config.chart.stacked && i > 0 && typeof series[i][0] === 'undefined') {
          // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)
          for (var s = i - 1; s >= 0; s--) {
            // for loop to get to 1st previous value until we get it
            if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {
              lineYPosition = prevSeriesY[s][0];
              prevY = lineYPosition;
              break;
            }
          }
        }
      }

      return {
        prevY: prevY,
        lineYPosition: lineYPosition
      };
    }
  }]);

  return Line;
}();

/**
 * ApexCharts XAxis Class for drawing X-Axis.
 *
 * @module XAxis
 **/

var XAxis =
/*#__PURE__*/
function () {
  function XAxis(ctx) {
    _classCallCheck(this, XAxis);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.xaxisLabels = w.globals.labels.slice();

    if (w.globals.timelineLabels.length > 0) {
      //  timeline labels are there
      this.xaxisLabels = w.globals.timelineLabels.slice();
    }

    this.drawnLabels = [];

    if (w.config.xaxis.position === 'top') {
      this.offY = 0;
    } else {
      this.offY = w.globals.gridHeight + 1;
    }

    this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;
    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;
    this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;
    this.xaxisForeColors = w.config.xaxis.labels.style.colors;
    this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;

    if (this.xaxisBorderWidth.indexOf('%') > -1) {
      this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth) / 100;
    } else {
      this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth);
    }

    this.xaxisBorderHeight = w.config.xaxis.axisBorder.height; // For bars, we will only consider single y xais,
    // as we are not providing multiple yaxis for bar charts

    this.yaxis = w.config.yaxis[0];
    this.axesUtils = new AxesUtils(ctx);
  }

  _createClass(XAxis, [{
    key: "drawXaxis",
    value: function drawXaxis() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var elXaxis = graphics.group({
        class: 'apexcharts-xaxis',
        transform: "translate(".concat(w.config.xaxis.offsetX, ", ").concat(w.config.xaxis.offsetY, ")")
      });
      var elXaxisTexts = graphics.group({
        class: 'apexcharts-xaxis-texts-g',
        transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
      });
      elXaxis.add(elXaxisTexts);
      var colWidth; // initial x Position (keep adding column width in the loop)

      var xPos = w.globals.padHorizontal;
      var labels = [];

      for (var i = 0; i < this.xaxisLabels.length; i++) {
        labels.push(this.xaxisLabels[i]);
      }

      if (w.globals.isXNumeric) {
        colWidth = w.globals.gridWidth / (labels.length - 1);
        xPos = xPos + colWidth / 2 + w.config.xaxis.labels.offsetX;
      } else {
        colWidth = w.globals.gridWidth / labels.length;
        xPos = xPos + colWidth + w.config.xaxis.labels.offsetX;
      }

      var labelsLen = labels.length;

      if (w.config.xaxis.labels.show) {
        for (var _i = 0; _i <= labelsLen - 1; _i++) {
          var x = xPos - colWidth / 2 + w.config.xaxis.labels.offsetX;
          var label = this.axesUtils.getLabel(labels, w.globals.timelineLabels, x, _i, this.drawnLabels);
          this.drawnLabels.push(label.text);
          var offsetYCorrection = 28;

          if (w.globals.rotateXLabels) {
            offsetYCorrection = 22;
          }

          var elTick = graphics.drawText({
            x: label.x,
            y: this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection,
            text: '',
            textAnchor: 'middle',
            fontSize: this.xaxisFontSize,
            fontFamily: this.xaxisFontFamily,
            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[_i] : this.xaxisForeColors,
            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass
          });

          if (_i === labelsLen - 1) {
            if (w.globals.skipLastTimelinelabel) {
              label.text = '';
            }
          }

          elXaxisTexts.add(elTick);
          graphics.addTspan(elTick, label.text, this.xaxisFontFamily);
          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
          elTooltipTitle.textContent = label.text;
          elTick.node.appendChild(elTooltipTitle);
          xPos = xPos + colWidth;
        }
      }

      if (w.config.xaxis.title.text !== undefined) {
        var elXaxisTitle = graphics.group({
          class: 'apexcharts-xaxis-title'
        });
        var elXAxisTitleText = graphics.drawText({
          x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,
          y: this.offY - parseInt(this.xaxisFontSize) + w.globals.xAxisLabelsHeight + w.config.xaxis.title.offsetY,
          text: w.config.xaxis.title.text,
          textAnchor: 'middle',
          fontSize: w.config.xaxis.title.style.fontSize,
          fontFamily: w.config.xaxis.title.style.fontFamily,
          foreColor: w.config.xaxis.title.style.color,
          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass
        });
        elXaxisTitle.add(elXAxisTitleText);
        elXaxis.add(elXaxisTitle);
      }

      if (w.config.xaxis.axisBorder.show) {
        var lineCorrection = 0;

        if (w.config.chart.type === 'bar' && w.globals.isXNumeric) {
          lineCorrection = lineCorrection - 15;
        }

        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        elXaxis.add(elHorzLine);
      }

      return elXaxis;
    } // this actually becomes the vertical axis (for bar charts)

  }, {
    key: "drawXaxisInversed",
    value: function drawXaxisInversed(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;
      var elYaxis = graphics.group({
        class: 'apexcharts-yaxis apexcharts-xaxis-inversed',
        rel: realIndex
      });
      var elYaxisTexts = graphics.group({
        class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',
        transform: 'translate(' + translateYAxisX + ', 0)'
      });
      elYaxis.add(elYaxisTexts);
      var colHeight; // initial x Position (keep adding column width in the loop)

      var yPos;
      var labels = [];

      for (var i = 0; i < this.xaxisLabels.length; i++) {
        labels.push(this.xaxisLabels[i]);
      }

      colHeight = w.globals.gridHeight / labels.length;
      yPos = -(colHeight / 2.2);
      var lbFormatter = w.globals.yLabelFormatters[0];
      var ylabels = w.config.yaxis[0].labels;

      if (ylabels.show) {
        for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {
          var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];
          label = lbFormatter(label);
          var elLabel = graphics.drawText({
            x: ylabels.offsetX - 15,
            y: yPos + colHeight + ylabels.offsetY,
            text: label,
            textAnchor: this.yaxis.opposite ? 'start' : 'end',
            foreColor: ylabels.style.color ? ylabels.style.color : ylabels.style.colors[_i2],
            fontSize: ylabels.style.fontSize,
            fontFamily: ylabels.style.fontFamily,
            cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass
          });
          elYaxisTexts.add(elLabel);

          if (w.config.yaxis[realIndex].labels.rotate !== 0) {
            var labelRotatingCenter = graphics.rotateAroundCenter(elLabel.node);
            elLabel.node.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].labels.rotate, " ").concat(labelRotatingCenter.x, " ").concat(labelRotatingCenter.y, ")"));
          }

          yPos = yPos + colHeight;
        }
      }

      if (w.config.yaxis[0].title.text !== undefined) {
        var elXaxisTitle = graphics.group({
          class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',
          transform: 'translate(' + translateYAxisX + ', 0)'
        });
        var elXAxisTitleText = graphics.drawText({
          x: 0,
          y: w.globals.gridHeight / 2,
          text: w.config.yaxis[0].title.text,
          textAnchor: 'middle',
          foreColor: w.config.yaxis[0].title.style.color,
          fontSize: w.config.yaxis[0].title.style.fontSize,
          fontFamily: w.config.yaxis[0].title.style.fontFamily,
          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass
        });
        elXaxisTitle.add(elXAxisTitleText);
        elYaxis.add(elXaxisTitle);
      }

      if (w.config.xaxis.axisBorder.show) {
        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, this.yaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        elYaxis.add(elHorzLine);
        this.axesUtils.drawYAxisTicks(0, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);
      }

      return elYaxis;
    }
  }, {
    key: "drawXaxisTicks",
    value: function drawXaxisTicks(x1, appendToElement) {
      var w = this.w;
      var x2 = x1;
      if (x1 < 0 || x1 > w.globals.gridWidth) return;
      var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;
      var y2 = y1 + w.config.xaxis.axisTicks.height;

      if (w.config.xaxis.axisTicks.show) {
        var graphics = new Graphics(this.ctx);
        var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color); // we are not returning anything, but appending directly to the element pased in param

        appendToElement.add(line);
        line.node.classList.add('apexcharts-xaxis-tick');
      }
    }
  }, {
    key: "getXAxisTicksPositions",
    value: function getXAxisTicksPositions() {
      var w = this.w;
      var xAxisTicksPositions = [];
      var xCount = this.xaxisLabels.length;
      var x1 = w.globals.padHorizontal;

      if (w.globals.timelineLabels.length > 0) {
        for (var i = 0; i < xCount; i++) {
          x1 = this.xaxisLabels[i].position;
          xAxisTicksPositions.push(x1);
        }
      } else {
        var xCountForCategoryCharts = xCount;

        for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {
          var x1Count = xCountForCategoryCharts;

          if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {
            x1Count -= 1;
          }

          x1 = x1 + w.globals.gridWidth / x1Count;
          xAxisTicksPositions.push(x1);
        }
      }

      return xAxisTicksPositions;
    } // to rotate x-axis labels or to put ... for longer text in xaxis

  }, {
    key: "xAxisLabelCorrections",
    value: function xAxisLabelCorrections() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');
      var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text');
      var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');
      var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text');

      if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {
        for (var xat = 0; xat < xAxisTexts.length; xat++) {
          var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);
          textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;

          textRotatingCenter.x = textRotatingCenter.x + 1;
          xAxisTexts[xat].setAttribute('transform', "rotate(".concat(w.config.xaxis.labels.rotate, " ").concat(textRotatingCenter.x, " ").concat(textRotatingCenter.y, ")"));
          xAxisTexts[xat].setAttribute('text-anchor', "end");
          var offsetHeight = 10;
          xAxis.setAttribute('transform', "translate(0, ".concat(-offsetHeight, ")"));
          var tSpan = xAxisTexts[xat].childNodes;

          if (w.config.xaxis.labels.trim) {
            graphics.placeTextWithEllipsis(tSpan[0], tSpan[0].textContent, w.config.xaxis.labels.maxHeight - 40);
          }
        }
      } else {
        var width = w.globals.gridWidth / w.globals.labels.length;

        for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {
          var _tSpan = xAxisTexts[_xat].childNodes;

          if (w.config.xaxis.labels.trim && w.config.xaxis.type !== 'datetime') {
            graphics.placeTextWithEllipsis(_tSpan[0], _tSpan[0].textContent, width);
          }
        }
      }

      if (yAxisTextsInversed.length > 0) {
        // truncate rotated y axis in bar chart (x axis)
        var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();
        var lastLabelPosX = yAxisTextsInversed[0].getBBox();

        if (firstLabelPosX.x < -20) {
          yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);
        }

        if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth) {
          yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);
        } // truncate rotated x axis in bar chart (y axis)


        for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {
          graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - parseInt(w.config.yaxis[0].title.style.fontSize) * 2 - 20);
        }
      }
    } // renderXAxisBands() {
    //   let w = this.w;
    //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')
    //   w.globals.dom.elGraphical.add(plotBand)
    // }

  }]);

  return XAxis;
}();

var Range =
/*#__PURE__*/
function () {
  function Range(ctx) {
    _classCallCheck(this, Range);

    this.ctx = ctx;
    this.w = ctx.w;
  } // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axiss
  // This routine creates the Y axis values for a graph.


  _createClass(Range, [{
    key: "niceScale",
    value: function niceScale(yMin, yMax, diff) {
      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var ticks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10;
      var w = this.w;
      var NO_MIN_MAX_PROVIDED = this.w.config.yaxis[index].max === undefined && this.w.config.yaxis[index].min === undefined || this.w.config.yaxis[index].forceNiceScale;

      if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils.isNumber(yMin) && !Utils.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {
        // when all values are 0
        yMin = 0;
        yMax = ticks;
        var linearScale = this.linearScale(yMin, yMax, ticks);
        return linearScale;
      }

      if (yMin > yMax) {
        // if somehow due to some wrong config, user sent max less than min,
        // adjust the min/max again
        console.warn('yaxis.min cannot be greater than yaxis.max');
        yMax = yMin + 0.1;
      } else if (yMin === yMax) {
        // If yMin and yMax are identical, then
        // adjust the yMin and yMax values to actually
        // make a graph. Also avoids division by zero errors.
        yMin = yMin === 0 ? 0 : yMin - 0.5; // some small value

        yMax = yMax === 0 ? 2 : yMax + 0.5; // some small value
      } // Calculate Min amd Max graphical labels and graph
      // increments.  The number of ticks defaults to
      // 10 which is the SUGGESTED value.  Any tick value
      // entered is used as a suggested value which is
      // adjusted to be a 'pretty' value.
      //
      // Output will be an array of the Y axis values that
      // encompass the Y values.


      var result = []; // Determine Range

      var range = Math.abs(yMax - yMin);

      if (range < 1 && NO_MIN_MAX_PROVIDED && (w.config.chart.type === 'candlestick' || w.config.series[index].type === 'candlestick' || w.globals.isRangeData)) {
        /* fix https://github.com/apexcharts/apexcharts.js/issues/430 */
        yMax = yMax * 1.01;
      }

      var tiks = ticks + 1; // Adjust ticks if needed

      if (tiks < 2) {
        tiks = 2;
      } else if (tiks > 2) {
        tiks -= 2;
      } // Get raw step value


      var tempStep = range / tiks; // Calculate pretty step value

      var mag = Math.floor(Utils.log10(tempStep));
      var magPow = Math.pow(10, mag);
      var magMsd = parseInt(tempStep / magPow);
      var stepSize = magMsd * magPow; // build Y label array.
      // Lower and upper bounds calculations

      var lb = stepSize * Math.floor(yMin / stepSize);
      var ub = stepSize * Math.ceil(yMax / stepSize); // Build array

      var val = lb;

      while (1) {
        result.push(val);
        val += stepSize;

        if (val > ub) {
          break;
        }
      }

      if (NO_MIN_MAX_PROVIDED && diff > 10) {
        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      } else {
        result = [];
        var v = yMin;
        result.push(v);
        var valuesDivider = Math.abs(yMax - yMin) / ticks;

        for (var i = 0; i <= ticks; i++) {
          v = v + valuesDivider;
          result.push(v);
        }

        if (result[result.length - 2] >= yMax) {
          result.pop();
        }

        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      }
    }
  }, {
    key: "linearScale",
    value: function linearScale(yMin, yMax) {
      var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
      var range = Math.abs(yMax - yMin);
      var step = range / ticks;

      if (ticks === Number.MAX_VALUE) {
        ticks = 10;
        step = 1;
      }

      var result = [];
      var v = yMin;

      while (ticks >= 0) {
        result.push(v);
        v = v + step;
        ticks -= 1;
      }

      return {
        result: result,
        niceMin: result[0],
        niceMax: result[result.length - 1]
      };
    }
  }, {
    key: "logarithmicScale",
    value: function logarithmicScale(index, yMin, yMax, ticks) {
      if (yMin < 0 || yMin === Number.MIN_VALUE) yMin = 0.01;
      var base = 10;
      var min = Math.log(yMin) / Math.log(base);
      var max = Math.log(yMax) / Math.log(base);
      var range = Math.abs(yMax - yMin);
      var step = range / ticks;
      var result = [];
      var v = yMin;

      while (ticks >= 0) {
        result.push(v);
        v = v + step;
        ticks -= 1;
      }

      var logs = result.map(function (niceNumber, i) {
        if (niceNumber <= 0) {
          niceNumber = 0.01;
        } // calculate adjustment factor


        var scale = (max - min) / (yMax - yMin);
        var logVal = Math.pow(base, min + scale * (niceNumber - min));
        return Math.round(logVal / Utils.roundToBase(logVal, base)) * Utils.roundToBase(logVal, base);
      }); // Math.floor may have rounded the value to 0, revert back to 1

      if (logs[0] === 0) logs[0] = 1;
      return {
        result: logs,
        niceMin: logs[0],
        niceMax: logs[logs.length - 1]
      };
    }
  }, {
    key: "setYScaleForIndex",
    value: function setYScaleForIndex(index, minY, maxY) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var y = gl.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];

      if (typeof gl.yAxisScale[index] === 'undefined') {
        gl.yAxisScale[index] = [];
      }

      if (y.logarithmic) {
        gl.allSeriesCollapsed = false;
        gl.yAxisScale[index] = this.logarithmicScale(index, minY, maxY, y.tickAmount ? y.tickAmount : Math.floor(Math.log10(maxY)));
      } else {
        if (maxY === -Number.MAX_VALUE || !Utils.isNumber(maxY)) {
          // no data in the chart. Either all series collapsed or user passed a blank array
          gl.yAxisScale[index] = this.linearScale(0, 5, 5);
        } else {
          // there is some data. Turn off the allSeriesCollapsed flag
          gl.allSeriesCollapsed = false;

          if ((y.min !== undefined || y.max !== undefined) && !y.forceNiceScale) {
            // fix https://github.com/apexcharts/apexcharts.js/issues/492
            gl.yAxisScale[index] = this.linearScale(minY, maxY, y.tickAmount);
          } else {
            var diff = Math.abs(maxY - minY);
            gl.yAxisScale[index] = this.niceScale(minY, maxY, diff, index, // fix https://github.com/apexcharts/apexcharts.js/issues/397
            y.tickAmount ? y.tickAmount : diff < 5 && diff > 1 ? diff + 1 : 5);
          }
        }
      }
    }
  }, {
    key: "setMultipleYScales",
    value: function setMultipleYScales() {
      var _this = this;

      var gl = this.w.globals;
      var cnf = this.w.config;
      var minYArr = gl.minYArr.concat([]);
      var maxYArr = gl.maxYArr.concat([]);
      var scalesIndices = []; // here, we loop through the yaxis array and find the item which has "seriesName" property

      cnf.yaxis.forEach(function (yaxe, i) {
        var index = i;
        cnf.series.forEach(function (s, si) {
          // if seriesName matches and that series is not collapsed, we use that scale
          if (s.name === yaxe.seriesName && gl.collapsedSeriesIndices.indexOf(si) === -1) {
            index = si;

            if (i !== si) {
              scalesIndices.push({
                index: si,
                similarIndex: i,
                alreadyExists: true
              });
            } else {
              scalesIndices.push({
                index: si
              });
            }
          }
        });
        var minY = minYArr[index];
        var maxY = maxYArr[index];

        _this.setYScaleForIndex(i, minY, maxY);
      });
      this.sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices);
    }
  }, {
    key: "sameScaleInMultipleAxes",
    value: function sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices) {
      var _this2 = this;

      var cnf = this.w.config;
      var gl = this.w.globals; // we got the scalesIndices array in the above code, but we need to filter out the items which doesn't have same scales

      var similarIndices = [];
      scalesIndices.forEach(function (scale) {
        if (scale.alreadyExists) {
          if (typeof similarIndices[scale.index] === 'undefined') {
            similarIndices[scale.index] = [];
          }

          similarIndices[scale.index].push(scale.index);
          similarIndices[scale.index].push(scale.similarIndex);
        }
      });

      function intersect(a, b) {
        return a.filter(function (value) {
          return b.indexOf(value) !== -1;
        });
      }

      gl.yAxisSameScaleIndices = similarIndices;
      similarIndices.forEach(function (si, i) {
        similarIndices.forEach(function (sj, j) {
          if (i !== j) {
            if (intersect(si, sj).length > 0) {
              similarIndices[i] = similarIndices[i].concat(similarIndices[j]);
            }
          }
        });
      }); // then, we remove duplicates from the similarScale array

      var uniqueSimilarIndices = similarIndices.map(function (item) {
        return item.filter(function (i, pos) {
          return item.indexOf(i) === pos;
        });
      }); // sort further to remove whole duplicate arrays later

      var sortedIndices = uniqueSimilarIndices.map(function (s) {
        return s.sort();
      }); // remove undefined items

      similarIndices = similarIndices.filter(function (s) {
        return !!s;
      });
      var indices = sortedIndices.slice();
      var stringIndices = indices.map(function (ind) {
        return JSON.stringify(ind);
      });
      indices = indices.filter(function (ind, p) {
        return stringIndices.indexOf(JSON.stringify(ind)) === p;
      });
      var sameScaleMinYArr = [];
      var sameScaleMaxYArr = [];
      minYArr.forEach(function (minYValue, yi) {
        indices.forEach(function (scale, i) {
          // we compare only the yIndex which exists in the indices array
          if (scale.indexOf(yi) > -1) {
            if (typeof sameScaleMinYArr[i] === 'undefined') {
              sameScaleMinYArr[i] = [];
              sameScaleMaxYArr[i] = [];
            }

            sameScaleMinYArr[i].push({
              key: yi,
              value: minYValue
            });
            sameScaleMaxYArr[i].push({
              key: yi,
              value: maxYArr[yi]
            });
          }
        });
      });
      var sameScaleMin = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, Number.MIN_VALUE);
      var sameScaleMax = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      sameScaleMinYArr.forEach(function (s, i) {
        s.forEach(function (sc, j) {
          sameScaleMin[i] = Math.min(sc.value, sameScaleMin[i]);
        });
      });
      sameScaleMaxYArr.forEach(function (s, i) {
        s.forEach(function (sc, j) {
          sameScaleMax[i] = Math.max(sc.value, sameScaleMax[i]);
        });
      });
      minYArr.forEach(function (min, i) {
        sameScaleMaxYArr.forEach(function (s, si) {
          var minY = sameScaleMin[si];
          var maxY = sameScaleMax[si];

          if (cnf.chart.stacked) {
            // for stacked charts, we need to add the values
            maxY = 0;
            s.forEach(function (ind, k) {
              maxY += ind.value;

              if (minY !== Number.MIN_VALUE) {
                minY += sameScaleMinYArr[si][k].value;
              }
            });
          }

          s.forEach(function (ind, k) {
            if (s[k].key === i) {
              if (cnf.yaxis[i].min !== undefined) {
                if (typeof cnf.yaxis[i].min === 'function') {
                  minY = cnf.yaxis[i].min(gl.minY);
                } else {
                  minY = cnf.yaxis[i].min;
                }
              }

              if (cnf.yaxis[i].max !== undefined) {
                if (typeof cnf.yaxis[i].max === 'function') {
                  maxY = cnf.yaxis[i].max(gl.maxY);
                } else {
                  maxY = cnf.yaxis[i].max;
                }
              }

              _this2.setYScaleForIndex(i, minY, maxY);
            }
          });
        });
      });
    }
  }, {
    key: "autoScaleY",
    value: function autoScaleY(ctx, yaxis, e) {
      if (!ctx) {
        ctx = this;
      }

      var w = ctx.w;

      if (w.globals.isMultipleYAxis) {
        // The autoScale option for multiple y-axis is turned off as it leads to buggy behavior.
        return yaxis;
      }

      var seriesX = w.globals.seriesX[0];
      var isStacked = w.config.chart.stacked;
      yaxis.forEach(function (yaxe, yI) {
        var firstXIndex = 0;

        for (var xi = 0; xi < seriesX.length; xi++) {
          if (seriesX[xi] >= e.xaxis.min) {
            firstXIndex = xi;
            break;
          }
        }

        var initialMin = w.globals.minYArr[yI];
        var initialMax = w.globals.maxYArr[yI];
        var min, max;
        var stackedSer = w.globals.stackedSeriesTotals;
        w.globals.series.forEach(function (serie, sI) {
          var firstValue = serie[firstXIndex];

          if (isStacked) {
            firstValue = stackedSer[firstXIndex];
            min = max = firstValue;
            stackedSer.forEach(function (y, yI) {
              if (seriesX[yI] <= e.xaxis.max && seriesX[yI] >= e.xaxis.min) {
                if (y > max && y !== null) max = y;
                if (serie[yI] < min && serie[yI] !== null) min = serie[yI];
              }
            });
          } else {
            min = max = firstValue;
            serie.forEach(function (y, yI) {
              if (seriesX[yI] <= e.xaxis.max && seriesX[yI] >= e.xaxis.min) {
                var valMin = y;
                var valMax = y;
                w.globals.series.forEach(function (wS, wSI) {
                  if (y !== null) {
                    valMin = Math.min(wS[yI], valMin);
                    valMax = Math.max(wS[yI], valMax);
                  }
                });
                if (valMax > max && valMax !== null) max = valMax;
                if (valMin < min && valMin !== null) min = valMin;
              }
            });
          }

          if (min === undefined && max === undefined) {
            min = initialMin;
            max = initialMax;
          }

          min *= min < 0 ? 1.1 : 0.9;
          max *= max < 0 ? 0.9 : 1.1;

          if (max < 0 && max < initialMax) {
            max = initialMax;
          }

          if (min < 0 && min > initialMin) {
            min = initialMin;
          }

          if (yaxis.length > 1) {
            yaxis[sI].min = yaxe.min === undefined ? min : yaxe.min;
            yaxis[sI].max = yaxe.max === undefined ? max : yaxe.max;
          } else {
            yaxis[0].min = yaxe.min === undefined ? min : yaxe.min;
            yaxis[0].max = yaxe.max === undefined ? max : yaxe.max;
          }
        });
      });
      return yaxis;
    }
  }]);

  return Range;
}();

/**
 * Range is used to generates values between min and max.
 *
 * @module Range
 **/

var Range$1 =
/*#__PURE__*/
function () {
  function Range$$1(ctx) {
    _classCallCheck(this, Range$$1);

    this.ctx = ctx;
    this.w = ctx.w;
    this.scales = new Range(ctx);
  }

  _createClass(Range$$1, [{
    key: "init",
    value: function init() {
      this.setYRange();
      this.setXRange();
      this.setZRange();
    }
  }, {
    key: "getMinYMaxY",
    value: function getMinYMaxY(startingIndex) {
      var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
      var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;
      var len = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var gl = this.w.globals;
      var maxY = -Number.MAX_VALUE;
      var minY = Number.MIN_VALUE;

      if (len === null) {
        len = startingIndex + 1;
      }

      var series = gl.series;
      var seriesMin = series;
      var seriesMax = series;

      if (this.w.config.chart.type === 'candlestick') {
        seriesMin = gl.seriesCandleL;
        seriesMax = gl.seriesCandleH;
      } else if (gl.isRangeData) {
        seriesMin = gl.seriesRangeStart;
        seriesMax = gl.seriesRangeEnd;
      }

      for (var i = startingIndex; i < len; i++) {
        gl.dataPoints = Math.max(gl.dataPoints, series[i].length);

        for (var j = 0; j < gl.series[i].length; j++) {
          var val = series[i][j];

          if (val !== null && Utils.isNumber(val)) {
            maxY = Math.max(maxY, seriesMax[i][j]);
            lowestY = Math.min(lowestY, seriesMin[i][j]);
            highestY = Math.max(highestY, seriesMin[i][j]);

            if (this.w.config.chart.type === 'candlestick') {
              maxY = Math.max(maxY, gl.seriesCandleO[i][j]);
              maxY = Math.max(maxY, gl.seriesCandleH[i][j]);
              maxY = Math.max(maxY, gl.seriesCandleL[i][j]);
              maxY = Math.max(maxY, gl.seriesCandleC[i][j]);
              highestY = maxY;
            }

            if (Utils.isFloat(val)) {
              val = Utils.noExponents(val);
              gl.yValueDecimal = Math.max(gl.yValueDecimal, val.toString().split('.')[1].length);
            }

            if (minY > seriesMin[i][j] && seriesMin[i][j] < 0) {
              minY = seriesMin[i][j];
            }
          } else {
            gl.hasNullValues = true;
          }
        }
      }

      return {
        minY: minY,
        maxY: maxY,
        lowestY: lowestY,
        highestY: highestY
      };
    }
  }, {
    key: "setYRange",
    value: function setYRange() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.maxY = -Number.MAX_VALUE;
      gl.minY = Number.MIN_VALUE;
      var lowestYInAllSeries = Number.MAX_VALUE;

      if (gl.isMultipleYAxis) {
        // we need to get minY and maxY for multiple y axis
        for (var i = 0; i < gl.series.length; i++) {
          var minYMaxYArr = this.getMinYMaxY(i, lowestYInAllSeries, null, i + 1);
          gl.minYArr.push(minYMaxYArr.minY);
          gl.maxYArr.push(minYMaxYArr.maxY);
          lowestYInAllSeries = minYMaxYArr.lowestY;
        }
      } // and then, get the minY and maxY from all series


      var minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);
      gl.minY = minYMaxY.minY;
      gl.maxY = minYMaxY.maxY;
      lowestYInAllSeries = minYMaxY.lowestY;

      if (cnf.chart.stacked) {
        // for stacked charts, we calculate each series's parallel values. i.e, series[0][j] + series[1][j] .... [series[i.length][j]] and get the max out of it
        var stackedPoss = [];
        var stackedNegs = [];

        if (gl.series.length) {
          for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {
            var poss = 0;
            var negs = 0;

            for (var _i = 0; _i < gl.series.length; _i++) {
              if (gl.series[_i][j] !== null && Utils.isNumber(gl.series[_i][j])) {
                if (gl.series[_i][j] > 0) {
                  // 0.0001 fixes #185 when values are very small
                  poss = poss + parseFloat(gl.series[_i][j]) + 0.0001;
                } else {
                  negs = negs + parseFloat(gl.series[_i][j]);
                }
              }

              if (_i === gl.series.length - 1) {
                // push all the totals to the array for future use
                stackedPoss.push(poss);
                stackedNegs.push(negs);
              }
            }
          }
        } // get the max/min out of the added parallel values


        for (var z = 0; z < stackedPoss.length; z++) {
          gl.maxY = Math.max(gl.maxY, stackedPoss[z]);
          gl.minY = Math.min(gl.minY, stackedNegs[z]);
        }
      } // if the numbers are too big, reduce the range
      // for eg, if number is between 100000-110000, putting 0 as the lowest value is not so good idea. So change the gl.minY for line/area/candlesticks


      if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'candlestick') {
        if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE && lowestYInAllSeries !== gl.maxY // single value possibility
        ) {
            var diff = gl.maxY - lowestYInAllSeries;

            if (lowestYInAllSeries >= 0 && lowestYInAllSeries <= 10) {
              // if minY is already 0/low value, we don't want to go negatives here - so this check is essential.
              diff = 0;
            }

            gl.minY = lowestYInAllSeries - diff * 5 / 100; // if (lowestYInAllSeries > 0 && gl.minY < 0) {

            /* fix https://github.com/apexcharts/apexcharts.js/issues/614 */
            //  gl.minY = 0
            // }

            /* fix https://github.com/apexcharts/apexcharts.js/issues/426 */

            gl.maxY = gl.maxY + diff * 5 / 100;
          }
      }

      cnf.yaxis.map(function (yaxe, index) {
        // override all min/max values by user defined values (y axis)
        if (yaxe.max !== undefined) {
          if (typeof yaxe.max === 'number') {
            gl.maxYArr[index] = yaxe.max;
          } else if (typeof yaxe.max === 'function') {
            gl.maxYArr[index] = yaxe.max(gl.maxY);
          } // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis


          gl.maxY = gl.maxYArr[index];
        }

        if (yaxe.min !== undefined) {
          if (typeof yaxe.min === 'number') {
            gl.minYArr[index] = yaxe.min;
          } else if (typeof yaxe.min === 'function') {
            gl.minYArr[index] = yaxe.min(gl.minY);
          } // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis


          gl.minY = gl.minYArr[index];
        }
      }); // for horizontal bar charts, we need to check xaxis min/max as user may have specified there

      if (gl.isBarHorizontal) {
        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {
          gl.minY = cnf.xaxis.min;
        }

        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {
          gl.maxY = cnf.xaxis.max;
        }
      } // for multi y-axis we need different scales for each


      if (gl.isMultipleYAxis) {
        this.scales.setMultipleYScales();
        gl.minY = lowestYInAllSeries;
        gl.yAxisScale.forEach(function (scale, i) {
          gl.minYArr[i] = scale.niceMin;
          gl.maxYArr[i] = scale.niceMax;
        });
      } else {
        this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);
        gl.minY = gl.yAxisScale[0].niceMin;
        gl.maxY = gl.yAxisScale[0].niceMax;
        gl.minYArr[0] = gl.yAxisScale[0].niceMin;
        gl.maxYArr[0] = gl.yAxisScale[0].niceMax;
      }

      return {
        minY: gl.minY,
        maxY: gl.maxY,
        minYArr: gl.minYArr,
        maxYArr: gl.maxYArr
      };
    }
  }, {
    key: "setXRange",
    value: function setXRange() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided || gl.noLabelsProvided || gl.isXNumeric; // minX maxX starts here

      if (gl.isXNumeric) {
        for (var i = 0; i < gl.series.length; i++) {
          if (gl.labels[i]) {
            for (var j = 0; j < gl.labels[i].length; j++) {
              if (gl.labels[i][j] !== null && Utils.isNumber(gl.labels[i][j])) {
                gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);
                gl.initialmaxX = Math.max(gl.maxX, gl.labels[i][j]);
                gl.minX = Math.min(gl.minX, gl.labels[i][j]);
                gl.initialminX = Math.min(gl.minX, gl.labels[i][j]);
              }
            }
          }
        }
      }

      if (gl.noLabelsProvided) {
        if (cnf.xaxis.categories.length === 0) {
          gl.maxX = gl.labels[gl.labels.length - 1];
          gl.initialmaxX = gl.labels[gl.labels.length - 1];
          gl.minX = 1;
          gl.initialminX = 1;
        }
      } // for numeric xaxis, we need to adjust some padding left and right for bar charts


      if (gl.comboChartsHasBars || cnf.chart.type === 'candlestick' || cnf.chart.type === 'bar' && gl.isXNumeric) {
        if (cnf.xaxis.type !== 'category' || gl.isXNumeric) {
          var t = gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth); // some padding to the left to prevent cropping of the bars

          var minX = gl.minX - t / 2;
          gl.minX = minX;
          gl.initialminX = minX; // some padding to the right to prevent cropping of the bars

          var maxX = gl.maxX + t / ((gl.series.length + 1) / gl.series.length);
          gl.maxX = maxX;
          gl.initialmaxX = maxX;
        }
      }

      if ((gl.isXNumeric || gl.noLabelsProvided) && (!cnf.xaxis.convertedCatToNumeric || gl.dataFormatXNumeric)) {
        var ticks;

        if (cnf.xaxis.tickAmount === undefined) {
          ticks = Math.round(gl.svgWidth / 150); // no labels provided and total number of dataPoints is less than 20

          if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 20) {
            ticks = gl.dataPoints - 1;
          } // this check is for when ticks exceeds total datapoints and that would result in duplicate labels


          if (ticks > gl.dataPoints && gl.dataPoints !== 0) {
            ticks = gl.dataPoints - 1;
          }
        } else if (cnf.xaxis.tickAmount === 'dataPoints') {
          ticks = gl.series[gl.maxValsInArrayIndex].length - 1;
        } else {
          ticks = cnf.xaxis.tickAmount;
        } // override all min/max values by user defined values (x axis)


        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {
          gl.maxX = cnf.xaxis.max;
        }

        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {
          gl.minX = cnf.xaxis.min;
        } // if range is provided, adjust the new minX


        if (cnf.xaxis.range !== undefined) {
          gl.minX = gl.maxX - cnf.xaxis.range;
        }

        if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {
          gl.xAxisScale = this.scales.linearScale(gl.minX, gl.maxX, ticks);
        } else {
          gl.xAxisScale = this.scales.linearScale(1, ticks, ticks);

          if (gl.noLabelsProvided && gl.labels.length > 0) {
            gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1); // this is the only place seriesX is again mutated

            gl.seriesX = gl.labels.slice();
          }
        } // we will still store these labels as the count for this will be different (to draw grid and labels placement)


        if (isXNumeric) {
          gl.labels = gl.xAxisScale.result.slice();
        }
      }

      if (gl.minX === gl.maxX) {
        // single dataPoint
        if (cnf.xaxis.type === 'datetime') {
          var newMinX = new Date(gl.minX);
          newMinX.setDate(newMinX.getDate() - 2);
          gl.minX = new Date(newMinX).getTime();
          var newMaxX = new Date(gl.maxX);
          newMaxX.setDate(newMaxX.getDate() + 2);
          gl.maxX = new Date(newMaxX).getTime();
        } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {
          gl.minX = gl.minX - 2;
          gl.maxX = gl.maxX + 2;
        }
      }

      if (gl.isXNumeric) {
        // get the least x diff if numeric x axis is present
        gl.seriesX.forEach(function (sX, i) {
          sX.forEach(function (s, j) {
            if (j > 0) {
              var xDiff = s - gl.seriesX[i][j - 1];
              gl.minXDiff = Math.min(xDiff, gl.minXDiff);
            }
          });
        });
        this.calcMinXDiffForTinySeries();
      }

      return {
        minX: gl.minX,
        maxX: gl.maxX
      };
    }
  }, {
    key: "calcMinXDiffForTinySeries",
    value: function calcMinXDiffForTinySeries() {
      var w = this.w;
      var len = w.globals.labels.length;

      if (w.globals.labels.length === 1) {
        w.globals.minXDiff = (w.globals.maxX - w.globals.minX) / len / 3;
      } else {
        if (w.globals.minXDiff === Number.MAX_VALUE) {
          // possibly a single dataPoint (fixes react-apexcharts/issue#34)
          if (w.globals.timelineLabels.length > 0) {
            len = w.globals.timelineLabels.length;
          }

          if (len < 3) {
            len = 3;
          }

          w.globals.minXDiff = (w.globals.maxX - w.globals.minX) / len;
        }
      }

      return w.globals.minXDiff;
    }
  }, {
    key: "setZRange",
    value: function setZRange() {
      var gl = this.w.globals; // minZ, maxZ starts here

      if (gl.isDataXYZ) {
        for (var i = 0; i < gl.series.length; i++) {
          if (typeof gl.seriesZ[i] !== 'undefined') {
            for (var j = 0; j < gl.seriesZ[i].length; j++) {
              if (gl.seriesZ[i][j] !== null && Utils.isNumber(gl.seriesZ[i][j])) {
                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);
                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);
              }
            }
          }
        }
      }
    }
  }]);

  return Range$$1;
}();

/**
 * ApexCharts TimeScale Class for generating time ticks for x-axis.
 *
 * @module TimeScale
 **/

var TimeScale =
/*#__PURE__*/
function () {
  function TimeScale(ctx) {
    _classCallCheck(this, TimeScale);

    this.ctx = ctx;
    this.w = ctx.w;
    this.timeScaleArray = [];
  }

  _createClass(TimeScale, [{
    key: "calculateTimeScaleTicks",
    value: function calculateTimeScaleTicks(minX, maxX) {
      var _this = this;

      var w = this.w; // null check when no series to show

      if (w.globals.allSeriesCollapsed) {
        w.globals.labels = [];
        w.globals.timelineLabels = [];
        return [];
      }

      var dt = new DateTime(this.ctx);
      var daysDiff = (maxX - minX) / (1000 * 60 * 60 * 24);
      this.determineInterval(daysDiff);
      w.globals.disableZoomIn = false;
      w.globals.disableZoomOut = false;

      if (daysDiff < 0.005) {
        w.globals.disableZoomIn = true;
      } else if (daysDiff > 50000) {
        w.globals.disableZoomOut = true;
      }

      var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX);
      var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;
      var hoursWidthOnXAxis = daysWidthOnXAxis / 24;
      var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;
      var numberOfHours = Math.floor(daysDiff * 24);
      var numberOfMinutes = Math.floor(daysDiff * 24 * 60);
      var numberOfDays = Math.floor(daysDiff);
      var numberOfMonths = Math.floor(daysDiff / 30);
      var numberOfYears = Math.floor(daysDiff / 365);
      var firstVal = {
        minMinute: timeIntervals.minMinute,
        minHour: timeIntervals.minHour,
        minDate: timeIntervals.minDate,
        minMonth: timeIntervals.minMonth,
        minYear: timeIntervals.minYear
      };
      var currentMinute = firstVal.minMinute;
      var currentHour = firstVal.minHour;
      var currentMonthDate = firstVal.minDate;
      var currentDate = firstVal.minDate;
      var currentMonth = firstVal.minMonth;
      var currentYear = firstVal.minYear;
      var params = {
        firstVal: firstVal,
        currentMinute: currentMinute,
        currentHour: currentHour,
        currentMonthDate: currentMonthDate,
        currentDate: currentDate,
        currentMonth: currentMonth,
        currentYear: currentYear,
        daysWidthOnXAxis: daysWidthOnXAxis,
        hoursWidthOnXAxis: hoursWidthOnXAxis,
        minutesWidthOnXAxis: minutesWidthOnXAxis,
        numberOfMinutes: numberOfMinutes,
        numberOfHours: numberOfHours,
        numberOfDays: numberOfDays,
        numberOfMonths: numberOfMonths,
        numberOfYears: numberOfYears
      };

      switch (this.tickInterval) {
        case 'years':
          {
            this.generateYearScale(params);
            break;
          }

        case 'months':
        case 'half_year':
          {
            this.generateMonthScale(params);
            break;
          }

        case 'months_days':
        case 'months_fortnight':
        case 'days':
        case 'week_days':
          {
            this.generateDayScale(params);
            break;
          }

        case 'hours':
          {
            this.generateHourScale(params);
            break;
          }

        case 'minutes':
          this.generateMinuteScale(params);
          break;
      } // first, we will adjust the month values index
      // as in the upper function, it is starting from 0
      // we will start them from 1


      var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {
        var defaultReturn = {
          position: ts.position,
          unit: ts.unit,
          year: ts.year,
          day: ts.day ? ts.day : 1,
          hour: ts.hour ? ts.hour : 0,
          month: ts.month + 1
        };

        if (ts.unit === 'month') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value + 1
          });
        } else if (ts.unit === 'day' || ts.unit === 'hour') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value
          });
        } else if (ts.unit === 'minute') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value,
            minute: ts.value
          });
        }

        return ts;
      });
      var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {
        var modulo = 1;
        var ticks = Math.ceil(w.globals.gridWidth / 120);
        var value = ts.value;

        if (w.config.xaxis.tickAmount !== undefined) {
          ticks = w.config.xaxis.tickAmount;
        }

        if (adjustedMonthInTimeScaleArray.length > ticks) {
          modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);
        }

        var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months

        var shouldNotPrint = false; // should skip these values

        switch (_this.tickInterval) {
          case 'half_year':
            modulo = 7;

            if (ts.unit === 'year') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'months':
            modulo = 1;

            if (ts.unit === 'year') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'months_fortnight':
            modulo = 15;

            if (ts.unit === 'year' || ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            if (value === 30) {
              shouldNotPrint = true;
            }

            break;

          case 'months_days':
            modulo = 10;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            if (value === 30) {
              shouldNotPrint = true;
            }

            break;

          case 'week_days':
            modulo = 8;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'days':
            modulo = 1;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'hours':
            if (ts.unit === 'day') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'minutes':
            if (value % 5 !== 0) {
              shouldNotPrint = true;
            }

            break;
        }

        if (_this.tickInterval === 'minutes' || _this.tickInterval === 'hours') {
          if (!shouldNotPrint) {
            return true;
          }
        } else {
          if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {
            return true;
          }
        }
      });
      return filteredTimeScale;
    }
  }, {
    key: "recalcDimensionsBasedOnFormat",
    value: function recalcDimensionsBasedOnFormat(filteredTimeScale, inverted) {
      var w = this.w;
      var reformattedTimescaleArray = this.formatDates(filteredTimeScale);
      var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);

      if (!inverted) {
        w.globals.timelineLabels = removedOverlappingTS.slice();
      } else {
        w.globals.invertedTimelineLabels = removedOverlappingTS.slice();
      } // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords
      // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX
      // Dependency on Dimensions(), need to refactor correctly
      // TODO - find an alternate way to avoid calling this Heavy method twice


      var dimensions = new Dimensions(this.ctx);
      dimensions.plotCoords();
    }
  }, {
    key: "determineInterval",
    value: function determineInterval(daysDiff) {
      switch (true) {
        case daysDiff > 1825:
          // difference is more than 5 years
          this.tickInterval = 'years';
          break;

        case daysDiff > 800 && daysDiff <= 1825:
          this.tickInterval = 'half_year';
          break;

        case daysDiff > 180 && daysDiff <= 800:
          this.tickInterval = 'months';
          break;

        case daysDiff > 90 && daysDiff <= 180:
          this.tickInterval = 'months_fortnight';
          break;

        case daysDiff > 60 && daysDiff <= 90:
          this.tickInterval = 'months_days';
          break;

        case daysDiff > 30 && daysDiff <= 60:
          this.tickInterval = 'week_days';
          break;

        case daysDiff > 2 && daysDiff <= 30:
          this.tickInterval = 'days';
          break;

        case daysDiff > 0.1 && daysDiff <= 2:
          // less than  2 days
          this.tickInterval = 'hours';
          break;

        case daysDiff < 0.1:
          this.tickInterval = 'minutes';
          break;

        default:
          this.tickInterval = 'days';
          break;
      }
    }
  }, {
    key: "generateYearScale",
    value: function generateYearScale(params) {
      var firstVal = params.firstVal,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          daysWidthOnXAxis = params.daysWidthOnXAxis,
          numberOfYears = params.numberOfYears;
      var firstTickValue = firstVal.minYear;
      var firstTickPosition = 0;
      var dt = new DateTime(this.ctx);
      var unit = 'year';

      if (firstVal.minDate > 1 && firstVal.minMonth > 0) {
        var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate); // remainingDaysofFirstMonth is used to reacht the 2nd tick position

        var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1; // calculate the first tick position

        firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;
        firstTickValue = firstVal.minYear + 1; // push the first tick in the array

        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: firstTickValue,
          month: Utils.monthMod(currentMonth + 1)
        });
      } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {
        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: currentYear,
          month: Utils.monthMod(currentMonth + 1)
        });
      }

      var year = firstTickValue;
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfYears; i++) {
        year++;
        pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;
        this.timeScaleArray.push({
          position: pos,
          value: year,
          unit: unit,
          year: year,
          month: 1
        });
      }
    }
  }, {
    key: "generateMonthScale",
    value: function generateMonthScale(params) {
      var firstVal = params.firstVal,
          currentMonthDate = params.currentMonthDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          daysWidthOnXAxis = params.daysWidthOnXAxis,
          numberOfMonths = params.numberOfMonths;
      var firstTickValue = currentMonth;
      var firstTickPosition = 0;
      var dt = new DateTime(this.ctx);
      var unit = 'month';
      var yrCounter = 0;

      if (firstVal.minDate > 1) {
        // remainingDaysofFirstMonth is used to reacht the 2nd tick position
        var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1; // calculate the first tick position

        firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;
        firstTickValue = Utils.monthMod(currentMonth + 1);
        var year = currentYear + yrCounter;

        var _month = Utils.monthMod(firstTickValue);

        var value = firstTickValue; // it's Jan, so update the year

        if (firstTickValue === 0) {
          unit = 'year';
          value = year;
          _month = 1;
          yrCounter += 1;
          year = year + yrCounter;
        } // push the first tick in the array


        this.timeScaleArray.push({
          position: firstTickPosition,
          value: value,
          unit: unit,
          year: year,
          month: _month
        });
      } else {
        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: currentYear,
          month: Utils.monthMod(currentMonth)
        });
      }

      var month = firstTickValue + 1;
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {
        month = Utils.monthMod(month);

        if (month === 0) {
          unit = 'year';
          yrCounter += 1;
        } else {
          unit = 'month';
        }

        var _year = currentYear + Math.floor(month / 12) + yrCounter;

        pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;
        var monthVal = month === 0 ? _year : month;
        this.timeScaleArray.push({
          position: pos,
          value: monthVal,
          unit: unit,
          year: _year,
          month: month === 0 ? 1 : month
        });
        month++;
      }
    }
  }, {
    key: "generateDayScale",
    value: function generateDayScale(params) {
      var firstVal = params.firstVal,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          hoursWidthOnXAxis = params.hoursWidthOnXAxis,
          numberOfDays = params.numberOfDays;
      var dt = new DateTime(this.ctx);
      var unit = 'day';
      var remainingHours = 24 - firstVal.minHour;
      var yrCounter = 0; // calculate the first tick position

      var firstTickPosition = remainingHours * hoursWidthOnXAxis;
      var firstTickValue = firstVal.minDate + 1;
      var val = firstTickValue;

      var changeMonth = function changeMonth(dateVal, month, year) {
        var monthdays = dt.determineDaysOfMonths(month + 1, year);

        if (dateVal > monthdays) {
          month = month + 1;
          date = 1;
          unit = 'month';
          val = month;
          return month;
        }

        return month;
      };

      var date = firstTickValue;
      var month = changeMonth(date, currentMonth, currentYear); // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: val,
        unit: unit,
        year: currentYear,
        month: Utils.monthMod(month),
        day: date
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfDays; i++) {
        date += 1;
        unit = 'day';
        month = changeMonth(date, month, currentYear + Math.floor(month / 12) + yrCounter);
        var year = currentYear + Math.floor(month / 12) + yrCounter;
        pos = 24 * hoursWidthOnXAxis + pos;

        var _val = date === 1 ? Utils.monthMod(month) : date;

        this.timeScaleArray.push({
          position: pos,
          value: _val,
          unit: unit,
          year: year,
          month: Utils.monthMod(month),
          day: _val
        });
      }
    }
  }, {
    key: "generateHourScale",
    value: function generateHourScale(params) {
      var firstVal = params.firstVal,
          currentDate = params.currentDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          minutesWidthOnXAxis = params.minutesWidthOnXAxis,
          numberOfHours = params.numberOfHours;
      var dt = new DateTime(this.ctx);
      var yrCounter = 0;
      var unit = 'hour';

      var changeDate = function changeDate(dateVal, month) {
        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);

        if (dateVal > monthdays) {
          date = 1;
          month = month + 1;
        }

        return {
          month: month,
          date: date
        };
      };

      var changeMonth = function changeMonth(dateVal, month) {
        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);

        if (dateVal > monthdays) {
          month = month + 1;
          return month;
        }

        return month;
      };

      var remainingMins = 60 - firstVal.minMinute;
      var firstTickPosition = remainingMins * minutesWidthOnXAxis;
      var firstTickValue = firstVal.minHour + 1;
      var hour = firstTickValue + 1;

      if (remainingMins === 60) {
        firstTickPosition = 0;
        firstTickValue = firstVal.minHour;
        hour = firstTickValue + 1;
      }

      var date = currentDate;
      var month = changeMonth(date, currentMonth); // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: firstTickValue,
        unit: unit,
        day: date,
        hour: hour,
        year: currentYear,
        month: Utils.monthMod(month)
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfHours; i++) {
        unit = 'hour';

        if (hour >= 24) {
          hour = 0;
          date += 1;
          unit = 'day';
          var checkNextMonth = changeDate(date, month);
          month = checkNextMonth.month;
          month = changeMonth(date, month);
        }

        var year = currentYear + Math.floor(month / 12) + yrCounter;
        pos = hour === 0 && i === 0 ? remainingMins * minutesWidthOnXAxis : 60 * minutesWidthOnXAxis + pos;
        var val = hour === 0 ? date : hour;
        this.timeScaleArray.push({
          position: pos,
          value: val,
          unit: unit,
          hour: hour,
          day: date,
          year: year,
          month: Utils.monthMod(month)
        });
        hour++;
      }
    }
  }, {
    key: "generateMinuteScale",
    value: function generateMinuteScale(params) {
      var firstVal = params.firstVal,
          currentMinute = params.currentMinute,
          currentHour = params.currentHour,
          currentDate = params.currentDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          minutesWidthOnXAxis = params.minutesWidthOnXAxis,
          numberOfMinutes = params.numberOfMinutes;
      var yrCounter = 0;
      var unit = 'minute';
      var remainingMins = currentMinute - firstVal.minMinute;
      var firstTickPosition = minutesWidthOnXAxis - remainingMins;
      var firstTickValue = firstVal.minMinute + 1;
      var minute = firstTickValue + 1;
      var date = currentDate;
      var month = currentMonth;
      var year = currentYear;
      var hour = currentHour; // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: firstTickValue,
        unit: unit,
        day: date,
        hour: hour,
        minute: minute,
        year: year,
        month: Utils.monthMod(month)
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfMinutes; i++) {
        if (minute >= 60) {
          minute = 0;
          hour += 1;

          if (hour === 24) {
            hour = 0;
          }
        }

        var _year2 = currentYear + Math.floor(month / 12) + yrCounter;

        pos = minutesWidthOnXAxis + pos;
        var val = minute;
        this.timeScaleArray.push({
          position: pos,
          value: val,
          unit: unit,
          hour: hour,
          minute: minute,
          day: date,
          year: _year2,
          month: Utils.monthMod(month)
        });
        minute++;
      }
    }
  }, {
    key: "createRawDateString",
    value: function createRawDateString(ts, value) {
      var raw = ts.year;
      raw += '-' + ('0' + ts.month.toString()).slice(-2); // unit is day

      if (ts.unit === 'day') {
        raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';
      } else {
        raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);
      } // unit is hour


      if (ts.unit === 'hour') {
        raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';
      } else {
        raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);
      } // unit is minute


      raw += ts.unit === 'minute' ? ':' + ('0' + value).slice(-2) + ':00.000Z' : ':00:00.000Z';
      return raw;
    }
  }, {
    key: "formatDates",
    value: function formatDates(filteredTimeScale) {
      var _this2 = this;

      var w = this.w;
      var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {
        var value = ts.value.toString();
        var dt = new DateTime(_this2.ctx);

        var raw = _this2.createRawDateString(ts, value); // parse the whole ISO datestring


        var dateString = new Date(Date.parse(raw));

        if (w.config.xaxis.labels.format === undefined) {
          var customFormat = 'dd MMM';
          var dtFormatter = w.config.xaxis.labels.datetimeFormatter;
          if (ts.unit === 'year') customFormat = dtFormatter.year;
          if (ts.unit === 'month') customFormat = dtFormatter.month;
          if (ts.unit === 'day') customFormat = dtFormatter.day;
          if (ts.unit === 'hour') customFormat = dtFormatter.hour;
          if (ts.unit === 'minute') customFormat = dtFormatter.minute;
          value = dt.formatDate(dateString, customFormat, true, false);
        } else {
          value = dt.formatDate(dateString, w.config.xaxis.labels.format);
        }

        return {
          dateString: raw,
          position: ts.position,
          value: value,
          unit: ts.unit,
          year: ts.year,
          month: ts.month
        };
      });
      return reformattedTimescaleArray;
    }
  }, {
    key: "removeOverlappingTS",
    value: function removeOverlappingTS(arr) {
      var _this3 = this;

      var graphics = new Graphics(this.ctx);
      var lastDrawnIndex = 0;
      var filteredArray = arr.map(function (item, index) {
        if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {
          var prevLabelWidth = graphics.getTextRects(arr[lastDrawnIndex].value).width;
          var prevPos = arr[lastDrawnIndex].position;
          var pos = item.position;

          if (pos > prevPos + prevLabelWidth + 10) {
            lastDrawnIndex = index;
            return item;
          } else {
            return null;
          }
        } else {
          return item;
        }
      });
      filteredArray = filteredArray.filter(function (f) {
        return f !== null;
      });
      return filteredArray;
    }
  }]);

  return TimeScale;
}();

/**
 * ApexCharts Core Class responsible for major calculations and creating elements.
 *
 * @module Core
 **/

var Core =
/*#__PURE__*/
function () {
  function Core(el, ctx) {
    _classCallCheck(this, Core);

    this.ctx = ctx;
    this.w = ctx.w;
    this.el = el;
    this.coreUtils = new CoreUtils(this.ctx);
    this.twoDSeries = [];
    this.threeDSeries = [];
    this.twoDSeriesX = [];
  } // get data and store into appropriate vars


  _createClass(Core, [{
    key: "setupElements",
    value: function setupElements() {
      var gl = this.w.globals;
      var cnf = this.w.config; // const graphics = new Graphics(this.ctx)

      var ct = cnf.chart.type;
      var axisChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', // 'rangeArea',
      'candlestick', 'radar', 'scatter', 'bubble', 'heatmap'];
      var xyChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', // 'rangeArea',
      'candlestick', 'scatter', 'bubble'];
      gl.axisCharts = axisChartsArrTypes.indexOf(ct) > -1;
      gl.xyCharts = xyChartsArrTypes.indexOf(ct) > -1;
      gl.isBarHorizontal = (cnf.chart.type === 'bar' || cnf.chart.type === 'rangeBar') && cnf.plotOptions.bar.horizontal;
      gl.chartClass = '.apexcharts' + gl.cuid;
      gl.dom.baseEl = this.el;
      gl.dom.elWrap = document.createElement('div');
      Graphics.setAttrs(gl.dom.elWrap, {
        id: gl.chartClass.substring(1),
        class: 'apexcharts-canvas ' + gl.chartClass.substring(1)
      });
      this.el.appendChild(gl.dom.elWrap);
      gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap);
      gl.dom.Paper.attr({
        class: 'apexcharts-svg',
        'xmlns:data': 'ApexChartsNS',
        transform: "translate(".concat(cnf.chart.offsetX, ", ").concat(cnf.chart.offsetY, ")")
      });
      gl.dom.Paper.node.style.background = cnf.chart.background;
      this.setSVGDimensions();
      gl.dom.elGraphical = gl.dom.Paper.group().attr({
        class: 'apexcharts-inner apexcharts-graphical'
      });
      gl.dom.elDefs = gl.dom.Paper.defs();
      gl.dom.elLegendWrap = document.createElement('div');
      gl.dom.elLegendWrap.classList.add('apexcharts-legend');
      gl.dom.elWrap.appendChild(gl.dom.elLegendWrap); // gl.dom.Paper.add(gl.dom.elLegendWrap)

      gl.dom.Paper.add(gl.dom.elGraphical);
      gl.dom.elGraphical.add(gl.dom.elDefs);
    }
  }, {
    key: "plotChartType",
    value: function plotChartType(ser, xyRatios) {
      var w = this.w;
      var cnf = w.config;
      var gl = w.globals;
      var lineSeries = {
        series: [],
        i: []
      };
      var areaSeries = {
        series: [],
        i: []
      };
      var scatterSeries = {
        series: [],
        i: []
      };
      var columnSeries = {
        series: [],
        i: []
      };
      var candlestickSeries = {
        series: [],
        i: []
      };
      gl.series.map(function (series, st) {
        // if user has specified a particular type for particular series
        if (typeof ser[st].type !== 'undefined') {
          if (ser[st].type === 'column' || ser[st].type === 'bar') {
            w.config.plotOptions.bar.horizontal = false; // horizontal bars not supported in mixed charts, hence forcefully set to false

            columnSeries.series.push(series);
            columnSeries.i.push(st);
          } else if (ser[st].type === 'area') {
            areaSeries.series.push(series);
            areaSeries.i.push(st);
          } else if (ser[st].type === 'line') {
            lineSeries.series.push(series);
            lineSeries.i.push(st);
          } else if (ser[st].type === 'scatter') {
            scatterSeries.series.push(series);
            scatterSeries.i.push(st);
          } else if (ser[st].type === 'bubble') ; else if (ser[st].type === 'candlestick') {
            candlestickSeries.series.push(series);
            candlestickSeries.i.push(st);
          } else {
            // user has specified type, but it is not valid (other than line/area/column)
            console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble');
          }

          gl.comboCharts = true;
        } else {
          lineSeries.series.push(series);
          lineSeries.i.push(st);
        }
      });
      var line = new Line(this.ctx, xyRatios);
      var candlestick = new CandleStick(this.ctx, xyRatios);
      var pie = new Pie(this.ctx);
      var radialBar = new Radial(this.ctx);
      var rangeBar = new RangeBar(this.ctx, xyRatios);
      var radar = new Radar(this.ctx);
      var elGraph = [];

      if (gl.comboCharts) {
        if (areaSeries.series.length > 0) {
          elGraph.push(line.draw(areaSeries.series, 'area', areaSeries.i));
        }

        if (columnSeries.series.length > 0) {
          if (w.config.chart.stacked) {
            var barStacked = new BarStacked(this.ctx, xyRatios);
            elGraph.push(barStacked.draw(columnSeries.series, columnSeries.i));
          } else {
            var bar = new Bar(this.ctx, xyRatios);
            elGraph.push(bar.draw(columnSeries.series, columnSeries.i));
          }
        }

        if (lineSeries.series.length > 0) {
          elGraph.push(line.draw(lineSeries.series, 'line', lineSeries.i));
        }

        if (candlestickSeries.series.length > 0) {
          elGraph.push(candlestick.draw(candlestickSeries.series, candlestickSeries.i));
        }

        if (scatterSeries.series.length > 0) {
          var scatterLine = new Line(this.ctx, xyRatios, true);
          elGraph.push(scatterLine.draw(scatterSeries.series, 'scatter', scatterSeries.i));
        } // TODO: allow bubble series in a combo chart
        // if (bubbleSeries.series.length > 0) {
        //   const bubbleLine = new Line(this.ctx, xyRatios, true)
        //   elGraph.push(
        //     bubbleLine.draw(bubbleSeries.series, 'bubble', bubbleSeries.i)
        //   )
        // }

      } else {
        switch (cnf.chart.type) {
          case 'line':
            elGraph = line.draw(gl.series, 'line');
            break;

          case 'area':
            elGraph = line.draw(gl.series, 'area');
            break;

          case 'bar':
            if (cnf.chart.stacked) {
              var _barStacked = new BarStacked(this.ctx, xyRatios);

              elGraph = _barStacked.draw(gl.series);
            } else {
              var _bar = new Bar(this.ctx, xyRatios);

              elGraph = _bar.draw(gl.series);
            }

            break;

          case 'candlestick':
            var candleStick = new CandleStick(this.ctx, xyRatios);
            elGraph = candleStick.draw(gl.series);
            break;

          case 'rangeBar':
            elGraph = rangeBar.draw(gl.series);
            break;

          case 'heatmap':
            var heatmap = new HeatMap(this.ctx, xyRatios);
            elGraph = heatmap.draw(gl.series);
            break;

          case 'pie':
          case 'donut':
            elGraph = pie.draw(gl.series);
            break;

          case 'radialBar':
            elGraph = radialBar.draw(gl.series);
            break;

          case 'radar':
            elGraph = radar.draw(gl.series);
            break;

          default:
            elGraph = line.draw(gl.series);
        }
      }

      return elGraph;
    }
  }, {
    key: "setSVGDimensions",
    value: function setSVGDimensions() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.svgWidth = cnf.chart.width;
      gl.svgHeight = cnf.chart.height;
      var elDim = Utils.getDimensions(this.el);
      var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();

      if (widthUnit === '%') {
        if (Utils.isNumber(elDim[0])) {
          if (elDim[0].width === 0) {
            elDim = Utils.getDimensions(this.el.parentNode);
          }

          gl.svgWidth = elDim[0] * parseInt(cnf.chart.width) / 100;
        }
      } else if (widthUnit === 'px' || widthUnit === '') {
        gl.svgWidth = parseInt(cnf.chart.width);
      }

      if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {
        var heightUnit = cnf.chart.height.toString().split(/[0-9]+/g).pop();

        if (heightUnit === '%') {
          var elParentDim = Utils.getDimensions(this.el.parentNode);
          gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height) / 100;
        } else {
          gl.svgHeight = parseInt(cnf.chart.height);
        }
      } else {
        if (gl.axisCharts) {
          gl.svgHeight = gl.svgWidth / 1.61;
        } else {
          gl.svgHeight = gl.svgWidth;
        }
      }

      if (gl.svgWidth < 0) gl.svgWidth = 0;
      if (gl.svgHeight < 0) gl.svgHeight = 0;
      Graphics.setAttrs(gl.dom.Paper.node, {
        width: gl.svgWidth,
        height: gl.svgHeight
      }); // gl.dom.Paper.node.parentNode.parentNode.style.minWidth = gl.svgWidth + "px";

      var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? cnf.chart.parentHeightOffset : 0;
      gl.dom.Paper.node.parentNode.parentNode.style.minHeight = gl.svgHeight + offsetY + 'px';
      gl.dom.elWrap.style.width = gl.svgWidth + 'px';
      gl.dom.elWrap.style.height = gl.svgHeight + 'px';
    }
  }, {
    key: "shiftGraphPosition",
    value: function shiftGraphPosition() {
      var gl = this.w.globals;
      var tY = gl.translateY;
      var tX = gl.translateX;
      var scalingAttrs = {
        transform: 'translate(' + tX + ', ' + tY + ')'
      };
      Graphics.setAttrs(gl.dom.elGraphical.node, scalingAttrs);
    } // To prevent extra spacings in the bottom of the chart, we need to recalculate the height for pie/donut/radialbar charts

  }, {
    key: "resizeNonAxisCharts",
    value: function resizeNonAxisCharts() {
      var w = this.w;
      var gl = w.globals;
      var legendHeight = 0;
      var offY = 20;

      if (w.config.legend.position === 'top' || w.config.legend.position === 'bottom') {
        legendHeight = new Legend(this.ctx).getLegendBBox().clwh + 10;
      }

      var radialEl = w.globals.dom.baseEl.querySelector('.apexcharts-radialbar');
      var elRadialSize = w.globals.radialSize * 2;

      if (radialEl && w.config.plotOptions.radialBar.startAngle !== -90) {
        elRadialSize = Utils.getBoundingClientRect(radialEl).height;
      }

      var chartInnerDimensions = Math.max(elRadialSize, w.globals.radialSize * 2);
      var newHeight = chartInnerDimensions + gl.translateY + legendHeight + offY;

      if (gl.dom.elLegendForeign) {
        gl.dom.elLegendForeign.setAttribute('height', newHeight);
      }

      gl.dom.elWrap.style.height = newHeight + 'px';
      Graphics.setAttrs(gl.dom.Paper.node, {
        height: newHeight
      });
      gl.dom.Paper.node.parentNode.parentNode.style.minHeight = newHeight + 'px';
    }
    /*
     ** All the calculations for setting range in charts will be done here
     */

  }, {
    key: "coreCalculations",
    value: function coreCalculations() {
      var range = new Range$1(this.ctx);
      range.init();
    }
  }, {
    key: "resetGlobals",
    value: function resetGlobals() {
      var _this = this;

      var gl = this.w.globals;
      gl.series = [];
      gl.seriesCandleO = [];
      gl.seriesCandleH = [];
      gl.seriesCandleL = [];
      gl.seriesCandleC = [];
      gl.seriesRangeStart = [];
      gl.seriesRangeEnd = [];
      gl.seriesPercent = [];
      gl.seriesX = [];
      gl.seriesZ = [];
      gl.seriesNames = [];
      gl.seriesTotals = [];
      gl.stackedSeriesTotals = [];
      gl.labels = [];
      gl.timelineLabels = [];
      gl.noLabelsProvided = false;
      gl.timescaleTicks = [];
      gl.resizeTimer = null;
      gl.selectionResizeTimer = null;

      gl.seriesXvalues = function () {
        return _this.w.config.series.map(function (s) {
          return [];
        });
      }();

      gl.seriesYvalues = function () {
        return _this.w.config.series.map(function (s) {
          return [];
        });
      }();

      gl.delayedElements = [];
      gl.pointsArray = [];
      gl.dataLabelsRects = [];
      gl.isXNumeric = false;
      gl.isDataXYZ = false;
      gl.maxY = -Number.MAX_VALUE;
      gl.minY = Number.MIN_VALUE;
      gl.minYArr = [];
      gl.maxYArr = [];
      gl.maxX = -Number.MAX_VALUE;
      gl.minX = Number.MAX_VALUE;
      gl.initialmaxX = -Number.MAX_VALUE;
      gl.initialminX = Number.MAX_VALUE;
      gl.maxDate = 0;
      gl.minDate = Number.MAX_VALUE;
      gl.minZ = Number.MAX_VALUE;
      gl.maxZ = -Number.MAX_VALUE;
      gl.minXDiff = Number.MAX_VALUE;
      gl.yAxisScale = [];
      gl.xAxisScale = null;
      gl.xAxisTicksPositions = [];
      gl.yLabelsCoords = [];
      gl.yTitleCoords = [];
      gl.xRange = 0;
      gl.yRange = [];
      gl.zRange = 0;
      gl.dataPoints = 0;
    }
  }, {
    key: "isMultipleY",
    value: function isMultipleY() {
      // user has supplied an array in yaxis property. So, turn on multipleYAxis flag
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) {
        this.w.globals.isMultipleYAxis = true;
        return true;
      }
    }
  }, {
    key: "excludeCollapsedSeriesInYAxis",
    value: function excludeCollapsedSeriesInYAxis() {
      var _this2 = this;

      var w = this.w;
      w.globals.ignoreYAxisIndexes = w.globals.collapsedSeries.map(function (collapsed, i) {
        if (_this2.w.globals.isMultipleYAxis) {
          return collapsed.index;
        }
      });
    }
  }, {
    key: "isMultiFormat",
    value: function isMultiFormat() {
      return this.isFormatXY() || this.isFormat2DArray();
    } // given format is [{x, y}, {x, y}]

  }, {
    key: "isFormatXY",
    value: function isFormatXY() {
      var series = this.w.config.series.slice();
      var sr = new Series(this.ctx);
      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();

      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {
        return true;
      }
    } // given format is [[x, y], [x, y]]

  }, {
    key: "isFormat2DArray",
    value: function isFormat2DArray() {
      var series = this.w.config.series.slice();
      var sr = new Series(this.ctx);
      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();

      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {
        return true;
      }
    }
  }, {
    key: "handleFormat2DArray",
    value: function handleFormat2DArray(ser, i) {
      var cnf = this.w.config;
      var gl = this.w.globals;

      for (var j = 0; j < ser[i].data.length; j++) {
        if (typeof ser[i].data[j][1] !== 'undefined') {
          if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4) {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1][3]));
          } else {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1]));
          }

          gl.dataFormatXNumeric = true;
        }

        if (cnf.xaxis.type === 'datetime') {
          // if timestamps are provided and xaxis type is datettime,
          var ts = new Date(ser[i].data[j][0]);
          ts = new Date(ts).getTime();
          this.twoDSeriesX.push(ts);
        } else {
          this.twoDSeriesX.push(ser[i].data[j][0]);
        }
      }

      for (var _j = 0; _j < ser[i].data.length; _j++) {
        if (typeof ser[i].data[_j][2] !== 'undefined') {
          this.threeDSeries.push(ser[i].data[_j][2]);
          gl.isDataXYZ = true;
        }
      }
    }
  }, {
    key: "handleFormatXY",
    value: function handleFormatXY(ser, i) {
      var cnf = this.w.config;
      var gl = this.w.globals;
      var dt = new DateTime(this.ctx);
      var activeI = i;

      if (gl.collapsedSeriesIndices.indexOf(i) > -1) {
        // fix #368
        activeI = this.activeSeriesIndex;
      } // get series


      for (var j = 0; j < ser[i].data.length; j++) {
        if (typeof ser[i].data[j].y !== 'undefined') {
          if (Array.isArray(ser[i].data[j].y)) {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y[ser[i].data[j].y.length - 1]));
          } else {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y));
          }
        }
      } // get seriesX


      for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {
        var isXString = typeof ser[activeI].data[_j2].x === 'string';
        var isXDate = !!dt.isValidDate(ser[activeI].data[_j2].x.toString());

        if (isXString || isXDate) {
          // user supplied '01/01/2017' or a date string (a JS date object is not supported)
          if (isXString) {
            if (cnf.xaxis.type === 'datetime' && !gl.isRangeData) {
              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));
            } else {
              // a category and not a numeric x value
              this.fallbackToCategory = true;
              this.twoDSeriesX.push(ser[activeI].data[_j2].x);
            }
          } else {
            if (cnf.xaxis.type === 'datetime') {
              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));
            } else {
              gl.dataFormatXNumeric = true;
              gl.isXNumeric = true;
              this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));
            }
          }
        } else {
          // a numeric value in x property
          gl.isXNumeric = true;
          gl.dataFormatXNumeric = true;
          this.twoDSeriesX.push(ser[activeI].data[_j2].x);
        }
      }

      if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {
        for (var t = 0; t < ser[i].data.length; t++) {
          this.threeDSeries.push(ser[i].data[t].z);
        }

        gl.isDataXYZ = true;
      }
    }
  }, {
    key: "handleRangeData",
    value: function handleRangeData(ser, i) {
      var gl = this.w.globals;
      var range = {};

      if (this.isFormat2DArray()) {
        range = this.handleRangeDataFormat('array', ser, i);
      } else if (this.isFormatXY()) {
        range = this.handleRangeDataFormat('xy', ser, i);
      }

      gl.seriesRangeStart.push(range.start);
      gl.seriesRangeEnd.push(range.end);
      return range;
    }
  }, {
    key: "handleCandleStickData",
    value: function handleCandleStickData(ser, i) {
      var gl = this.w.globals;
      var ohlc = {};

      if (this.isFormat2DArray()) {
        ohlc = this.handleCandleStickDataFormat('array', ser, i);
      } else if (this.isFormatXY()) {
        ohlc = this.handleCandleStickDataFormat('xy', ser, i);
      }

      gl.seriesCandleO.push(ohlc.o);
      gl.seriesCandleH.push(ohlc.h);
      gl.seriesCandleL.push(ohlc.l);
      gl.seriesCandleC.push(ohlc.c);
      return ohlc;
    }
  }, {
    key: "handleRangeDataFormat",
    value: function handleRangeDataFormat(format, ser, i) {
      var rangeStart = [];
      var rangeEnd = [];
      var err = 'Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts';
      var serObj = new Series(this.ctx);
      var activeIndex = serObj.getActiveConfigSeriesIndex();

      if (format === 'array') {
        if (ser[activeIndex].data[0][1].length !== 2) {
          throw new Error(err);
        }

        for (var j = 0; j < ser[i].data.length; j++) {
          rangeStart.push(ser[i].data[j][1][0]);
          rangeEnd.push(ser[i].data[j][1][1]);
        }
      } else if (format === 'xy') {
        if (ser[activeIndex].data[0].y.length !== 2) {
          throw new Error(err);
        }

        for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {
          rangeStart.push(ser[i].data[_j3].y[0]);
          rangeEnd.push(ser[i].data[_j3].y[1]);
        }
      }

      return {
        start: rangeStart,
        end: rangeEnd
      };
    }
  }, {
    key: "handleCandleStickDataFormat",
    value: function handleCandleStickDataFormat(format, ser, i) {
      var serO = [];
      var serH = [];
      var serL = [];
      var serC = [];
      var err = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick';

      if (format === 'array') {
        if (ser[i].data[0][1].length !== 4) {
          throw new Error(err);
        }

        for (var j = 0; j < ser[i].data.length; j++) {
          serO.push(ser[i].data[j][1][0]);
          serH.push(ser[i].data[j][1][1]);
          serL.push(ser[i].data[j][1][2]);
          serC.push(ser[i].data[j][1][3]);
        }
      } else if (format === 'xy') {
        if (ser[i].data[0].y.length !== 4) {
          throw new Error(err);
        }

        for (var _j4 = 0; _j4 < ser[i].data.length; _j4++) {
          serO.push(ser[i].data[_j4].y[0]);
          serH.push(ser[i].data[_j4].y[1]);
          serL.push(ser[i].data[_j4].y[2]);
          serC.push(ser[i].data[_j4].y[3]);
        }
      }

      return {
        o: serO,
        h: serH,
        l: serL,
        c: serC
      };
    }
  }, {
    key: "parseDataAxisCharts",
    value: function parseDataAxisCharts(ser) {
      var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;
      var cnf = this.w.config;
      var gl = this.w.globals;
      var dt = new DateTime(ctx);

      for (var i = 0; i < ser.length; i++) {
        this.twoDSeries = [];
        this.twoDSeriesX = [];
        this.threeDSeries = [];

        if (typeof ser[i].data === 'undefined') {
          console.error("It is a possibility that you may have not included 'data' property in series.");
          return;
        }

        if (cnf.chart.type === 'rangeBar' || cnf.chart.type === 'rangeArea' || ser[i].type === 'rangeBar' || ser[i].type === 'rangeArea') {
          gl.isRangeData = true;
          this.handleRangeData(ser, i);
        }

        if (this.isMultiFormat()) {
          if (this.isFormat2DArray()) {
            this.handleFormat2DArray(ser, i);
          } else if (this.isFormatXY()) {
            this.handleFormatXY(ser, i);
          }

          if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick') {
            this.handleCandleStickData(ser, i);
          }

          gl.series.push(this.twoDSeries);
          gl.labels.push(this.twoDSeriesX);
          gl.seriesX.push(this.twoDSeriesX);

          if (!this.fallbackToCategory) {
            gl.isXNumeric = true;
          }
        } else {
          if (cnf.xaxis.type === 'datetime') {
            // user didn't supplied [{x,y}] or [[x,y]], but single array in data.
            // Also labels/categories were supplied differently
            gl.isXNumeric = true;
            var dates = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();

            for (var j = 0; j < dates.length; j++) {
              if (typeof dates[j] === 'string') {
                // user provided date strings
                var isDate = dt.isValidDate(dates[j]);

                if (isDate) {
                  this.twoDSeriesX.push(dt.parseDate(dates[j]));
                } else {
                  throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');
                }
              } else {
                // user provided timestamps
                if (String(dates[j]).length !== 13) {
                  throw new Error('Please provide a valid JavaScript timestamp');
                } else {
                  this.twoDSeriesX.push(dates[j]);
                }
              }
            }

            gl.seriesX.push(this.twoDSeriesX);
          } else if (cnf.xaxis.type === 'numeric') {
            gl.isXNumeric = true;
            var x = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();

            if (x.length > 0) {
              this.twoDSeriesX = x;
              gl.seriesX.push(this.twoDSeriesX);
            }
          }

          gl.labels.push(this.twoDSeriesX);
          var singleArray = ser[i].data.map(function (d) {
            return Utils.parseNumber(d);
          });
          gl.series.push(singleArray);
        }

        gl.seriesZ.push(this.threeDSeries);

        if (ser[i].name !== undefined) {
          gl.seriesNames.push(ser[i].name);
        } else {
          gl.seriesNames.push('series-' + parseInt(i + 1));
        }
      }

      return this.w;
    }
  }, {
    key: "parseDataNonAxisCharts",
    value: function parseDataNonAxisCharts(ser) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.series = ser.slice();
      gl.seriesNames = cnf.labels.slice();

      for (var i = 0; i < gl.series.length; i++) {
        if (gl.seriesNames[i] === undefined) {
          gl.seriesNames.push('series-' + (i + 1));
        }
      }

      return this.w;
    }
    /** User possibly set string categories in xaxis.categories or labels prop
     * Or didn't set xaxis labels at all - in which case we manually do it.
     * If user passed series data as [[3, 2], [4, 5]] or [{ x: 3, y: 55 }],
     * this shouldn't be called
     * @param {array} ser - the series which user passed to the config
     */

  }, {
    key: "handleExternalLabelsData",
    value: function handleExternalLabelsData(ser) {
      var cnf = this.w.config;
      var gl = this.w.globals;

      if (cnf.xaxis.categories.length > 0) {
        // user provided labels in xaxis.category prop
        gl.labels = cnf.xaxis.categories;
      } else if (cnf.labels.length > 0) {
        // user provided labels in labels props
        gl.labels = cnf.labels.slice();
      } else if (this.fallbackToCategory) {
        // user provided labels in x prop in [{ x: 3, y: 55 }] data, and those labels are already stored in gl.labels[0], so just re-arrange the gl.labels array
        gl.labels = gl.labels[0];
      } else {
        // user didn't provided any labels, fallback to 1-2-3-4-5
        var labelArr = [];

        if (gl.axisCharts) {
          // for axis charts, we get the longest series and create labels from it
          if (gl.series.length > 0) {
            for (var i = 0; i < gl.series[gl.maxValsInArrayIndex].length; i++) {
              labelArr.push(i + 1);
            }
          } // create gl.seriesX as it will be used in calculations of x positions


          for (var _i = 0; _i < ser.length; _i++) {
            gl.seriesX.push(labelArr);
          } // turn on the isXNumeric flag to allow minX and maxX to function properly


          gl.isXNumeric = true;
        } // no series to pull labels from, put a 0-10 series
        // possibly, user collapsed all series. Hence we can't work with above calc


        if (labelArr.length === 0) {
          labelArr = [0, 10];

          for (var _i2 = 0; _i2 < ser.length; _i2++) {
            gl.seriesX.push(labelArr);
          }
        } // Finally, pass the labelArr in gl.labels which will be printed on x-axis


        gl.labels = labelArr; // Turn on this global flag to indicate no labels were provided by user

        gl.noLabelsProvided = true;
      }
    } // Segregate user provided data into appropriate vars

  }, {
    key: "parseData",
    value: function parseData(ser) {
      var w = this.w;
      var cnf = w.config;
      var gl = w.globals;
      this.excludeCollapsedSeriesInYAxis(); // If we detected string in X prop of series, we fallback to category x-axis

      this.fallbackToCategory = false;
      this.resetGlobals();
      this.isMultipleY();

      if (gl.axisCharts) {
        // axisCharts includes line / area / column / scatter
        this.parseDataAxisCharts(ser);
      } else {
        // non-axis charts are pie / donut
        this.parseDataNonAxisCharts(ser);
      }

      this.coreUtils.getLargestSeries(); // set Null values to 0 in all series when user hides/shows some series

      if (cnf.chart.type === 'bar' && cnf.chart.stacked) {
        var series = new Series(this.ctx);
        gl.series = series.setNullSeriesToZeroValues(gl.series);
      }

      this.coreUtils.getSeriesTotals();

      if (gl.axisCharts) {
        this.coreUtils.getStackedSeriesTotals();
      }

      this.coreUtils.getPercentSeries();

      if (!gl.dataFormatXNumeric && (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0)) {
        // x-axis labels couldn't be detected; hence try searching every option in config
        this.handleExternalLabelsData(ser);
      }
    }
  }, {
    key: "xySettings",
    value: function xySettings() {
      var xyRatios = null;
      var w = this.w;

      if (w.globals.axisCharts) {
        if (w.config.xaxis.crosshairs.position === 'back') {
          var crosshairs = new Crosshairs(this.ctx);
          crosshairs.drawXCrosshairs();
        }

        if (w.config.yaxis[0].crosshairs.position === 'back') {
          var _crosshairs = new Crosshairs(this.ctx);

          _crosshairs.drawYCrosshairs();
        }

        xyRatios = this.coreUtils.getCalculatedRatios();

        if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined) {
          var ts = new TimeScale(this.ctx);
          var formattedTimeScale;

          if (isFinite(w.globals.minX) && isFinite(w.globals.maxX) && !w.globals.isBarHorizontal) {
            formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);
            ts.recalcDimensionsBasedOnFormat(formattedTimeScale, false);
          } else if (w.globals.isBarHorizontal) {
            formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minY, w.globals.maxY);
            ts.recalcDimensionsBasedOnFormat(formattedTimeScale, true);
          }
        }
      }

      return xyRatios;
    }
  }, {
    key: "drawAxis",
    value: function drawAxis(type, xyRatios) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var xAxis = new XAxis(this.ctx);
      var yAxis = new YAxis(this.ctx);

      if (gl.axisCharts && type !== 'radar') {
        var elXaxis, elYaxis;

        if (gl.isBarHorizontal) {
          elYaxis = yAxis.drawYaxisInversed(0);
          elXaxis = xAxis.drawXaxisInversed(0);
          gl.dom.elGraphical.add(elXaxis);
          gl.dom.elGraphical.add(elYaxis);
        } else {
          elXaxis = xAxis.drawXaxis();
          gl.dom.elGraphical.add(elXaxis);
          cnf.yaxis.map(function (yaxe, index) {
            if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {
              elYaxis = yAxis.drawYaxis(index);
              gl.dom.Paper.add(elYaxis);
            }
          });
        }
      }

      cnf.yaxis.map(function (yaxe, index) {
        if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {
          yAxis.yAxisTitleRotate(index, yaxe.opposite);
        }
      });
    }
  }, {
    key: "setupBrushHandler",
    value: function setupBrushHandler() {
      var _this3 = this;

      var w = this.w; // only for brush charts

      if (!w.config.chart.brush.enabled) {
        return;
      } // if user has not defined a custom function for selection - we handle the brush chart
      // otherwise we leave it to the user to define the functionality for selection


      if (typeof w.config.chart.events.selection !== 'function') {
        var targets = w.config.chart.brush.targets || [w.config.chart.brush.target]; // retro compatibility with single target option

        targets.forEach(function (target) {
          var targetChart = ApexCharts.getChartByID(target);
          targetChart.w.globals.brushSource = _this3.ctx;

          var updateSourceChart = function updateSourceChart() {
            _this3.ctx._updateOptions({
              chart: {
                selection: {
                  xaxis: {
                    min: targetChart.w.globals.minX,
                    max: targetChart.w.globals.maxX
                  }
                }
              }
            }, false, false);
          };

          if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {
            targetChart.w.config.chart.events.zoomed = function () {
              updateSourceChart();
            };
          }

          if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {
            targetChart.w.config.chart.events.scrolled = function () {
              updateSourceChart();
            };
          }
        });

        w.config.chart.events.selection = function (chart, e) {
          targets.forEach(function (target) {
            var targetChart = ApexCharts.getChartByID(target);
            var yaxis = Utils.clone(w.config.yaxis);

            if (w.config.chart.brush.autoScaleYaxis) {
              var scale = new Range(targetChart);
              yaxis = scale.autoScaleY(targetChart, yaxis, e);
            }

            targetChart._updateOptions({
              xaxis: {
                min: e.xaxis.min,
                max: e.xaxis.max
              },
              yaxis: yaxis
            }, false, false, false, false);
          });
        };
      }
    }
  }]);

  return Core;
}();

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise$1.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise$1.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise$1.prototype['finally'] = finallyConstructor;

Promise$1.all = function(arr) {
  return new Promise$1(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise$1.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise$1) {
    return value;
  }

  return new Promise$1(function(resolve) {
    resolve(value);
  });
};

Promise$1.reject = function(value) {
  return new Promise$1(function(resolve, reject) {
    reject(value);
  });
};

Promise$1.race = function(values) {
  return new Promise$1(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

var Exports =
/*#__PURE__*/
function () {
  function Exports(ctx) {
    _classCallCheck(this, Exports);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Exports, [{
    key: "getSvgString",
    value: function getSvgString() {
      return this.w.globals.dom.Paper.svg();
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var w = this.w; // hide some elements to avoid printing them on exported svg

      var xcrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');
      var ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');

      if (xcrosshairs) {
        xcrosshairs.setAttribute('x', -500);
      }

      if (ycrosshairs) {
        ycrosshairs.setAttribute('y1', -100);
        ycrosshairs.setAttribute('y2', -100);
      }
    }
  }, {
    key: "svgUrl",
    value: function svgUrl() {
      this.cleanup();
      var svgData = this.getSvgString();
      var svgBlob = new Blob([svgData], {
        type: 'image/svg+xml;charset=utf-8'
      });
      return URL.createObjectURL(svgBlob);
    }
  }, {
    key: "dataURI",
    value: function dataURI() {
      var _this = this;

      return new Promise$1(function (resolve) {
        var w = _this.w;

        _this.cleanup();

        var canvas = document.createElement('canvas');
        canvas.width = w.globals.svgWidth;
        canvas.height = w.globals.svgHeight;
        var canvasBg = w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = canvasBg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        var DOMURL = window.URL || window.webkitURL || window;
        var img = new Image();
        img.crossOrigin = 'anonymous';

        var svgData = _this.getSvgString();

        var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);

        img.onload = function () {
          ctx.drawImage(img, 0, 0);
          DOMURL.revokeObjectURL(svgUrl);
          var imgURI = canvas.toDataURL('image/png');
          resolve(imgURI);
        };

        img.src = svgUrl;
      });
    }
  }, {
    key: "exportToSVG",
    value: function exportToSVG() {
      this.triggerDownload(this.svgUrl(), '.svg');
    }
  }, {
    key: "exportToPng",
    value: function exportToPng() {
      var _this2 = this;

      this.dataURI().then(function (imgURI) {
        _this2.triggerDownload(imgURI, '.png');
      });
    }
  }, {
    key: "triggerDownload",
    value: function triggerDownload(href, ext) {
      var downloadLink = document.createElement('a');
      downloadLink.href = href;
      downloadLink.download = this.w.globals.chartID + ext;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }
  }]);

  return Exports;
}();

/**
 * ApexCharts Grid Class for drawing Cartesian Grid.
 *
 * @module Grid
 **/

var Grid =
/*#__PURE__*/
function () {
  function Grid(ctx) {
    _classCallCheck(this, Grid);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.anim = new Animations(this.ctx);
    this.xaxisLabels = w.globals.labels.slice();
    this.animX = w.config.grid.xaxis.lines.animate && w.config.chart.animations.enabled;
    this.animY = w.config.grid.yaxis.lines.animate && w.config.chart.animations.enabled;

    if (w.globals.timelineLabels.length > 0) {
      //  timeline labels are there
      this.xaxisLabels = w.globals.timelineLabels.slice();
    }
  } // .when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well


  _createClass(Grid, [{
    key: "drawGridArea",
    value: function drawGridArea() {
      var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var w = this.w;
      var graphics = new Graphics(this.ctx);

      if (elGrid === null) {
        elGrid = graphics.group({
          class: 'apexcharts-grid'
        });
      }

      var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');
      var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');
      elGrid.add(elHorzLine);
      elGrid.add(elVerticalLine);
      return elGrid;
    }
  }, {
    key: "drawGrid",
    value: function drawGrid() {
      var w = this.w;
      var xAxis = new XAxis(this.ctx);
      var yaxis = new YAxis(this.ctx);
      var gl = this.w.globals;
      var elgrid = null;

      if (gl.axisCharts) {
        if (w.config.grid.show) {
          // grid is drawn after xaxis and yaxis are drawn
          elgrid = this.renderGrid();
          gl.dom.elGraphical.add(elgrid.el);
          this.drawGridArea(elgrid.el);
        } else {
          var elgridArea = this.drawGridArea();
          gl.dom.elGraphical.add(elgridArea);
        }

        if (elgrid !== null) {
          xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);
        }

        yaxis.setYAxisTextAlignments();
      }
    } // This mask will clip off overflowing graphics from the drawable area

  }, {
    key: "createGridMask",
    value: function createGridMask() {
      var w = this.w;
      var gl = w.globals;
      var graphics = new Graphics(this.ctx);
      var strokeSize = Array.isArray(w.config.stroke.width) ? 0 : w.config.stroke.width;

      if (Array.isArray(w.config.stroke.width)) {
        var strokeMaxSize = 0;
        w.config.stroke.width.forEach(function (m) {
          strokeMaxSize = Math.max(strokeMaxSize, m);
        });
        strokeSize = strokeMaxSize;
      }

      gl.dom.elGridRectMask = document.createElementNS(gl.SVGNS, 'clipPath');
      gl.dom.elGridRectMask.setAttribute('id', "gridRectMask".concat(gl.cuid));
      gl.dom.elGridRectMarkerMask = document.createElementNS(gl.SVGNS, 'clipPath');
      gl.dom.elGridRectMarkerMask.setAttribute('id', "gridRectMarkerMask".concat(gl.cuid));
      gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2, -strokeSize / 2, gl.gridWidth + strokeSize, gl.gridHeight + strokeSize, 0, '#fff');
      var coreUtils = new CoreUtils(this);
      coreUtils.getLargestMarkerSize();
      var markerSize = w.globals.markers.largestSize + 1;
      gl.dom.elGridRectMarker = graphics.drawRect(-markerSize, -markerSize, gl.gridWidth + markerSize * 2, gl.gridHeight + markerSize * 2, 0, '#fff');
      gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);
      gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);
      var defs = gl.dom.baseEl.querySelector('defs');
      defs.appendChild(gl.dom.elGridRectMask);
      defs.appendChild(gl.dom.elGridRectMarkerMask);
    } // actual grid rendering

  }, {
    key: "renderGrid",
    value: function renderGrid() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var strokeDashArray = w.config.grid.strokeDashArray;
      var elg = graphics.group({
        class: 'apexcharts-grid'
      });
      var elgridLinesH = graphics.group({
        class: 'apexcharts-gridlines-horizontal'
      });
      var elgridLinesV = graphics.group({
        class: 'apexcharts-gridlines-vertical'
      });
      elg.add(elgridLinesH);
      elg.add(elgridLinesV);
      var tickAmount = 8;

      for (var i = 0; i < w.globals.series.length; i++) {
        if (typeof w.globals.yAxisScale[i] !== 'undefined') {
          tickAmount = w.globals.yAxisScale[i].result.length - 1;
        }

        if (tickAmount > 2) break;
      }

      var xCount;

      if (!w.globals.isBarHorizontal) {
        xCount = this.xaxisLabels.length; // draw vertical lines

        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var x1 = w.globals.padHorizontal;
          var y1 = 0;
          var x2;
          var y2 = w.globals.gridHeight;

          if (w.globals.timelineLabels.length > 0) {
            for (var _i = 0; _i < xCount; _i++) {
              x1 = this.xaxisLabels[_i].position;
              x2 = this.xaxisLabels[_i].position;

              if (w.config.grid.xaxis.lines.show && x1 > 0 && x1 < w.globals.gridWidth) {
                var line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);
                line.node.classList.add('apexcharts-gridline');
                elgridLinesV.add(line);

                if (this.animX) {
                  this.animateLine(line, {
                    x1: 0,
                    x2: 0
                  }, {
                    x1: x1,
                    x2: x2
                  });
                }
              }

              var xAxis = new XAxis(this.ctx);

              if (_i === xCount - 1) {
                if (!w.globals.skipLastTimelinelabel) {
                  // skip drawing last label here
                  xAxis.drawXaxisTicks(x1, elg);
                }
              } else {
                xAxis.drawXaxisTicks(x1, elg);
              }
            }
          } else {
            var xCountForCategoryCharts = xCount;

            for (var _i2 = 0; _i2 < xCountForCategoryCharts; _i2++) {
              var x1Count = xCountForCategoryCharts;

              if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {
                x1Count -= 1;
              }

              x1 = x1 + w.globals.gridWidth / x1Count;
              x2 = x1; // skip the last line

              if (_i2 === x1Count - 1) break;

              if (w.config.grid.xaxis.lines.show) {
                var _line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);

                _line.node.classList.add('apexcharts-gridline');

                elgridLinesV.add(_line);

                if (this.animX) {
                  this.animateLine(_line, {
                    x1: 0,
                    x2: 0
                  }, {
                    x1: x1,
                    x2: x2
                  });
                }
              }

              var _xAxis = new XAxis(this.ctx);

              _xAxis.drawXaxisTicks(x1, elg);
            }
          }
        } // draw horizontal lines


        if (w.config.grid.yaxis.lines.show) {
          var _x = 0;
          var _y = 0;
          var _y2 = 0;
          var _x2 = w.globals.gridWidth;

          for (var _i3 = 0; _i3 < tickAmount + 1; _i3++) {
            var _line2 = graphics.drawLine(_x, _y, _x2, _y2, w.config.grid.borderColor, strokeDashArray);

            elgridLinesH.add(_line2);

            _line2.node.classList.add('apexcharts-gridline');

            if (this.animY) {
              this.animateLine(_line2, {
                y1: _y + 20,
                y2: _y2 + 20
              }, {
                y1: _y,
                y2: _y2
              });
            }

            _y = _y + w.globals.gridHeight / tickAmount;
            _y2 = _y;
          }
        }
      } else {
        xCount = tickAmount; // draw vertical lines

        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var _x3 = w.globals.padHorizontal;
          var _y3 = 0;

          var _x4;

          var _y4 = w.globals.gridHeight;

          for (var _i4 = 0; _i4 < xCount + 1; _i4++) {
            _x3 = _x3 + w.globals.gridWidth / xCount + 0.3;
            _x4 = _x3; // skip the last vertical line

            if (_i4 === xCount - 1) break;

            if (w.config.grid.xaxis.lines.show) {
              var _line3 = graphics.drawLine(_x3, _y3, _x4, _y4, w.config.grid.borderColor, strokeDashArray);

              _line3.node.classList.add('apexcharts-gridline');

              elgridLinesV.add(_line3);

              if (this.animX) {
                this.animateLine(_line3, {
                  x1: 0,
                  x2: 0
                }, {
                  x1: _x3,
                  x2: _x4
                });
              }
            } // skip the first vertical line


            var _xAxis2 = new XAxis(this.ctx);

            _xAxis2.drawXaxisTicks(_x3, elg);
          }
        } // draw horizontal lines


        if (w.config.grid.yaxis.lines.show) {
          var _x5 = 0;
          var _y5 = 0;
          var _y6 = 0;
          var _x6 = w.globals.gridWidth;

          for (var _i5 = 0; _i5 < w.globals.dataPoints + 1; _i5++) {
            var _line4 = graphics.drawLine(_x5, _y5, _x6, _y6, w.config.grid.borderColor, strokeDashArray);

            elgridLinesH.add(_line4);

            _line4.node.classList.add('apexcharts-gridline');

            if (this.animY) {
              this.animateLine(_line4, {
                y1: _y5 + 20,
                y2: _y6 + 20
              }, {
                y1: _y5,
                y2: _y6
              });
            }

            _y5 = _y5 + w.globals.gridHeight / w.globals.dataPoints;
            _y6 = _y5;
          }
        }
      }

      this.drawGridBands(elg, xCount, tickAmount);
      return {
        el: elg,
        xAxisTickWidth: w.globals.gridWidth / xCount
      };
    }
  }, {
    key: "drawGridBands",
    value: function drawGridBands(elg, xCount, tickAmount) {
      var w = this.w;
      var graphics = new Graphics(this.ctx); // rows background bands

      if (w.config.grid.row.colors !== undefined && w.config.grid.row.colors.length > 0) {
        var x1 = 0;
        var y1 = 0;
        var y2 = w.globals.gridHeight / tickAmount;
        var x2 = w.globals.gridWidth;

        for (var i = 0, c = 0; i < tickAmount; i++, c++) {
          if (c >= w.config.grid.row.colors.length) {
            c = 0;
          }

          var color = w.config.grid.row.colors[c];
          var rect = graphics.drawRect(x1, y1, x2, y2, 0, color, w.config.grid.row.opacity);
          elg.add(rect);
          rect.node.classList.add('apexcharts-gridRow');
          y1 = y1 + w.globals.gridHeight / tickAmount;
        }
      } // columns background bands


      if (w.config.grid.column.colors !== undefined && w.config.grid.column.colors.length > 0) {
        var _x7 = w.globals.padHorizontal;
        var _y7 = 0;

        var _x8 = w.globals.padHorizontal + w.globals.gridWidth / xCount;

        var _y8 = w.globals.gridHeight;

        for (var _i6 = 0, _c = 0; _i6 < xCount; _i6++, _c++) {
          if (_c >= w.config.grid.column.colors.length) {
            _c = 0;
          }

          var _color = w.config.grid.column.colors[_c];

          var _rect = graphics.drawRect(_x7, _y7, _x8, _y8, 0, _color, w.config.grid.column.opacity);

          _rect.node.classList.add('apexcharts-gridColumn');

          elg.add(_rect);
          _x7 = _x7 + w.globals.gridWidth / xCount;
        }
      }
    }
  }, {
    key: "animateLine",
    value: function animateLine(line, from, to) {
      var w = this.w;
      var initialAnim = w.config.chart.animations;

      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
        var speed = initialAnim.speed;
        this.anim.animateLine(line, from, to, speed);
      }
    }
  }]);

  return Grid;
}();

/**
 * ApexCharts Responsive Class to override options for different screen sizes.
 *
 * @module Responsive
 **/

var Responsive =
/*#__PURE__*/
function () {
  function Responsive(ctx) {
    _classCallCheck(this, Responsive);

    this.ctx = ctx;
    this.w = ctx.w;
  } // the opts parameter if not null has to be set overriding everything
  // as the opts is set by user externally


  _createClass(Responsive, [{
    key: "checkResponsiveConfig",
    value: function checkResponsiveConfig(opts) {
      var _this = this;

      var w = this.w;
      var cnf = w.config; // check if responsive config exists

      if (cnf.responsive.length === 0) return;
      var res = cnf.responsive.slice();
      res.sort(function (a, b) {
        return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;
      }).reverse();
      var config = new Config({});

      var iterateResponsiveOptions = function iterateResponsiveOptions() {
        var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var largestBreakpoint = res[0].breakpoint;
        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

        if (width > largestBreakpoint) {
          var options = CoreUtils.extendArrayProps(config, w.globals.initialConfig);
          newOptions = Utils.extend(options, newOptions);
          newOptions = Utils.extend(w.config, newOptions);

          _this.overrideResponsiveOptions(newOptions);
        } else {
          for (var i = 0; i < res.length; i++) {
            if (width < res[i].breakpoint) {
              newOptions = CoreUtils.extendArrayProps(config, res[i].options);
              newOptions = Utils.extend(w.config, newOptions);

              _this.overrideResponsiveOptions(newOptions);
            }
          }
        }
      };

      if (opts) {
        var options = CoreUtils.extendArrayProps(config, opts);
        options = Utils.extend(w.config, options);
        options = Utils.extend(options, opts);
        iterateResponsiveOptions(options);
      } else {
        iterateResponsiveOptions({});
      }
    }
  }, {
    key: "overrideResponsiveOptions",
    value: function overrideResponsiveOptions(newOptions) {
      var newConfig = new Config(newOptions).init();
      this.w.config = newConfig;
    }
  }]);

  return Responsive;
}();

/**
 * ApexCharts Theme Class for setting the colors and palettes.
 *
 * @module Theme
 **/

var Theme =
/*#__PURE__*/
function () {
  function Theme(ctx) {
    _classCallCheck(this, Theme);

    this.ctx = ctx;
    this.w = ctx.w;
    this.colors = [];
  }

  _createClass(Theme, [{
    key: "init",
    value: function init() {
      this.setDefaultColors();
    }
  }, {
    key: "setDefaultColors",
    value: function setDefaultColors() {
      var w = this.w;
      var utils = new Utils();
      w.globals.dom.elWrap.classList.add(w.config.theme.mode);

      if (w.config.colors === undefined) {
        w.globals.colors = this.predefined();
      } else {
        w.globals.colors = w.config.colors;
      }

      if (w.config.theme.monochrome.enabled) {
        var monoArr = [];
        var glsCnt = w.globals.series.length;

        if (w.config.plotOptions.bar.distributed && w.config.chart.type === 'bar') {
          glsCnt = w.globals.series[0].length * w.globals.series.length;
        }

        var mainColor = w.config.theme.monochrome.color;
        var part = 1 / (glsCnt / w.config.theme.monochrome.shadeIntensity);
        var shade = w.config.theme.monochrome.shadeTo;
        var percent = 0;

        for (var gsl = 0; gsl < glsCnt; gsl++) {
          var newColor = void 0;

          if (shade === 'dark') {
            newColor = utils.shadeColor(percent * -1, mainColor);
            percent = percent + part;
          } else {
            newColor = utils.shadeColor(percent, mainColor);
            percent = percent + part;
          }

          monoArr.push(newColor);
        }

        w.globals.colors = monoArr.slice();
      }

      var defaultColors = w.globals.colors.slice(); // if user specfied less colors than no. of series, push the same colors again

      this.pushExtraColors(w.globals.colors); // The Border colors

      if (w.config.stroke.colors === undefined) {
        w.globals.stroke.colors = defaultColors;
      } else {
        w.globals.stroke.colors = w.config.stroke.colors;
      }

      this.pushExtraColors(w.globals.stroke.colors); // The FILL colors

      if (w.config.fill.colors === undefined) {
        w.globals.fill.colors = defaultColors;
      } else {
        w.globals.fill.colors = w.config.fill.colors;
      }

      this.pushExtraColors(w.globals.fill.colors);

      if (w.config.dataLabels.style.colors === undefined) {
        w.globals.dataLabels.style.colors = defaultColors;
      } else {
        w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors;
      }

      this.pushExtraColors(w.globals.dataLabels.style.colors, 50);

      if (w.config.plotOptions.radar.polygons.fill.colors === undefined) {
        w.globals.radarPolygons.fill.colors = [w.config.theme.mode === 'dark' ? '#202D48' : '#fff'];
      } else {
        w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors;
      }

      this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20); // The point colors

      if (w.config.markers.colors === undefined) {
        w.globals.markers.colors = defaultColors;
      } else {
        w.globals.markers.colors = w.config.markers.colors;
      }

      this.pushExtraColors(w.globals.markers.colors);
    } // When the number of colors provided is less than the number of series, this method
    // will push same colors to the list
    // params:
    // distributed is only valid for distributed column/bar charts

  }, {
    key: "pushExtraColors",
    value: function pushExtraColors(colorSeries, length) {
      var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var w = this.w;
      var len = length || w.globals.series.length;

      if (distributed === null) {
        distributed = w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.colorScale.inverse;
      }

      if (distributed) {
        len = w.globals.series[0].length * w.globals.series.length;
      }

      if (colorSeries.length < len) {
        var diff = len - colorSeries.length;

        for (var i = 0; i < diff; i++) {
          colorSeries.push(colorSeries[i]);
        }
      }
    }
  }, {
    key: "updateThemeOptions",
    value: function updateThemeOptions(options) {
      options.chart = options.chart || {};
      options.tooltip = options.tooltip || {};
      var mode = options.theme.mode || 'light';
      var palette = options.theme.palette ? options.theme.palette : mode === 'dark' ? 'palette4' : 'palette1';
      var foreColor = options.chart.foreColor ? options.chart.foreColor : mode === 'dark' ? '#f6f7f8' : '#373d3f';
      options.tooltip.theme = mode;
      options.chart.foreColor = foreColor;
      options.theme.palette = palette;
      return options;
    }
  }, {
    key: "predefined",
    value: function predefined() {
      var palette = this.w.config.theme.palette; // D6E3F8, FCEFEF, DCE0D9, A5978B, EDDDD4, D6E3F8, FEF5EF

      switch (palette) {
        case 'palette1':
          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];
          break;

        case 'palette2':
          this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800'];
          break;

        case 'palette3':
          this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B'];
          break;

        case 'palette4':
          this.colors = ['#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a', '#546E7A'];
          break;

        case 'palette5':
          this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7'];
          break;

        case 'palette6':
          this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'];
          break;

        case 'palette7':
          this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'];
          break;

        case 'palette8':
          this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'];
          break;

        case 'palette9':
          this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'];
          break;

        case 'palette10':
          this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2'];
          break;

        default:
          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];
          break;
      }

      return this.colors;
    }
  }]);

  return Theme;
}();

var Utils$1 =
/*#__PURE__*/
function () {
  function Utils(tooltipContext) {
    _classCallCheck(this, Utils);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
  }
  /**
   ** When hovering over series, you need to capture which series is being hovered on.
   ** This function will return both capturedseries index as well as inner index of that series
   * @memberof Utils
   * @param {object}
   * - hoverArea = the rect on which user hovers
   * - elGrid = dimensions of the hover rect (it can be different than hoverarea)
   */


  _createClass(Utils, [{
    key: "getNearestValues",
    value: function getNearestValues(_ref) {
      var hoverArea = _ref.hoverArea,
          elGrid = _ref.elGrid,
          clientX = _ref.clientX,
          clientY = _ref.clientY,
          hasBars = _ref.hasBars;
      var w = this.w;
      var hoverWidth = w.globals.gridWidth;
      var xDivisor = hoverWidth / (w.globals.dataPoints - 1);
      var seriesBound = elGrid.getBoundingClientRect();

      if (hasBars && w.globals.comboCharts || hasBars) {
        xDivisor = hoverWidth / w.globals.dataPoints;
      }

      var hoverX = clientX - seriesBound.left;
      var hoverY = clientY - seriesBound.top;
      var inRect = hoverX < 0 || hoverY < 0 || hoverX > w.globals.gridWidth || hoverY > w.globals.gridHeight;

      if (inRect) {
        hoverArea.classList.remove('hovering-zoom');
        hoverArea.classList.remove('hovering-pan');
      } else {
        if (w.globals.zoomEnabled) {
          hoverArea.classList.remove('hovering-pan');
          hoverArea.classList.add('hovering-zoom');
        } else if (w.globals.panEnabled) {
          hoverArea.classList.remove('hovering-zoom');
          hoverArea.classList.add('hovering-pan');
        }
      }

      var j = Math.round(hoverX / xDivisor);

      if (hasBars) {
        j = Math.ceil(hoverX / xDivisor);
        j = j - 1;
      }

      var capturedSeries = null;
      var closest = null;
      var seriesXValArr = [];
      var seriesYValArr = [];

      for (var s = 0; s < w.globals.seriesXvalues.length; s++) {
        seriesXValArr.push([w.globals.seriesXvalues[s][0] - 0.000001].concat(w.globals.seriesXvalues[s]));
      }

      seriesXValArr = seriesXValArr.map(function (seriesXVal) {
        return seriesXVal.filter(function (s) {
          return s;
        });
      });
      seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {
        return seriesYVal.filter(function (s) {
          return s;
        });
      }); // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value

      if (w.globals.isXNumeric) {
        closest = this.closestInMultiArray(hoverX, hoverY, seriesXValArr, seriesYValArr);
        capturedSeries = closest.index;
        j = closest.j;

        if (capturedSeries !== null) {
          // initial push, it should be a little smaller than the 1st val
          seriesXValArr = w.globals.seriesXvalues[capturedSeries];
          closest = this.closestInArray(hoverX, seriesXValArr);
          j = closest.index;
        }
      }

      if (!j || j < 1) j = 0;
      return {
        capturedSeries: capturedSeries,
        j: j,
        hoverX: hoverX,
        hoverY: hoverY
      };
    }
  }, {
    key: "closestInMultiArray",
    value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {
      var w = this.w;
      var activeIndex = 0;
      var currIndex = null;
      var j = -1;

      if (w.globals.series.length > 1) {
        activeIndex = this.getFirstActiveXArray(Xarrays);
      } else {
        currIndex = 0;
      }

      var currY = Yarrays[activeIndex][0];
      var currX = Xarrays[activeIndex][0];
      var diffX = Math.abs(hoverX - currX);
      var diffY = Math.abs(hoverY - currY);
      var diff = diffY + diffX;
      Yarrays.map(function (arrY, arrIndex) {
        arrY.map(function (y, innerKey) {
          var newdiffY = Math.abs(hoverY - Yarrays[arrIndex][innerKey]);
          var newdiffX = Math.abs(hoverX - Xarrays[arrIndex][innerKey]);
          var newdiff = newdiffX + newdiffY;

          if (newdiff < diff) {
            diff = newdiff;
            diffX = newdiffX;
            diffY = newdiffY;
            currIndex = arrIndex;
            j = innerKey;
          }
        });
      });
      return {
        index: currIndex,
        j: j
      };
    }
  }, {
    key: "getFirstActiveXArray",
    value: function getFirstActiveXArray(Xarrays) {
      var activeIndex = 0;
      var coreUtils = new CoreUtils(this.ctx);
      var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {
        if (xarr.length > 0) {
          return index;
        } else {
          return -1;
        }
      });

      for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
        var total = coreUtils.getSeriesTotalByIndex(a);

        if (firstActiveSeriesIndex[a] !== -1 && total !== 0 && !coreUtils.seriesHaveSameValues(a)) {
          activeIndex = firstActiveSeriesIndex[a];
          break;
        }
      }

      return activeIndex;
    }
  }, {
    key: "closestInArray",
    value: function closestInArray(val, arr) {
      var curr = arr[0];
      var currIndex = null;
      var diff = Math.abs(val - curr);

      for (var i = 0; i < arr.length; i++) {
        var newdiff = Math.abs(val - arr[i]);

        if (newdiff < diff) {
          diff = newdiff;
          curr = arr[i];
          currIndex = i;
        }
      }

      return {
        index: currIndex
      };
    }
    /**
     * When there are multiple series, it is possible to have different x values for each series.
     * But it may be possible in those multiple series, that there is same x value for 2 or more
     * series.
     * @memberof Utils
     * @param {int}
     * - j = is the inner index of series -> (series[i][j])
     * @return {bool}
     */

  }, {
    key: "isXoverlap",
    value: function isXoverlap(j) {
      var w = this.w;
      var xSameForAllSeriesJArr = [];
      var seriesX = w.globals.seriesX.filter(function (s) {
        return typeof s[0] !== 'undefined';
      });

      if (seriesX.length > 0) {
        for (var i = 0; i < seriesX.length - 1; i++) {
          if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {
            if (seriesX[i][j] !== seriesX[i + 1][j]) {
              xSameForAllSeriesJArr.push('unEqual');
            }
          }
        }
      }

      if (xSameForAllSeriesJArr.length === 0) {
        return true;
      }

      return false;
    }
  }, {
    key: "isinitialSeriesSameLen",
    value: function isinitialSeriesSameLen() {
      var sameLen = true;
      var initialSeries = this.w.globals.initialSeries;

      for (var i = 0; i < initialSeries.length - 1; i++) {
        if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {
          sameLen = false;
          break;
        }
      }

      return sameLen;
    }
  }, {
    key: "getBarsHeight",
    value: function getBarsHeight(allbars) {
      var bars = _toConsumableArray(allbars);

      var totalHeight = bars.reduce(function (acc, bar) {
        return acc + bar.getBBox().height;
      }, 0);
      return totalHeight;
    }
  }, {
    key: "toggleAllTooltipSeriesGroups",
    value: function toggleAllTooltipSeriesGroups(state) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.allTooltipSeriesGroups.length === 0) {
        ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');
      }

      var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;

      for (var i = 0; i < allTooltipSeriesGroups.length; i++) {
        if (state === 'enable') {
          allTooltipSeriesGroups[i].classList.add('active');
          allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;
        } else {
          allTooltipSeriesGroups[i].classList.remove('active');
          allTooltipSeriesGroups[i].style.display = 'none';
        }
      }
    }
  }]);

  return Utils;
}();

/**
 * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.
 *
 * @module Tooltip.Labels
 **/

var Labels =
/*#__PURE__*/
function () {
  function Labels(tooltipContext) {
    _classCallCheck(this, Labels);

    this.w = tooltipContext.w;
    this.ctx = tooltipContext.ctx;
    this.ttCtx = tooltipContext;
    this.tooltipUtil = new Utils$1(tooltipContext);
  }

  _createClass(Labels, [{
    key: "drawSeriesTexts",
    value: function drawSeriesTexts(_ref) {
      var _ref$shared = _ref.shared,
          shared = _ref$shared === void 0 ? true : _ref$shared,
          ttItems = _ref.ttItems,
          _ref$i = _ref.i,
          i = _ref$i === void 0 ? 0 : _ref$i,
          _ref$j = _ref.j,
          j = _ref$j === void 0 ? null : _ref$j;
      var w = this.w;

      if (w.config.tooltip.custom !== undefined) {
        this.handleCustomTooltip({
          i: i,
          j: j
        });
      } else {
        this.toggleActiveInactiveSeries(shared);
      }

      var values = this.getValuesToPrint({
        i: i,
        j: j
      });
      this.printLabels({
        i: i,
        j: j,
        values: values,
        ttItems: ttItems,
        shared: shared
      }); // Re-calculate tooltip dimensions now that we have drawn the text

      var tooltipEl = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;
      this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;
    }
  }, {
    key: "printLabels",
    value: function printLabels(_ref2) {
      var i = _ref2.i,
          j = _ref2.j,
          values = _ref2.values,
          ttItems = _ref2.ttItems,
          shared = _ref2.shared;
      var w = this.w;
      var val;
      var xVal = values.xVal,
          zVal = values.zVal,
          xAxisTTVal = values.xAxisTTVal;
      var seriesName = '';
      var pColor = w.globals.colors[i];

      if (j !== null && w.config.plotOptions.bar.distributed) {
        pColor = w.globals.colors[j];
      }

      for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {
        var f = this.getFormatters(i);
        seriesName = this.getSeriesName({
          fn: f.yLbTitleFormatter,
          index: i,
          seriesIndex: i,
          j: j
        });

        if (shared) {
          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;
          f = this.getFormatters(tIndex);
          seriesName = this.getSeriesName({
            fn: f.yLbTitleFormatter,
            index: tIndex,
            seriesIndex: i,
            j: j
          });
          pColor = w.globals.colors[tIndex]; // for plot charts, not for pie/donuts

          val = f.yLbFormatter(w.globals.series[tIndex][j], {
            series: w.globals.series,
            seriesIndex: tIndex,
            dataPointIndex: j,
            w: w
          }); // discard 0 values in BARS

          if (this.ttCtx.hasBars() && w.config.chart.stacked && w.globals.series[tIndex][j] === 0 || typeof w.globals.series[tIndex][j] === 'undefined') {
            val = undefined;
          }
        } else {
          val = f.yLbFormatter(w.globals.series[i][j], {
            series: w.globals.series,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        } // for pie / donuts


        if (j === null) {
          val = f.yLbFormatter(w.globals.series[i], w);
        }

        this.DOMHandling({
          t: t,
          ttItems: ttItems,
          values: {
            val: val,
            xVal: xVal,
            xAxisTTVal: xAxisTTVal,
            zVal: zVal
          },
          seriesName: seriesName,
          shared: shared,
          pColor: pColor
        });
      }
    }
  }, {
    key: "getFormatters",
    value: function getFormatters(i) {
      var w = this.w;
      var yLbFormatter = w.globals.yLabelFormatters[i];
      var yLbTitleFormatter;

      if (w.globals.ttVal !== undefined) {
        if (Array.isArray(w.globals.ttVal)) {
          yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;
          yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;
        } else {
          yLbFormatter = w.globals.ttVal.formatter;

          if (typeof w.globals.ttVal.title.formatter === 'function') {
            yLbTitleFormatter = w.globals.ttVal.title.formatter;
          }
        }
      } else {
        yLbTitleFormatter = w.config.tooltip.y.title.formatter;
      }

      if (typeof yLbFormatter !== 'function') {
        if (w.globals.yLabelFormatters[0]) {
          yLbFormatter = w.globals.yLabelFormatters[0];
        } else {
          yLbFormatter = function yLbFormatter(label) {
            return label;
          };
        }
      }

      if (typeof yLbTitleFormatter !== 'function') {
        yLbTitleFormatter = function yLbTitleFormatter(label) {
          return label;
        };
      }

      return {
        yLbFormatter: yLbFormatter,
        yLbTitleFormatter: yLbTitleFormatter
      };
    }
  }, {
    key: "getSeriesName",
    value: function getSeriesName(_ref3) {
      var fn = _ref3.fn,
          index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          j = _ref3.j;
      var w = this.w;
      return fn(String(w.globals.seriesNames[index]), {
        series: w.globals.series,
        seriesIndex: seriesIndex,
        dataPointIndex: j,
        w: w
      });
    }
  }, {
    key: "DOMHandling",
    value: function DOMHandling(_ref4) {
      var t = _ref4.t,
          ttItems = _ref4.ttItems,
          values = _ref4.values,
          seriesName = _ref4.seriesName,
          shared = _ref4.shared,
          pColor = _ref4.pColor;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var val = values.val,
          xVal = values.xVal,
          xAxisTTVal = values.xAxisTTVal,
          zVal = values.zVal;
      var ttItemsChildren = null;
      ttItemsChildren = ttItems[t].children;

      if (w.config.tooltip.fillSeriesColor) {
        //  elTooltip.style.backgroundColor = pColor
        ttItems[t].style.backgroundColor = pColor;
        ttItemsChildren[0].style.display = 'none';
      }

      if (ttCtx.showTooltipTitle) {
        if (ttCtx.tooltipTitle === null) {
          // get it once if null, and store it in class property
          ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');
        }

        ttCtx.tooltipTitle.innerHTML = xVal;
      } // if xaxis tooltip is constructed, we need to replace the innerHTML


      if (ttCtx.blxaxisTooltip) {
        ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;
      }

      var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label');

      if (ttYLabel) {
        ttYLabel.innerHTML = seriesName ? seriesName + ': ' : '';
      }

      var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value');

      if (ttYVal) {
        ttYVal.innerHTML = val;
      }

      if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {
        ttItemsChildren[0].style.backgroundColor = pColor;
      }

      if (!w.config.tooltip.marker.show) {
        ttItemsChildren[0].style.display = 'none';
      }

      if (zVal !== null) {
        var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');
        ttZLabel.innerHTML = w.config.tooltip.z.title;
        var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');
        ttZVal.innerHTML = zVal;
      }

      if (shared && ttItemsChildren[0]) {
        // hide when no Val or series collapsed
        if (typeof val === 'undefined' || val === null || w.globals.collapsedSeriesIndices.indexOf(t) > -1) {
          ttItemsChildren[0].parentNode.style.display = 'none';
        } else {
          ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;
        }
      }
    }
  }, {
    key: "toggleActiveInactiveSeries",
    value: function toggleActiveInactiveSeries(shared) {
      var w = this.w;

      if (shared) {
        // make all tooltips active
        this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');
      } else {
        // disable all tooltip text groups
        this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); // enable the first tooltip text group

        var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group');

        if (firstTooltipSeriesGroup) {
          firstTooltipSeriesGroup.classList.add('active');
          firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;
        }
      }
    }
  }, {
    key: "getValuesToPrint",
    value: function getValuesToPrint(_ref5) {
      var i = _ref5.i,
          j = _ref5.j;
      var w = this.w;
      var filteredSeriesX = this.ctx.series.filteredSeriesX();
      var xVal = '';
      var xAxisTTVal = '';
      var zVal = null;
      var val = null;
      var customFormatterOpts = {
        series: w.globals.series,
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      };
      var zFormatter = w.globals.ttZFormatter;

      if (j === null) {
        val = w.globals.series[i];
      } else {
        if (w.globals.isXNumeric) {
          xVal = filteredSeriesX[i][j];

          if (filteredSeriesX[i].length === 0) {
            // a series (possibly the first one) might be collapsed, so get the next active index
            var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);
            xVal = filteredSeriesX[firstActiveSeriesIndex][j];
          }
        } else {
          xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';
        }
      }

      var bufferXVal = xVal;

      if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {
        var xFormat = new Formatters(this.ctx);
        xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal, bufferXVal);
      } else {
        if (!w.globals.isBarHorizontal) {
          xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);
        }
      } // override default x-axis formatter with tooltip formatter


      if (w.config.tooltip.x.formatter !== undefined) {
        xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);
      }

      if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[0].length > 0) {
        zVal = zFormatter(w.globals.seriesZ[i][j], w);
      }

      if (typeof w.config.xaxis.tooltip.formatter === 'function') {
        xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);
      } else {
        xAxisTTVal = xVal;
      }

      return {
        val: val,
        xVal: xVal,
        xAxisTTVal: xAxisTTVal,
        zVal: zVal
      };
    }
  }, {
    key: "handleCustomTooltip",
    value: function handleCustomTooltip(_ref6) {
      var i = _ref6.i,
          j = _ref6.j;
      var w = this.w;
      var tooltipEl = this.ttCtx.getElTooltip(); // override everything with a custom html tooltip and replace it

      tooltipEl.innerHTML = w.config.tooltip.custom({
        ctx: this.ctx,
        series: w.globals.series,
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      });
    }
  }]);

  return Labels;
}();

/**
 * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.
 *
 * @module Tooltip.Position
 **/

var Position =
/*#__PURE__*/
function () {
  function Position(tooltipContext) {
    _classCallCheck(this, Position);

    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
    this.w = tooltipContext.w;
  }
  /**
   * This will move the crosshair (the vertical/horz line that moves along with mouse)
   * Along with this, this function also calls the xaxisMove function
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
   */


  _createClass(Position, [{
    key: "moveXCrosshairs",
    value: function moveXCrosshairs(cx) {
      var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var ttCtx = this.ttCtx;
      var w = this.w;
      var xcrosshairs = ttCtx.getElXCrosshairs();
      var x = cx - ttCtx.xcrosshairsWidth / 2;
      var tickAmount = w.globals.labels.slice().length;

      if (j !== null) {
        x = w.globals.gridWidth / tickAmount * j;
      }

      if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {
        if (x + ttCtx.xcrosshairsWidth > w.globals.gridWidth) {
          x = w.globals.gridWidth - ttCtx.xcrosshairsWidth;
        }
      } else {
        if (j !== null) {
          x = x + w.globals.gridWidth / tickAmount / 2;
        }
      }

      if (x < 0) {
        x = 0;
      }

      if (x > w.globals.gridWidth) {
        x = w.globals.gridWidth;
      }

      if (xcrosshairs !== null) {
        xcrosshairs.setAttribute('x', x);
        xcrosshairs.setAttribute('x1', x);
        xcrosshairs.setAttribute('x2', x);
        xcrosshairs.setAttribute('y2', w.globals.gridHeight);
        xcrosshairs.classList.add('active');
      }

      if (ttCtx.blxaxisTooltip) {
        var tx = x;

        if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {
          tx = x + ttCtx.xcrosshairsWidth / 2;
        }

        this.moveXAxisTooltip(tx);
      }
    }
    /**
     * This will move the crosshair (the vertical/horz line that moves along with mouse)
     * Along with this, this function also calls the xaxisMove function
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
     */

  }, {
    key: "moveYCrosshairs",
    value: function moveYCrosshairs(cy) {
      var ttCtx = this.ttCtx;

      if (ttCtx.ycrosshairs !== null) {
        Graphics.setAttrs(ttCtx.ycrosshairs, {
          y1: cy,
          y2: cy
        });
        Graphics.setAttrs(ttCtx.ycrosshairsHidden, {
          y1: cy,
          y2: cy
        });
      }
    }
    /**
     ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move
     */

  }, {
    key: "moveXAxisTooltip",
    value: function moveXAxisTooltip(cx) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.xaxisTooltip !== null) {
        ttCtx.xaxisTooltip.classList.add('active');
        var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;
        var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();
        var xaxisTTTextWidth = xaxisTTText.width;
        cx = cx - xaxisTTTextWidth / 2;

        if (!isNaN(cx)) {
          cx = cx + w.globals.translateX;
          var textRect = 0;
          var graphics = new Graphics(this.ctx);
          textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);
          ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';
          ttCtx.xaxisTooltip.style.left = cx + 'px';
          ttCtx.xaxisTooltip.style.top = cy + 'px';
        }
      }
    }
  }, {
    key: "moveYAxisTooltip",
    value: function moveYAxisTooltip(index) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.yaxisTTEls === null) {
        ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
      }

      var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'));
      var cy = w.globals.translateY + ycrosshairsHiddenRectY1;
      var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();
      var yAxisTTHeight = yAxisTTRect.height;
      var cx = w.globals.translateYAxisX[index] - 2;

      if (w.config.yaxis[index].opposite) {
        cx = cx - 26;
      }

      cy = cy - yAxisTTHeight / 2;

      if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {
        ttCtx.yaxisTTEls[index].classList.add('active');
        ttCtx.yaxisTTEls[index].style.top = cy + 'px';
        ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';
      } else {
        ttCtx.yaxisTTEls[index].classList.remove('active');
      }
    }
    /**
     ** moves the whole tooltip by changing x, y attrs
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip
     * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip
     * @param {int} - r = point's radius
     */

  }, {
    key: "moveTooltip",
    value: function moveTooltip(cx, cy) {
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var tooltipEl = ttCtx.getElTooltip();
      var tooltipRect = ttCtx.tooltipRect;
      var pointR = r !== null ? parseInt(r) : 1;
      var x = parseInt(cx) + pointR + 5;
      var y = parseInt(cy) + pointR / 2; // - tooltipRect.ttHeight / 2

      if (x > w.globals.gridWidth / 2) {
        x = x - tooltipRect.ttWidth - pointR - 15;
      }

      if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {
        x = w.globals.gridWidth - tooltipRect.ttWidth;
      }

      if (x < -20) {
        x = -20;
      }

      if (w.config.tooltip.followCursor) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top - tooltipRect.ttHeight / 2;
      }

      var newPositions = this.positionChecks(tooltipRect, x, y);
      x = newPositions.x;
      y = newPositions.y;

      if (!isNaN(x)) {
        x = x + w.globals.translateX;
        tooltipEl.style.left = x + 'px';
        tooltipEl.style.top = y + 'px';
      }
    }
  }, {
    key: "positionChecks",
    value: function positionChecks(tooltipRect, x, y) {
      var w = this.w;

      if (tooltipRect.ttHeight + y > w.globals.gridHeight) {
        y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;
      }

      if (y < 0) {
        y = 0;
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "moveMarkers",
    value: function moveMarkers(i, j) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (w.globals.markers.size[i] > 0) {
        var allPoints = w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(i, "'] .apexcharts-marker"));

        for (var p = 0; p < allPoints.length; p++) {
          if (parseInt(allPoints[p].getAttribute('rel')) === j) {
            ttCtx.marker.resetPointsSize();
            ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);
          }
        }
      } else {
        ttCtx.marker.resetPointsSize();
        this.moveDynamicPointOnHover(j, i);
      }
    } // This function is used when you need to show markers/points only on hover -
    // DIFFERENT X VALUES in multiple series

  }, {
    key: "moveDynamicPointOnHover",
    value: function moveDynamicPointOnHover(j, capturedSeries) {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var cx = 0;
      var cy = 0;
      var pointsArr = w.globals.pointsArray;
      var hoverSize = w.config.markers.hover.size;

      if (hoverSize === undefined) {
        hoverSize = w.globals.markers.size[capturedSeries] + w.config.markers.hover.sizeOffset;
      }

      cx = pointsArr[capturedSeries][j][0];
      cy = pointsArr[capturedSeries][j][1] ? pointsArr[capturedSeries][j][1] : 0;
      var point = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(capturedSeries, "'] .apexcharts-series-markers circle"));

      if (point) {
        point.setAttribute('r', hoverSize);
        point.setAttribute('cx', cx);
        point.setAttribute('cy', cy);
      } // point.style.opacity = w.config.markers.hover.opacity


      this.moveXCrosshairs(cx);

      if (!ttCtx.fixedTooltip) {
        this.moveTooltip(cx, cy, hoverSize);
      }
    } // This function is used when you need to show markers/points only on hover -
    // SAME X VALUES in multiple series

  }, {
    key: "moveDynamicPointsOnHover",
    value: function moveDynamicPointsOnHover(j) {
      var ttCtx = this.ttCtx;
      var w = ttCtx.w;
      var cx = 0;
      var cy = 0;
      var activeSeries = 0;
      var pointsArr = w.globals.pointsArray;
      var series = new Series(this.ctx);
      activeSeries = series.getActiveSeriesIndex();
      var hoverSize = w.config.markers.hover.size;

      if (hoverSize === undefined) {
        hoverSize = w.globals.markers.size[activeSeries] + w.config.markers.hover.sizeOffset;
      }

      if (pointsArr[activeSeries]) {
        cx = pointsArr[activeSeries][j][0];
        cy = pointsArr[activeSeries][j][1];
      }

      var points = null;
      var allPoints = ttCtx.getAllMarkers();

      if (allPoints !== null) {
        points = allPoints;
      } else {
        points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle');
      }

      if (points !== null) {
        for (var p = 0; p < points.length; p++) {
          var pointArr = pointsArr[p];

          if (pointArr && pointArr.length) {
            var pcy = pointsArr[p][j][1];
            points[p].setAttribute('cx', cx);
            var realIndex = parseInt(points[p].parentNode.parentNode.parentNode.getAttribute('data:realIndex'));

            if (pcy !== null) {
              points[realIndex] && points[realIndex].setAttribute('r', hoverSize);
              points[realIndex] && points[realIndex].setAttribute('cy', pcy);
            } else {
              points[realIndex] && points[realIndex].setAttribute('r', 0);
            }
          }
        }
      }

      this.moveXCrosshairs(cx);

      if (!ttCtx.fixedTooltip) {
        var tcy = cy || w.globals.gridHeight;
        this.moveTooltip(cx, tcy, hoverSize);
      }
    }
  }, {
    key: "moveStickyTooltipOverBars",
    value: function moveStickyTooltipOverBars(j) {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var jBar = w.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='1'] path[j='".concat(j, "'], .apexcharts-candlestick-series .apexcharts-series[rel='1'] path[j='").concat(j, "'], .apexcharts-rangebar-series .apexcharts-series[rel='1'] path[j='").concat(j, "']"));
      var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;
      var bcy = 0;
      var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;

      if (w.globals.isXNumeric) {
        bcx = bcx - bw / 2;
      } else {
        bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;

        if (isNaN(bcx)) {
          bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;
        }
      } // tooltip will move vertically along with mouse as it is a shared tooltip


      var elGrid = ttCtx.getElGrid();
      var seriesBound = elGrid.getBoundingClientRect();
      bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;
      this.moveXCrosshairs(bcx);

      if (!ttCtx.fixedTooltip) {
        var tcy = bcy || w.globals.gridHeight;
        this.moveTooltip(bcx, tcy);
      }
    }
  }]);

  return Position;
}();

/**
 * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.
 *
 * @module Tooltip.Marker
 **/

var Marker =
/*#__PURE__*/
function () {
  function Marker(tooltipContext) {
    _classCallCheck(this, Marker);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
    this.tooltipPosition = new Position(tooltipContext);
  }

  _createClass(Marker, [{
    key: "drawDynamicPoints",
    value: function drawDynamicPoints() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var marker = new Markers(this.ctx);
      var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');

      for (var i = 0; i < elsSeries.length; i++) {
        var seriesIndex = parseInt(elsSeries[i].getAttribute('data:realIndex'));
        var pointsMain = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesIndex, "'] .apexcharts-series-markers-wrap"));

        if (pointsMain !== null) {
          // it can be null as we have tooltips in donut/bar charts
          var point = void 0;
          var PointClasses = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));

          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
            PointClasses += ' no-pointer-events';
          }

          var elPointOptions = marker.getMarkerConfig(PointClasses, seriesIndex);
          point = graphics.drawMarker(0, 0, elPointOptions);
          point.node.setAttribute('default-marker-size', 0);
          var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');
          elPointsG.classList.add('apexcharts-series-markers');
          elPointsG.appendChild(point.node);
          pointsMain.appendChild(elPointsG);
        }
      }
    }
  }, {
    key: "enlargeCurrentPoint",
    value: function enlargeCurrentPoint(rel, point) {
      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var w = this.w;

      if (w.config.chart.type !== 'bubble') {
        this.newPointSize(rel, point);
      }

      var cx = point.getAttribute('cx');
      var cy = point.getAttribute('cy');

      if (x !== null && y !== null) {
        cx = x;
        cy = y;
      }

      this.tooltipPosition.moveXCrosshairs(cx);

      if (!this.fixedTooltip) {
        if (w.config.chart.type === 'radar') {
          var elGrid = this.ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          cx = this.ttCtx.e.clientX - seriesBound.left;
        }

        this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);
      }
    }
  }, {
    key: "enlargePoints",
    value: function enlargePoints(j) {
      var w = this.w;
      var me = this;
      var ttCtx = this.ttCtx;
      var col = j;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');
      var newSize = w.config.markers.hover.size;

      for (var p = 0; p < points.length; p++) {
        var rel = points[p].getAttribute('rel');
        var index = points[p].getAttribute('index');

        if (newSize === undefined) {
          newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
        }

        if (col === parseInt(rel)) {
          me.newPointSize(col, points[p]);
          var cx = points[p].getAttribute('cx');
          var cy = points[p].getAttribute('cy');
          me.tooltipPosition.moveXCrosshairs(cx);

          if (!ttCtx.fixedTooltip) {
            me.tooltipPosition.moveTooltip(cx, cy, newSize);
          }
        } else {
          me.oldPointSize(points[p]);
        }
      }
    }
  }, {
    key: "newPointSize",
    value: function newPointSize(rel, point) {
      var w = this.w;
      var newSize = w.config.markers.hover.size;
      var elPoint = null;

      if (rel === 0) {
        elPoint = point.parentNode.firstChild;
      } else {
        elPoint = point.parentNode.lastChild;
      }

      var index = parseInt(elPoint.getAttribute('index'));

      if (newSize === undefined) {
        newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
      }

      elPoint.setAttribute('r', newSize);
    }
  }, {
    key: "oldPointSize",
    value: function oldPointSize(point) {
      var size = parseInt(point.getAttribute('default-marker-size'));
      point.setAttribute('r', size);
    }
  }, {
    key: "resetPointsSize",
    value: function resetPointsSize() {
      var w = this.w;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');

      for (var p = 0; p < points.length; p++) {
        var size = parseInt(points[p].getAttribute('default-marker-size'));

        if (Utils.isNumber(size)) {
          points[p].setAttribute('r', size);
        } else {
          points[p].setAttribute('r', 0);
        }
      }
    }
  }]);

  return Marker;
}();

/**
 * ApexCharts Tooltip.Intersect Class.
 *
 * @module Tooltip.Intersect
 **/

var Intersect =
/*#__PURE__*/
function () {
  function Intersect(tooltipContext) {
    _classCallCheck(this, Intersect);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
  }

  _createClass(Intersect, [{
    key: "getAttr",
    value: function getAttr(e, attr) {
      return parseFloat(e.target.getAttribute(attr));
    }
  }, {
    key: "handleHeatTooltip",
    value: function handleHeatTooltip(_ref) {
      var e = _ref.e,
          opt = _ref.opt,
          x = _ref.x,
          y = _ref.y;
      var ttCtx = this.ttCtx;
      var w = this.w;

      if (e.target.classList.contains('apexcharts-heatmap-rect')) {
        var i = this.getAttr(e, 'i');
        var j = this.getAttr(e, 'j');
        var cx = this.getAttr(e, 'cx');
        var cy = this.getAttr(e, 'cy');
        var width = this.getAttr(e, 'width');
        var height = this.getAttr(e, 'height');
        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: false
        });
        x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;
        y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;
        ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);

        if (x > w.globals.gridWidth / 2) {
          x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;
        }

        if (ttCtx.w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect(); // x = ttCtx.e.clientX - seriesBound.left

          y = ttCtx.e.clientY - seriesBound.top + w.globals.translateY / 2 - 10;
        }
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "handleMarkerTooltip",
    value: function handleMarkerTooltip(_ref2) {
      var e = _ref2.e,
          opt = _ref2.opt,
          x = _ref2.x,
          y = _ref2.y;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var i;
      var j;

      if (e.target.classList.contains('apexcharts-marker')) {
        var cx = parseInt(opt.paths.getAttribute('cx'));
        var cy = parseInt(opt.paths.getAttribute('cy'));
        var val = parseFloat(opt.paths.getAttribute('val'));
        j = parseInt(opt.paths.getAttribute('rel'));
        i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel')) - 1;

        if (ttCtx.intersect) {
          var el = Utils.findAncestor(opt.paths, 'apexcharts-series');

          if (el) {
            i = parseInt(el.getAttribute('data:realIndex'));
          }
        }

        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared
        });

        if (e.type === 'mouseup') {
          ttCtx.markerClick(e, i, j);
        }

        x = cx;
        y = cy + w.globals.translateY - ttCtx.tooltipRect.ttHeight * 1.4;

        if (ttCtx.w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;
        }

        if (val < 0) {
          y = cy;
        }

        ttCtx.marker.enlargeCurrentPoint(j, opt.paths, x, y);
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "handleBarTooltip",
    value: function handleBarTooltip(_ref3) {
      var e = _ref3.e,
          opt = _ref3.opt;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var tooltipEl = ttCtx.getElTooltip();
      var bx = 0;
      var x = 0;
      var y = 0; // let bW = 0

      var i = 0;
      var strokeWidth;
      var barXY = this.getBarTooltipXY({
        e: e,
        opt: opt
      });
      i = barXY.i;
      var barHeight = barXY.barHeight;
      var j = barXY.j;

      if (w.globals.isBarHorizontal && ttCtx.hasBars() || !w.config.tooltip.shared) {
        x = barXY.x;
        y = barXY.y;
        strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width; // bW = barXY.barWidth

        bx = x;
      } else {
        if (!w.globals.comboCharts && !w.config.tooltip.shared) {
          bx = bx / 2;
        }
      } // y is NaN, make it touch the bottom of grid area


      if (isNaN(y)) {
        y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;
      } // x exceeds gridWidth


      if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth) {
        x = x - ttCtx.tooltipRect.ttWidth;
      } else if (x < 0) {
        x = x + ttCtx.tooltipRect.ttWidth;
      }

      if (ttCtx.w.config.tooltip.followCursor) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        y = ttCtx.e.clientY - seriesBound.top;
      } // if tooltip is still null, querySelector


      if (ttCtx.tooltip === null) {
        ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
      }

      if (!w.config.tooltip.shared) {
        if (w.globals.comboChartsHasBars) {
          ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);
        } else {
          ttCtx.tooltipPosition.moveXCrosshairs(bx);
        }
      } // move tooltip here


      if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || w.globals.isBarHorizontal && ttCtx.hasBars())) {
        if (isReversed) {
          x = w.globals.gridWidth - x;
        }

        tooltipEl.style.left = x + w.globals.translateX + 'px';
        var seriesIndex = parseInt(opt.paths.parentNode.getAttribute('data:realIndex'));
        var isReversed = w.globals.isMultipleYAxis ? w.config.yaxis[seriesIndex] && w.config.yaxis[seriesIndex].reversed : w.config.yaxis[0].reversed;

        if (isReversed && !(w.globals.isBarHorizontal && ttCtx.hasBars())) {
          y = y + barHeight - (w.globals.series[i][j] < 0 ? barHeight : 0) * 2;
        }

        if (ttCtx.tooltipRect.ttHeight + y > w.globals.gridHeight) {
          y = w.globals.gridHeight - ttCtx.tooltipRect.ttHeight + w.globals.translateY;
          tooltipEl.style.top = y + 'px';
        } else {
          tooltipEl.style.top = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2 + 'px';
        }
      }
    }
  }, {
    key: "getBarTooltipXY",
    value: function getBarTooltipXY(_ref4) {
      var e = _ref4.e,
          opt = _ref4.opt;
      var w = this.w;
      var j = null;
      var ttCtx = this.ttCtx;
      var i = 0;
      var x = 0;
      var y = 0;
      var barWidth = 0;
      var barHeight = 0;
      var cl = e.target.classList;

      if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area') || cl.contains('apexcharts-rangebar-area')) {
        var bar = e.target;
        var barRect = bar.getBoundingClientRect();
        var seriesBound = opt.elGrid.getBoundingClientRect();
        var bh = barRect.height;
        barHeight = barRect.height;
        var bw = barRect.width;
        var cx = parseInt(bar.getAttribute('cx'));
        var cy = parseInt(bar.getAttribute('cy'));
        barWidth = parseFloat(bar.getAttribute('barWidth'));
        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        j = parseInt(bar.getAttribute('j'));
        i = parseInt(bar.parentNode.getAttribute('rel')) - 1;

        if (w.globals.comboCharts) {
          i = parseInt(bar.parentNode.getAttribute('data:realIndex'));
        } // if (w.config.tooltip.shared) {
        // this check not needed  at the moment
        //   const yDivisor = w.globals.gridHeight / (w.globals.series.length)
        //   const hoverY = ttCtx.clientY - ttCtx.seriesBound.top
        //   j = Math.ceil(hoverY / yDivisor)
        // }


        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared
        });

        if (w.config.tooltip.followCursor) {
          if (w.globals.isBarHorizontal) {
            x = clientX - seriesBound.left + 15;
            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;
          } else {
            if (w.globals.isXNumeric) {
              x = cx - bw / 2;
            } else {
              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;
            }

            y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;
          }
        } else {
          if (w.globals.isBarHorizontal) {
            x = cx;

            if (x < ttCtx.xyRatios.baseLineInvertedY) {
              x = cx - ttCtx.tooltipRect.ttWidth;
            }

            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;
          } else {
            // if columns
            if (w.globals.isXNumeric) {
              x = cx - bw / 2;
            } else {
              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;
            }

            y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10
          }
        }
      }

      return {
        x: x,
        y: y,
        barHeight: barHeight,
        barWidth: barWidth,
        i: i,
        j: j
      };
    }
  }]);

  return Intersect;
}();

/**
 * ApexCharts Tooltip.AxesTooltip Class.
 *
 * @module Tooltip.AxesTooltip
 **/
var AxesTooltip =
/*#__PURE__*/
function () {
  function AxesTooltip(tooltipContext) {
    _classCallCheck(this, AxesTooltip);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
  }
  /**
   * This method adds the secondary tooltip which appears below x axis
   * @memberof Tooltip
   **/


  _createClass(AxesTooltip, [{
    key: "drawXaxisTooltip",
    value: function drawXaxisTooltip() {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var isBottom = w.config.xaxis.position === 'bottom';
      ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : 1;
      var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';
      var renderTo = w.globals.dom.elWrap;

      if (ttCtx.blxaxisTooltip) {
        var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');

        if (xaxisTooltip === null) {
          ttCtx.xaxisTooltip = document.createElement('div');
          ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass + ' ' + w.config.tooltip.theme);
          renderTo.appendChild(ttCtx.xaxisTooltip);
          ttCtx.xaxisTooltipText = document.createElement('div');
          ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');
          ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;
          ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;
          ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);
        }
      }
    }
    /**
     * This method adds the secondary tooltip which appears below x axis
     * @memberof Tooltip
     **/

  }, {
    key: "drawYaxisTooltip",
    value: function drawYaxisTooltip() {
      var w = this.w;
      var ttCtx = this.ttCtx;

      var _loop = function _loop(i) {
        var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;
        ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;
        var tooltipCssClass = isRight ? "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-right") : "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-left");
        w.globals.yAxisSameScaleIndices.map(function (samescales, ssi) {
          samescales.map(function (s, si) {
            if (si === i) {
              tooltipCssClass += w.config.yaxis[si].show ? " " : " apexcharts-yaxistooltip-hidden";
            }
          });
        });
        var renderTo = w.globals.dom.elWrap;

        if (ttCtx.blyaxisTooltip) {
          var yaxisTooltip = w.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i));

          if (yaxisTooltip === null) {
            ttCtx.yaxisTooltip = document.createElement('div');
            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass + ' ' + w.config.tooltip.theme);
            renderTo.appendChild(ttCtx.yaxisTooltip);
            if (i === 0) ttCtx.yaxisTooltipText = [];
            ttCtx.yaxisTooltipText.push(document.createElement('div'));
            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');
            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);
          }
        }
      };

      for (var i = 0; i < w.config.yaxis.length; i++) {
        _loop(i);
      }
    }
    /**
     * @memberof Tooltip
     **/

  }, {
    key: "setXCrosshairWidth",
    value: function setXCrosshairWidth() {
      var w = this.w;
      var ttCtx = this.ttCtx; // set xcrosshairs width

      var xcrosshairs = ttCtx.getElXCrosshairs();
      ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width);

      if (!w.globals.comboCharts) {
        if (w.config.xaxis.crosshairs.width === 'tickWidth') {
          var count = w.globals.labels.length;
          ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;
        } else if (w.config.xaxis.crosshairs.width === 'barWidth') {
          var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');

          if (bar !== null) {
            var barWidth = parseFloat(bar.getAttribute('barWidth'));
            ttCtx.xcrosshairsWidth = barWidth;
          } else {
            ttCtx.xcrosshairsWidth = 1;
          }
        }
      } else {
        var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');

        if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {
          var _barWidth = parseFloat(_bar.getAttribute('barWidth'));

          ttCtx.xcrosshairsWidth = _barWidth;
        } else {
          if (w.config.xaxis.crosshairs.width === 'tickWidth') {
            var _count = w.globals.labels.length;
            ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;
          }
        }
      }

      if (w.globals.isBarHorizontal) {
        ttCtx.xcrosshairsWidth = 0;
      }

      if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {
        xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);
      }
    }
  }, {
    key: "handleYCrosshair",
    value: function handleYCrosshair() {
      var w = this.w;
      var ttCtx = this.ttCtx; // set ycrosshairs height

      ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');
      ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');
    }
  }, {
    key: "drawYaxisTooltipText",
    value: function drawYaxisTooltipText(index, clientY, xyRatios) {
      var ttCtx = this.ttCtx;
      var w = this.w;
      var lbFormatter = w.globals.yLabelFormatters[index];

      if (ttCtx.blyaxisTooltip) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[index];
        var height = w.globals.maxYArr[index] - w.globals.minYArr[index];
        var val = w.globals.minYArr[index] + (height - hoverY);
        ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);
        ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);
        ttCtx.tooltipPosition.moveYAxisTooltip(index);
      }
    }
  }]);

  return AxesTooltip;
}();

/**
 * ApexCharts Core Tooltip Class to handle the tooltip generation.
 *
 * @module Tooltip
 **/

var Tooltip =
/*#__PURE__*/
function () {
  function Tooltip(ctx) {
    _classCallCheck(this, Tooltip);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.tConfig = w.config.tooltip;
    this.tooltipUtil = new Utils$1(this);
    this.tooltipLabels = new Labels(this);
    this.tooltipPosition = new Position(this);
    this.marker = new Marker(this);
    this.intersect = new Intersect(this);
    this.axesTooltip = new AxesTooltip(this);
    this.showOnIntersect = this.tConfig.intersect;
    this.showTooltipTitle = this.tConfig.x.show;
    this.fixedTooltip = this.tConfig.fixed.enabled;
    this.xaxisTooltip = null;
    this.yaxisTTEls = null;
    this.isBarShared = !w.globals.isBarHorizontal && this.tConfig.shared;
  }

  _createClass(Tooltip, [{
    key: "getElTooltip",
    value: function getElTooltip(ctx) {
      if (!ctx) ctx = this;
      return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
    }
  }, {
    key: "getElXCrosshairs",
    value: function getElXCrosshairs() {
      return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');
    }
  }, {
    key: "getElGrid",
    value: function getElGrid() {
      return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');
    }
  }, {
    key: "drawTooltip",
    value: function drawTooltip(xyRatios) {
      var w = this.w;
      this.xyRatios = xyRatios;
      this.blxaxisTooltip = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;
      this.blyaxisTooltip = w.config.yaxis[0].tooltip.enabled && w.globals.axisCharts;
      this.allTooltipSeriesGroups = [];

      if (!w.globals.axisCharts) {
        this.showTooltipTitle = false;
      }

      var tooltipEl = document.createElement('div');
      tooltipEl.classList.add('apexcharts-tooltip');
      tooltipEl.classList.add(this.tConfig.theme);
      w.globals.dom.elWrap.appendChild(tooltipEl);

      if (w.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip();
        this.axesTooltip.drawYaxisTooltip();
        this.axesTooltip.setXCrosshairWidth();
        this.axesTooltip.handleYCrosshair();
        var xAxis = new XAxis(this.ctx);
        this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();
      } // we forcefully set intersect true for these conditions


      if (w.globals.comboCharts && !this.tConfig.shared || this.tConfig.intersect && !this.tConfig.shared || (w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') && !this.tConfig.shared) {
        this.showOnIntersect = true;
      }

      if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {
        // when user don't want to show points all the time, but only on when hovering on series
        this.marker.drawDynamicPoints(this);
      } // no visible series, exit


      if (w.globals.collapsedSeries.length === w.globals.series.length) return;
      this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
      this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;

      if (this.showTooltipTitle) {
        this.tooltipTitle = document.createElement('div');
        this.tooltipTitle.classList.add('apexcharts-tooltip-title');
        this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || w.config.chart.fontFamily;
        this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize;
        tooltipEl.appendChild(this.tooltipTitle);
      }

      var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared

      if ((w.globals.xyCharts || w.globals.comboCharts) && this.tConfig.shared) {
        if (!this.showOnIntersect) {
          ttItemsCnt = w.globals.series.length;
        } else {
          ttItemsCnt = 1;
        }
      }

      this.ttItems = this.createTTElements(ttItemsCnt);
      this.addSVGEvents();
    }
  }, {
    key: "createTTElements",
    value: function createTTElements(ttItemsCnt) {
      var w = this.w;
      var ttItems = [];
      var tooltipEl = this.getElTooltip();

      for (var i = 0; i < ttItemsCnt; i++) {
        var gTxt = document.createElement('div');
        gTxt.classList.add('apexcharts-tooltip-series-group');

        if (this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries)) {
          if (this.tConfig.enabledOnSeries.indexOf(i) < 0) {
            gTxt.classList.add('apexcharts-tooltip-series-group-hidden');
          }
        }

        var point = document.createElement('span');
        point.classList.add('apexcharts-tooltip-marker');
        point.style.backgroundColor = w.globals.colors[i];
        gTxt.appendChild(point);
        var gYZ = document.createElement('div');
        gYZ.classList.add('apexcharts-tooltip-text');
        gYZ.style.fontFamily = this.tConfig.style.fontFamily || w.config.chart.fontFamily;
        gYZ.style.fontSize = this.tConfig.style.fontSize; // y values group

        var gYValText = document.createElement('div');
        gYValText.classList.add('apexcharts-tooltip-y-group');
        var txtLabel = document.createElement('span');
        txtLabel.classList.add('apexcharts-tooltip-text-label');
        gYValText.appendChild(txtLabel);
        var txtValue = document.createElement('span');
        txtValue.classList.add('apexcharts-tooltip-text-value');
        gYValText.appendChild(txtValue); // z values group

        var gZValText = document.createElement('div');
        gZValText.classList.add('apexcharts-tooltip-z-group');
        var txtZLabel = document.createElement('span');
        txtZLabel.classList.add('apexcharts-tooltip-text-z-label');
        gZValText.appendChild(txtZLabel);
        var txtZValue = document.createElement('span');
        txtZValue.classList.add('apexcharts-tooltip-text-z-value');
        gZValText.appendChild(txtZValue);
        gYZ.appendChild(gYValText);
        gYZ.appendChild(gZValText);
        gTxt.appendChild(gYZ);
        tooltipEl.appendChild(gTxt);
        ttItems.push(gTxt);
      }

      return ttItems;
    }
  }, {
    key: "addSVGEvents",
    value: function addSVGEvents() {
      var w = this.w;
      var type = w.config.chart.type;
      var tooltipEl = this.getElTooltip();
      var commonBar = !!(type === 'bar' || type === 'candlestick' || type === 'rangeBar');
      var hoverArea = w.globals.dom.Paper.node;
      var elGrid = this.getElGrid();

      if (elGrid) {
        this.seriesBound = elGrid.getBoundingClientRect();
      }

      var tooltipY = [];
      var tooltipX = [];
      var seriesHoverParams = {
        hoverArea: hoverArea,
        elGrid: elGrid,
        tooltipEl: tooltipEl,
        tooltipY: tooltipY,
        tooltipX: tooltipX,
        ttItems: this.ttItems
      };
      var points;

      if (w.globals.axisCharts) {
        if (type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble') {
          points = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker");
        } else if (commonBar) {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area');
        } else if (type === 'heatmap') {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap');
        } else if (type === 'radar') {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-marker');
        }

        if (points && points.length) {
          for (var p = 0; p < points.length; p++) {
            tooltipY.push(points[p].getAttribute('cy'));
            tooltipX.push(points[p].getAttribute('cx'));
          }
        }
      }

      var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || commonBar && this.hasBars() && this.tConfig.shared;

      if (validSharedChartTypes) {
        this.addPathsEventListeners([hoverArea], seriesHoverParams);
      } else if (commonBar && !w.globals.comboCharts) {
        this.addBarsEventListeners(seriesHoverParams);
      } else if (type === 'bubble' || type === 'scatter' || type === 'radar' || this.showOnIntersect && (type === 'area' || type === 'line')) {
        this.addPointsEventsListeners(seriesHoverParams);
      } else if (!w.globals.axisCharts || type === 'heatmap') {
        var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');
        this.addPathsEventListeners(seriesAll, seriesHoverParams);
      }

      if (this.showOnIntersect) {
        var linePoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker');

        if (linePoints.length > 0) {
          // if we find any lineSeries, addEventListeners for them
          this.addPathsEventListeners(linePoints, seriesHoverParams);
        }

        var areaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-marker');

        if (areaPoints.length > 0) {
          // if we find any areaSeries, addEventListeners for them
          this.addPathsEventListeners(areaPoints, seriesHoverParams);
        } // combo charts may have bars, so add event listeners here too


        if (this.hasBars() && !this.tConfig.shared) {
          this.addBarsEventListeners(seriesHoverParams);
        }
      }
    }
  }, {
    key: "drawFixedTooltipRect",
    value: function drawFixedTooltipRect() {
      var w = this.w;
      var tooltipEl = this.getElTooltip();
      var tooltipRect = tooltipEl.getBoundingClientRect();
      var ttWidth = tooltipRect.width + 10;
      var ttHeight = tooltipRect.height + 10;
      var x = this.tConfig.fixed.offsetX;
      var y = this.tConfig.fixed.offsetY;

      if (this.tConfig.fixed.position.toLowerCase().indexOf('right') > -1) {
        x = x + w.globals.svgWidth - ttWidth + 10;
      }

      if (this.tConfig.fixed.position.toLowerCase().indexOf('bottom') > -1) {
        y = y + w.globals.svgHeight - ttHeight - 10;
      }

      tooltipEl.style.left = x + 'px';
      tooltipEl.style.top = y + 'px';
      return {
        x: x,
        y: y,
        ttWidth: ttWidth,
        ttHeight: ttHeight
      };
    }
  }, {
    key: "addPointsEventsListeners",
    value: function addPointsEventsListeners(seriesHoverParams) {
      var w = this.w;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');
      this.addPathsEventListeners(points, seriesHoverParams);
    }
  }, {
    key: "addBarsEventListeners",
    value: function addBarsEventListeners(seriesHoverParams) {
      var w = this.w;
      var bars = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area');
      this.addPathsEventListeners(bars, seriesHoverParams);
    }
  }, {
    key: "addPathsEventListeners",
    value: function addPathsEventListeners(paths, opts) {
      var _this = this;

      var self = this;

      var _loop = function _loop(p) {
        var extendedOpts = {
          paths: paths[p],
          tooltipEl: opts.tooltipEl,
          tooltipY: opts.tooltipY,
          tooltipX: opts.tooltipX,
          elGrid: opts.elGrid,
          hoverArea: opts.hoverArea,
          ttItems: opts.ttItems
        };
        _this.w.globals.tooltipOpts = extendedOpts;
        var events = ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'];
        events.map(function (ev) {
          return paths[p].addEventListener(ev, self.seriesHover.bind(self, extendedOpts), {
            capture: false,
            passive: true
          });
        });
      };

      for (var p = 0; p < paths.length; p++) {
        _loop(p);
      }
    }
    /*
     ** The actual series hover function
     */

  }, {
    key: "seriesHover",
    value: function seriesHover(opt, e) {
      var _this2 = this;

      var chartGroups = [];
      var w = this.w; // if user has more than one charts in group, we need to sync

      if (w.config.chart.group) {
        chartGroups = this.ctx.getGroupedCharts();
      }

      if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {
        return;
      }

      if (chartGroups.length) {
        chartGroups.forEach(function (ch) {
          var tooltipEl = _this2.getElTooltip(ch);

          var newOpts = {
            paths: opt.paths,
            tooltipEl: tooltipEl,
            tooltipY: opt.tooltipY,
            tooltipX: opt.tooltipX,
            elGrid: opt.elGrid,
            hoverArea: opt.hoverArea,
            ttItems: ch.w.globals.tooltip.ttItems // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly

          };

          if (ch.w.globals.minX === _this2.w.globals.minX && ch.w.globals.maxX === _this2.w.globals.maxX) {
            ch.w.globals.tooltip.seriesHoverByContext({
              chartCtx: ch,
              ttCtx: ch.w.globals.tooltip,
              opt: newOpts,
              e: e
            });
          }
        });
      } else {
        this.seriesHoverByContext({
          chartCtx: this.ctx,
          ttCtx: this.w.globals.tooltip,
          opt: opt,
          e: e
        });
      }
    }
  }, {
    key: "seriesHoverByContext",
    value: function seriesHoverByContext(_ref) {
      var chartCtx = _ref.chartCtx,
          ttCtx = _ref.ttCtx,
          opt = _ref.opt,
          e = _ref.e;
      var w = chartCtx.w;
      var tooltipEl = this.getElTooltip(); // tooltipRect is calculated on every mousemove, because the text is dynamic

      ttCtx.tooltipRect = {
        x: 0,
        y: 0,
        ttWidth: tooltipEl.getBoundingClientRect().width,
        ttHeight: tooltipEl.getBoundingClientRect().height
      };
      ttCtx.e = e; // highlight the current hovered bars

      if (ttCtx.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {
        if (this.tConfig.onDatasetHover.highlightDataSeries) {
          var series = new Series(chartCtx);
          series.toggleSeriesOnHover(e, e.target.parentNode);
        }
      }

      if (ttCtx.fixedTooltip) {
        ttCtx.drawFixedTooltipRect();
      }

      if (w.globals.axisCharts) {
        ttCtx.axisChartsTooltips({
          e: e,
          opt: opt,
          tooltipRect: ttCtx.tooltipRect
        });
      } else {
        // non-plot charts i.e pie/donut/circle
        ttCtx.nonAxisChartsTooltips({
          e: e,
          opt: opt,
          tooltipRect: ttCtx.tooltipRect
        });
      }
    } // tooltip handling for line/area/bar/columns/scatter

  }, {
    key: "axisChartsTooltips",
    value: function axisChartsTooltips(_ref2) {
      var e = _ref2.e,
          opt = _ref2.opt;
      var w = this.w;
      var j, x, y;
      var self = this;
      var capj = null;
      var seriesBound = opt.elGrid.getBoundingClientRect();
      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
      var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      this.clientY = clientY;
      this.clientX = clientX;

      if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {
        self.handleMouseOut(opt);
        return;
      }

      if (Array.isArray(this.tConfig.enabledOnSeries) && !w.config.tooltip.shared) {
        var index = parseInt(opt.paths.getAttribute('index'));

        if (this.tConfig.enabledOnSeries.indexOf(index) < 0) {
          self.handleMouseOut(opt);
          return;
        }
      }

      var tooltipEl = this.getElTooltip();
      var xcrosshairs = this.getElXCrosshairs();
      var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !w.globals.isBarHorizontal && this.hasBars() && this.tConfig.shared || w.globals.comboCharts && this.hasBars;

      if (w.globals.isBarHorizontal && this.hasBars()) {
        isStickyTooltip = false;
      }

      if (e.type === 'mousemove' || e.type === 'touchmove' || e.type === 'mouseup') {
        if (xcrosshairs !== null) {
          xcrosshairs.classList.add('active');
        }

        if (self.ycrosshairs !== null && self.blyaxisTooltip) {
          self.ycrosshairs.classList.add('active');
        }

        if (isStickyTooltip && !self.showOnIntersect) {
          capj = self.tooltipUtil.getNearestValues({
            context: self,
            hoverArea: opt.hoverArea,
            elGrid: opt.elGrid,
            clientX: clientX,
            clientY: clientY,
            hasBars: self.hasBars
          });
          j = capj.j;
          var capturedSeries = capj.capturedSeries;

          if (capj.hoverX < 0 || capj.hoverX > w.globals.gridWidth) {
            self.handleMouseOut(opt);
            return;
          }

          if (capturedSeries !== null) {
            var ignoreNull = w.globals.series[capturedSeries][j] === null;

            if (ignoreNull) {
              opt.tooltipEl.classList.remove('active');
              return;
            }

            if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {
              if (this.tConfig.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isinitialSeriesSameLen()) {
                this.create(e, self, capturedSeries, j, opt.ttItems);
              } else {
                this.create(e, self, capturedSeries, j, opt.ttItems, false);
              }
            } else {
              if (this.tooltipUtil.isXoverlap(j)) {
                self.create(e, self, 0, j, opt.ttItems);
              }
            }
          } else {
            // couldn't capture any series. check if shared X is same,
            // if yes, draw a grouped tooltip
            if (this.tooltipUtil.isXoverlap(j)) {
              self.create(e, self, 0, j, opt.ttItems);
            }
          }
        } else {
          if (w.config.chart.type === 'heatmap') {
            var markerXY = this.intersect.handleHeatTooltip({
              e: e,
              opt: opt,
              x: x,
              y: y
            });
            x = markerXY.x;
            y = markerXY.y;
            tooltipEl.style.left = x + 'px';
            tooltipEl.style.top = y + 'px';
          } else {
            if (this.hasBars) {
              this.intersect.handleBarTooltip({
                e: e,
                opt: opt
              });
            }

            if (this.hasMarkers) {
              // intersect - line/area/scatter/bubble
              this.intersect.handleMarkerTooltip({
                e: e,
                opt: opt,
                x: x,
                y: y
              });
            }
          }
        }

        if (this.blyaxisTooltip) {
          for (var yt = 0; yt < w.config.yaxis.length; yt++) {
            self.axesTooltip.drawYaxisTooltipText(yt, clientY, self.xyRatios);
          }
        }

        opt.tooltipEl.classList.add('active');
      } else if (e.type === 'mouseout' || e.type === 'touchend') {
        this.handleMouseOut(opt);
      }
    } // tooltip handling for pie/donuts

  }, {
    key: "nonAxisChartsTooltips",
    value: function nonAxisChartsTooltips(_ref3) {
      var e = _ref3.e,
          opt = _ref3.opt,
          tooltipRect = _ref3.tooltipRect;
      var w = this.w;
      var rel = opt.paths.getAttribute('rel');
      var tooltipEl = this.getElTooltip();
      var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();

      if (e.type === 'mousemove' || e.type === 'touchmove') {
        tooltipEl.classList.add('active');
        this.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: parseInt(rel) - 1,
          shared: false
        });
        var x = w.globals.clientX - seriesBound.left - tooltipRect.ttWidth / 2;
        var y = w.globals.clientY - seriesBound.top - tooltipRect.ttHeight - 10;
        tooltipEl.style.left = x + 'px';
        tooltipEl.style.top = y + 'px';
      } else if (e.type === 'mouseout' || e.type === 'touchend') {
        tooltipEl.classList.remove('active');
      }
    }
  }, {
    key: "deactivateHoverFilter",
    value: function deactivateHoverFilter() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var allPaths = w.globals.dom.Paper.select(".apexcharts-bar-area");

      for (var b = 0; b < allPaths.length; b++) {
        graphics.pathMouseLeave(allPaths[b]);
      }
    }
  }, {
    key: "handleMouseOut",
    value: function handleMouseOut(opt) {
      var w = this.w;
      var xcrosshairs = this.getElXCrosshairs();
      opt.tooltipEl.classList.remove('active');
      this.deactivateHoverFilter();

      if (w.config.chart.type !== 'bubble') {
        this.marker.resetPointsSize();
      }

      if (xcrosshairs !== null) {
        xcrosshairs.classList.remove('active');
      }

      if (this.ycrosshairs !== null) {
        this.ycrosshairs.classList.remove('active');
      }

      if (this.blxaxisTooltip) {
        this.xaxisTooltip.classList.remove('active');
      }

      if (this.blyaxisTooltip) {
        if (this.yaxisTTEls === null) {
          this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
        }

        for (var i = 0; i < this.yaxisTTEls.length; i++) {
          this.yaxisTTEls[i].classList.remove('active');
        }
      }
    }
  }, {
    key: "getElMarkers",
    value: function getElMarkers() {
      return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers');
    }
  }, {
    key: "getAllMarkers",
    value: function getAllMarkers() {
      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');
    }
  }, {
    key: "hasMarkers",
    value: function hasMarkers() {
      var markers = this.getElMarkers();
      return markers.length > 0;
    }
  }, {
    key: "getElBars",
    value: function getElBars() {
      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series');
    }
  }, {
    key: "hasBars",
    value: function hasBars() {
      var bars = this.getElBars();
      return bars.length > 0;
    }
  }, {
    key: "markerClick",
    value: function markerClick(e, seriesIndex, dataPointIndex) {
      var w = this.w;

      if (typeof w.config.chart.events.markerClick === 'function') {
        w.config.chart.events.markerClick(e, this.ctx, {
          seriesIndex: seriesIndex,
          dataPointIndex: dataPointIndex,
          w: w
        });
      }

      this.ctx.fireEvent('markerClick', [e, this.ctx, {
        seriesIndex: seriesIndex,
        dataPointIndex: dataPointIndex,
        w: w
      }]);
    }
  }, {
    key: "create",
    value: function create(e, context, capturedSeries, j, ttItems) {
      var shared = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var w = this.w;
      var ttCtx = context;

      if (e.type === 'mouseup') {
        this.markerClick(e, capturedSeries, j);
      }

      if (shared === null) shared = this.tConfig.shared;
      var hasMarkers = this.hasMarkers();
      var bars = this.getElBars();

      if (shared) {
        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: ttItems,
          i: capturedSeries,
          j: j,
          shared: this.showOnIntersect ? false : this.tConfig.shared
        });

        if (hasMarkers) {
          if (w.globals.markers.largestSize > 0) {
            ttCtx.marker.enlargePoints(j);
          } else {
            ttCtx.tooltipPosition.moveDynamicPointsOnHover(j);
          }
        }

        if (this.hasBars()) {
          this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);

          if (this.barSeriesHeight > 0) {
            // hover state, activate snap filter
            var graphics = new Graphics(this.ctx);
            var paths = w.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(j, "']")); // de-activate first

            this.deactivateHoverFilter();
            this.tooltipPosition.moveStickyTooltipOverBars(j);

            for (var b = 0; b < paths.length; b++) {
              graphics.pathMouseEnter(paths[b]);
            }
          }
        }
      } else {
        ttCtx.tooltipLabels.drawSeriesTexts({
          shared: false,
          ttItems: ttItems,
          i: capturedSeries,
          j: j
        });

        if (this.hasBars()) {
          ttCtx.tooltipPosition.moveStickyTooltipOverBars(j);
        }

        if (hasMarkers) {
          ttCtx.tooltipPosition.moveMarkers(capturedSeries, j);
        }
      }
    }
  }]);

  return Tooltip;
}();

var icoPan = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <defs>\n        <path d=\"M0 0h24v24H0z\" id=\"a\"/>\n    </defs>\n    <clipPath id=\"b\">\n        <use overflow=\"visible\" xlink:href=\"#a\"/>\n    </clipPath>\n    <path clip-path=\"url(#b)\" d=\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\"/>\n</svg>";

var icoZoom = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"/>\n    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n    <path d=\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\"/>\n</svg>";

var icoReset = "<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/>\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n</svg>";

var icoZoomIn = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

var icoZoomOut = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

var icoSelect = "<svg fill=\"#6E8192\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\"/>\n</svg>";

var icoMenu = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"none\" d=\"M0 0h24v24H0V0z\"/><path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"/></svg>";

/**
 * ApexCharts Toolbar Class for creating toolbar in axis based charts.
 *
 * @module Toolbar
 **/

var Toolbar =
/*#__PURE__*/
function () {
  function Toolbar(ctx) {
    _classCallCheck(this, Toolbar);

    this.ctx = ctx;
    this.w = ctx.w;
    this.ev = this.w.config.chart.events;
    this.localeValues = this.w.globals.locale.toolbar;
  }

  _createClass(Toolbar, [{
    key: "createToolbar",
    value: function createToolbar() {
      var w = this.w;
      var elToolbarWrap = document.createElement('div');
      elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');
      w.globals.dom.elWrap.appendChild(elToolbarWrap);
      this.elZoom = document.createElement('div');
      this.elZoomIn = document.createElement('div');
      this.elZoomOut = document.createElement('div');
      this.elPan = document.createElement('div');
      this.elSelection = document.createElement('div');
      this.elZoomReset = document.createElement('div');
      this.elMenuIcon = document.createElement('div');
      this.elMenu = document.createElement('div');
      this.elCustomIcons = [];
      this.t = w.config.chart.toolbar.tools;

      if (Array.isArray(this.t.customIcons)) {
        for (var i = 0; i < this.t.customIcons.length; i++) {
          this.elCustomIcons.push(document.createElement('div'));
        }
      }

      this.elMenuItems = [];
      var toolbarControls = [];

      if (this.t.zoomin && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomIn,
          icon: typeof this.t.zoomin === 'string' ? this.t.zoomin : icoZoomIn,
          title: this.localeValues.zoomIn,
          class: 'apexcharts-zoom-in-icon'
        });
      }

      if (this.t.zoomout && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomOut,
          icon: typeof this.t.zoomout === 'string' ? this.t.zoomout : icoZoomOut,
          title: this.localeValues.zoomOut,
          class: 'apexcharts-zoom-out-icon'
        });
      }

      if (this.t.zoom && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoom,
          icon: typeof this.t.zoom === 'string' ? this.t.zoom : icoZoom,
          title: this.localeValues.selectionZoom,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-zoom-icon'
        });
      }

      if (this.t.selection && w.config.chart.selection.enabled) {
        toolbarControls.push({
          el: this.elSelection,
          icon: typeof this.t.selection === 'string' ? this.t.selection : icoSelect,
          title: this.localeValues.selection,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-selection-icon'
        });
      }

      if (this.t.pan && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elPan,
          icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,
          title: this.localeValues.pan,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-pan-icon'
        });
      }

      if (this.t.reset && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomReset,
          icon: typeof this.t.reset === 'string' ? this.t.reset : icoReset,
          title: this.localeValues.reset,
          class: 'apexcharts-reset-zoom-icon'
        });
      }

      if (this.t.download) {
        toolbarControls.push({
          el: this.elMenuIcon,
          icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,
          title: this.localeValues.menu,
          class: 'apexcharts-menu-icon'
        });
      }

      for (var _i = 0; _i < this.elCustomIcons.length; _i++) {
        toolbarControls.push({
          el: this.elCustomIcons[_i],
          icon: this.t.customIcons[_i].icon,
          title: this.t.customIcons[_i].title,
          index: this.t.customIcons[_i].index,
          class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class
        });
      }

      toolbarControls.forEach(function (t, index) {
        if (t.index) {
          Utils.moveIndexInArray(toolbarControls, index, t.index);
        }
      });

      for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {
        Graphics.setAttrs(toolbarControls[_i2].el, {
          class: toolbarControls[_i2].class,
          title: toolbarControls[_i2].title
        });
        toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;
        elToolbarWrap.appendChild(toolbarControls[_i2].el);
      }

      elToolbarWrap.appendChild(this.elMenu);
      Graphics.setAttrs(this.elMenu, {
        class: 'apexcharts-menu'
      });
      var menuItems = [{
        name: 'exportSVG',
        title: this.localeValues.exportToSVG
      }, {
        name: 'exportPNG',
        title: this.localeValues.exportToPNG
      }];

      for (var _i3 = 0; _i3 < menuItems.length; _i3++) {
        this.elMenuItems.push(document.createElement('div'));
        this.elMenuItems[_i3].innerHTML = menuItems[_i3].title;
        Graphics.setAttrs(this.elMenuItems[_i3], {
          class: "apexcharts-menu-item ".concat(menuItems[_i3].name),
          title: menuItems[_i3].title
        });
        this.elMenu.appendChild(this.elMenuItems[_i3]);
      }

      if (w.globals.zoomEnabled) {
        this.elZoom.classList.add('selected');
      } else if (w.globals.panEnabled) {
        this.elPan.classList.add('selected');
      } else if (w.globals.selectionEnabled) {
        this.elSelection.classList.add('selected');
      }

      this.addToolbarEventListeners();
    }
  }, {
    key: "addToolbarEventListeners",
    value: function addToolbarEventListeners() {
      var _this = this;

      this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));
      this.elSelection.addEventListener('click', this.toggleSelection.bind(this));
      this.elZoom.addEventListener('click', this.toggleZooming.bind(this));
      this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));
      this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));
      this.elPan.addEventListener('click', this.togglePanning.bind(this));
      this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));
      this.elMenuItems.forEach(function (m) {
        if (m.classList.contains('exportSVG')) {
          m.addEventListener('click', _this.downloadSVG.bind(_this));
        } else if (m.classList.contains('exportPNG')) {
          m.addEventListener('click', _this.downloadPNG.bind(_this));
        }
      });

      for (var i = 0; i < this.t.customIcons.length; i++) {
        this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click);
      }
    }
  }, {
    key: "toggleSelection",
    value: function toggleSelection() {
      this.toggleOtherControls();
      this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled;

      if (!this.elSelection.classList.contains('selected')) {
        this.elSelection.classList.add('selected');
      } else {
        this.elSelection.classList.remove('selected');
      }
    }
  }, {
    key: "toggleZooming",
    value: function toggleZooming() {
      this.toggleOtherControls();
      this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled;

      if (!this.elZoom.classList.contains('selected')) {
        this.elZoom.classList.add('selected');
      } else {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "getToolbarIconsReference",
    value: function getToolbarIconsReference() {
      var w = this.w;

      if (!this.elZoom) {
        this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');
      }

      if (!this.elPan) {
        this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');
      }

      if (!this.elSelection) {
        this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');
      }
    }
  }, {
    key: "enableZooming",
    value: function enableZooming() {
      this.toggleOtherControls();
      this.w.globals.zoomEnabled = true;

      if (this.elZoom) {
        this.elZoom.classList.add('selected');
      }

      if (this.elPan) {
        this.elPan.classList.remove('selected');
      }
    }
  }, {
    key: "enablePanning",
    value: function enablePanning() {
      this.toggleOtherControls();
      this.w.globals.panEnabled = true;

      if (this.elPan) {
        this.elPan.classList.add('selected');
      }

      if (this.elZoom) {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "togglePanning",
    value: function togglePanning() {
      this.toggleOtherControls();
      this.w.globals.panEnabled = !this.w.globals.panEnabled;

      if (!this.elPan.classList.contains('selected')) {
        this.elPan.classList.add('selected');
      } else {
        this.elPan.classList.remove('selected');
      }
    }
  }, {
    key: "toggleOtherControls",
    value: function toggleOtherControls() {
      var w = this.w;
      w.globals.panEnabled = false;
      w.globals.zoomEnabled = false;
      w.globals.selectionEnabled = false;
      this.getToolbarIconsReference();

      if (this.elPan) {
        this.elPan.classList.remove('selected');
      }

      if (this.elSelection) {
        this.elSelection.classList.remove('selected');
      }

      if (this.elZoom) {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "handleZoomIn",
    value: function handleZoomIn() {
      var w = this.w;
      var centerX = (w.globals.minX + w.globals.maxX) / 2;
      var newMinX = (w.globals.minX + centerX) / 2;
      var newMaxX = (w.globals.maxX + centerX) / 2;

      if (!w.globals.disableZoomIn) {
        this.zoomUpdateOptions(newMinX, newMaxX);
      }
    }
  }, {
    key: "handleZoomOut",
    value: function handleZoomOut() {
      var w = this.w; // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis

      if (w.config.xaxis.type === 'datetime' && new Date(w.globals.minX).getUTCFullYear() < 1000) {
        return;
      }

      var centerX = (w.globals.minX + w.globals.maxX) / 2;
      var newMinX = w.globals.minX - (centerX - w.globals.minX);
      var newMaxX = w.globals.maxX - (centerX - w.globals.maxX);

      if (!w.globals.disableZoomOut) {
        this.zoomUpdateOptions(newMinX, newMaxX);
      }
    }
  }, {
    key: "zoomUpdateOptions",
    value: function zoomUpdateOptions(newMinX, newMaxX) {
      var xaxis = {
        min: newMinX,
        max: newMaxX
      };
      var beforeZoomRange = this.getBeforeZoomRange(xaxis);

      if (beforeZoomRange) {
        xaxis = beforeZoomRange.xaxis;
      }

      this.w.globals.zoomed = true;

      this.ctx._updateOptions({
        xaxis: xaxis
      }, false, this.w.config.chart.animations.dynamicAnimation.enabled);

      this.zoomCallback(xaxis);
    }
  }, {
    key: "zoomCallback",
    value: function zoomCallback(xaxis, yaxis) {
      if (typeof this.ev.zoomed === 'function') {
        this.ev.zoomed(this.ctx, {
          xaxis: xaxis,
          yaxis: yaxis
        });
      }
    }
  }, {
    key: "getBeforeZoomRange",
    value: function getBeforeZoomRange(xaxis, yaxis) {
      var newRange = null;

      if (typeof this.ev.beforeZoom === 'function') {
        newRange = this.ev.beforeZoom(this, {
          xaxis: xaxis,
          yaxis: yaxis
        });
      }

      return newRange;
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.elMenu.classList.contains('open')) {
        this.elMenu.classList.remove('open');
      } else {
        this.elMenu.classList.add('open');
      }
    }
  }, {
    key: "downloadPNG",
    value: function downloadPNG() {
      var downloadPNG = new Exports(this.ctx);
      downloadPNG.exportToPng(this.ctx);
      this.toggleMenu();
    }
  }, {
    key: "downloadSVG",
    value: function downloadSVG() {
      var downloadSVG = new Exports(this.ctx);
      downloadSVG.exportToSVG();
      this.toggleMenu();
    }
  }, {
    key: "handleZoomReset",
    value: function handleZoomReset(e) {
      var _this2 = this;

      var charts = this.ctx.getSyncedCharts();
      charts.forEach(function (ch) {
        var w = ch.w;

        if (w.globals.minX !== w.globals.initialminX && w.globals.maxX !== w.globals.initialmaxX) {
          ch.revertDefaultAxisMinMax();

          if (typeof w.config.chart.events.zoomed === 'function') {
            _this2.zoomCallback({
              min: w.config.xaxis.min,
              max: w.config.xaxis.max
            });
          }

          w.globals.zoomed = false;

          ch._updateSeries(w.globals.initialSeries, w.config.chart.animations.dynamicAnimation.enabled);
        }
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.elZoom = null;
      this.elZoomIn = null;
      this.elZoomOut = null;
      this.elPan = null;
      this.elSelection = null;
      this.elZoomReset = null;
      this.elMenuIcon = null;
    }
  }]);

  return Toolbar;
}();

/**
 * ApexCharts Zoom Class for handling zooming and panning on axes based charts.
 *
 * @module ZoomPanSelection
 **/

var ZoomPanSelection =
/*#__PURE__*/
function (_Toolbar) {
  _inherits(ZoomPanSelection, _Toolbar);

  function ZoomPanSelection(ctx) {
    var _this;

    _classCallCheck(this, ZoomPanSelection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZoomPanSelection).call(this, ctx));
    _this.ctx = ctx;
    _this.w = ctx.w;
    _this.dragged = false;
    _this.graphics = new Graphics(_this.ctx);
    _this.eventList = ['mousedown', 'mouseleave', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];
    _this.clientX = 0;
    _this.clientY = 0;
    _this.startX = 0;
    _this.endX = 0;
    _this.dragX = 0;
    _this.startY = 0;
    _this.endY = 0;
    _this.dragY = 0;
    return _this;
  }

  _createClass(ZoomPanSelection, [{
    key: "init",
    value: function init(_ref) {
      var _this2 = this;

      var xyRatios = _ref.xyRatios;
      var w = this.w;
      var me = this;
      this.xyRatios = xyRatios;
      this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);
      this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);
      this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');
      this.zoomRect.node.classList.add('apexcharts-zoom-rect');
      this.selectionRect.node.classList.add('apexcharts-selection-rect');
      w.globals.dom.elGraphical.add(this.zoomRect);
      w.globals.dom.elGraphical.add(this.selectionRect);

      if (w.config.chart.selection.type === 'x') {
        this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          minY: 0,
          maxX: w.globals.gridWidth,
          maxY: w.globals.gridHeight
        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      } else if (w.config.chart.selection.type === 'y') {
        this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          maxX: w.globals.gridWidth
        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      } else {
        this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      }

      this.preselectedSelection();
      this.hoverArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);
      this.hoverArea.classList.add('zoomable');
      this.eventList.forEach(function (event) {
        _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {
          capture: false,
          passive: true
        });
      });
    } // remove the event listeners which were previously added on hover area

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.slDraggableRect) {
        this.slDraggableRect.draggable(false);
        this.slDraggableRect.off();
        this.selectionRect.off();
      }

      this.selectionRect = null;
      this.zoomRect = null;
      this.gridRect = null;
    }
  }, {
    key: "svgMouseEvents",
    value: function svgMouseEvents(xyRatios, e) {
      var w = this.w;
      var me = this;
      var toolbar = this.ctx.toolbar;
      var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;

      if (e.shiftKey) {
        this.shiftWasPressed = true;
        toolbar.enablePanning();
      } else {
        if (this.shiftWasPressed) {
          toolbar.enableZooming();
          this.shiftWasPressed = false;
        }
      }

      var falsePositives = e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar');
      if (falsePositives) return;
      me.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
      me.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;

      if (e.type === 'mousedown' && e.which === 1) {
        var gridRectDim = me.gridRect.getBoundingClientRect();
        me.startX = me.clientX - gridRectDim.left;
        me.startY = me.clientY - gridRectDim.top;
        me.dragged = false;
        me.w.globals.mousedown = true;
      }

      if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {
        me.dragged = true;

        if (w.globals.panEnabled) {
          w.globals.selection = null;

          if (me.w.globals.mousedown) {
            me.panDragging({
              context: me,
              zoomtype: zoomtype,
              xyRatios: xyRatios
            });
          }
        } else {
          if (me.w.globals.mousedown && w.globals.zoomEnabled || me.w.globals.mousedown && w.globals.selectionEnabled) {
            me.selection = me.selectionDrawing({
              context: me,
              zoomtype: zoomtype
            });
          }
        }
      }

      if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') {
        // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup
        var _gridRectDim = me.gridRect.getBoundingClientRect();

        if (me.w.globals.mousedown) {
          // user released the drag, now do all the calculations
          me.endX = me.clientX - _gridRectDim.left;
          me.endY = me.clientY - _gridRectDim.top;
          me.dragX = Math.abs(me.endX - me.startX);
          me.dragY = Math.abs(me.endY - me.startY);

          if (w.globals.zoomEnabled || w.globals.selectionEnabled) {
            me.selectionDrawn({
              context: me,
              zoomtype: zoomtype
            });
          }
        }

        if (w.globals.zoomEnabled) {
          me.hideSelectionRect(this.selectionRect);
        }

        me.dragged = false;
        me.w.globals.mousedown = false;
      }

      this.makeSelectionRectDraggable();
    }
  }, {
    key: "makeSelectionRectDraggable",
    value: function makeSelectionRectDraggable() {
      var w = this.w;
      if (!this.selectionRect) return;
      var rectDim = this.selectionRect.node.getBoundingClientRect();

      if (rectDim.width > 0 && rectDim.height > 0) {
        this.slDraggableRect.selectize().resize({
          constraint: {
            minX: 0,
            minY: 0,
            maxX: w.globals.gridWidth,
            maxY: w.globals.gridHeight
          }
        }).on('resizing', this.selectionDragging.bind(this, 'resizing'));
      }
    }
  }, {
    key: "preselectedSelection",
    value: function preselectedSelection() {
      var w = this.w;
      var xyRatios = this.xyRatios;

      if (!w.globals.zoomEnabled) {
        if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {
          this.drawSelectionRect(w.globals.selection);
        } else {
          if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {
            var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;
            var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;
            var selectionRect = {
              x: x,
              y: 0,
              width: width,
              height: w.globals.gridHeight,
              translateX: 0,
              translateY: 0,
              selectionEnabled: true
            };
            this.drawSelectionRect(selectionRect);
            this.makeSelectionRectDraggable();

            if (typeof w.config.chart.events.selection === 'function') {
              w.config.chart.events.selection(this.ctx, {
                xaxis: {
                  min: w.config.chart.selection.xaxis.min,
                  max: w.config.chart.selection.xaxis.max
                },
                yaxis: {}
              });
            }
          }
        }
      }
    }
  }, {
    key: "drawSelectionRect",
    value: function drawSelectionRect(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          width = _ref2.width,
          height = _ref2.height,
          translateX = _ref2.translateX,
          translateY = _ref2.translateY;
      var w = this.w;
      var zoomRect = this.zoomRect;
      var selectionRect = this.selectionRect;

      if (this.dragged || w.globals.selection !== null) {
        var scalingAttrs = {
          transform: 'translate(' + translateX + ', ' + translateY + ')' // change styles based on zoom or selection
          // zoom is Enabled and user has dragged, so draw blue rect

        };

        if (w.globals.zoomEnabled && this.dragged) {
          zoomRect.attr({
            x: x,
            y: y,
            width: width,
            height: height,
            fill: w.config.chart.zoom.zoomedArea.fill.color,
            'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,
            stroke: w.config.chart.zoom.zoomedArea.stroke.color,
            'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,
            'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity
          });
          Graphics.setAttrs(zoomRect.node, scalingAttrs);
        } // selection is enabled


        if (w.globals.selectionEnabled) {
          selectionRect.attr({
            x: x,
            y: y,
            width: width > 0 ? width : 0,
            height: height > 0 ? height : 0,
            fill: w.config.chart.selection.fill.color,
            'fill-opacity': w.config.chart.selection.fill.opacity,
            stroke: w.config.chart.selection.stroke.color,
            'stroke-width': w.config.chart.selection.stroke.width,
            'stroke-dasharray': w.config.chart.selection.stroke.dashArray,
            'stroke-opacity': w.config.chart.selection.stroke.opacity
          });
          Graphics.setAttrs(selectionRect.node, scalingAttrs);
        }
      }
    }
  }, {
    key: "hideSelectionRect",
    value: function hideSelectionRect(rect) {
      if (rect) {
        rect.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    }
  }, {
    key: "selectionDrawing",
    value: function selectionDrawing(_ref3) {
      var context = _ref3.context,
          zoomtype = _ref3.zoomtype;
      var w = this.w;
      var me = context;
      var gridRectDim = this.gridRect.getBoundingClientRect();
      var startX = me.startX - 1;
      var startY = me.startY;
      var selectionWidth = me.clientX - gridRectDim.left - startX;
      var selectionHeight = me.clientY - gridRectDim.top - startY;
      var translateX = 0;
      var translateY = 0;
      var selectionRect = {};

      if (Math.abs(selectionWidth + startX) > w.globals.gridWidth) {
        // user dragged the mouse outside drawing area to the right
        selectionWidth = w.globals.gridWidth - startX;
      } else if (me.clientX - gridRectDim.left < 0) {
        // user dragged the mouse outside drawing area to the left
        selectionWidth = startX;
      } // inverse selection X


      if (startX > me.clientX - gridRectDim.left) {
        selectionWidth = Math.abs(selectionWidth);
        translateX = -selectionWidth;
      } // inverse selection Y


      if (startY > me.clientY - gridRectDim.top) {
        selectionHeight = Math.abs(selectionHeight);
        translateY = -selectionHeight;
      }

      if (zoomtype === 'x') {
        selectionRect = {
          x: startX,
          y: 0,
          width: selectionWidth,
          height: w.globals.gridHeight,
          translateX: translateX,
          translateY: 0
        };
      } else if (zoomtype === 'y') {
        selectionRect = {
          x: 0,
          y: startY,
          width: w.globals.gridWidth,
          height: selectionHeight,
          translateX: 0,
          translateY: translateY
        };
      } else {
        selectionRect = {
          x: startX,
          y: startY,
          width: selectionWidth,
          height: selectionHeight,
          translateX: translateX,
          translateY: translateY
        };
      }

      me.drawSelectionRect(selectionRect);
      me.selectionDragging('resizing');
      return selectionRect;
    }
  }, {
    key: "selectionDragging",
    value: function selectionDragging(type, e) {
      var _this3 = this;

      var w = this.w;
      var xyRatios = this.xyRatios;
      var selRect = this.selectionRect;
      var timerInterval = 0;

      if (type === 'resizing') {
        timerInterval = 30;
      }

      if (typeof w.config.chart.events.selection === 'function' && w.globals.selectionEnabled) {
        // a small debouncer is required when resizing to avoid freezing the chart
        clearTimeout(this.w.globals.selectionResizeTimer);
        this.w.globals.selectionResizeTimer = window.setTimeout(function () {
          var gridRectDim = _this3.gridRect.getBoundingClientRect();

          var selectionRect = selRect.node.getBoundingClientRect();
          var minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;
          var maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;
          var minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];
          var maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];
          w.config.chart.events.selection(_this3.ctx, {
            xaxis: {
              min: minX,
              max: maxX
            },
            yaxis: {
              min: minY,
              max: maxY
            }
          });
        }, timerInterval);
      }
    }
  }, {
    key: "selectionDrawn",
    value: function selectionDrawn(_ref4) {
      var context = _ref4.context,
          zoomtype = _ref4.zoomtype;
      var w = this.w;
      var me = context;
      var xyRatios = this.xyRatios;
      var toolbar = this.ctx.toolbar;

      if (me.startX > me.endX) {
        var tempX = me.startX;
        me.startX = me.endX;
        me.endX = tempX;
      }

      if (me.startY > me.endY) {
        var tempY = me.startY;
        me.startY = me.endY;
        me.endY = tempY;
      }

      var xLowestValue = w.globals.xAxisScale.niceMin + me.startX * xyRatios.xRatio;
      var xHighestValue = w.globals.xAxisScale.niceMin + me.endX * xyRatios.xRatio; // TODO: we will consider the 1st y axis values here for getting highest and lowest y

      var yHighestValue = [];
      var yLowestValue = [];
      w.config.yaxis.forEach(function (yaxe, index) {
        yHighestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.startY));
        yLowestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.endY));
      });

      if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {
        if (w.globals.zoomEnabled) {
          var yaxis = Utils.clone(w.globals.initialConfig.yaxis); // before zooming in/out, store the last yaxis and xaxis range, so that when user hits the RESET button, we get the original range
          // also - make sure user is not already zoomed in/out - otherwise we will store zoomed values in lastAxis

          if (!w.globals.zoomed) {
            w.globals.lastXAxis = Utils.clone(w.config.xaxis);
            w.globals.lastYAxis = Utils.clone(w.config.yaxis);
          }

          var xaxis = {
            min: xLowestValue,
            max: xHighestValue
          };

          if (zoomtype === 'xy' || zoomtype === 'y') {
            yaxis.forEach(function (yaxe, index) {
              yaxis[index].min = yLowestValue[index];
              yaxis[index].max = yHighestValue[index];
            });
          }

          if (w.config.chart.zoom.autoScaleYaxis) {
            var scale = new Range(me.ctx);
            yaxis = scale.autoScaleY(me.ctx, yaxis, {
              xaxis: xaxis
            });
          }

          if (toolbar) {
            var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);

            if (beforeZoomRange) {
              xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;
              yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxe : yaxis;
            }
          }

          var options = {
            xaxis: xaxis
          };

          if (!w.config.chart.group) {
            // if chart in a group, prevent yaxis update here
            // fix issue #650
            options[yaxis] = yaxis;
          }

          me.ctx._updateOptions(options, false, me.w.config.chart.animations.dynamicAnimation.enabled);

          if (typeof w.config.chart.events.zoomed === 'function') {
            toolbar.zoomCallback(xaxis, yaxis);
          }

          w.globals.zoomed = true;
        } else if (w.globals.selectionEnabled) {
          var _yaxis = null;
          var _xaxis = null;
          _xaxis = {
            min: xLowestValue,
            max: xHighestValue
          };

          if (zoomtype === 'xy' || zoomtype === 'y') {
            _yaxis = Utils.clone(w.config.yaxis);

            _yaxis.forEach(function (yaxe, index) {
              _yaxis[index].min = yLowestValue[index];
              _yaxis[index].max = yHighestValue[index];
            });
          }

          w.globals.selection = me.selection;

          if (typeof w.config.chart.events.selection === 'function') {
            w.config.chart.events.selection(me.ctx, {
              xaxis: _xaxis,
              yaxis: _yaxis
            });
          }
        }
      }
    }
  }, {
    key: "panDragging",
    value: function panDragging(_ref5) {
      var context = _ref5.context;
      var w = this.w;
      var me = context;
      var moveDirection; // check to make sure there is data to compare against

      if (typeof w.globals.lastClientPosition.x !== 'undefined') {
        // get the change from last position to this position
        var deltaX = w.globals.lastClientPosition.x - me.clientX;
        var deltaY = w.globals.lastClientPosition.y - me.clientY; // check which direction had the highest amplitude and then figure out direction by checking if the value is greater or less than zero

        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {
          moveDirection = 'left';
        } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {
          moveDirection = 'right';
        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {
          moveDirection = 'up';
        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {
          moveDirection = 'down';
        }
      } // set the new last position to the current for next time (to get the position of drag)


      w.globals.lastClientPosition = {
        x: me.clientX,
        y: me.clientY
      };
      var xLowestValue = w.globals.minX;
      var xHighestValue = w.globals.maxX;
      me.panScrolled(moveDirection, xLowestValue, xHighestValue);
    }
  }, {
    key: "panScrolled",
    value: function panScrolled(moveDirection, xLowestValue, xHighestValue) {
      var w = this.w;
      var xyRatios = this.xyRatios;
      var yaxis = Utils.clone(w.globals.initialConfig.yaxis);

      if (moveDirection === 'left') {
        xLowestValue = w.globals.minX + w.globals.gridWidth / 15 * xyRatios.xRatio;
        xHighestValue = w.globals.maxX + w.globals.gridWidth / 15 * xyRatios.xRatio;
      } else if (moveDirection === 'right') {
        xLowestValue = w.globals.minX - w.globals.gridWidth / 15 * xyRatios.xRatio;
        xHighestValue = w.globals.maxX - w.globals.gridWidth / 15 * xyRatios.xRatio;
      }

      if (xLowestValue < w.globals.initialminX || xHighestValue > w.globals.initialmaxX) {
        xLowestValue = w.globals.minX;
        xHighestValue = w.globals.maxX;
      }

      var xaxis = {
        min: xLowestValue,
        max: xHighestValue
      };

      if (w.config.chart.zoom.autoScaleYaxis) {
        var scale = new Range(this.ctx);
        yaxis = scale.autoScaleY(this.ctx, yaxis, {
          xaxis: xaxis
        });
      }

      var options = {
        xaxis: {
          min: xLowestValue,
          max: xHighestValue
        }
      };

      if (!w.config.chart.group) {
        // if chart in a group, prevent yaxis update here
        // fix issue #650
        options[yaxis] = yaxis;
      }

      this.ctx._updateOptions(options, false, false);

      if (typeof w.config.chart.events.scrolled === 'function') {
        w.config.chart.events.scrolled(this.ctx, {
          xaxis: {
            min: xLowestValue,
            max: xHighestValue
          }
        });
      }
    }
  }]);

  return ZoomPanSelection;
}(Toolbar);

var TitleSubtitle =
/*#__PURE__*/
function () {
  function TitleSubtitle(ctx) {
    _classCallCheck(this, TitleSubtitle);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(TitleSubtitle, [{
    key: "draw",
    value: function draw() {
      this.drawTitleSubtitle('title');
      this.drawTitleSubtitle('subtitle');
    }
  }, {
    key: "drawTitleSubtitle",
    value: function drawTitleSubtitle(type) {
      var w = this.w;
      var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;
      var x = w.globals.svgWidth / 2;
      var y = tsConfig.offsetY;
      var textAnchor = 'middle';

      if (tsConfig.align === 'left') {
        x = 10;
        textAnchor = 'start';
      } else if (tsConfig.align === 'right') {
        x = w.globals.svgWidth - 10;
        textAnchor = 'end';
      }

      x = x + tsConfig.offsetX;
      y = y + parseInt(tsConfig.style.fontSize) + 2;

      if (tsConfig.text !== undefined) {
        var graphics = new Graphics(this.ctx);
        var titleText = graphics.drawText({
          x: x,
          y: y,
          text: tsConfig.text,
          textAnchor: textAnchor,
          fontSize: tsConfig.style.fontSize,
          fontFamily: tsConfig.style.fontFamily,
          foreColor: tsConfig.style.color,
          opacity: 1
        });
        titleText.node.setAttribute('class', "apexcharts-".concat(type, "-text"));
        w.globals.dom.Paper.add(titleText);
      }
    }
  }]);

  return TitleSubtitle;
}();

(function (root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && __webpack_require__("./node_modules/webpack/buildin/amd-options.js")) {
    define(function () {
      return factory(root, root.document);
    });
    /* below check fixes #412 */
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined') {
    module.exports = root.document ? factory(root, root.document) : function (w) {
      return factory(w, w.document);
    };
  } else {
    root.SVG = factory(root, root.document);
  }
})(typeof window !== 'undefined' ? window : undefined, function (window, document) {
  // Find global reference - uses 'this' by default when available,
  // falls back to 'window' otherwise (for bundlers like Webpack)
  var globalRef = typeof this !== 'undefined' ? this : window; // The main wrapping element

  var SVG = globalRef.SVG = function (element) {
    if (SVG.supported) {
      element = new SVG.Doc(element);

      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      return element;
    }
  }; // Default namespaces


  SVG.ns = 'http://www.w3.org/2000/svg';
  SVG.xmlns = 'http://www.w3.org/2000/xmlns/';
  SVG.xlink = 'http://www.w3.org/1999/xlink';
  SVG.svgjs = 'http://svgjs.com/svgjs'; // Svg support test

  SVG.supported = function () {
    return true; // !!document.createElementNS &&
    //     !! document.createElementNS(SVG.ns,'svg').createSVGRect
  }(); // Don't bother to continue if SVG is not supported


  if (!SVG.supported) return false; // Element id sequence

  SVG.did = 1000; // Get next named element id

  SVG.eid = function (name) {
    return 'Svgjs' + capitalize(name) + SVG.did++;
  }; // Method for element creation


  SVG.create = function (name) {
    // create element
    var element = document.createElementNS(this.ns, name); // apply unique id

    element.setAttribute('id', this.eid(name));
    return element;
  }; // Method for extending objects


  SVG.extend = function () {
    var modules, methods, key, i; // Get list of modules

    modules = [].slice.call(arguments); // Get object with extensions

    methods = modules.pop();

    for (i = modules.length - 1; i >= 0; i--) {
      if (modules[i]) {
        for (key in methods) {
          modules[i].prototype[key] = methods[key];
        }
      }
    } // Make sure SVG.Set inherits any newly added methods


    if (SVG.Set && SVG.Set.inherit) {
      SVG.Set.inherit();
    }
  }; // Invent new element


  SVG.invent = function (config) {
    // Create element initializer
    var initializer = typeof config.create === 'function' ? config.create : function () {
      this.constructor.call(this, SVG.create(config.create));
    }; // Inherit prototype

    if (config.inherit) {
      initializer.prototype = new config.inherit();
    } // Extend with methods


    if (config.extend) {
      SVG.extend(initializer, config.extend);
    } // Attach construct method to parent


    if (config.construct) {
      SVG.extend(config.parent || SVG.Container, config.construct);
    }

    return initializer;
  }; // Adopt existing svg elements


  SVG.adopt = function (node) {
    // check for presence of node
    if (!node) return null; // make sure a node isn't already adopted

    if (node.instance) return node.instance; // initialize variables

    var element; // adopt with element-specific settings

    if (node.nodeName == 'svg') {
      element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();
    } else if (node.nodeName == 'linearGradient') {
      element = new SVG.Gradient('linear');
    } else if (node.nodeName == 'radialGradient') {
      element = new SVG.Gradient('radial');
    } else if (SVG[capitalize(node.nodeName)]) {
      element = new SVG[capitalize(node.nodeName)]();
    } else {
      element = new SVG.Element(node);
    } // ensure references


    element.type = node.nodeName;
    element.node = node;
    node.instance = element; // SVG.Class specific preparations

    if (element instanceof SVG.Doc) {
      element.namespace().defs();
    } // pull svgjs data from the dom (getAttributeNS doesn't work in html5)


    element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    return element;
  }; // Initialize parsing element


  SVG.prepare = function () {
    // Select document body and create invisible svg element
    var body = document.getElementsByTagName('body')[0],
        draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object

    SVG.parser = {
      body: body || document.documentElement,
      draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node,
      poly: draw.polyline().node,
      path: draw.path().node,
      native: SVG.create('svg')
    };
  };

  SVG.parser = {
    native: SVG.create('svg')
  };
  document.addEventListener('DOMContentLoaded', function () {
    if (!SVG.parser.draw) {
      SVG.prepare();
    }
  }, false); // Storage for regular expressions

  SVG.regex = {
    // Parse unit value
    numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
    // Parse hex value
    hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    // Parse rgb value
    rgb: /rgb\((\d+),(\d+),(\d+)\)/,
    // Parse reference id
    reference: /#([a-z0-9\-_]+)/i,
    // splits a transformation chain
    transforms: /\)\s*,?\s*/,
    // Whitespace
    whitespace: /\s/g,
    // Test hex value
    isHex: /^#[a-f0-9]{3,6}$/i,
    // Test rgb value
    isRgb: /^rgb\(/,
    // Test css declaration
    isCss: /[^:]+:[^;]+;?/,
    // Test for blank string
    isBlank: /^(\s+)?$/,
    // Test for numeric string
    isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    // Test for percent value
    isPercent: /^-?[\d\.]+%$/,
    // Test for image url
    isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
    // split at whitespace and comma
    delimiter: /[\s,]+/,
    // The following regex are used to parse the d attribute of a path
    // Matches all hyphens which are not after an exponent
    hyphen: /([^e])\-/gi,
    // Replaces and tests for all path letters
    pathLetters: /[MLHVCSQTAZ]/gi,
    // yes we need this one, too
    isPathLetter: /[MLHVCSQTAZ]/i,
    // matches 0.154.23.45
    numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
    // matches .
    dots: /\./g
  };
  SVG.utils = {
    // Map function
    map: function map(array, block) {
      var i,
          il = array.length,
          result = [];

      for (i = 0; i < il; i++) {
        result.push(block(array[i]));
      }

      return result;
    },
    // Filter function
    filter: function filter(array, block) {
      var i,
          il = array.length,
          result = [];

      for (i = 0; i < il; i++) {
        if (block(array[i])) {
          result.push(array[i]);
        }
      }

      return result;
    },
    // Degrees to radians
    radians: function radians(d) {
      return d % 360 * Math.PI / 180;
    },
    // Radians to degrees
    degrees: function degrees(r) {
      return r * 180 / Math.PI % 360;
    },
    filterSVGElements: function filterSVGElements(nodes) {
      return this.filter(nodes, function (el) {
        return el instanceof window.SVGElement;
      });
    }
  };
  SVG.defaults = {
    // Default attribute values
    attrs: {
      // fill and stroke
      'fill-opacity': 1,
      'stroke-opacity': 1,
      'stroke-width': 0,
      'stroke-linejoin': 'miter',
      'stroke-linecap': 'butt',
      fill: '#000000',
      stroke: '#000000',
      opacity: 1,
      // position
      x: 0,
      y: 0,
      cx: 0,
      cy: 0,
      // size
      width: 0,
      height: 0,
      // radius
      r: 0,
      rx: 0,
      ry: 0,
      // gradient
      offset: 0,
      'stop-opacity': 1,
      'stop-color': '#000000',
      // text
      'font-size': 16,
      'font-family': 'Helvetica, Arial, sans-serif',
      'text-anchor': 'start'
    } // Module for color convertions

  };

  SVG.Color = function (color) {
    var match; // initialize defaults

    this.r = 0;
    this.g = 0;
    this.b = 0;
    if (!color) return; // parse color

    if (typeof color === 'string') {
      if (SVG.regex.isRgb.test(color)) {
        // get rgb values
        match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values

        this.r = parseInt(match[1]);
        this.g = parseInt(match[2]);
        this.b = parseInt(match[3]);
      } else if (SVG.regex.isHex.test(color)) {
        // get hex values
        match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values

        this.r = parseInt(match[1], 16);
        this.g = parseInt(match[2], 16);
        this.b = parseInt(match[3], 16);
      }
    } else if (_typeof(color) === 'object') {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
    }
  };

  SVG.extend(SVG.Color, {
    // Default to hex conversion
    toString: function toString() {
      return this.toHex();
    },
    // Build hex value
    toHex: function toHex() {
      return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);
    },
    // Build rgb value
    toRgb: function toRgb() {
      return 'rgb(' + [this.r, this.g, this.b].join() + ')';
    },
    // Calculate true brightness
    brightness: function brightness() {
      return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    },
    // Make color morphable
    morph: function morph(color) {
      this.destination = new SVG.Color(color);
      return this;
    },
    // Get morphed color at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // normalise pos

      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color

      return new SVG.Color({
        r: ~~(this.r + (this.destination.r - this.r) * pos),
        g: ~~(this.g + (this.destination.g - this.g) * pos),
        b: ~~(this.b + (this.destination.b - this.b) * pos)
      });
    }
  }); // Testers
  // Test if given value is a color string

  SVG.Color.test = function (color) {
    color += '';
    return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);
  }; // Test if given value is a rgb object


  SVG.Color.isRgb = function (color) {
    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
  }; // Test if given value is a color


  SVG.Color.isColor = function (color) {
    return SVG.Color.isRgb(color) || SVG.Color.test(color);
  }; // Module for array conversion


  SVG.Array = function (array, fallback) {
    array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback

    if (array.length == 0 && fallback) {
      array = fallback.valueOf();
    } // parse array


    this.value = this.parse(array);
  };

  SVG.extend(SVG.Array, {
    // Make array morphable
    morph: function morph(array) {
      this.destination = this.parse(array); // normalize length of arrays

      if (this.value.length != this.destination.length) {
        var lastValue = this.value[this.value.length - 1],
            lastDestination = this.destination[this.destination.length - 1];

        while (this.value.length > this.destination.length) {
          this.destination.push(lastDestination);
        }

        while (this.value.length < this.destination.length) {
          this.value.push(lastValue);
        }
      }

      return this;
    },
    // Clean up any duplicate points
    settle: function settle() {
      // find all unique values
      for (var i = 0, il = this.value.length, seen = []; i < il; i++) {
        if (seen.indexOf(this.value[i]) == -1) {
          seen.push(this.value[i]);
        }
      } // set new value


      return this.value = seen;
    },
    // Get morphed array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // generate morphed array

      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos);
      }

      return new SVG.Array(array);
    },
    // Convert array to string
    toString: function toString() {
      return this.value.join(' ');
    },
    // Real value
    valueOf: function valueOf() {
      return this.value;
    },
    // Parse whitespace separated string
    parse: function parse(array) {
      array = array.valueOf(); // if already is an array, no need to parse it

      if (Array.isArray(array)) return array;
      return this.split(array);
    },
    // Strip unnecessary whitespace
    split: function split(string) {
      return string.trim().split(SVG.regex.delimiter).map(parseFloat);
    },
    // Reverse array
    reverse: function reverse() {
      this.value.reverse();
      return this;
    },
    clone: function clone() {
      var clone = new this.constructor();
      clone.value = array_clone(this.value);
      return clone;
    }
  }); // Poly points array

  SVG.PointArray = function (array, fallback) {
    SVG.Array.call(this, array, fallback || [[0, 0]]);
  }; // Inherit from SVG.Array


  SVG.PointArray.prototype = new SVG.Array();
  SVG.PointArray.prototype.constructor = SVG.PointArray;
  SVG.extend(SVG.PointArray, {
    // Convert array to string
    toString: function toString() {
      // convert to a poly point string
      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push(this.value[i].join(','));
      }

      return array.join(' ');
    },
    // Convert array to line object
    toLine: function toLine() {
      return {
        x1: this.value[0][0],
        y1: this.value[0][1],
        x2: this.value[1][0],
        y2: this.value[1][1]
      };
    },
    // Get morphed array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // generate morphed point string

      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);
      }

      return new SVG.PointArray(array);
    },
    // Parse point string and flat array
    parse: function parse(array) {
      var points = [];
      array = array.valueOf(); // if it is an array

      if (Array.isArray(array)) {
        // and it is not flat, there is no need to parse it
        if (Array.isArray(array[0])) {
          // make sure to use a clone
          return array.map(function (el) {
            return el.slice();
          });
        } else if (array[0].x != null) {
          // allow point objects to be passed
          return array.map(function (el) {
            return [el.x, el.y];
          });
        }
      } else {
        // Else, it is considered as a string
        // parse points
        array = array.trim().split(SVG.regex.delimiter).map(parseFloat);
      } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


      if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples and parse points as floats

      for (var i = 0, len = array.length; i < len; i = i + 2) {
        points.push([array[i], array[i + 1]]);
      }

      return points;
    },
    // Move point string
    move: function move(x, y) {
      var box = this.bbox(); // get relative offset

      x -= box.x;
      y -= box.y; // move every point

      if (!isNaN(x) && !isNaN(y)) {
        for (var i = this.value.length - 1; i >= 0; i--) {
          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];
        }
      }

      return this;
    },
    // Resize poly string
    size: function size(width, height) {
      var i,
          box = this.bbox(); // recalculate position of all points according to new size

      for (i = this.value.length - 1; i >= 0; i--) {
        if (box.width) this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;
        if (box.height) this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;
      }

      return this;
    },
    // Get bounding box of points
    bbox: function bbox() {
      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      SVG.parser.poly.setAttribute('points', this.toString());
      return SVG.parser.poly.getBBox();
    }
  });
  var pathHandlers = {
    M: function M(c, p, p0) {
      p.x = p0.x = c[0];
      p.y = p0.y = c[1];
      return ['M', p.x, p.y];
    },
    L: function L(c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['L', c[0], c[1]];
    },
    H: function H(c, p) {
      p.x = c[0];
      return ['H', c[0]];
    },
    V: function V(c, p) {
      p.y = c[0];
      return ['V', c[0]];
    },
    C: function C(c, p) {
      p.x = c[4];
      p.y = c[5];
      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
    },
    S: function S(c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['S', c[0], c[1], c[2], c[3]];
    },
    Q: function Q(c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['Q', c[0], c[1], c[2], c[3]];
    },
    T: function T(c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['T', c[0], c[1]];
    },
    Z: function Z(c, p, p0) {
      p.x = p0.x;
      p.y = p0.y;
      return ['Z'];
    },
    A: function A(c, p) {
      p.x = c[5];
      p.y = c[6];
      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
    }
  };
  var mlhvqtcsa = 'mlhvqtcsaz'.split('');

  for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {
    pathHandlers[mlhvqtcsa[i]] = function (i) {
      return function (c, p, p0) {
        if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {
          c[5] = c[5] + p.x, c[6] = c[6] + p.y;
        } else {
          for (var j = 0, jl = c.length; j < jl; ++j) {
            c[j] = c[j] + (j % 2 ? p.y : p.x);
          }
        }
        return pathHandlers[i](c, p, p0);
      };
    }(mlhvqtcsa[i].toUpperCase());
  } // Path points array


  SVG.PathArray = function (array, fallback) {
    SVG.Array.call(this, array, fallback || [['M', 0, 0]]);
  }; // Inherit from SVG.Array


  SVG.PathArray.prototype = new SVG.Array();
  SVG.PathArray.prototype.constructor = SVG.PathArray;
  SVG.extend(SVG.PathArray, {
    // Convert array to string
    toString: function toString() {
      return arrayToString(this.value);
    },
    // Move path string
    move: function move(x, y) {
      // get bounding box of current situation
      var box = this.bbox(); // get relative offset

      x -= box.x;
      y -= box.y;

      if (!isNaN(x) && !isNaN(y)) {
        // move every point
        for (var l, i = this.value.length - 1; i >= 0; i--) {
          l = this.value[i][0];

          if (l == 'M' || l == 'L' || l == 'T') {
            this.value[i][1] += x;
            this.value[i][2] += y;
          } else if (l == 'H') {
            this.value[i][1] += x;
          } else if (l == 'V') {
            this.value[i][1] += y;
          } else if (l == 'C' || l == 'S' || l == 'Q') {
            this.value[i][1] += x;
            this.value[i][2] += y;
            this.value[i][3] += x;
            this.value[i][4] += y;

            if (l == 'C') {
              this.value[i][5] += x;
              this.value[i][6] += y;
            }
          } else if (l == 'A') {
            this.value[i][6] += x;
            this.value[i][7] += y;
          }
        }
      }

      return this;
    },
    // Resize path string
    size: function size(width, height) {
      // get bounding box of current situation
      var i,
          l,
          box = this.bbox(); // recalculate position of all points according to new size

      for (i = this.value.length - 1; i >= 0; i--) {
        l = this.value[i][0];

        if (l == 'M' || l == 'L' || l == 'T') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;
        } else if (l == 'H') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
        } else if (l == 'V') {
          this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;
        } else if (l == 'C' || l == 'S' || l == 'Q') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;
          this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;
          this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;

          if (l == 'C') {
            this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;
            this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y;
          }
        } else if (l == 'A') {
          // resize radii
          this.value[i][1] = this.value[i][1] * width / box.width;
          this.value[i][2] = this.value[i][2] * height / box.height; // move position values

          this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;
          this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y;
        }
      }

      return this;
    },
    // Test if the passed path array use the same path data commands as this path array
    equalCommands: function equalCommands(pathArray) {
      var i, il, equalCommands;
      pathArray = new SVG.PathArray(pathArray);
      equalCommands = this.value.length === pathArray.value.length;

      for (i = 0, il = this.value.length; equalCommands && i < il; i++) {
        equalCommands = this.value[i][0] === pathArray.value[i][0];
      }

      return equalCommands;
    },
    // Make path array morphable
    morph: function morph(pathArray) {
      pathArray = new SVG.PathArray(pathArray);

      if (this.equalCommands(pathArray)) {
        this.destination = pathArray;
      } else {
        this.destination = null;
      }

      return this;
    },
    // Get morphed path array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this;
      var sourceArray = this.value,
          destinationArray = this.destination.value,
          array = [],
          pathArray = new SVG.PathArray(),
          i,
          il,
          j,
          jl; // Animate has specified in the SVG spec
      // See: https://www.w3.org/TR/SVG11/paths.html#PathElement

      for (i = 0, il = sourceArray.length; i < il; i++) {
        array[i] = [sourceArray[i][0]];

        for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
          array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
        } // For the two flags of the elliptical arc command, the SVG spec say:
        // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
        // Elliptical arc command as an array followed by corresponding indexes:
        // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        //   0    1   2        3                 4             5      6  7


        if (array[i][0] === 'A') {
          array[i][4] = +(array[i][4] != 0);
          array[i][5] = +(array[i][5] != 0);
        }
      } // Directly modify the value of a path array, this is done this way for performance


      pathArray.value = array;
      return pathArray;
    },
    // Absolutize and parse path to array
    parse: function parse(array) {
      // if it's already a patharray, no need to parse it
      if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing

      var s,
          arr,
          paramCnt = {
        'M': 2,
        'L': 2,
        'H': 1,
        'V': 1,
        'C': 6,
        'S': 4,
        'Q': 4,
        'T': 2,
        'A': 7,
        'Z': 0
      };

      if (typeof array === 'string') {
        array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers
        .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen
        .trim() // trim
        .split(SVG.regex.delimiter); // split into array
      } else {
        array = array.reduce(function (prev, curr) {
          return [].concat.call(prev, curr);
        }, []);
      } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]


      var arr = [],
          p = new SVG.Point(),
          p0 = new SVG.Point(),
          index = 0,
          len = array.length;

      do {
        // Test if we have a path letter
        if (SVG.regex.isPathLetter.test(array[index])) {
          s = array[index];
          ++index; // If last letter was a move command and we got no new, it defaults to [L]ine
        } else if (s == 'M') {
          s = 'L';
        } else if (s == 'm') {
          s = 'l';
        }

        arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
      } while (len > index);

      return arr;
    },
    // Get bounding box of path
    bbox: function bbox() {
      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      SVG.parser.path.setAttribute('d', this.toString());
      return SVG.parser.path.getBBox();
    }
  }); // Module for unit convertions

  SVG.Number = SVG.invent({
    // Initialize
    create: function create(value, unit) {
      // initialize defaults
      this.value = 0;
      this.unit = unit || ''; // parse value

      if (typeof value === 'number') {
        // ensure a valid numeric value
        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
      } else if (typeof value === 'string') {
        unit = value.match(SVG.regex.numberAndUnit);

        if (unit) {
          // make value numeric
          this.value = parseFloat(unit[1]); // normalize

          if (unit[5] == '%') {
            this.value /= 100;
          } else if (unit[5] == 's') {
            this.value *= 1000;
          } // store unit


          this.unit = unit[5];
        }
      } else {
        if (value instanceof SVG.Number) {
          this.value = value.valueOf();
          this.unit = value.unit;
        }
      }
    },
    // Add methods
    extend: {
      // Stringalize
      toString: function toString() {
        return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;
      },
      toJSON: function toJSON() {
        return this.toString();
      },
      // Convert to primitive
      valueOf: function valueOf() {
        return this.value;
      },
      // Add number
      plus: function plus(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this + number, this.unit || number.unit);
      },
      // Subtract number
      minus: function minus(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this - number, this.unit || number.unit);
      },
      // Multiply number
      times: function times(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this * number, this.unit || number.unit);
      },
      // Divide number
      divide: function divide(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this / number, this.unit || number.unit);
      },
      // Convert to different unit
      to: function to(unit) {
        var number = new SVG.Number(this);

        if (typeof unit === 'string') {
          number.unit = unit;
        }

        return number;
      },
      // Make number morphable
      morph: function morph(number) {
        this.destination = new SVG.Number(number);

        if (number.relative) {
          this.destination.value += this.value;
        }

        return this;
      },
      // Get morphed number at given position
      at: function at(pos) {
        // Make sure a destination is defined
        if (!this.destination) return this; // Generate new morphed number

        return new SVG.Number(this.destination).minus(this).times(pos).plus(this);
      }
    }
  });
  SVG.Element = SVG.invent({
    // Initialize node
    create: function create(node) {
      // make stroke value accessible dynamically
      this._stroke = SVG.defaults.attrs.stroke;
      this._event = null; // initialize data object

      this.dom = {}; // create circular reference

      if (this.node = node) {
        this.type = node.nodeName;
        this.node.instance = this; // store current attribute value

        this._stroke = node.getAttribute('stroke') || this._stroke;
      }
    },
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x) {
        return this.attr('x', _x);
      },
      // Move over y-axis
      y: function y(_y) {
        return this.attr('y', _y);
      },
      // Move by center over x-axis
      cx: function cx(x) {
        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
      },
      // Move by center over y-axis
      cy: function cy(y) {
        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
      },
      // Move element to given x and y values
      move: function move(x, y) {
        return this.x(x).y(y);
      },
      // Move element by its center
      center: function center(x, y) {
        return this.cx(x).cy(y);
      },
      // Set width of element
      width: function width(_width) {
        return this.attr('width', _width);
      },
      // Set height of element
      height: function height(_height) {
        return this.attr('height', _height);
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));
      },
      // Clone element
      clone: function clone(parent) {
        // write dom data to the dom so the clone can pickup the data
        this.writeDataToDom(); // clone element and assign new id

        var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself

        if (parent) parent.add(clone);else this.after(clone);
        return clone;
      },
      // Remove element
      remove: function remove() {
        if (this.parent()) {
          this.parent().removeElement(this);
        }

        return this;
      },
      // Replace element
      replace: function replace(element) {
        this.after(element).remove();
        return element;
      },
      // Add element to given container and return self
      addTo: function addTo(parent) {
        return parent.put(this);
      },
      // Add element to given container and return container
      putIn: function putIn(parent) {
        return parent.add(this);
      },
      // Get / set id
      id: function id(_id) {
        return this.attr('id', _id);
      },
      // Checks whether the given point inside the bounding box of the element
      inside: function inside(x, y) {
        var box = this.bbox();
        return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
      },
      // Show element
      show: function show() {
        return this.style('display', '');
      },
      // Hide element
      hide: function hide() {
        return this.style('display', 'none');
      },
      // Is element visible?
      visible: function visible() {
        return this.style('display') != 'none';
      },
      // Return id on string conversion
      toString: function toString() {
        return this.attr('id');
      },
      // Return array of classes on the node
      classes: function classes() {
        var attr = this.attr('class');
        return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);
      },
      // Return true if class exists on the node, false otherwise
      hasClass: function hasClass(name) {
        return this.classes().indexOf(name) != -1;
      },
      // Add class to the node
      addClass: function addClass(name) {
        if (!this.hasClass(name)) {
          var array = this.classes();
          array.push(name);
          this.attr('class', array.join(' '));
        }

        return this;
      },
      // Remove class from the node
      removeClass: function removeClass(name) {
        if (this.hasClass(name)) {
          this.attr('class', this.classes().filter(function (c) {
            return c != name;
          }).join(' '));
        }

        return this;
      },
      // Toggle the presence of a class on the node
      toggleClass: function toggleClass(name) {
        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
      },
      // Get referenced element form attribute value
      reference: function reference(attr) {
        return SVG.get(this.attr(attr));
      },
      // Returns the parent element instance
      parent: function parent(type) {
        var parent = this; // check for parent

        if (!parent.node.parentNode) return null; // get parent element

        parent = SVG.adopt(parent.node.parentNode);
        if (!type) return parent; // loop trough ancestors if type is given

        while (parent && parent.node instanceof window.SVGElement) {
          if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
          if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document') return null; // #759, #720

          parent = SVG.adopt(parent.node.parentNode);
        }
      },
      // Get parent document
      doc: function doc() {
        return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);
      },
      // return array of all ancestors of given type up to the root svg
      parents: function parents(type) {
        var parents = [],
            parent = this;

        do {
          parent = parent.parent(type);
          if (!parent || !parent.node) break;
          parents.push(parent);
        } while (parent.parent);

        return parents;
      },
      // matches the element vs a css selector
      matches: function matches(selector) {
        return _matches(this.node, selector);
      },
      // Returns the svg node to call native svg methods on it
      native: function native() {
        return this.node;
      },
      // Import raw svg
      svg: function svg(_svg) {
        // create temporary holder
        var well = document.createElement('svg'); // act as a setter if svg is given

        if (_svg && this instanceof SVG.Parent) {
          // dump raw svg
          well.innerHTML = '<svg>' + _svg.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes

          for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {
            this.node.appendChild(well.firstChild.firstChild);
          } // otherwise act as a getter

        } else {
          // create a wrapping svg element in case of partial content
          well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom

          this.writeDataToDom(); // insert a copy of this node

          _svg.appendChild(this.node.cloneNode(true)); // return target element


          return well.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, '');
        }

        return this;
      },
      // write svgjs data to the dom
      writeDataToDom: function writeDataToDom() {
        // dump variables recursively
        if (this.each || this.lines) {
          var fn = this.each ? this : this.lines();
          fn.each(function () {
            this.writeDataToDom();
          });
        } // remove previously set data


        this.node.removeAttribute('svgjs:data');

        if (Object.keys(this.dom).length) {
          this.node.setAttribute('svgjs:data', JSON.stringify(this.dom));
        } // see #428


        return this;
      },
      // set given data to the elements data property
      setData: function setData(o) {
        this.dom = o;
        return this;
      },
      is: function is(obj) {
        return _is(this, obj);
      }
    }
  });
  SVG.easing = {
    '-': function _(pos) {
      return pos;
    },
    '<>': function _(pos) {
      return -Math.cos(pos * Math.PI) / 2 + 0.5;
    },
    '>': function _(pos) {
      return Math.sin(pos * Math.PI / 2);
    },
    '<': function _(pos) {
      return -Math.cos(pos * Math.PI / 2) + 1;
    }
  };

  SVG.morph = function (pos) {
    return function (from, to) {
      return new SVG.MorphObj(from, to).at(pos);
    };
  };

  SVG.Situation = SVG.invent({
    create: function create(o) {
      this.init = false;
      this.reversed = false;
      this.reversing = false;
      this.duration = new SVG.Number(o.duration).valueOf();
      this.delay = new SVG.Number(o.delay).valueOf();
      this.start = +new Date() + this.delay;
      this.finish = this.start + this.duration;
      this.ease = o.ease; // this.loop is incremented from 0 to this.loops
      // it is also incremented when in an infinite loop (when this.loops is true)

      this.loop = 0;
      this.loops = false;
      this.animations = {// functionToCall: [list of morphable objects]
        // e.g. move: [SVG.Number, SVG.Number]
      };
      this.attrs = {// holds all attributes which are not represented from a function svg.js provides
        // e.g. someAttr: SVG.Number
      };
      this.styles = {// holds all styles which should be animated
        // e.g. fill-color: SVG.Color
      };
      this.transforms = [// holds all transformations as transformation objects
        // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
      ];
      this.once = {// functions to fire at a specific position
        // e.g. "0.5": function foo(){}
      };
    }
  });
  SVG.FX = SVG.invent({
    create: function create(element) {
      this._target = element;
      this.situations = [];
      this.active = false;
      this.situation = null;
      this.paused = false;
      this.lastPos = 0;
      this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)
      // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1

      this.absPos = 0;
      this._speed = 1;
    },
    extend: {
      /**
       * sets or returns the target of this animation
       * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
       * @param ease function || string Function which should be used for easing or easing keyword
       * @param delay Number indicating the delay before the animation starts
       * @return target || this
       */
      animate: function animate(o, ease, delay) {
        if (_typeof(o) === 'object') {
          ease = o.ease;
          delay = o.delay;
          o = o.duration;
        }

        var situation = new SVG.Situation({
          duration: o || 1000,
          delay: delay || 0,
          ease: SVG.easing[ease || '-'] || ease
        });
        this.queue(situation);
        return this;
      },

      /**
      * sets a delay before the next element of the queue is called
      * @param delay Duration of delay in milliseconds
      * @return this.target()
      */
      delay: function delay(_delay) {
        // The delay is performed by an empty situation with its duration
        // attribute set to the duration of the delay
        var situation = new SVG.Situation({
          duration: _delay,
          delay: 0,
          ease: SVG.easing['-']
        });
        return this.queue(situation);
      },

      /**
      * sets or returns the target of this animation
      * @param null || target SVG.Element which should be set as new target
      * @return target || this
      */
      target: function target(_target) {
        if (_target && _target instanceof SVG.Element) {
          this._target = _target;
          return this;
        }

        return this._target;
      },
      // returns the absolute position at a given time
      timeToAbsPos: function timeToAbsPos(timestamp) {
        return (timestamp - this.situation.start) / (this.situation.duration / this._speed);
      },
      // returns the timestamp from a given absolute positon
      absPosToTime: function absPosToTime(absPos) {
        return this.situation.duration / this._speed * absPos + this.situation.start;
      },
      // starts the animationloop
      startAnimFrame: function startAnimFrame() {
        this.stopAnimFrame();
        this.animationFrame = window.requestAnimationFrame(function () {
          this.step();
        }.bind(this));
      },
      // cancels the animationframe
      stopAnimFrame: function stopAnimFrame() {
        window.cancelAnimationFrame(this.animationFrame);
      },
      // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
      start: function start() {
        // dont start if already started
        if (!this.active && this.situation) {
          this.active = true;
          this.startCurrent();
        }

        return this;
      },
      // start the current situation
      startCurrent: function startCurrent() {
        this.situation.start = +new Date() + this.situation.delay / this._speed;
        this.situation.finish = this.situation.start + this.situation.duration / this._speed;
        return this.initAnimations().step();
      },

      /**
      * adds a function / Situation to the animation queue
      * @param fn function / situation to add
      * @return this
      */
      queue: function queue(fn) {
        if (typeof fn === 'function' || fn instanceof SVG.Situation) {
          this.situations.push(fn);
        }

        if (!this.situation) this.situation = this.situations.shift();
        return this;
      },

      /**
      * pulls next element from the queue and execute it
      * @return this
      */
      dequeue: function dequeue() {
        // stop current animation
        this.stop(); // get next animation from queue

        this.situation = this.situations.shift();

        if (this.situation) {
          if (this.situation instanceof SVG.Situation) {
            this.start();
          } else {
            // If it is not a SVG.Situation, then it is a function, we execute it
            this.situation.call(this);
          }
        }

        return this;
      },
      // updates all animations to the current state of the element
      // this is important when one property could be changed from another property
      initAnimations: function initAnimations() {
        var i, j, source;
        var s = this.situation;
        if (s.init) return this;

        for (i in s.animations) {
          source = this.target()[i]();

          if (!Array.isArray(source)) {
            source = [source];
          }

          if (!Array.isArray(s.animations[i])) {
            s.animations[i] = [s.animations[i]];
          } // if(s.animations[i].length > source.length) {
          //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))
          // }


          for (j = source.length; j--;) {
            // The condition is because some methods return a normal number instead
            // of a SVG.Number
            if (s.animations[i][j] instanceof SVG.Number) {
              source[j] = new SVG.Number(source[j]);
            }

            s.animations[i][j] = source[j].morph(s.animations[i][j]);
          }
        }

        for (i in s.attrs) {
          s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);
        }

        for (i in s.styles) {
          s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);
        }

        s.initialTransformation = this.target().matrixify();
        s.init = true;
        return this;
      },
      clearQueue: function clearQueue() {
        this.situations = [];
        return this;
      },
      clearCurrent: function clearCurrent() {
        this.situation = null;
        return this;
      },

      /** stops the animation immediately
      * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
      * @param clearQueue A Boolean indicating whether to remove queued animation as well.
      * @return this
      */
      stop: function stop(jumpToEnd, clearQueue) {
        var active = this.active;
        this.active = false;

        if (clearQueue) {
          this.clearQueue();
        }

        if (jumpToEnd && this.situation) {
          // initialize the situation if it was not
          !active && this.startCurrent();
          this.atEnd();
        }

        this.stopAnimFrame();
        return this.clearCurrent();
      },

      /** resets the element to the state where the current element has started
      * @return this
      */
      reset: function reset() {
        if (this.situation) {
          var temp = this.situation;
          this.stop();
          this.situation = temp;
          this.atStart();
        }

        return this;
      },
      // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.
      finish: function finish() {
        this.stop(true, false);

        while (this.dequeue().situation && this.stop(true, false)) {
        }

        this.clearQueue().clearCurrent();
        return this;
      },
      // set the internal animation pointer at the start position, before any loops, and updates the visualisation
      atStart: function atStart() {
        return this.at(0, true);
      },
      // set the internal animation pointer at the end position, after all the loops, and updates the visualisation
      atEnd: function atEnd() {
        if (this.situation.loops === true) {
          // If in a infinite loop, we end the current iteration
          this.situation.loops = this.situation.loop + 1;
        }

        if (typeof this.situation.loops === 'number') {
          // If performing a finite number of loops, we go after all the loops
          return this.at(this.situation.loops, true);
        } else {
          // If no loops, we just go at the end
          return this.at(1, true);
        }
      },
      // set the internal animation pointer to the specified position and updates the visualisation
      // if isAbsPos is true, pos is treated as an absolute position
      at: function at(pos, isAbsPos) {
        var durDivSpd = this.situation.duration / this._speed;
        this.absPos = pos; // If pos is not an absolute position, we convert it into one

        if (!isAbsPos) {
          if (this.situation.reversed) this.absPos = 1 - this.absPos;
          this.absPos += this.situation.loop;
        }

        this.situation.start = +new Date() - this.absPos * durDivSpd;
        this.situation.finish = this.situation.start + durDivSpd;
        return this.step(true);
      },

      /**
      * sets or returns the speed of the animations
      * @param speed null || Number The new speed of the animations
      * @return Number || this
      */
      speed: function speed(_speed) {
        if (_speed === 0) return this.pause();

        if (_speed) {
          this._speed = _speed; // We use an absolute position here so that speed can affect the delay before the animation

          return this.at(this.absPos, true);
        } else return this._speed;
      },
      // Make loopable
      loop: function loop(times, reverse) {
        var c = this.last(); // store total loops

        c.loops = times != null ? times : true;
        c.loop = 0;
        if (reverse) c.reversing = true;
        return this;
      },
      // pauses the animation
      pause: function pause() {
        this.paused = true;
        this.stopAnimFrame();
        return this;
      },
      // unpause the animation
      play: function play() {
        if (!this.paused) return this;
        this.paused = false; // We use an absolute position here so that the delay before the animation can be paused

        return this.at(this.absPos, true);
      },

      /**
      * toggle or set the direction of the animation
      * true sets direction to backwards while false sets it to forwards
      * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)
      * @return this
      */
      reverse: function reverse(reversed) {
        var c = this.last();
        if (typeof reversed === 'undefined') c.reversed = !c.reversed;else c.reversed = reversed;
        return this;
      },

      /**
      * returns a float from 0-1 indicating the progress of the current animation
      * @param eased Boolean indicating whether the returned position should be eased or not
      * @return number
      */
      progress: function progress(easeIt) {
        return easeIt ? this.situation.ease(this.pos) : this.pos;
      },

      /**
      * adds a callback function which is called when the current animation is finished
      * @param fn Function which should be executed as callback
      * @return number
      */
      after: function after(fn) {
        var c = this.last(),
            wrapper = function wrapper(e) {
          if (e.detail.situation == c) {
            fn.call(this, c);
            this.off('finished.fx', wrapper); // prevent memory leak
          }
        };

        this.target().on('finished.fx', wrapper);
        return this._callStart();
      },
      // adds a callback which is called whenever one animation step is performed
      during: function during(fn) {
        var c = this.last(),
            wrapper = function wrapper(e) {
          if (e.detail.situation == c) {
            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);
          }
        }; // see above


        this.target().off('during.fx', wrapper).on('during.fx', wrapper);
        this.after(function () {
          this.off('during.fx', wrapper);
        });
        return this._callStart();
      },
      // calls after ALL animations in the queue are finished
      afterAll: function afterAll(fn) {
        var wrapper = function wrapper(e) {
          fn.call(this);
          this.off('allfinished.fx', wrapper);
        }; // see above


        this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);
        return this._callStart();
      },
      // calls on every animation step for all animations
      duringAll: function duringAll(fn) {
        var wrapper = function wrapper(e) {
          fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation);
        };

        this.target().off('during.fx', wrapper).on('during.fx', wrapper);
        this.afterAll(function () {
          this.off('during.fx', wrapper);
        });
        return this._callStart();
      },
      last: function last() {
        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
      },
      // adds one property to the animations
      add: function add(method, args, type) {
        this.last()[type || 'animations'][method] = args;
        return this._callStart();
      },

      /** perform one step of the animation
      *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
      *  @return this
      */
      step: function step(ignoreTime) {
        // convert current time to an absolute position
        if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position

        if (this.situation.loops !== false) {
          var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0

          absPos = Math.max(this.absPos, 0);
          absPosInt = Math.floor(absPos);

          if (this.situation.loops === true || absPosInt < this.situation.loops) {
            this.pos = absPos - absPosInt;
            lastLoop = this.situation.loop;
            this.situation.loop = absPosInt;
          } else {
            this.absPos = this.situation.loops;
            this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed

            lastLoop = this.situation.loop - 1;
            this.situation.loop = this.situation.loops;
          }

          if (this.situation.reversing) {
            // Toggle reversed if an odd number of loops as occured since the last call of step
            this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);
          }
        } else {
          // If there are no loop, the absolute position must not be above 1
          this.absPos = Math.min(this.absPos, 1);
          this.pos = this.absPos;
        } // while the absolute position can be below 0, the position must not be below 0


        if (this.pos < 0) this.pos = 0;
        if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing

        var eased = this.situation.ease(this.pos); // call once-callbacks

        for (var i in this.situation.once) {
          if (i > this.lastPos && i <= eased) {
            this.situation.once[i].call(this.target(), this.pos, eased);
            delete this.situation.once[i];
          }
        } // fire during callback with position, eased position and current situation as parameter


        if (this.active) this.target().fire('during', {
          pos: this.pos,
          eased: eased,
          fx: this,
          situation: this.situation
        }); // the user may call stop or finish in the during callback
        // so make sure that we still have a valid situation

        if (!this.situation) {
          return this;
        } // apply the actual animation to every property


        this.eachAt(); // do final code when situation is finished

        if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {
          // stop animation callback
          this.stopAnimFrame(); // fire finished callback with current situation as parameter

          this.target().fire('finished', {
            fx: this,
            situation: this.situation
          });

          if (!this.situations.length) {
            this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback

            if (!this.situations.length) {
              this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...

              this.active = false;
            }
          } // start next animation


          if (this.active) this.dequeue();else this.clearCurrent();
        } else if (!this.paused && this.active) {
          // we continue animating when we are not at the end
          this.startAnimFrame();
        } // save last eased position for once callback triggering


        this.lastPos = eased;
        return this;
      },
      // calculates the step for every property and calls block with it
      eachAt: function eachAt() {
        var i,
            len,
            at,
            self = this,
            target = this.target(),
            s = this.situation; // apply animations which can be called trough a method

        for (i in s.animations) {
          at = [].concat(s.animations[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target[i].apply(target, at);
        } // apply animation which has to be applied with attr()


        for (i in s.attrs) {
          at = [i].concat(s.attrs[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target.attr.apply(target, at);
        } // apply animation which has to be applied with style()


        for (i in s.styles) {
          at = [i].concat(s.styles[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target.style.apply(target, at);
        } // animate initialTransformation which has to be chained


        if (s.transforms.length) {
          // get initial initialTransformation
          at = s.initialTransformation;

          for (i = 0, len = s.transforms.length; i < len; i++) {
            // get next transformation in chain
            var a = s.transforms[i]; // multiply matrix directly

            if (a instanceof SVG.Matrix) {
              if (a.relative) {
                at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));
              } else {
                at = at.morph(a).at(s.ease(this.pos));
              }

              continue;
            } // when transformation is absolute we have to reset the needed transformation first


            if (!a.relative) {
              a.undo(at.extract());
            } // and reapply it after


            at = at.multiply(a.at(s.ease(this.pos)));
          } // set new matrix on element


          target.matrix(at);
        }

        return this;
      },
      // adds an once-callback which is called at a specific position and never again
      once: function once(pos, fn, isEased) {
        var c = this.last();
        if (!isEased) pos = c.ease(pos);
        c.once[pos] = fn;
        return this;
      },
      _callStart: function _callStart() {
        setTimeout(function () {
          this.start();
        }.bind(this), 0);
        return this;
      }
    },
    parent: SVG.Element,
    // Add method to parent elements
    construct: {
      // Get fx module or create a new one, then animate with given duration and ease
      animate: function animate(o, ease, delay) {
        return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);
      },
      delay: function delay(_delay2) {
        return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay2);
      },
      stop: function stop(jumpToEnd, clearQueue) {
        if (this.fx) {
          this.fx.stop(jumpToEnd, clearQueue);
        }

        return this;
      },
      finish: function finish() {
        if (this.fx) {
          this.fx.finish();
        }

        return this;
      },
      // Pause current animation
      pause: function pause() {
        if (this.fx) {
          this.fx.pause();
        }

        return this;
      },
      // Play paused current animation
      play: function play() {
        if (this.fx) {
          this.fx.play();
        }

        return this;
      },
      // Set/Get the speed of the animations
      speed: function speed(_speed2) {
        if (this.fx) {
          if (_speed2 == null) {
            return this.fx.speed();
          } else {
            this.fx.speed(_speed2);
          }
        }

        return this;
      }
    }
  }); // MorphObj is used whenever no morphable object is given

  SVG.MorphObj = SVG.invent({
    create: function create(from, to) {
      // prepare color for morphing
      if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values

      if (SVG.regex.delimiter.test(from)) {
        // prepare path for morphing
        if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing
        else return new SVG.Array(from).morph(to);
      } // prepare number for morphing


      if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing

      this.value = from;
      this.destination = to;
    },
    extend: {
      at: function at(pos, real) {
        return real < 1 ? this.value : this.destination;
      },
      valueOf: function valueOf() {
        return this.value;
      }
    }
  });
  SVG.extend(SVG.FX, {
    // Add animatable attributes
    attr: function attr(a, v, relative) {
      // apply attributes individually
      if (_typeof(a) === 'object') {
        for (var key in a) {
          this.attr(key, a[key]);
        }
      } else {
        this.add(a, v, 'attrs');
      }

      return this;
    },
    // Add animatable styles
    style: function style(s, v) {
      if (_typeof(s) === 'object') {
        for (var key in s) {
          this.style(key, s[key]);
        }
      } else {
        this.add(s, v, 'styles');
      }

      return this;
    },
    // Animatable x-axis
    x: function x(_x2, relative) {
      if (this.target() instanceof SVG.G) {
        this.transform({
          x: _x2
        }, relative);
        return this;
      }

      var num = new SVG.Number(_x2);
      num.relative = relative;
      return this.add('x', num);
    },
    // Animatable y-axis
    y: function y(_y2, relative) {
      if (this.target() instanceof SVG.G) {
        this.transform({
          y: _y2
        }, relative);
        return this;
      }

      var num = new SVG.Number(_y2);
      num.relative = relative;
      return this.add('y', num);
    },
    // Animatable center x-axis
    cx: function cx(x) {
      return this.add('cx', new SVG.Number(x));
    },
    // Animatable center y-axis
    cy: function cy(y) {
      return this.add('cy', new SVG.Number(y));
    },
    // Add animatable move
    move: function move(x, y) {
      return this.x(x).y(y);
    },
    // Add animatable center
    center: function center(x, y) {
      return this.cx(x).cy(y);
    },
    // Add animatable size
    size: function size(width, height) {
      if (this.target() instanceof SVG.Text) {
        // animate font size for Text elements
        this.attr('font-size', width);
      } else {
        // animate bbox based size for all other elements
        var box;

        if (!width || !height) {
          box = this.target().bbox();
        }

        if (!width) {
          width = box.width / box.height * height;
        }

        if (!height) {
          height = box.height / box.width * width;
        }

        this.add('width', new SVG.Number(width)).add('height', new SVG.Number(height));
      }

      return this;
    },
    // Add animatable width
    width: function width(_width2) {
      return this.add('width', new SVG.Number(_width2));
    },
    // Add animatable height
    height: function height(_height2) {
      return this.add('height', new SVG.Number(_height2));
    },
    // Add animatable plot
    plot: function plot(a, b, c, d) {
      // Lines can be plotted with 4 arguments
      if (arguments.length == 4) {
        return this.plot([a, b, c, d]);
      }

      return this.add('plot', new (this.target().morphArray)(a));
    },
    // Add leading method
    leading: function leading(value) {
      return this.target().leading ? this.add('leading', new SVG.Number(value)) : this;
    },
    // Add animatable viewbox
    viewbox: function viewbox(x, y, width, height) {
      if (this.target() instanceof SVG.Container) {
        this.add('viewbox', new SVG.ViewBox(x, y, width, height));
      }

      return this;
    },
    update: function update(o) {
      if (this.target() instanceof SVG.Stop) {
        if (typeof o === 'number' || o instanceof SVG.Number) {
          return this.update({
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          });
        }

        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', o.offset);
      }

      return this;
    }
  });
  SVG.Box = SVG.invent({
    create: function create(x, y, width, height) {
      if (_typeof(x) === 'object' && !(x instanceof SVG.Element)) {
        // chromes getBoundingClientRect has no x and y property
        return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);
      } else if (arguments.length == 4) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      } // add center, right, bottom...


      fullBox(this);
    },
    extend: {
      // Merge rect box with another, return a new instance
      merge: function merge(box) {
        var b = new this.constructor(); // merge boxes

        b.x = Math.min(this.x, box.x);
        b.y = Math.min(this.y, box.y);
        b.width = Math.max(this.x + this.width, box.x + box.width) - b.x;
        b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;
        return fullBox(b);
      },
      transform: function transform(m) {
        var xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            bbox;
        var pts = [new SVG.Point(this.x, this.y), new SVG.Point(this.x2, this.y), new SVG.Point(this.x, this.y2), new SVG.Point(this.x2, this.y2)];
        pts.forEach(function (p) {
          p = p.transform(m);
          xMin = Math.min(xMin, p.x);
          xMax = Math.max(xMax, p.x);
          yMin = Math.min(yMin, p.y);
          yMax = Math.max(yMax, p.y);
        });
        bbox = new this.constructor();
        bbox.x = xMin;
        bbox.width = xMax - xMin;
        bbox.y = yMin;
        bbox.height = yMax - yMin;
        fullBox(bbox);
        return bbox;
      }
    }
  });
  SVG.BBox = SVG.invent({
    // Initialize
    create: function create(element) {
      SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given

      if (element instanceof SVG.Element) {
        var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered

        try {
          if (!document.documentElement.contains) {
            // This is IE - it does not support contains() for top-level SVGs
            var topParent = element.node;

            while (topParent.parentNode) {
              topParent = topParent.parentNode;
            }

            if (topParent != document) throw new Error('Element not in the dom');
          } // the element is NOT in the dom, throw error
          // disabling the check below which fixes issue #76
          // if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')
          // find native bbox


          box = element.node.getBBox();
        } catch (e) {
          if (element instanceof SVG.Shape) {
            if (!SVG.parser.draw) {
              // fixes apexcharts/vue-apexcharts #14
              SVG.prepare();
            }

            var clone = element.clone(SVG.parser.draw.instance).show();
            box = clone.node.getBBox();
            clone.remove();
          } else {
            box = {
              x: element.node.clientLeft,
              y: element.node.clientTop,
              width: element.node.clientWidth,
              height: element.node.clientHeight
            };
          }
        }

        SVG.Box.call(this, box);
      }
    },
    // Define ancestor
    inherit: SVG.Box,
    // Define Parent
    parent: SVG.Element,
    // Constructor
    construct: {
      // Get bounding box
      bbox: function bbox() {
        return new SVG.BBox(this);
      }
    }
  });
  SVG.BBox.prototype.constructor = SVG.BBox;
  SVG.extend(SVG.Element, {
    tbox: function tbox() {
      console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.');
      return this.rbox(this.doc());
    }
  });
  SVG.RBox = SVG.invent({
    // Initialize
    create: function create(element) {
      SVG.Box.apply(this, [].slice.call(arguments));

      if (element instanceof SVG.Element) {
        SVG.Box.call(this, element.node.getBoundingClientRect());
      }
    },
    inherit: SVG.Box,
    // define Parent
    parent: SVG.Element,
    extend: {
      addOffset: function addOffset() {
        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
        this.x += window.pageXOffset;
        this.y += window.pageYOffset;
        return this;
      }
    },
    // Constructor
    construct: {
      // Get rect box
      rbox: function rbox(el) {
        if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse());
        return new SVG.RBox(this).addOffset();
      }
    }
  });
  SVG.RBox.prototype.constructor = SVG.RBox;
  SVG.Matrix = SVG.invent({
    // Initialize
    create: function create(source) {
      var i,
          base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object

      source = source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : _typeof(source) === 'object' ? source : base; // merge source

      for (i = abcdef.length - 1; i >= 0; --i) {
        this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];
      }
    },
    // Add methods
    extend: {
      // Extract individual transformations
      extract: function extract() {
        // find delta transform points
        var px = deltaTransformPoint(this, 0, 1),
            py = deltaTransformPoint(this, 1, 0),
            skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
        return {
          // translation
          x: this.e,
          y: this.f,
          transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
          transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
          // skew
          skewX: -skewX,
          skewY: 180 / Math.PI * Math.atan2(py.y, py.x),
          // scale
          scaleX: Math.sqrt(this.a * this.a + this.b * this.b),
          scaleY: Math.sqrt(this.c * this.c + this.d * this.d),
          // rotation
          rotation: skewX,
          a: this.a,
          b: this.b,
          c: this.c,
          d: this.d,
          e: this.e,
          f: this.f,
          matrix: new SVG.Matrix(this)
        };
      },
      // Clone matrix
      clone: function clone() {
        return new SVG.Matrix(this);
      },
      // Morph one matrix into another
      morph: function morph(matrix) {
        // store new destination
        this.destination = new SVG.Matrix(matrix);
        return this;
      },
      // Get morphed matrix at a given position
      at: function at(pos) {
        // make sure a destination is defined
        if (!this.destination) return this; // calculate morphed matrix at a given position

        var matrix = new SVG.Matrix({
          a: this.a + (this.destination.a - this.a) * pos,
          b: this.b + (this.destination.b - this.b) * pos,
          c: this.c + (this.destination.c - this.c) * pos,
          d: this.d + (this.destination.d - this.d) * pos,
          e: this.e + (this.destination.e - this.e) * pos,
          f: this.f + (this.destination.f - this.f) * pos
        });
        return matrix;
      },
      // Multiplies by given matrix
      multiply: function multiply(matrix) {
        return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));
      },
      // Inverses matrix
      inverse: function inverse() {
        return new SVG.Matrix(this.native().inverse());
      },
      // Translate matrix
      translate: function translate(x, y) {
        return new SVG.Matrix(this.native().translate(x || 0, y || 0));
      },
      // Scale matrix
      scale: function scale(x, y, cx, cy) {
        // support uniformal scale
        if (arguments.length == 1) {
          y = x;
        } else if (arguments.length == 3) {
          cy = cx;
          cx = y;
          y = x;
        }

        return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0));
      },
      // Rotate matrix
      rotate: function rotate(r, cx, cy) {
        // convert degrees to radians
        r = SVG.utils.radians(r);
        return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0));
      },
      // Flip matrix on x or y, at a given offset
      flip: function flip(a, o) {
        return a == 'x' ? this.scale(-1, 1, o, 0) : a == 'y' ? this.scale(1, -1, 0, o) : this.scale(-1, -1, a, o != null ? o : a);
      },
      // Skew
      skew: function skew(x, y, cx, cy) {
        // support uniformal skew
        if (arguments.length == 1) {
          y = x;
        } else if (arguments.length == 3) {
          cy = cx;
          cx = y;
          y = x;
        } // convert degrees to radians


        x = SVG.utils.radians(x);
        y = SVG.utils.radians(y);
        return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0));
      },
      // SkewX
      skewX: function skewX(x, cx, cy) {
        return this.skew(x, 0, cx, cy);
      },
      // SkewY
      skewY: function skewY(y, cx, cy) {
        return this.skew(0, y, cx, cy);
      },
      // Transform around a center point
      around: function around(cx, cy, matrix) {
        return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0));
      },
      // Convert to native SVGMatrix
      native: function native() {
        // create new matrix
        var matrix = SVG.parser.native.createSVGMatrix(); // update with current values

        for (var i = abcdef.length - 1; i >= 0; i--) {
          matrix[abcdef[i]] = this[abcdef[i]];
        }

        return matrix;
      },
      // Convert matrix to string
      toString: function toString() {
        // Construct the matrix directly, avoid values that are too small
        return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';
      }
    },
    // Define parent
    parent: SVG.Element,
    // Add parent method
    construct: {
      // Get current matrix
      ctm: function ctm() {
        return new SVG.Matrix(this.node.getCTM());
      },
      // Get current screen matrix
      screenCTM: function screenCTM() {
        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
           This is needed because FF does not return the transformation matrix
           for the inner coordinate system when getScreenCTM() is called on nested svgs.
           However all other Browsers do that */
        if (this instanceof SVG.Nested) {
          var rect = this.rect(1, 1);
          var m = rect.node.getScreenCTM();
          rect.remove();
          return new SVG.Matrix(m);
        }

        return new SVG.Matrix(this.node.getScreenCTM());
      }
    }
  });
  SVG.Point = SVG.invent({
    // Initialize
    create: function create(x, y) {
      var source,
          base = {
        x: 0,
        y: 0 // ensure source as object

      };
      source = Array.isArray(x) ? {
        x: x[0],
        y: x[1]
      } : _typeof(x) === 'object' ? {
        x: x.x,
        y: x.y
      } : x != null ? {
        x: x,
        y: y != null ? y : x
      } : base; // If y has no value, then x is used has its value
      // merge source

      this.x = source.x;
      this.y = source.y;
    },
    // Add methods
    extend: {
      // Clone point
      clone: function clone() {
        return new SVG.Point(this);
      },
      // Morph one point into another
      morph: function morph(x, y) {
        // store new destination
        this.destination = new SVG.Point(x, y);
        return this;
      },
      // Get morphed point at a given position
      at: function at(pos) {
        // make sure a destination is defined
        if (!this.destination) return this; // calculate morphed matrix at a given position

        var point = new SVG.Point({
          x: this.x + (this.destination.x - this.x) * pos,
          y: this.y + (this.destination.y - this.y) * pos
        });
        return point;
      },
      // Convert to native SVGPoint
      native: function native() {
        // create new point
        var point = SVG.parser.native.createSVGPoint(); // update with current values

        point.x = this.x;
        point.y = this.y;
        return point;
      },
      // transform point with matrix
      transform: function transform(matrix) {
        return new SVG.Point(this.native().matrixTransform(matrix.native()));
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Get point
    point: function point(x, y) {
      return new SVG.Point(x, y).transform(this.screenCTM().inverse());
    }
  });
  SVG.extend(SVG.Element, {
    // Set svg element attribute
    attr: function attr(a, v, n) {
      // act as full getter
      if (a == null) {
        // get an object of attributes
        a = {};
        v = this.node.attributes;

        for (n = v.length - 1; n >= 0; n--) {
          a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;
        }

        return a;
      } else if (_typeof(a) === 'object') {
        // apply every attribute individually if an object is passed
        for (v in a) {
          this.attr(v, a[v]);
        }
      } else if (v === null) {
        // remove value
        this.node.removeAttribute(a);
      } else if (v == null) {
        // act as a getter if the first and only argument is not an object
        v = this.node.getAttribute(a);
        return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;
      } else {
        // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0
        if (a == 'stroke-width') {
          this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);
        } else if (a == 'stroke') {
          this._stroke = v;
        } // convert image fill and stroke to patterns


        if (a == 'fill' || a == 'stroke') {
          if (SVG.regex.isImage.test(v)) {
            v = this.doc().defs().image(v, 0, 0);
          }

          if (v instanceof SVG.Image) {
            v = this.doc().defs().pattern(0, 0, function () {
              this.add(v);
            });
          }
        } // ensure correct numeric values (also accepts NaN and Infinity)


        if (typeof v === 'number') {
          v = new SVG.Number(v);
        } // ensure full hex color
        else if (SVG.Color.isColor(v)) {
            v = new SVG.Color(v);
          } // parse array values
          else if (Array.isArray(v)) {
              v = new SVG.Array(v);
            } // if the passed attribute is leading...


        if (a == 'leading') {
          // ... call the leading method instead
          if (this.leading) {
            this.leading(v);
          }
        } else {
          // set given attribute on node
          typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());
        } // rebuild if required


        if (this.rebuild && (a == 'font-size' || a == 'x')) {
          this.rebuild(a, v);
        }
      }

      return this;
    }
  });
  SVG.extend(SVG.Element, {
    // Add transformations
    transform: function transform(o, relative) {
      // get target in case of the fx module, otherwise reference this
      var target = this,
          matrix,
          bbox; // act as a getter

      if (_typeof(o) !== 'object') {
        // get current matrix
        matrix = new SVG.Matrix(target).extract();
        return typeof o === 'string' ? matrix[o] : matrix;
      } // get current matrix


      matrix = new SVG.Matrix(target); // ensure relative flag

      relative = !!relative || !!o.relative; // act on matrix

      if (o.a != null) {
        matrix = relative // relative
        ? matrix.multiply(new SVG.Matrix(o)) // absolute
        : new SVG.Matrix(o); // act on rotation
      } else if (o.rotation != null) {
        // ensure centre point
        ensureCentre(o, target); // apply transformation

        matrix = relative // relative
        ? matrix.rotate(o.rotation, o.cx, o.cy) // absolute
        : matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy); // act on scale
      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure scale values on both axes

        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;
        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;

        if (!relative) {
          // absolute; multiply inversed values
          var e = matrix.extract();
          o.scaleX = o.scaleX * 1 / e.scaleX;
          o.scaleY = o.scaleY * 1 / e.scaleY;
        }

        matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew
      } else if (o.skew != null || o.skewX != null || o.skewY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure skew values on both axes

        o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0;
        o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0;

        if (!relative) {
          // absolute; reset skew values
          var e = matrix.extract();
          matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse());
        }

        matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip
      } else if (o.flip) {
        if (o.flip == 'x' || o.flip == 'y') {
          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;
        } else {
          if (o.offset == null) {
            bbox = target.bbox();
            o.flip = bbox.cx;
            o.offset = bbox.cy;
          } else {
            o.flip = o.offset;
          }
        }

        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate
      } else if (o.x != null || o.y != null) {
        if (relative) {
          // relative
          matrix = matrix.translate(o.x, o.y);
        } else {
          // absolute
          if (o.x != null) matrix.e = o.x;
          if (o.y != null) matrix.f = o.y;
        }
      }

      return this.attr('transform', matrix);
    }
  });
  SVG.extend(SVG.FX, {
    transform: function transform(o, relative) {
      // get target in case of the fx module, otherwise reference this
      var target = this.target(),
          matrix,
          bbox; // act as a getter

      if (_typeof(o) !== 'object') {
        // get current matrix
        matrix = new SVG.Matrix(target).extract();
        return typeof o === 'string' ? matrix[o] : matrix;
      } // ensure relative flag


      relative = !!relative || !!o.relative; // act on matrix

      if (o.a != null) {
        matrix = new SVG.Matrix(o); // act on rotation
      } else if (o.rotation != null) {
        // ensure centre point
        ensureCentre(o, target); // apply transformation

        matrix = new SVG.Rotate(o.rotation, o.cx, o.cy); // act on scale
      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure scale values on both axes

        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;
        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;
        matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew
      } else if (o.skewX != null || o.skewY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure skew values on both axes

        o.skewX = o.skewX != null ? o.skewX : 0;
        o.skewY = o.skewY != null ? o.skewY : 0;
        matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip
      } else if (o.flip) {
        if (o.flip == 'x' || o.flip == 'y') {
          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;
        } else {
          if (o.offset == null) {
            bbox = target.bbox();
            o.flip = bbox.cx;
            o.offset = bbox.cy;
          } else {
            o.flip = o.offset;
          }
        }

        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate
      } else if (o.x != null || o.y != null) {
        matrix = new SVG.Translate(o.x, o.y);
      }

      if (!matrix) return this;
      matrix.relative = relative;
      this.last().transforms.push(matrix);
      return this._callStart();
    }
  });
  SVG.extend(SVG.Element, {
    // Reset all transformations
    untransform: function untransform() {
      return this.attr('transform', null);
    },
    // merge the whole transformation chain into one matrix and returns it
    matrixify: function matrixify() {
      var matrix = (this.attr('transform') || ''). // split transformations
      split(SVG.regex.transforms).slice(0, -1).map(function (str) {
        // generate key => value pairs
        var kv = str.trim().split('(');
        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {
          return parseFloat(str);
        })];
      }) // merge every transformation into one matrix
      .reduce(function (matrix, transform) {
        if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));
        return matrix[transform[0]].apply(matrix, transform[1]);
      }, new SVG.Matrix());
      return matrix;
    },
    // add an element to another parent without changing the visual representation on the screen
    toParent: function toParent(parent) {
      if (this == parent) return this;
      var ctm = this.screenCTM();
      var pCtm = parent.screenCTM().inverse();
      this.addTo(parent).untransform().transform(pCtm.multiply(ctm));
      return this;
    },
    // same as above with parent equals root-svg
    toDoc: function toDoc() {
      return this.toParent(this.doc());
    }
  });
  SVG.Transformation = SVG.invent({
    create: function create(source, inversed) {
      if (arguments.length > 1 && typeof inversed !== 'boolean') {
        return this.constructor.call(this, [].slice.call(arguments));
      }

      if (Array.isArray(source)) {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          this[this.arguments[i]] = source[i];
        }
      } else if (_typeof(source) === 'object') {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          this[this.arguments[i]] = source[this.arguments[i]];
        }
      }

      this.inversed = false;

      if (inversed === true) {
        this.inversed = true;
      }
    },
    extend: {
      arguments: [],
      method: '',
      at: function at(pos) {
        var params = [];

        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          params.push(this[this.arguments[i]]);
        }

        var m = this._undo || new SVG.Matrix();
        m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos);
        return this.inversed ? m.inverse() : m;
      },
      undo: function undo(o) {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          o[this.arguments[i]] = typeof this[this.arguments[i]] === 'undefined' ? 0 : o[this.arguments[i]];
        } // The method SVG.Matrix.extract which was used before calling this
        // method to obtain a value for the parameter o doesn't return a cx and
        // a cy so we use the ones that were provided to this object at its creation


        o.cx = this.cx;
        o.cy = this.cy;
        this._undo = new SVG[capitalize(this.method)](o, true).at(1);
        return this;
      }
    }
  });
  SVG.Translate = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['transformedX', 'transformedY'],
      method: 'translate'
    }
  });
  SVG.Rotate = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['rotation', 'cx', 'cy'],
      method: 'rotate',
      at: function at(pos) {
        var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy);
        return this.inversed ? m.inverse() : m;
      },
      undo: function undo(o) {
        this._undo = o;
        return this;
      }
    }
  });
  SVG.Scale = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['scaleX', 'scaleY', 'cx', 'cy'],
      method: 'scale'
    }
  });
  SVG.Skew = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['skewX', 'skewY', 'cx', 'cy'],
      method: 'skew'
    }
  });
  SVG.extend(SVG.Element, {
    // Dynamic style generator
    style: function style(s, v) {
      if (arguments.length == 0) {
        // get full style
        return this.node.style.cssText || '';
      } else if (arguments.length < 2) {
        // apply every style individually if an object is passed
        if (_typeof(s) === 'object') {
          for (v in s) {
            this.style(v, s[v]);
          }
        } else if (SVG.regex.isCss.test(s)) {
          // parse css string
          s = s.split(/\s*;\s*/) // filter out suffix ; and stuff like ;;
          .filter(function (e) {
            return !!e;
          }).map(function (e) {
            return e.split(/\s*:\s*/);
          }); // apply every definition individually

          while (v = s.pop()) {
            this.style(v[0], v[1]);
          }
        } else {
          // act as a getter if the first and only argument is not an object
          return this.node.style[camelCase(s)];
        }
      } else {
        this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;
      }

      return this;
    }
  });
  SVG.Parent = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Element,
    // Add class methods
    extend: {
      // Returns all child elements
      children: function children() {
        return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {
          return SVG.adopt(node);
        });
      },
      // Add given element at a position
      add: function add(element, i) {
        if (i == null) {
          this.node.appendChild(element.node);
        } else if (element.node != this.node.childNodes[i]) {
          this.node.insertBefore(element.node, this.node.childNodes[i]);
        }

        return this;
      },
      // Basically does the same as `add()` but returns the added element instead
      put: function put(element, i) {
        this.add(element, i);
        return element;
      },
      // Checks if the given element is a child
      has: function has(element) {
        return this.index(element) >= 0;
      },
      // Gets index of given element
      index: function index(element) {
        return [].slice.call(this.node.childNodes).indexOf(element.node);
      },
      // Get a element at the given index
      get: function get(i) {
        return SVG.adopt(this.node.childNodes[i]);
      },
      // Get first child
      first: function first() {
        return this.get(0);
      },
      // Get the last child
      last: function last() {
        return this.get(this.node.childNodes.length - 1);
      },
      // Iterates over all children and invokes a given block
      each: function each(block, deep) {
        var i,
            il,
            children = this.children();

        for (i = 0, il = children.length; i < il; i++) {
          if (children[i] instanceof SVG.Element) {
            block.apply(children[i], [i, children]);
          }

          if (deep && children[i] instanceof SVG.Container) {
            children[i].each(block, deep);
          }
        }

        return this;
      },
      // Remove a given child
      removeElement: function removeElement(element) {
        this.node.removeChild(element.node);
        return this;
      },
      // Remove all elements in this container
      clear: function clear() {
        // remove children
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // remove defs reference


        delete this._defs;
        return this;
      },
      // Get defs
      defs: function defs() {
        return this.doc().defs();
      }
    }
  });
  SVG.extend(SVG.Parent, {
    ungroup: function ungroup(parent, depth) {
      if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;
      parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));
      depth = depth || Infinity;
      this.each(function () {
        if (this instanceof SVG.Defs) return this;
        if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);
        return this.toParent(parent);
      });
      this.node.firstChild || this.remove();
      return this;
    },
    flatten: function flatten(parent, depth) {
      return this.ungroup(parent, depth);
    }
  });
  SVG.Container = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Parent
  });
  SVG.ViewBox = SVG.invent({
    create: function create(source) {
      var base = [0, 0, 0, 0];
      var x,
          y,
          width,
          height,
          box,
          view,
          we,
          he,
          wm = 1,
          // width multiplier
      hm = 1,
          // height multiplier
      reg = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi;

      if (source instanceof SVG.Element) {
        we = source;
        he = source;
        view = (source.attr('viewBox') || '').match(reg);
        box = source.bbox; // get dimensions of current node

        width = new SVG.Number(source.width());
        height = new SVG.Number(source.height()); // find nearest non-percentual dimensions

        while (width.unit == '%') {
          wm *= width.value;
          width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());
          we = we.parent();
        }

        while (height.unit == '%') {
          hm *= height.value;
          height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());
          he = he.parent();
        } // ensure defaults


        this.x = 0;
        this.y = 0;
        this.width = width * wm;
        this.height = height * hm;
        this.zoom = 1;

        if (view) {
          // get width and height from viewbox
          x = parseFloat(view[0]);
          y = parseFloat(view[1]);
          width = parseFloat(view[2]);
          height = parseFloat(view[3]); // calculate zoom accoring to viewbox

          this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width; // calculate real pixel dimensions on parent SVG.Doc element

          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
      } else {
        // ensure source as object
        source = typeof source === 'string' ? source.match(reg).map(function (el) {
          return parseFloat(el);
        }) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.x, source.y, source.width, source.height] : arguments.length == 4 ? [].slice.call(arguments) : base;
        this.x = source[0];
        this.y = source[1];
        this.width = source[2];
        this.height = source[3];
      }
    },
    extend: {
      toString: function toString() {
        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
      },
      morph: function morph(x, y, width, height) {
        this.destination = new SVG.ViewBox(x, y, width, height);
        return this;
      },
      at: function at(pos) {
        if (!this.destination) return this;
        return new SVG.ViewBox([this.x + (this.destination.x - this.x) * pos, this.y + (this.destination.y - this.y) * pos, this.width + (this.destination.width - this.width) * pos, this.height + (this.destination.height - this.height) * pos]);
      }
    },
    // Define parent
    parent: SVG.Container,
    // Add parent method
    construct: {
      // get/set viewbox
      viewbox: function viewbox(x, y, width, height) {
        if (arguments.length == 0) // act as a getter if there are no arguments
          {
            return new SVG.ViewBox(this);
          } // otherwise act as a setter


        return this.attr('viewBox', new SVG.ViewBox(x, y, width, height));
      }
    }
  }) // Add events to elements
  ;
  ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', // , 'mouseenter' -> not supported by IE
  // , 'mouseleave' -> not supported by IE
  'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {
    // add event to SVG.Element
    SVG.Element.prototype[event] = function (f) {
      // bind event to element rather than element node
      SVG.on(this.node, event, f);
      return this;
    };
  }); // Initialize listeners stack

  SVG.listeners = [];
  SVG.handlerMap = [];
  SVG.listenerId = 0; // Add event binder in the SVG namespace

  SVG.on = function (node, event, listener, binding, options) {
    // create listener, get object-index
    var l = listener.bind(binding || node.instance || node),
        index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,
        ev = event.split('.')[0],
        ns = event.split('.')[1] || '*'; // ensure valid object

    SVG.listeners[index] = SVG.listeners[index] || {};
    SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};
    SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};

    if (!listener._svgjsListenerId) {
      listener._svgjsListenerId = ++SVG.listenerId;
    } // reference listener


    SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l; // add listener

    node.addEventListener(ev, l, options || false);
  }; // Add event unbinder in the SVG namespace


  SVG.off = function (node, event, listener) {
    var index = SVG.handlerMap.indexOf(node),
        ev = event && event.split('.')[0],
        ns = event && event.split('.')[1],
        namespace = '';
    if (index == -1) return;

    if (listener) {
      if (typeof listener === 'function') listener = listener._svgjsListenerId;
      if (!listener) return; // remove listener reference

      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {
        // remove listener
        node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false);
        delete SVG.listeners[index][ev][ns || '*'][listener];
      }
    } else if (ns && ev) {
      // remove all listeners for a namespaced event
      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {
        for (listener in SVG.listeners[index][ev][ns]) {
          SVG.off(node, [ev, ns].join('.'), listener);
        }

        delete SVG.listeners[index][ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in SVG.listeners[index]) {
        for (namespace in SVG.listeners[index][event]) {
          if (ns === namespace) {
            SVG.off(node, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (SVG.listeners[index][ev]) {
        for (namespace in SVG.listeners[index][ev]) {
          SVG.off(node, [ev, namespace].join('.'));
        }

        delete SVG.listeners[index][ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in SVG.listeners[index]) {
        SVG.off(node, event);
      }

      delete SVG.listeners[index];
      delete SVG.handlerMap[index];
    }
  }; //


  SVG.extend(SVG.Element, {
    // Bind given event to listener
    on: function on(event, listener, binding, options) {
      SVG.on(this.node, event, listener, binding, options);
      return this;
    },
    // Unbind event from listener
    off: function off(event, listener) {
      SVG.off(this.node, event, listener);
      return this;
    },
    // Fire given event
    fire: function fire(event, data) {
      // Dispatch event
      if (event instanceof window.Event) {
        this.node.dispatchEvent(event);
      } else {
        this.node.dispatchEvent(event = new SVG.CustomEvent(event, {
          detail: data,
          cancelable: true
        }));
      }

      this._event = event;
      return this;
    },
    event: function event() {
      return this._event;
    }
  });
  SVG.Defs = SVG.invent({
    // Initialize node
    create: 'defs',
    // Inherit from
    inherit: SVG.Container
  });
  SVG.G = SVG.invent({
    // Initialize node
    create: 'g',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x3) {
        return _x3 == null ? this.transform('x') : this.transform({
          x: _x3 - this.x()
        }, true);
      },
      // Move over y-axis
      y: function y(_y3) {
        return _y3 == null ? this.transform('y') : this.transform({
          y: _y3 - this.y()
        }, true);
      },
      // Move by center over x-axis
      cx: function cx(x) {
        return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2);
      },
      // Move by center over y-axis
      cy: function cy(y) {
        return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2);
      },
      gbox: function gbox() {
        var bbox = this.bbox(),
            trans = this.transform();
        bbox.x += trans.x;
        bbox.x2 += trans.x;
        bbox.cx += trans.x;
        bbox.y += trans.y;
        bbox.y2 += trans.y;
        bbox.cy += trans.y;
        return bbox;
      }
    },
    // Add parent method
    construct: {
      // Create a group element
      group: function group() {
        return this.put(new SVG.G());
      }
    }
  });
  SVG.Doc = SVG.invent({
    // Initialize node
    create: function create(element) {
      if (element) {
        // ensure the presence of a dom element
        element = typeof element === 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.
        // This allows svg.js to work with svg documents as well.

        if (element.nodeName == 'svg') {
          this.constructor.call(this, element);
        } else {
          this.constructor.call(this, SVG.create('svg'));
          element.appendChild(this.node);
          this.size('100%', '100%');
        } // set svg element attributes and ensure defs node


        this.namespace().defs();
      }
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Add namespaces
      namespace: function namespace() {
        return this.attr({
          xmlns: SVG.ns,
          version: '1.1'
        }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);
      },
      // Creates and returns defs element
      defs: function defs() {
        if (!this._defs) {
          var defs; // Find or create a defs element in this instance

          if (defs = this.node.getElementsByTagName('defs')[0]) {
            this._defs = SVG.adopt(defs);
          } else {
            this._defs = new SVG.Defs();
          } // Make sure the defs node is at the end of the stack


          this.node.appendChild(this._defs.node);
        }

        return this._defs;
      },
      // custom parent method
      parent: function parent() {
        if (!this.node.parentNode || this.node.parentNode.nodeName == '#document') return null;
        return this.node.parentNode;
      },
      // Fix for possible sub-pixel offset. See:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
      spof: function spof() {
        var pos = this.node.getScreenCTM();

        if (pos) {
          this.style('left', -pos.e % 1 + 'px').style('top', -pos.f % 1 + 'px');
        }

        return this;
      },
      // Removes the doc from the DOM
      remove: function remove() {
        if (this.parent()) {
          this.parent().removeChild(this.node);
        }

        return this;
      },
      clear: function clear() {
        // remove children
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // remove defs reference


        delete this._defs; // add back parser

        if (SVG.parser.draw && !SVG.parser.draw.parentNode) {
          this.node.appendChild(SVG.parser.draw);
        }

        return this;
      },
      clone: function clone(parent) {
        // write dom data to the dom so the clone can pickup the data
        this.writeDataToDom(); // get reference to node

        var node = this.node; // clone element and assign new id

        var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself

        if (parent) {
          (parent.node || parent).appendChild(clone.node);
        } else {
          node.parentNode.insertBefore(clone.node, node.nextSibling);
        }

        return clone;
      }
    }
  }); // ### This module adds backward / forward functionality to elements.
  //

  SVG.extend(SVG.Element, {
    // Get all siblings, including myself
    siblings: function siblings() {
      return this.parent().children();
    },
    // Get the curent position siblings
    position: function position() {
      return this.parent().index(this);
    },
    // Get the next element (will return null if there is none)
    next: function next() {
      return this.siblings()[this.position() + 1];
    },
    // Get the next element (will return null if there is none)
    previous: function previous() {
      return this.siblings()[this.position() - 1];
    },
    // Send given element one step forward
    forward: function forward() {
      var i = this.position() + 1,
          p = this.parent(); // move node one step forward

      p.removeElement(this).add(this, i); // make sure defs node is always at the top

      if (p instanceof SVG.Doc) {
        p.node.appendChild(p.defs().node);
      }

      return this;
    },
    // Send given element one step backward
    backward: function backward() {
      var i = this.position();

      if (i > 0) {
        this.parent().removeElement(this).add(this, i - 1);
      }

      return this;
    },
    // Send given element all the way to the front
    front: function front() {
      var p = this.parent(); // Move node forward

      p.node.appendChild(this.node); // Make sure defs node is always at the top

      if (p instanceof SVG.Doc) {
        p.node.appendChild(p.defs().node);
      }

      return this;
    },
    // Send given element all the way to the back
    back: function back() {
      if (this.position() > 0) {
        this.parent().removeElement(this).add(this, 0);
      }

      return this;
    },
    // Inserts a given element before the targeted element
    before: function before(element) {
      element.remove();
      var i = this.position();
      this.parent().add(element, i);
      return this;
    },
    // Insters a given element after the targeted element
    after: function after(element) {
      element.remove();
      var i = this.position();
      this.parent().add(element, i + 1);
      return this;
    }
  });
  SVG.Mask = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('mask')); // keep references to masked elements

      this.targets = [];
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Unmask all masked elements and remove itself
      remove: function remove() {
        // unmask all targets
        for (var i = this.targets.length - 1; i >= 0; i--) {
          if (this.targets[i]) {
            this.targets[i].unmask();
          }
        }

        this.targets = []; // remove mask from parent

        SVG.Element.prototype.remove.call(this);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create masking element
      mask: function mask() {
        return this.defs().put(new SVG.Mask());
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Distribute mask to svg element
    maskWith: function maskWith(element) {
      // use given mask or create a new one
      this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element); // store reverence on self in mask

      this.masker.targets.push(this); // apply mask

      return this.attr('mask', 'url("#' + this.masker.attr('id') + '")');
    },
    // Unmask element
    unmask: function unmask() {
      delete this.masker;
      return this.attr('mask', null);
    }
  });
  SVG.ClipPath = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('clipPath')); // keep references to clipped elements

      this.targets = [];
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Unclip all clipped elements and remove itself
      remove: function remove() {
        // unclip all targets
        for (var i = this.targets.length - 1; i >= 0; i--) {
          if (this.targets[i]) {
            this.targets[i].unclip();
          }
        }

        this.targets = []; // remove clipPath from parent

        this.parent().removeElement(this);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create clipping element
      clip: function clip() {
        return this.defs().put(new SVG.ClipPath());
      }
    }
  }); //

  SVG.extend(SVG.Element, {
    // Distribute clipPath to svg element
    clipWith: function clipWith(element) {
      // use given clip or create a new one
      this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element); // store reverence on self in mask

      this.clipper.targets.push(this); // apply mask

      return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")');
    },
    // Unclip element
    unclip: function unclip() {
      delete this.clipper;
      return this.attr('clip-path', null);
    }
  });
  SVG.Gradient = SVG.invent({
    // Initialize node
    create: function create(type) {
      this.constructor.call(this, SVG.create(type + 'Gradient')); // store type

      this.type = type;
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Add a color stop
      at: function at(offset, color, opacity) {
        return this.put(new SVG.Stop()).update(offset, color, opacity);
      },
      // Update gradient
      update: function update(block) {
        // remove all stops
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Return the fill id
      fill: function fill() {
        return 'url(#' + this.id() + ')';
      },
      // Alias string convertion to fill
      toString: function toString() {
        return this.fill();
      },
      // custom attr to handle transform
      attr: function attr(a, b, c) {
        if (a == 'transform') a = 'gradientTransform';
        return SVG.Container.prototype.attr.call(this, a, b, c);
      }
    },
    // Add parent method
    construct: {
      // Create gradient element in defs
      gradient: function gradient(type, block) {
        return this.defs().gradient(type, block);
      }
    }
  }); // Add animatable methods to both gradient and fx module

  SVG.extend(SVG.Gradient, SVG.FX, {
    // From position
    from: function from(x, y) {
      return (this._target || this).type == 'radial' ? this.attr({
        fx: new SVG.Number(x),
        fy: new SVG.Number(y)
      }) : this.attr({
        x1: new SVG.Number(x),
        y1: new SVG.Number(y)
      });
    },
    // To position
    to: function to(x, y) {
      return (this._target || this).type == 'radial' ? this.attr({
        cx: new SVG.Number(x),
        cy: new SVG.Number(y)
      }) : this.attr({
        x2: new SVG.Number(x),
        y2: new SVG.Number(y)
      });
    }
  }); // Base gradient generation

  SVG.extend(SVG.Defs, {
    // define gradient
    gradient: function gradient(type, block) {
      return this.put(new SVG.Gradient(type)).update(block);
    }
  });
  SVG.Stop = SVG.invent({
    // Initialize node
    create: 'stop',
    // Inherit from
    inherit: SVG.Element,
    // Add class methods
    extend: {
      // add color stops
      update: function update(o) {
        if (typeof o === 'number' || o instanceof SVG.Number) {
          o = {
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          };
        } // set attributes


        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));
        return this;
      }
    }
  });
  SVG.Pattern = SVG.invent({
    // Initialize node
    create: 'pattern',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Return the fill id
      fill: function fill() {
        return 'url(#' + this.id() + ')';
      },
      // Update pattern by rebuilding
      update: function update(block) {
        // remove content
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Alias string convertion to fill
      toString: function toString() {
        return this.fill();
      },
      // custom attr to handle transform
      attr: function attr(a, b, c) {
        if (a == 'transform') a = 'patternTransform';
        return SVG.Container.prototype.attr.call(this, a, b, c);
      }
    },
    // Add parent method
    construct: {
      // Create pattern element in defs
      pattern: function pattern(width, height, block) {
        return this.defs().pattern(width, height, block);
      }
    }
  });
  SVG.extend(SVG.Defs, {
    // Define gradient
    pattern: function pattern(width, height, block) {
      return this.put(new SVG.Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      });
    }
  });
  SVG.Shape = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Element
  });
  SVG.Bare = SVG.invent({
    // Initialize
    create: function create(element, inherit) {
      // construct element
      this.constructor.call(this, SVG.create(element)); // inherit custom methods

      if (inherit) {
        for (var method in inherit.prototype) {
          if (typeof inherit.prototype[method] === 'function') {
            this[method] = inherit.prototype[method];
          }
        }
      }
    },
    // Inherit from
    inherit: SVG.Element,
    // Add methods
    extend: {
      // Insert some plain text
      words: function words(text) {
        // remove contents
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // create text node


        this.node.appendChild(document.createTextNode(text));
        return this;
      }
    }
  });
  SVG.extend(SVG.Parent, {
    // Create an element that is not described by SVG.js
    element: function element(_element, inherit) {
      return this.put(new SVG.Bare(_element, inherit));
    }
  });
  SVG.Symbol = SVG.invent({
    // Initialize node
    create: 'symbol',
    // Inherit from
    inherit: SVG.Container,
    construct: {
      // create symbol
      symbol: function symbol() {
        return this.put(new SVG.Symbol());
      }
    }
  });
  SVG.Use = SVG.invent({
    // Initialize node
    create: 'use',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Use element as a reference
      element: function element(_element2, file) {
        // Set lined element
        return this.attr('href', (file || '') + '#' + _element2, SVG.xlink);
      }
    },
    // Add parent method
    construct: {
      // Create a use element
      use: function use(element, file) {
        return this.put(new SVG.Use()).element(element, file);
      }
    }
  });
  SVG.Rect = SVG.invent({
    // Initialize node
    create: 'rect',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a rect element
      rect: function rect(width, height) {
        return this.put(new SVG.Rect()).size(width, height);
      }
    }
  });
  SVG.Circle = SVG.invent({
    // Initialize node
    create: 'circle',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create circle element, based on ellipse
      circle: function circle(size) {
        return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);
      }
    }
  });
  SVG.extend(SVG.Circle, SVG.FX, {
    // Radius x value
    rx: function rx(_rx) {
      return this.attr('r', _rx);
    },
    // Alias radius x value
    ry: function ry(_ry) {
      return this.rx(_ry);
    }
  });
  SVG.Ellipse = SVG.invent({
    // Initialize node
    create: 'ellipse',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create an ellipse
      ellipse: function ellipse(width, height) {
        return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);
      }
    }
  });
  SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
    // Radius x value
    rx: function rx(_rx2) {
      return this.attr('rx', _rx2);
    },
    // Radius y value
    ry: function ry(_ry2) {
      return this.attr('ry', _ry2);
    }
  }); // Add common method

  SVG.extend(SVG.Circle, SVG.Ellipse, {
    // Move over x-axis
    x: function x(_x4) {
      return _x4 == null ? this.cx() - this.rx() : this.cx(_x4 + this.rx());
    },
    // Move over y-axis
    y: function y(_y4) {
      return _y4 == null ? this.cy() - this.ry() : this.cy(_y4 + this.ry());
    },
    // Move by center over x-axis
    cx: function cx(x) {
      return x == null ? this.attr('cx') : this.attr('cx', x);
    },
    // Move by center over y-axis
    cy: function cy(y) {
      return y == null ? this.attr('cy') : this.attr('cy', y);
    },
    // Set width of element
    width: function width(_width3) {
      return _width3 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width3).divide(2));
    },
    // Set height of element
    height: function height(_height3) {
      return _height3 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height3).divide(2));
    },
    // Custom size function
    size: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));
    }
  });
  SVG.Line = SVG.invent({
    // Initialize node
    create: 'line',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Get array
      array: function array() {
        return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
      },
      // Overwrite native plot() method
      plot: function plot(x1, y1, x2, y2) {
        if (x1 == null) {
          return this.array();
        } else if (typeof y1 !== 'undefined') {
          x1 = {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          };
        } else {
          x1 = new SVG.PointArray(x1).toLine();
        }

        return this.attr(x1);
      },
      // Move by left top corner
      move: function move(x, y) {
        return this.attr(this.array().move(x, y).toLine());
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.attr(this.array().size(p.width, p.height).toLine());
      }
    },
    // Add parent method
    construct: {
      // Create a line element
      line: function line(x1, y1, x2, y2) {
        // make sure plot is called as a setter
        // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray
        return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);
      }
    }
  });
  SVG.Polyline = SVG.invent({
    // Initialize node
    create: 'polyline',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a wrapped polyline element
      polyline: function polyline(p) {
        // make sure plot is called as a setter
        return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());
      }
    }
  });
  SVG.Polygon = SVG.invent({
    // Initialize node
    create: 'polygon',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a wrapped polygon element
      polygon: function polygon(p) {
        // make sure plot is called as a setter
        return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());
      }
    }
  }); // Add polygon-specific functions

  SVG.extend(SVG.Polyline, SVG.Polygon, {
    // Get array
    array: function array() {
      return this._array || (this._array = new SVG.PointArray(this.attr('points')));
    },
    // Plot new path
    plot: function plot(p) {
      return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new SVG.PointArray(p));
    },
    // Clear array cache
    clear: function clear() {
      delete this._array;
      return this;
    },
    // Move by left top corner
    move: function move(x, y) {
      return this.attr('points', this.array().move(x, y));
    },
    // Set element size to given width and height
    size: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr('points', this.array().size(p.width, p.height));
    }
  }); // unify all point to point elements

  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
    // Define morphable array
    morphArray: SVG.PointArray,
    // Move by left top corner over x-axis
    x: function x(_x5) {
      return _x5 == null ? this.bbox().x : this.move(_x5, this.bbox().y);
    },
    // Move by left top corner over y-axis
    y: function y(_y5) {
      return _y5 == null ? this.bbox().y : this.move(this.bbox().x, _y5);
    },
    // Set width of element
    width: function width(_width4) {
      var b = this.bbox();
      return _width4 == null ? b.width : this.size(_width4, b.height);
    },
    // Set height of element
    height: function height(_height4) {
      var b = this.bbox();
      return _height4 == null ? b.height : this.size(b.width, _height4);
    }
  });
  SVG.Path = SVG.invent({
    // Initialize node
    create: 'path',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Define morphable array
      morphArray: SVG.PathArray,
      // Get array
      array: function array() {
        return this._array || (this._array = new SVG.PathArray(this.attr('d')));
      },
      // Plot new path
      plot: function plot(d) {
        return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new SVG.PathArray(d));
      },
      // Clear array cache
      clear: function clear() {
        delete this._array;
        return this;
      },
      // Move by left top corner
      move: function move(x, y) {
        return this.attr('d', this.array().move(x, y));
      },
      // Move by left top corner over x-axis
      x: function x(_x6) {
        return _x6 == null ? this.bbox().x : this.move(_x6, this.bbox().y);
      },
      // Move by left top corner over y-axis
      y: function y(_y6) {
        return _y6 == null ? this.bbox().y : this.move(this.bbox().x, _y6);
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.attr('d', this.array().size(p.width, p.height));
      },
      // Set width of element
      width: function width(_width5) {
        return _width5 == null ? this.bbox().width : this.size(_width5, this.bbox().height);
      },
      // Set height of element
      height: function height(_height5) {
        return _height5 == null ? this.bbox().height : this.size(this.bbox().width, _height5);
      }
    },
    // Add parent method
    construct: {
      // Create a wrapped path element
      path: function path(d) {
        // make sure plot is called as a setter
        return this.put(new SVG.Path()).plot(d || new SVG.PathArray());
      }
    }
  });
  SVG.Image = SVG.invent({
    // Initialize node
    create: 'image',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // (re)load image
      load: function load(url) {
        if (!url) return this;
        var self = this,
            img = new window.Image(); // preload image

        SVG.on(img, 'load', function () {
          SVG.off(img);
          var p = self.parent(SVG.Pattern);
          if (p === null) return; // ensure image size

          if (self.width() == 0 && self.height() == 0) {
            self.size(img.width, img.height);
          } // ensure pattern size if not set


          if (p && p.width() == 0 && p.height() == 0) {
            p.size(self.width(), self.height());
          } // callback


          if (typeof self._loaded === 'function') {
            self._loaded.call(self, {
              width: img.width,
              height: img.height,
              ratio: img.width / img.height,
              url: url
            });
          }
        });
        SVG.on(img, 'error', function (e) {
          SVG.off(img);

          if (typeof self._error === 'function') {
            self._error.call(self, e);
          }
        });
        return this.attr('href', img.src = this.src = url, SVG.xlink);
      },
      // Add loaded callback
      loaded: function loaded(_loaded) {
        this._loaded = _loaded;
        return this;
      },
      error: function error(_error) {
        this._error = _error;
        return this;
      }
    },
    // Add parent method
    construct: {
      // create image element, load image and set its size
      image: function image(source, width, height) {
        return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);
      }
    }
  });
  SVG.Text = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('text'));
      this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding

      this._rebuild = true; // enable automatic updating of dy values

      this._build = false; // disable build mode for adding multiple lines
      // set default font

      this.attr('font-family', SVG.defaults.attrs['font-family']);
    },
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x7) {
        // act as getter
        if (_x7 == null) {
          return this.attr('x');
        }

        return this.attr('x', _x7);
      },
      // Move over y-axis
      y: function y(_y7) {
        var oy = this.attr('y'),
            o = typeof oy === 'number' ? oy - this.bbox().y : 0; // act as getter

        if (_y7 == null) {
          return typeof oy === 'number' ? oy - o : oy;
        }

        return this.attr('y', typeof _y7.valueOf() === 'number' ? _y7 + o : _y7);
      },
      // Move center over x-axis
      cx: function cx(x) {
        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2);
      },
      // Move center over y-axis
      cy: function cy(y) {
        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2);
      },
      // Set the text content
      text: function text(_text) {
        // act as getter
        if (typeof _text === 'undefined') {
          var _text = '';
          var children = this.node.childNodes;

          for (var i = 0, len = children.length; i < len; ++i) {
            // add newline if its not the first child and newLined is set to true
            if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {
              _text += '\n';
            } // add content of this node


            _text += children[i].textContent;
          }

          return _text;
        } // remove existing content


        this.clear().build(true);

        if (typeof _text === 'function') {
          // call block
          _text.call(this, this);
        } else {
          // store text and make sure text is not blank
          _text = _text.split('\n'); // build new lines

          for (var i = 0, il = _text.length; i < il; i++) {
            this.tspan(_text[i]).newLine();
          }
        } // disable build mode and rebuild lines


        return this.build(false).rebuild();
      },
      // Set font size
      size: function size(_size) {
        return this.attr('font-size', _size).rebuild();
      },
      // Set / get leading
      leading: function leading(value) {
        // act as getter
        if (value == null) {
          return this.dom.leading;
        } // act as setter


        this.dom.leading = new SVG.Number(value);
        return this.rebuild();
      },
      // Get all the first level lines
      lines: function lines() {
        var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances

        var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {
          return SVG.adopt(el);
        }); // return an instance of SVG.set

        return new SVG.Set(lines);
      },
      // Rebuild appearance type
      rebuild: function rebuild(_rebuild) {
        // store new rebuild flag if given
        if (typeof _rebuild === 'boolean') {
          this._rebuild = _rebuild;
        } // define position of all lines


        if (this._rebuild) {
          var self = this,
              blankLineOffset = 0,
              dy = this.dom.leading * new SVG.Number(this.attr('font-size'));
          this.lines().each(function () {
            if (this.dom.newLined) {
              if (!self.textPath()) {
                this.attr('x', self.attr('x'));
              }

              if (this.text() == '\n') {
                blankLineOffset += dy;
              } else {
                this.attr('dy', dy + blankLineOffset);
                blankLineOffset = 0;
              }
            }
          });
          this.fire('rebuild');
        }

        return this;
      },
      // Enable / disable build mode
      build: function build(_build) {
        this._build = !!_build;
        return this;
      },
      // overwrite method from parent to set data properly
      setData: function setData(o) {
        this.dom = o;
        this.dom.leading = new SVG.Number(o.leading || 1.3);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create text element
      text: function text(_text2) {
        return this.put(new SVG.Text()).text(_text2);
      },
      // Create plain text element
      plain: function plain(text) {
        return this.put(new SVG.Text()).plain(text);
      }
    }
  });
  SVG.Tspan = SVG.invent({
    // Initialize node
    create: 'tspan',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Set text content
      text: function text(_text3) {
        if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
        typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);
        return this;
      },
      // Shortcut dx
      dx: function dx(_dx) {
        return this.attr('dx', _dx);
      },
      // Shortcut dy
      dy: function dy(_dy) {
        return this.attr('dy', _dy);
      },
      // Create new line
      newLine: function newLine() {
        // fetch text parent
        var t = this.parent(SVG.Text); // mark new line

        this.dom.newLined = true; // apply new hyn

        return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());
      }
    }
  });
  SVG.extend(SVG.Text, SVG.Tspan, {
    // Create plain text node
    plain: function plain(text) {
      // clear if build mode is disabled
      if (this._build === false) {
        this.clear();
      } // create text node


      this.node.appendChild(document.createTextNode(text));
      return this;
    },
    // Create a tspan
    tspan: function tspan(text) {
      var node = (this.textPath && this.textPath() || this).node,
          tspan = new SVG.Tspan(); // clear if build mode is disabled

      if (this._build === false) {
        this.clear();
      } // add new tspan


      node.appendChild(tspan.node);
      return tspan.text(text);
    },
    // Clear all lines
    clear: function clear() {
      var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes

      while (node.hasChildNodes()) {
        node.removeChild(node.lastChild);
      }

      return this;
    },
    // Get length of text element
    length: function length() {
      return this.node.getComputedTextLength();
    }
  });
  SVG.TextPath = SVG.invent({
    // Initialize node
    create: 'textPath',
    // Inherit from
    inherit: SVG.Parent,
    // Define parent class
    parent: SVG.Text,
    // Add parent method
    construct: {
      morphArray: SVG.PathArray,
      // Create path for text to run on
      path: function path(d) {
        // create textPath element
        var path = new SVG.TextPath(),
            track = this.doc().defs().path(d); // move lines to textpath

        while (this.node.hasChildNodes()) {
          path.node.appendChild(this.node.firstChild);
        } // add textPath element as child node


        this.node.appendChild(path.node); // link textPath to path and add content

        path.attr('href', '#' + track, SVG.xlink);
        return this;
      },
      // return the array of the path track element
      array: function array() {
        var track = this.track();
        return track ? track.array() : null;
      },
      // Plot path if any
      plot: function plot(d) {
        var track = this.track(),
            pathArray = null;

        if (track) {
          pathArray = track.plot(d);
        }

        return d == null ? pathArray : this;
      },
      // Get the path track element
      track: function track() {
        var path = this.textPath();

        if (path) {
          return path.reference('href');
        }
      },
      // Get the textPath child
      textPath: function textPath() {
        if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') {
          return SVG.adopt(this.node.firstChild);
        }
      }
    }
  });
  SVG.Nested = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('svg'));
      this.style('overflow', 'visible');
    },
    // Inherit from
    inherit: SVG.Container,
    // Add parent method
    construct: {
      // Create nested svg document
      nested: function nested() {
        return this.put(new SVG.Nested());
      }
    }
  });
  SVG.A = SVG.invent({
    // Initialize node
    create: 'a',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Link url
      to: function to(url) {
        return this.attr('href', url, SVG.xlink);
      },
      // Link show attribute
      show: function show(target) {
        return this.attr('show', target, SVG.xlink);
      },
      // Link target attribute
      target: function target(_target2) {
        return this.attr('target', _target2);
      }
    },
    // Add parent method
    construct: {
      // Create a hyperlink element
      link: function link(url) {
        return this.put(new SVG.A()).to(url);
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Create a hyperlink element
    linkTo: function linkTo(url) {
      var link = new SVG.A();

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this.parent().put(link).put(this);
    }
  });
  SVG.Marker = SVG.invent({
    // Initialize node
    create: 'marker',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Set width of element
      width: function width(_width6) {
        return this.attr('markerWidth', _width6);
      },
      // Set height of element
      height: function height(_height6) {
        return this.attr('markerHeight', _height6);
      },
      // Set marker refX and refY
      ref: function ref(x, y) {
        return this.attr('refX', x).attr('refY', y);
      },
      // Update marker
      update: function update(block) {
        // remove all content
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Return the fill id
      toString: function toString() {
        return 'url(#' + this.id() + ')';
      }
    },
    // Add parent method
    construct: {
      marker: function marker(width, height, block) {
        // Create marker element in defs
        return this.defs().marker(width, height, block);
      }
    }
  });
  SVG.extend(SVG.Defs, {
    // Create marker
    marker: function marker(width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new SVG.Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
    }
  });
  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
    // Create and attach markers
    marker: function marker(_marker, width, height, block) {
      var attr = ['marker']; // Build attribute name

      if (_marker != 'all') attr.push(_marker);
      attr = attr.join('-'); // Set marker attribute

      _marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);
      return this.attr(attr, _marker);
    }
  }); // Define list of available attributes for stroke and fill

  var sugar = {
    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
    fill: ['color', 'opacity', 'rule'],
    prefix: function prefix(t, a) {
      return a == 'color' ? t : t + '-' + a;
    } // Add sugar for fill and stroke

  };
  ['fill', 'stroke'].forEach(function (m) {
    var i,
        extension = {};

    extension[m] = function (o) {
      if (typeof o === 'undefined') {
        return this;
      }

      if (typeof o === 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') {
        this.attr(m, o);
      } else // set all attributes from sugar.fill and sugar.stroke list
        {
          for (i = sugar[m].length - 1; i >= 0; i--) {
            if (o[sugar[m][i]] != null) {
              this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
            }
          }
        }

      return this;
    };

    SVG.extend(SVG.Element, SVG.FX, extension);
  });
  SVG.extend(SVG.Element, SVG.FX, {
    // Map rotation to transform
    rotate: function rotate(d, cx, cy) {
      return this.transform({
        rotation: d,
        cx: cx,
        cy: cy
      });
    },
    // Map skew to transform
    skew: function skew(x, y, cx, cy) {
      return arguments.length == 1 || arguments.length == 3 ? this.transform({
        skew: x,
        cx: y,
        cy: cx
      }) : this.transform({
        skewX: x,
        skewY: y,
        cx: cx,
        cy: cy
      });
    },
    // Map scale to transform
    scale: function scale(x, y, cx, cy) {
      return arguments.length == 1 || arguments.length == 3 ? this.transform({
        scale: x,
        cx: y,
        cy: cx
      }) : this.transform({
        scaleX: x,
        scaleY: y,
        cx: cx,
        cy: cy
      });
    },
    // Map translate to transform
    translate: function translate(x, y) {
      return this.transform({
        x: x,
        y: y
      });
    },
    // Map flip to transform
    flip: function flip(a, o) {
      o = typeof a === 'number' ? a : o;
      return this.transform({
        flip: a || 'both',
        offset: o
      });
    },
    // Map matrix to transform
    matrix: function matrix(m) {
      return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));
    },
    // Opacity
    opacity: function opacity(value) {
      return this.attr('opacity', value);
    },
    // Relative move over x axis
    dx: function dx(x) {
      return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);
    },
    // Relative move over y axis
    dy: function dy(y) {
      return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);
    },
    // Relative move over x and y axes
    dmove: function dmove(x, y) {
      return this.dx(x).dy(y);
    }
  });
  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
    // Add x and y radius
    radius: function radius(x, y) {
      var type = (this._target || this).type;
      return type == 'radial' || type == 'circle' ? this.attr('r', new SVG.Number(x)) : this.rx(x).ry(y == null ? x : y);
    }
  });
  SVG.extend(SVG.Path, {
    // Get path length
    length: function length() {
      return this.node.getTotalLength();
    },
    // Get point at length
    pointAt: function pointAt(length) {
      return this.node.getPointAtLength(length);
    }
  });
  SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {
    // Set font
    font: function font(a, v) {
      if (_typeof(a) === 'object') {
        for (v in a) {
          this.font(v, a[v]);
        }
      }

      return a == 'leading' ? this.leading(v) : a == 'anchor' ? this.attr('text-anchor', v) : a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
    }
  });
  SVG.Set = SVG.invent({
    // Initialize
    create: function create(members) {
      // Set initial state
      Array.isArray(members) ? this.members = members : this.clear();
    },
    // Add class methods
    extend: {
      // Add element to set
      add: function add() {
        var i,
            il,
            elements = [].slice.call(arguments);

        for (i = 0, il = elements.length; i < il; i++) {
          this.members.push(elements[i]);
        }

        return this;
      },
      // Remove element from set
      remove: function remove(element) {
        var i = this.index(element); // remove given child

        if (i > -1) {
          this.members.splice(i, 1);
        }

        return this;
      },
      // Iterate over all members
      each: function each(block) {
        for (var i = 0, il = this.members.length; i < il; i++) {
          block.apply(this.members[i], [i, this.members]);
        }

        return this;
      },
      // Restore to defaults
      clear: function clear() {
        // initialize store
        this.members = [];
        return this;
      },
      // Get the length of a set
      length: function length() {
        return this.members.length;
      },
      // Checks if a given element is present in set
      has: function has(element) {
        return this.index(element) >= 0;
      },
      // retuns index of given element in set
      index: function index(element) {
        return this.members.indexOf(element);
      },
      // Get member at given index
      get: function get(i) {
        return this.members[i];
      },
      // Get first member
      first: function first() {
        return this.get(0);
      },
      // Get last member
      last: function last() {
        return this.get(this.members.length - 1);
      },
      // Default value
      valueOf: function valueOf() {
        return this.members;
      },
      // Get the bounding box of all members included or empty box if set has no items
      bbox: function bbox() {
        // return an empty box of there are no members
        if (this.members.length == 0) {
          return new SVG.RBox();
        } // get the first rbox and update the target bbox


        var rbox = this.members[0].rbox(this.members[0].doc());
        this.each(function () {
          // user rbox for correct position and visual representation
          rbox = rbox.merge(this.rbox(this.doc()));
        });
        return rbox;
      }
    },
    // Add parent method
    construct: {
      // Create a new set
      set: function set(members) {
        return new SVG.Set(members);
      }
    }
  });
  SVG.FX.Set = SVG.invent({
    // Initialize node
    create: function create(set) {
      // store reference to set
      this.set = set;
    }
  }); // Alias methods

  SVG.Set.inherit = function () {
    var m,
        methods = []; // gather shape methods

    for (var m in SVG.Shape.prototype) {
      if (typeof SVG.Shape.prototype[m] === 'function' && typeof SVG.Set.prototype[m] !== 'function') {
        methods.push(m);
      }
    } // apply shape aliasses


    methods.forEach(function (method) {
      SVG.Set.prototype[method] = function () {
        for (var i = 0, il = this.members.length; i < il; i++) {
          if (this.members[i] && typeof this.members[i][method] === 'function') {
            this.members[i][method].apply(this.members[i], arguments);
          }
        }

        return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;
      };
    }); // clear methods for the next round

    methods = []; // gather fx methods

    for (var m in SVG.FX.prototype) {
      if (typeof SVG.FX.prototype[m] === 'function' && typeof SVG.FX.Set.prototype[m] !== 'function') {
        methods.push(m);
      }
    } // apply fx aliasses


    methods.forEach(function (method) {
      SVG.FX.Set.prototype[method] = function () {
        for (var i = 0, il = this.set.members.length; i < il; i++) {
          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);
        }

        return this;
      };
    });
  };

  SVG.extend(SVG.Element, {
    // Store data values on svg nodes
    data: function data(a, v, r) {
      if (_typeof(a) === 'object') {
        for (v in a) {
          this.data(v, a[v]);
        }
      } else if (arguments.length < 2) {
        try {
          return JSON.parse(this.attr('data-' + a));
        } catch (e) {
          return this.attr('data-' + a);
        }
      } else {
        this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
      }

      return this;
    }
  });
  SVG.extend(SVG.Element, {
    // Remember arbitrary data
    remember: function remember(k, v) {
      // remember every item in an object individually
      if (_typeof(arguments[0]) === 'object') {
        for (var v in k) {
          this.remember(v, k[v]);
        }
      } // retrieve memory
      else if (arguments.length == 1) {
          return this.memory()[k];
        } // store memory
        else {
            this.memory()[k] = v;
          }

      return this;
    },
    // Erase a given memory
    forget: function forget() {
      if (arguments.length == 0) {
        this._memory = {};
      } else {
        for (var i = arguments.length - 1; i >= 0; i--) {
          delete this.memory()[arguments[i]];
        }
      }

      return this;
    },
    // Initialize or return local memory object
    memory: function memory() {
      return this._memory || (this._memory = {});
    }
  }); // Method for getting an element by id

  SVG.get = function (id) {
    var node = document.getElementById(idFromReference(id) || id);
    return SVG.adopt(node);
  }; // Select elements by query string


  SVG.select = function (query, parent) {
    return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {
      return SVG.adopt(node);
    }));
  };

  SVG.extend(SVG.Parent, {
    // Scoped select method
    select: function select(query) {
      return SVG.select(query, this.node);
    }
  });

  function pathRegReplace(a, b, c, d) {
    return c + d.replace(SVG.regex.dots, ' .');
  } // creates deep clone of array


  function array_clone(arr) {
    var clone = arr.slice(0);

    for (var i = clone.length; i--;) {
      if (Array.isArray(clone[i])) {
        clone[i] = array_clone(clone[i]);
      }
    }

    return clone;
  } // tests if a given element is instance of an object


  function _is(el, obj) {
    return el instanceof obj;
  } // tests if a given selector matches an element


  function _matches(el, selector) {
    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  } // Convert dash-separated-string to camelCase


  function camelCase(s) {
    return s.toLowerCase().replace(/-(.)/g, function (m, g) {
      return g.toUpperCase();
    });
  } // Capitalize first letter of a string


  function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  } // Ensure to six-based hex


  function fullHex(hex) {
    return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
  } // Component to hex value


  function compToHex(comp) {
    var hex = comp.toString(16);
    return hex.length == 1 ? '0' + hex : hex;
  } // Calculate proportional width and height values when necessary


  function proportionalSize(element, width, height) {
    if (width == null || height == null) {
      var box = element.bbox();

      if (width == null) {
        width = box.width / box.height * height;
      } else if (height == null) {
        height = box.height / box.width * width;
      }
    }

    return {
      width: width,
      height: height
    };
  } // Delta transform point


  function deltaTransformPoint(matrix, x, y) {
    return {
      x: x * matrix.a + y * matrix.c + 0,
      y: x * matrix.b + y * matrix.d + 0
    };
  } // Map matrix array to object


  function arrayToMatrix(a) {
    return {
      a: a[0],
      b: a[1],
      c: a[2],
      d: a[3],
      e: a[4],
      f: a[5]
    };
  } // Parse matrix if required


  function parseMatrix(matrix) {
    if (!(matrix instanceof SVG.Matrix)) {
      matrix = new SVG.Matrix(matrix);
    }

    return matrix;
  } // Add centre point to transform object


  function ensureCentre(o, target) {
    o.cx = o.cx == null ? target.bbox().cx : o.cx;
    o.cy = o.cy == null ? target.bbox().cy : o.cy;
  } // PathArray Helpers


  function arrayToString(a) {
    for (var i = 0, il = a.length, s = ''; i < il; i++) {
      s += a[i][0];

      if (a[i][1] != null) {
        s += a[i][1];

        if (a[i][2] != null) {
          s += ' ';
          s += a[i][2];

          if (a[i][3] != null) {
            s += ' ';
            s += a[i][3];
            s += ' ';
            s += a[i][4];

            if (a[i][5] != null) {
              s += ' ';
              s += a[i][5];
              s += ' ';
              s += a[i][6];

              if (a[i][7] != null) {
                s += ' ';
                s += a[i][7];
              }
            }
          }
        }
      }
    }

    return s + ' ';
  } // Deep new id assignment


  function assignNewId(node) {
    // do the same for SVG child nodes as well
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      if (node.childNodes[i] instanceof window.SVGElement) {
        assignNewId(node.childNodes[i]);
      }
    }

    return SVG.adopt(node).id(SVG.eid(node.nodeName));
  } // Add more bounding box properties


  function fullBox(b) {
    if (b.x == null) {
      b.x = 0;
      b.y = 0;
      b.width = 0;
      b.height = 0;
    }

    b.w = b.width;
    b.h = b.height;
    b.x2 = b.x + b.width;
    b.y2 = b.y + b.height;
    b.cx = b.x + b.width / 2;
    b.cy = b.y + b.height / 2;
    return b;
  } // Get id from reference string


  function idFromReference(url) {
    var m = (url || '').toString().match(SVG.regex.reference);
    if (m) return m[1];
  } // If values like 1e-88 are passed, this is not a valid 32 bit float,
  // but in those cases, we are so close to 0 that 0 works well!


  function float32String(v) {
    return Math.abs(v) > 1e-37 ? v : 0;
  } // Create matrix array for looping


  var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10

  if (typeof window.CustomEvent !== 'function') {
    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
    var CustomEventPoly = function CustomEventPoly(event, options) {
      options = options || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);
      return e;
    };

    CustomEventPoly.prototype = window.Event.prototype;
    SVG.CustomEvent = CustomEventPoly;
  } else {
    SVG.CustomEvent = window.CustomEvent;
  } // requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish


  (function (w) {
    var lastTime = 0;
    var vendors = ['moz', 'webkit'];

    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];
      w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'] || w[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    w.requestAnimationFrame = w.requestAnimationFrame || function (callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = w.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

    w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;
  })(window);

  return SVG;
});

/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
(function() {

  // Main filter class
  SVG.Filter = SVG.invent({
    create: 'filter',
    inherit: SVG.Parent,
    extend: {
      // Static strings
      source:           'SourceGraphic',
      sourceAlpha:      'SourceAlpha',
      background:       'BackgroundImage',
      backgroundAlpha:  'BackgroundAlpha',
      fill:             'FillPaint',
      stroke:           'StrokePaint',

      autoSetIn: true,
      // Custom put method for leaner code
      put: function(element, i) {
        this.add(element, i);

        if(!element.attr('in') && this.autoSetIn){
          element.attr('in',this.source);
        }
        if(!element.attr('result')){
          element.attr('result',element);
        }

        return element
      },
      // Blend effect
      blend: function(in1, in2, mode) {
        return this.put(new SVG.BlendEffect(in1, in2, mode))
      },
      // ColorMatrix effect
      colorMatrix: function(type, values) {
        return this.put(new SVG.ColorMatrixEffect(type, values))
      },
      // ConvolveMatrix effect
      convolveMatrix: function(matrix) {
        return this.put(new SVG.ConvolveMatrixEffect(matrix))
      },
      // ComponentTransfer effect
      componentTransfer: function(components) {
        return this.put(new SVG.ComponentTransferEffect(components))
      },
      // Composite effect
      composite: function(in1, in2, operator) {
        return this.put(new SVG.CompositeEffect(in1, in2, operator))
      },
      // Flood effect
      flood: function(color, opacity) {
        return this.put(new SVG.FloodEffect(color, opacity))
      },
      // Offset effect
      offset: function(x, y) {
        return this.put(new SVG.OffsetEffect(x,y))
      },
      // Image effect
      image: function(src) {
        return this.put(new SVG.ImageEffect(src))
      },
      // Merge effect
      merge: function() {
        //pass the array of arguments to the constructor because we dont know if the user gave us an array as the first arguemnt or wether they listed the effects in the arguments
        var args = [undefined];
        for(var i in arguments) args.push(arguments[i]);
        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect,args)))
      },
      // Gaussian Blur effect
      gaussianBlur: function(x,y) {
        return this.put(new SVG.GaussianBlurEffect(x,y))
      },
      // Morphology effect
      morphology: function(operator,radius){
        return this.put(new SVG.MorphologyEffect(operator,radius))
      },
      // DiffuseLighting effect
      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
        return this.put(new SVG.DiffuseLightingEffect(surfaceScale,diffuseConstant,kernelUnitLength))
      },
      // DisplacementMap effect
      displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){
        return this.put(new SVG.DisplacementMapEffect(in1,in2,scale,xChannelSelector,yChannelSelector))
      },
      // SpecularLighting effect
      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
        return this.put(new SVG.SpecularLightingEffect(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength))
      },
      // Tile effect
      tile: function(){
        return this.put(new SVG.TileEffect());
      },
      // Turbulence effect
      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
        return this.put(new SVG.TurbulenceEffect(baseFrequency,numOctaves,seed,stitchTiles,type))
      },
      // Default string value
      toString: function() {
        return 'url(#' + this.attr('id') + ')'
      }
    }
  });

  //add .filter function
  SVG.extend(SVG.Defs, {
    // Define filter
    filter: function(block) {
      var filter = this.put(new SVG.Filter);

      /* invoke passed block */
      if (typeof block === 'function')
        block.call(filter, filter);

      return filter
    }
  });
  SVG.extend(SVG.Container, {
    // Define filter on defs
    filter: function(block) {
      return this.defs().filter(block)
    }
  });
  SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
    // Create filter element in defs and store reference
    filter: function(block) {
      this.filterer = block instanceof SVG.Element ?
        block : this.doc().filter(block);

      if(this.doc() && this.filterer.doc() !== this.doc()){
        this.doc().defs().add(this.filterer);
      }

      this.attr('filter', this.filterer);

      return this.filterer
    },
    // Remove filter
    unfilter: function(remove) {
      /* also remove the filter node */
      if (this.filterer && remove === true)
        this.filterer.remove();

      /* delete reference to filterer */
      delete this.filterer;

      /* remove filter attribute */
      return this.attr('filter', null)
    }
  });

  // Create SVG.Effect class
  SVG.Effect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      // Set in attribute
      in: function(effect) {
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in')+'"]').get(0) || this.attr('in') : this.attr('in', effect)
      },
      // Named result
      result: function(result) {
        return result == null? this.attr('result') : this.attr('result',result)
      },
      // Stringification
      toString: function() {
        return this.result()
      }
    }
  });

  // create class for parent effects like merge
  // Inherit from SVG.Parent
  SVG.ParentEffect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Parent,
    extend: {
      // Set in attribute
      in: function(effect) {
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in')+'"]').get(0) || this.attr('in') : this.attr('in', effect)
      },
      // Named result
      result: function(result) {
        return result == null? this.attr('result') : this.attr('result',result)
      },
      // Stringification
      toString: function() {
        return this.result()
      }
    }
  });

  //chaining
  var chainingEffects = {
    // Blend effect
    blend: function(in2, mode) {
      return this.parent() && this.parent().blend(this, in2, mode) //pass this as the first input
    },
    // ColorMatrix effect
    colorMatrix: function(type, values) {
      return this.parent() && this.parent().colorMatrix(type, values).in(this)
    },
    // ConvolveMatrix effect
    convolveMatrix: function(matrix) {
      return this.parent() && this.parent().convolveMatrix(matrix).in(this)
    },
    // ComponentTransfer effect
    componentTransfer: function(components) {
      return this.parent() && this.parent().componentTransfer(components).in(this)
    },
    // Composite effect
    composite: function(in2, operator) {
      return this.parent() && this.parent().composite(this, in2, operator) //pass this as the first input
    },
    // Flood effect
    flood: function(color, opacity) {
      return this.parent() && this.parent().flood(color, opacity) //this effect dont have inputs
    },
    // Offset effect
    offset: function(x, y) {
      return this.parent() && this.parent().offset(x,y).in(this)
    },
    // Image effect
    image: function(src) {
      return this.parent() && this.parent().image(src) //this effect dont have inputs
    },
    // Merge effect
    merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(),[this].concat(arguments)) //pass this as the first argument
    },
    // Gaussian Blur effect
    gaussianBlur: function(x,y) {
      return this.parent() && this.parent().gaussianBlur(x,y).in(this)
    },
    // Morphology effect
    morphology: function(operator,radius){
      return this.parent() && this.parent().morphology(operator,radius).in(this)
    },
    // DiffuseLighting effect
    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
      return this.parent() && this.parent().diffuseLighting(surfaceScale,diffuseConstant,kernelUnitLength).in(this)
    },
    // DisplacementMap effect
    displacementMap: function(in2,scale,xChannelSelector,yChannelSelector){
      return this.parent() && this.parent().displacementMap(this,in2,scale,xChannelSelector,yChannelSelector) //pass this as the first input
    },
    // SpecularLighting effect
    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
      return this.parent() && this.parent().specularLighting(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength).in(this)
    },
    // Tile effect
    tile: function(){
      return this.parent() && this.parent().tile().in(this)
    },
    // Turbulence effect
    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
      return this.parent() && this.parent().turbulence(baseFrequency,numOctaves,seed,stitchTiles,type).in(this)
    }
  };
  SVG.extend(SVG.Effect,chainingEffects);
  SVG.extend(SVG.ParentEffect,chainingEffects);

  //crea class for child effects, like MergeNode, FuncR and lights
  SVG.ChildEffect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
    in: function(effect){
      this.attr('in',effect);
    }
    //dont include any "result" functions because these types of nodes dont have them
    }
  });

  // Create all different effects
  var effects = {
    blend: function(in1,in2,mode){
      this.attr({
        in: in1,
        in2: in2,
        mode: mode || 'normal'
      });
    },
    colorMatrix: function(type,values){
      if (type == 'matrix')
        values = normaliseMatrix(values);

      this.attr({
        type:   type
      , values: typeof values == 'undefined' ? null : values
      });
    },
    convolveMatrix: function(matrix){
      matrix = normaliseMatrix(matrix);

      this.attr({
        order:        Math.sqrt(matrix.split(' ').length)
      , kernelMatrix: matrix
      });
    },
    composite: function(in1, in2, operator){
      this.attr({
        in: in1,
        in2: in2,
        operator: operator
      });
    },
    flood: function(color,opacity){
      this.attr('flood-color',color);
      if(opacity != null) this.attr('flood-opacity',opacity);
    },
    offset: function(x,y){
      this.attr({
        dx: x,
        dy: y
      });
    },
    image: function(src){
      this.attr('href', src, SVG.xlink);
    },
    displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){
      this.attr({
        in: in1,
        in2: in2,
        scale: scale,
        xChannelSelector: xChannelSelector,
        yChannelSelector: yChannelSelector
      });
    },
    gaussianBlur: function(x,y){
      if(x != null || y != null)
        this.attr('stdDeviation', listString(Array.prototype.slice.call(arguments)));
      else
        this.attr('stdDeviation', '0 0');
    },
    morphology: function(operator,radius){
      this.attr({
        operator: operator,
        radius: radius
      });
    },
    tile: function(){

    },
    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
      this.attr({
        numOctaves: numOctaves,
        seed: seed,
        stitchTiles: stitchTiles,
        baseFrequency: baseFrequency,
        type: type
      });
    }
  };

  // Create all parent effects
  var parentEffects = {
    merge: function(){
      var children;

      //test to see if we have a set
      if(arguments[0] instanceof SVG.Set){
        var that = this;
        arguments[0].each(function(i){
          if(this instanceof SVG.MergeNode)
            that.put(this);
          else if(this instanceof SVG.Effect || this instanceof SVG.ParentEffect)
            that.put(new SVG.MergeNode(this));
        });
      }
      else{
        //if the first argument is an array use it
        if(Array.isArray(arguments[0]))
          children = arguments[0];
        else
          children = arguments;

        for(var i = 0; i < children.length; i++){
          if(children[i] instanceof SVG.MergeNode){
            this.put(children[i]);
          }
          else this.put(new SVG.MergeNode(children[i]));
        }
      }
    },
    componentTransfer: function(compontents){
      /* create rgb set */
      this.rgb = new SVG.Set

      /* create components */
      ;(['r', 'g', 'b', 'a']).forEach(function(c) {
        /* create component */
        this[c] = new SVG['Func' + c.toUpperCase()]('identity');

        /* store component in set */
        this.rgb.add(this[c]);

        /* add component node */
        this.node.appendChild(this[c].node);
      }.bind(this)); //lost context in foreach

      /* set components */
      if (compontents) {
        if (compontents.rgb) {
(['r', 'g', 'b']).forEach(function(c) {
            this[c].attr(compontents.rgb);
          }.bind(this));

          delete compontents.rgb;
        }

        /* set individual components */
        for (var c in compontents)
          this[c].attr(compontents[c]);
      }
    },
    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
      this.attr({
        surfaceScale: surfaceScale,
        diffuseConstant: diffuseConstant,
        kernelUnitLength: kernelUnitLength
      });
    },
    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
      this.attr({
        surfaceScale: surfaceScale,
        diffuseConstant: diffuseConstant,
        specularExponent: specularExponent,
        kernelUnitLength: kernelUnitLength
      });
    },
  };

  // Create child effects like PointLight and MergeNode
  var childEffects = {
    distantLight: function(azimuth, elevation){
      this.attr({
        azimuth: azimuth,
        elevation: elevation
      });
    },
    pointLight: function(x,y,z){
      this.attr({
        x: x,
        y: y,
        z: z
      });
    },
    spotLight: function(x,y,z,pointsAtX,pointsAtY,pointsAtZ){
      this.attr({
        x: x,
        y: y,
        z: z,
        pointsAtX: pointsAtX,
        pointsAtY: pointsAtY,
        pointsAtZ: pointsAtZ
      });
    },
    mergeNode: function(in1){
      this.attr('in',in1);
    }
  }

  // Create compontent functions
  ;(['r', 'g', 'b', 'a']).forEach(function(c) {
    /* create class */
    childEffects['Func' + c.toUpperCase()] = function(type) {
      this.attr('type',type);

      // take diffent arguments based on the type
      switch(type){
        case 'table':
          this.attr('tableValues',arguments[1]);
          break
        case 'linear':
          this.attr('slope',arguments[1]);
          this.attr('intercept',arguments[2]);
          break
        case 'gamma':
          this.attr('amplitude',arguments[1]);
          this.attr('exponent',arguments[2]);
          this.attr('offset',arguments[2]);
          break
      }
    };
  });

  //create effects
  foreach(effects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name + 'Effect'] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);

        //set the result
        this.result(this.attr('id') + 'Out');
      },
      inherit: SVG.Effect,
      extend: proto
    });
  });

  //create parent effects
  foreach(parentEffects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name + 'Effect'] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);

        //set the result
        this.result(this.attr('id') + 'Out');
      },
      inherit: SVG.ParentEffect,
      extend: proto
    });
  });

  //create child effects
  foreach(childEffects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);
      },
      inherit: SVG.ChildEffect,
      extend: proto
    });
  });

  // Effect-specific extensions
  SVG.extend(SVG.MergeEffect,{
    in: function(effect){
      if(effect instanceof SVG.MergeNode)
        this.add(effect,0);
      else
        this.add(new SVG.MergeNode(effect),0);

      return this
    }
  });
  SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{
    in2: function(effect){
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in2')+'"]').get(0) || this.attr('in2') : this.attr('in2', effect)
    }
  });

  // Presets
  SVG.filter = {
    sepiatone:  [ .343, .669, .119, 0, 0
                , .249, .626, .130, 0, 0
                , .172, .334, .111, 0, 0
                , .000, .000, .000, 1, 0 ]
  };

  // Helpers
  function normaliseMatrix(matrix) {
    /* convert possible array value to string */
    if (Array.isArray(matrix))
      matrix = new SVG.Array(matrix);

    /* ensure there are no leading, tailing or double spaces */
    return matrix.toString().replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' ')
  }

  function listString(list) {
    if (!Array.isArray(list))
      return list

    for (var i = 0, l = list.length, s = []; i < l; i++)
      s.push(list[i]);

    return s.join(' ')
  }

  function foreach(){ //loops through mutiple objects
    var fn = function(){};
    if(typeof arguments[arguments.length-1] == 'function'){
      fn = arguments[arguments.length-1];
      Array.prototype.splice.call(arguments,arguments.length-1,1);
    }
    for(var k in arguments){
      for(var i in arguments[k]){
        fn(arguments[k][i],i,arguments[k]);
      }
    }
  }

}).call(undefined);

(function() {

SVG.extend(SVG.PathArray, {
  morph: function(array) {

    var startArr = this.value
      ,  destArr = this.parse(array);

    var startOffsetM = 0
      ,  destOffsetM = 0;

    var startOffsetNextM = false
      ,  destOffsetNextM = false;

    while(true){
      // stop if there is no M anymore
      if(startOffsetM === false && destOffsetM === false) break

      // find the next M in path array
      startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM+1);
       destOffsetNextM = findNextM( destArr,  destOffsetM === false ? false :  destOffsetM+1);

      // We have to add one M to the startArray
      if(startOffsetM === false){
        var bbox = new SVG.PathArray(result.start).bbox();

        // when the last block had no bounding box we simply take the first M we got
        if(bbox.height == 0 || bbox.width == 0){
          startOffsetM =  startArr.push(startArr[0]) - 1;
        }else{
          // we take the middle of the bbox instead when we got one
          startOffsetM = startArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;
        }
      }

      // We have to add one M to the destArray
      if( destOffsetM === false){
        var bbox = new SVG.PathArray(result.dest).bbox();

        if(bbox.height == 0 || bbox.width == 0){
          destOffsetM =  destArr.push(destArr[0]) - 1;
        }else{
          destOffsetM =  destArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;
        }
      }

      // handle block from M to next M
      var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);

      // update the arrays to their new values
      startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));
       destArr =  destArr.slice(0,  destOffsetM).concat(result.dest ,  destOffsetNextM === false ? [] :  destArr.slice( destOffsetNextM));

      // update offsets
      startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;
       destOffsetM =  destOffsetNextM === false ? false :  destOffsetM + result.dest.length;

    }

    // copy back arrays
    this.value = startArr;
    this.destination = new SVG.PathArray();
    this.destination.value = destArr;

    return this
  }
});



// sorry for the long declaration
// slices out one block (from M to M) and syncronize it so the types and length match
function handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM, undefined){

  // slice out the block we need
  var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined)
    ,  destArrTemp =  destArr.slice( destOffsetM,  destOffsetNextM || undefined);

  var i = 0
    , posStart = {pos:[0,0], start:[0,0]}
    , posDest  = {pos:[0,0], start:[0,0]};

  do{

    // convert shorthand types to long form
    startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);
     destArrTemp[i] = simplyfy.call(posDest ,  destArrTemp[i]);

    // check if both shape types match
    // 2 elliptical arc curve commands ('A'), are considered different if the
    // flags (large-arc-flag, sweep-flag) don't match
    if(startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' ||
        (startArrTemp[i][0] == 'A' &&
          (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])
        )
      ) {

      // if not, convert shapes to beziere
      Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));
       Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));

    } else {

      // only update positions otherwise
      startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);
       destArrTemp[i] = setPosAndReflection.call(posDest ,  destArrTemp[i]);

    }

    // we are at the end at both arrays. stop here
    if(++i == startArrTemp.length && i == destArrTemp.length) break

    // destArray is longer. Add one element
    if(i == startArrTemp.length){
      startArrTemp.push([
        'C',
        posStart.pos[0],
        posStart.pos[1],
        posStart.pos[0],
        posStart.pos[1],
        posStart.pos[0],
        posStart.pos[1],
      ]);
    }

    // startArr is longer. Add one element
    if(i == destArrTemp.length){
      destArrTemp.push([
        'C',
        posDest.pos[0],
        posDest.pos[1],
        posDest.pos[0],
        posDest.pos[1],
        posDest.pos[0],
        posDest.pos[1]
      ]);
    }


  }while(true)

  // return the updated block
  return {start:startArrTemp, dest:destArrTemp}
}

// converts shorthand types to long form
function simplyfy(val){

  switch(val[0]){
    case 'z': // shorthand line to start
    case 'Z':
      val[0] = 'L';
      val[1] = this.start[0];
      val[2] = this.start[1];
      break
    case 'H': // shorthand horizontal line
      val[0] = 'L';
      val[2] = this.pos[1];
      break
    case 'V': // shorthand vertical line
      val[0] = 'L';
      val[2] = val[1];
      val[1] = this.pos[0];
      break
    case 'T': // shorthand quadratic beziere
      val[0] = 'Q';
      val[3] = val[1];
      val[4] = val[2];
      val[1] = this.reflection[1];
      val[2] = this.reflection[0];
      break
    case 'S': // shorthand cubic beziere
      val[0] = 'C';
      val[6] = val[4];
      val[5] = val[3];
      val[4] = val[2];
      val[3] = val[1];
      val[2] = this.reflection[1];
      val[1] = this.reflection[0];
      break
  }

  return val

}

// updates reflection point and current position
function setPosAndReflection(val){

  var len = val.length;

  this.pos = [ val[len-2], val[len-1] ];

  if('SCQT'.indexOf(val[0]) != -1)
    this.reflection = [ 2 * this.pos[0] - val[len-4], 2 * this.pos[1] - val[len-3] ];

  return val
}

// converts all types to cubic beziere
function toBeziere(val){
  var retVal = [val];

  switch(val[0]){
    case 'M': // special handling for M
      this.pos = this.start = [val[1], val[2]];
      return retVal
    case 'L':
      val[5] = val[3] = val[1];
      val[6] = val[4] = val[2];
      val[1] = this.pos[0];
      val[2] = this.pos[1];
      break
    case 'Q':
      val[6] = val[4];
      val[5] = val[3];
      val[4] = val[4] * 1/3 + val[2] * 2/3;
      val[3] = val[3] * 1/3 + val[1] * 2/3;
      val[2] = this.pos[1] * 1/3 + val[2] * 2/3;
      val[1] = this.pos[0] * 1/3 + val[1] * 2/3;
      break
    case 'A':
      retVal = arcToBeziere(this.pos, val);
      val = retVal[0];
      break
  }

  val[0] = 'C';
  this.pos = [val[5], val[6]];
  this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];

  return retVal

}

// finds the next position of type M
function findNextM(arr, offset){

  if(offset === false) return false

  for(var i = offset, len = arr.length;i < len;++i){

    if(arr[i][0] == 'M') return i

  }

  return false
}



// Convert an arc segment into equivalent cubic Bezier curves
// Depending on the arc, up to 4 curves might be used to represent it since a
// curve gives a good approximation for only a quarter of an ellipse
// The curves are returned as an array of SVG curve commands:
// [ ['C', x1, y1, x2, y2, x, y] ... ]
function arcToBeziere(pos, val) {
    // Parameters extraction, handle out-of-range parameters as specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters
    var rx = Math.abs(val[1]), ry = Math.abs(val[2]), xAxisRotation = val[3] % 360
      , largeArcFlag = val[4], sweepFlag = val[5], x = val[6], y = val[7]
      , A = new SVG.Point(pos), B = new SVG.Point(x, y)
      , primedCoord, lambda, mat, k, c, cSquare, t, O, OA, OB, tetaStart, tetaEnd
      , deltaTeta, nbSectors, f, arcSegPoints, angle, sinAngle, cosAngle, pt, i, il
      , retVal = [], x1, y1, x2, y2;

    // Ensure radii are non-zero
    if(rx === 0 || ry === 0 || (A.x === B.x && A.y === B.y)) {
      // treat this arc as a straight line segment
      return [['C', A.x, A.y, B.x, B.y, B.x, B.y]]
    }

    // Ensure radii are large enough using the algorithm provided in the SVG spec
    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii
    primedCoord = new SVG.Point((A.x-B.x)/2, (A.y-B.y)/2).transform(new SVG.Matrix().rotate(xAxisRotation));
    lambda = (primedCoord.x * primedCoord.x) / (rx * rx) + (primedCoord.y * primedCoord.y) / (ry * ry);
    if(lambda > 1) {
      lambda = Math.sqrt(lambda);
      rx = lambda*rx;
      ry = lambda*ry;
    }

    // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse
    mat = new SVG.Matrix().rotate(xAxisRotation).scale(1/rx, 1/ry).rotate(-xAxisRotation);
    A = A.transform(mat);
    B = B.transform(mat);

    // Calculate the horizontal and vertical distance between the initial and final point of the arc
    k = [B.x-A.x, B.y-A.y];

    // Find the length of the chord formed by A and B
    cSquare = k[0]*k[0] + k[1]*k[1];
    c = Math.sqrt(cSquare);

    // Calculate the ratios of the horizontal and vertical distance on the length of the chord
    k[0] /= c;
    k[1] /= c;

    // Calculate the distance between the circle center and the chord midpoint
    // using this formula: t = sqrt(r^2 - c^2 / 4)
    // where t is the distance between the cirle center and the chord midpoint,
    //       r is the rayon of the circle and c is the chord length
    // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php
    // Because of the imprecision of floating point numbers, cSquare might end
    // up being slightly above 4 which would result in a negative radicand
    // To prevent that, a test is made before computing the square root
    t = (cSquare < 4) ? Math.sqrt(1 - cSquare/4) : 0;

    // For most situations, there are actually two different ellipses that
    // satisfy the constraints imposed by the points A and B, the radii rx and ry,
    // and the xAxisRotation
    // When the flags largeArcFlag and sweepFlag are equal, it means that the
    // second ellipse is used as a solution
    // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
    if(largeArcFlag === sweepFlag) {
        t *= -1;
    }

    // Calculate the coordinates of the center of the circle from the midpoint of the chord
    // This is done by multiplying the ratios calculated previously by the distance between
    // the circle center and the chord midpoint and using these values to go from the midpoint
    // to the center of the circle
    // The negative of the vertical distance ratio is used to modify the x coordinate while
    // the horizontal distance ratio is used to modify the y coordinate
    // That is because the center of the circle is perpendicular to the chord and perpendicular
    // lines are negative reciprocals
    O = new SVG.Point((B.x+A.x)/2 + t*-k[1], (B.y+A.y)/2 + t*k[0]);
    // Move the center of the circle at the origin
    OA = new SVG.Point(A.x-O.x, A.y-O.y);
    OB = new SVG.Point(B.x-O.x, B.y-O.y);

    // Calculate the start and end angle
    tetaStart = Math.acos(OA.x/Math.sqrt(OA.x*OA.x + OA.y*OA.y));
    if (OA.y < 0) {
      tetaStart *= -1;
    }
    tetaEnd = Math.acos(OB.x/Math.sqrt(OB.x*OB.x + OB.y*OB.y));
    if (OB.y < 0) {
      tetaEnd *= -1;
    }

    // If sweep-flag is '1', then the arc will be drawn in a "positive-angle" direction,
    // make sure that the end angle is above the start angle
    if (sweepFlag && tetaStart > tetaEnd) {
      tetaEnd += 2*Math.PI;
    }
    // If sweep-flag is '0', then the arc will be drawn in a "negative-angle" direction,
    // make sure that the end angle is below the start angle
    if (!sweepFlag && tetaStart < tetaEnd) {
      tetaEnd -= 2*Math.PI;
    }

    // Find the number of Bezier curves that are required to represent the arc
    // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle
    nbSectors = Math.ceil(Math.abs(tetaStart-tetaEnd) * 2/Math.PI);

    // Calculate the coordinates of the points of all the Bezier curves required to represent the arc
    // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic
    arcSegPoints = [];
    angle = tetaStart;
    deltaTeta = (tetaEnd-tetaStart)/nbSectors;
    f = 4*Math.tan(deltaTeta/4)/3;
    for (i = 0; i <= nbSectors; i++) { // The <= is because a Bezier curve have a start and a endpoint
      cosAngle = Math.cos(angle);
      sinAngle = Math.sin(angle);

      pt = new SVG.Point(O.x+cosAngle, O.y+sinAngle);
      arcSegPoints[i] = [new SVG.Point(pt.x+f*sinAngle, pt.y-f*cosAngle), pt, new SVG.Point(pt.x-f*sinAngle, pt.y+f*cosAngle)];

      angle += deltaTeta;
    }

    // Remove the first control point of the first segment point and remove the second control point of the last segment point
    // These two control points are not used in the approximation of the arc, that is why they are removed
    arcSegPoints[0][0] = arcSegPoints[0][1].clone();
    arcSegPoints[arcSegPoints.length-1][2] = arcSegPoints[arcSegPoints.length-1][1].clone();

    // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse
    mat = new SVG.Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);
    for (i = 0, il = arcSegPoints.length; i < il; i++) {
      arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);
      arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);
      arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);
    }


    // Convert the segments points to SVG curve commands
    for (i = 1, il = arcSegPoints.length; i < il; i++) {
      pt = arcSegPoints[i-1][2];
      x1 = pt.x;
      y1 = pt.y;

      pt = arcSegPoints[i][0];
      x2 = pt.x;
      y2 = pt.y;

      pt = arcSegPoints[i][1];
      x = pt.x;
      y = pt.y;

      retVal.push(['C', x1, y1, x2, y2, x, y]);
    }

    return retVal
}
}());

/*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */
(function() {

  // creates handler, saves it
  function DragHandler(el){
    el.remember('_draggable', this);
    this.el = el;
  }


  // Sets new parameter, starts dragging
  DragHandler.prototype.init = function(constraint, val){
    var _this = this;
    this.constraint = constraint;
    this.value = val;
    this.el.on('mousedown.drag', function(e){ _this.start(e); });
    this.el.on('touchstart.drag', function(e){ _this.start(e); });
  };

  // transforms one point from screen to user coords
  DragHandler.prototype.transformPoint = function(event, offset){
      event = event || window.event;
      var touches = event.changedTouches && event.changedTouches[0] || event;
      this.p.x = touches.clientX - (offset || 0);
      this.p.y = touches.clientY;
      return this.p.matrixTransform(this.m)
  };

  // gets elements bounding box with special handling of groups, nested and use
  DragHandler.prototype.getBBox = function(){

    var box = this.el.bbox();

    if(this.el instanceof SVG.Nested) box = this.el.rbox();

    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {
      box.x = this.el.x();
      box.y = this.el.y();
    }

    return box
  };

  // start dragging
  DragHandler.prototype.start = function(e){

    // check for left button
    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){
      if((e.which || e.buttons) != 1){
          return
      }
    }

    var _this = this;

    // fire beforedrag event
    this.el.fire('beforedrag', { event: e, handler: this });
    if(this.el.event().defaultPrevented) return;

    // prevent browser drag behavior as soon as possible
    e.preventDefault();

    // prevent propagation to a parent that might also have dragging enabled
    e.stopPropagation();

    // search for parent on the fly to make sure we can call
    // draggable() even when element is not in the dom currently
    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc);
    this.p = this.parent.node.createSVGPoint();

    // save current transformation matrix
    this.m = this.el.node.getScreenCTM().inverse();

    var box = this.getBBox();

    var anchorOffset;

    // fix text-anchor in text-element (#37)
    if(this.el instanceof SVG.Text){
      anchorOffset = this.el.node.getComputedTextLength();

      switch(this.el.attr('text-anchor')){
        case 'middle':
          anchorOffset /= 2;
          break
        case 'start':
          anchorOffset = 0;
          break;
      }
    }

    this.startPoints = {
      // We take absolute coordinates since we are just using a delta here
      point: this.transformPoint(e, anchorOffset),
      box:   box,
      transform: this.el.transform()
    };

    // add drag and end events to window
    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e); });
    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e); });
    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e); });
    SVG.on(window, 'touchend.drag', function(e){ _this.end(e); });

    // fire dragstart event
    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this});
  };

  // while dragging
  DragHandler.prototype.drag = function(e){

    var box = this.getBBox()
      , p   = this.transformPoint(e)
      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x
      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y
      , c   = this.constraint
      , gx  = p.x - this.startPoints.point.x
      , gy  = p.y - this.startPoints.point.y;

    this.el.fire('dragmove', {
        event: e
      , p: p
      , m: this.m
      , handler: this
    });

    if(this.el.event().defaultPrevented) return p

    // move the element to its new position, if possible by constraint
    if (typeof c == 'function') {

      var coord = c.call(this.el, x, y, this.m);

      // bool, just show us if movement is allowed or not
      if (typeof coord == 'boolean') {
        coord = {
          x: coord,
          y: coord
        };
      }

      // if true, we just move. If !false its a number and we move it there
      if (coord.x === true) {
        this.el.x(x);
      } else if (coord.x !== false) {
        this.el.x(coord.x);
      }

      if (coord.y === true) {
        this.el.y(y);
      } else if (coord.y !== false) {
        this.el.y(coord.y);
      }

    } else if (typeof c == 'object') {

      // keep element within constrained box
      if (c.minX != null && x < c.minX) {
        x = c.minX;
        gx = x - this.startPoints.box.x;
      } else if (c.maxX != null && x > c.maxX - box.width) {
        x = c.maxX - box.width;
        gx = x - this.startPoints.box.x;
      } if (c.minY != null && y < c.minY) {
        y = c.minY;
        gy = y - this.startPoints.box.y;
      } else if (c.maxY != null && y > c.maxY - box.height) {
        y = c.maxY - box.height;
        gy = y - this.startPoints.box.y;
      }

      if (c.snapToGrid != null) {
        x = x - (x % c.snapToGrid);
        y = y - (y % c.snapToGrid);
        gx = gx - (gx % c.snapToGrid);
        gy = gy - (gy % c.snapToGrid);
      }

      if(this.el instanceof SVG.G)
        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true);
      else
        this.el.move(x, y);
    }

    // so we can use it in the end-method, too
    return p
  };

  DragHandler.prototype.end = function(e){

    // final drag
    var p = this.drag(e);

    // fire dragend event
    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this });

    // unbind events
    SVG.off(window, 'mousemove.drag');
    SVG.off(window, 'touchmove.drag');
    SVG.off(window, 'mouseup.drag');
    SVG.off(window, 'touchend.drag');

  };

  SVG.extend(SVG.Element, {
    // Make element draggable
    // Constraint might be an object (as described in readme.md) or a function in the form "function (x, y)" that gets called before every move.
    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. "False" skips moving, true moves to raw x, y.
    draggable: function(value, constraint) {

      // Check the parameters and reassign if needed
      if (typeof value == 'function' || typeof value == 'object') {
        constraint = value;
        value = true;
      }

      var dragHandler = this.remember('_draggable') || new DragHandler(this);

      // When no parameter is given, value is true
      value = typeof value === 'undefined' ? true : value;

      if(value) dragHandler.init(constraint || {}, value);
      else {
        this.off('mousedown.drag');
        this.off('touchstart.drag');
      }

      return this
    }

  });

}).call(undefined);

(function() {

function SelectHandler(el) {

    this.el = el;
    el.remember('_selectHandler', this);
    this.pointSelection = {isSelected: false};
    this.rectSelection = {isSelected: false};

}

SelectHandler.prototype.init = function (value, options) {

    var bbox = this.el.bbox();
    this.options = {};

    // Merging the defaults and the options-object together
    for (var i in this.el.selectize.defaults) {
        this.options[i] = this.el.selectize.defaults[i];
        if (options[i] !== undefined) {
            this.options[i] = options[i];
        }
    }

    this.parent = this.el.parent();
    this.nested = (this.nested || this.parent.group());
    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));

    // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving
    if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {
        this.selectPoints(value);
    } else {
        this.selectRect(value);
    }

    this.observe();
    this.cleanup();

};

SelectHandler.prototype.selectPoints = function (value) {

    this.pointSelection.isSelected = value;

    // When set is already there we dont have to create one
    if (this.pointSelection.set) {
        return this;
    }

    // Create our set of elements
    this.pointSelection.set = this.parent.set();
    // draw the circles and mark the element as selected
    this.drawCircles();

    return this;

};

// create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon
SelectHandler.prototype.getPointArray = function () {
    var bbox = this.el.bbox();

    return this.el.array().valueOf().map(function (el) {
        return [el[0] - bbox.x, el[1] - bbox.y];
    });
};

// The function to draw the circles
SelectHandler.prototype.drawCircles = function () {

    var _this = this, array = this.getPointArray();

    // go through the array of points
    for (var i = 0, len = array.length; i < len; ++i) {

        var curriedEvent = (function (k) {
            return function (ev) {
                ev = ev || window.event;
                ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
                ev.stopPropagation();

                var x = ev.pageX || ev.touches[0].pageX;
                var y = ev.pageY || ev.touches[0].pageY;
                _this.el.fire('point', {x: x, y: y, i: k, event: ev});
            };
        })(i);

        // add every point to the set
        this.pointSelection.set.add(
            // a circle with our css-classes and a touchstart-event which fires our event for moving points
            this.nested.circle(this.options.radius)
                .center(array[i][0], array[i][1])
                .addClass(this.options.classPoints)
                .addClass(this.options.classPoints + '_point')
                .on('touchstart', curriedEvent)
                .on('mousedown', curriedEvent)
        );
    }

};

// every time a circle is moved, we have to update the positions of our circle
SelectHandler.prototype.updatePointSelection = function () {
    var array = this.getPointArray();

    this.pointSelection.set.each(function (i) {
        if (this.cx() === array[i][0] && this.cy() === array[i][1]) {
            return;
        }
        this.center(array[i][0], array[i][1]);
    });
};

SelectHandler.prototype.updateRectSelection = function () {
    var bbox = this.el.bbox();

    this.rectSelection.set.get(0).attr({
        width: bbox.width,
        height: bbox.height
    });

    // set.get(1) is always in the upper left corner. no need to move it
    if (this.options.points) {
        this.rectSelection.set.get(2).center(bbox.width, 0);
        this.rectSelection.set.get(3).center(bbox.width, bbox.height);
        this.rectSelection.set.get(4).center(0, bbox.height);

        this.rectSelection.set.get(5).center(bbox.width / 2, 0);
        this.rectSelection.set.get(6).center(bbox.width, bbox.height / 2);
        this.rectSelection.set.get(7).center(bbox.width / 2, bbox.height);
        this.rectSelection.set.get(8).center(0, bbox.height / 2);
    }

    if (this.options.rotationPoint) {
        if (this.options.points) {
            this.rectSelection.set.get(9).center(bbox.width / 2, 20);
        } else {
            this.rectSelection.set.get(1).center(bbox.width / 2, 20);
        }
    }
};

SelectHandler.prototype.selectRect = function (value) {

    var _this = this, bbox = this.el.bbox();

    this.rectSelection.isSelected = value;

    // when set is already p
    this.rectSelection.set = this.rectSelection.set || this.parent.set();

    // helperFunction to create a mouse-down function which triggers the event specified in `eventName`
    function getMoseDownFunc(eventName) {
        return function (ev) {
            ev = ev || window.event;
            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
            ev.stopPropagation();

            var x = ev.pageX || ev.touches[0].pageX;
            var y = ev.pageY || ev.touches[0].pageY;
            _this.el.fire(eventName, {x: x, y: y, event: ev});
        };
    }

    // create the selection-rectangle and add the css-class
    if (!this.rectSelection.set.get(0)) {
        this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));
    }

    // Draw Points at the edges, if enabled
    if (this.options.points && !this.rectSelection.set.get(1)) {
        var ename ="touchstart", mname = "mousedown";
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', this.options.classPoints + '_lt').on(mname, getMoseDownFunc('lt')).on(ename, getMoseDownFunc('lt')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, 0).attr('class', this.options.classPoints + '_rt').on(mname, getMoseDownFunc('rt')).on(ename, getMoseDownFunc('rt')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height).attr('class', this.options.classPoints + '_rb').on(mname, getMoseDownFunc('rb')).on(ename, getMoseDownFunc('rb')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height).attr('class', this.options.classPoints + '_lb').on(mname, getMoseDownFunc('lb')).on(ename, getMoseDownFunc('lb')));

        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 0).attr('class', this.options.classPoints + '_t').on(mname, getMoseDownFunc('t')).on(ename, getMoseDownFunc('t')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height / 2).attr('class', this.options.classPoints + '_r').on(mname, getMoseDownFunc('r')).on(ename, getMoseDownFunc('r')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, bbox.height).attr('class', this.options.classPoints + '_b').on(mname, getMoseDownFunc('b')).on(ename, getMoseDownFunc('b')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height / 2).attr('class', this.options.classPoints + '_l').on(mname, getMoseDownFunc('l')).on(ename, getMoseDownFunc('l')));

        this.rectSelection.set.each(function () {
            this.addClass(_this.options.classPoints);
        });
    }

    // draw rotationPint, if enabled
    if (this.options.rotationPoint && ((this.options.points && !this.rectSelection.set.get(9)) || (!this.options.points && !this.rectSelection.set.get(1)))) {

        var curriedEvent = function (ev) {
            ev = ev || window.event;
            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
            ev.stopPropagation();

            var x = ev.pageX || ev.touches[0].pageX;
            var y = ev.pageY || ev.touches[0].pageY;
            _this.el.fire('rot', {x: x, y: y, event: ev});
        };
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 20).attr('class', this.options.classPoints + '_rot')
            .on("touchstart", curriedEvent).on("mousedown", curriedEvent));

    }

};

SelectHandler.prototype.handler = function () {

    var bbox = this.el.bbox();
    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));

    if (this.rectSelection.isSelected) {
        this.updateRectSelection();
    }

    if (this.pointSelection.isSelected) {
        this.updatePointSelection();
    }

};

SelectHandler.prototype.observe = function () {
    var _this = this;

    if (MutationObserver) {
        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {
            this.observerInst = this.observerInst || new MutationObserver(function () {
                _this.handler();
            });
            this.observerInst.observe(this.el.node, {attributes: true});
        } else {
            try {
                this.observerInst.disconnect();
                delete this.observerInst;
            } catch (e) {
            }
        }
    } else {
        this.el.off('DOMAttrModified.select');

        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {
            this.el.on('DOMAttrModified.select', function () {
                _this.handler();
            });
        }
    }
};

SelectHandler.prototype.cleanup = function () {

    //var _this = this;

    if (!this.rectSelection.isSelected && this.rectSelection.set) {
        // stop watching the element, remove the selection
        this.rectSelection.set.each(function () {
            this.remove();
        });

        this.rectSelection.set.clear();
        delete this.rectSelection.set;
    }

    if (!this.pointSelection.isSelected && this.pointSelection.set) {
        // Remove all points, clear the set, stop watching the element
        this.pointSelection.set.each(function () {
            this.remove();
        });

        this.pointSelection.set.clear();
        delete this.pointSelection.set;
    }

    if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {
        this.nested.remove();
        delete this.nested;

    }
};


SVG.extend(SVG.Element, {
    // Select element with mouse
    selectize: function (value, options) {

        // Check the parameters and reassign if needed
        if (typeof value === 'object') {
            options = value;
            value = true;
        }

        var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);

        selectHandler.init(value === undefined ? true : value, options || {});

        return this;

    }
});

SVG.Element.prototype.selectize.defaults = {
    points: true,                            // If true, points at the edges are drawn. Needed for resize!
    classRect: 'svg_select_boundingRect',    // Css-class added to the rect
    classPoints: 'svg_select_points',        // Css-class added to the points
    radius: 7,                               // radius of the points
    rotationPoint: true,                     // If true, rotation point is drawn. Needed for rotation!
    deepSelect: false                        // If true, moving of single points is possible (only line, polyline, polyon)
};
}());

(function() {
(function () {

    function ResizeHandler(el) {

        el.remember('_resizeHandler', this);

        this.el = el;
        this.parameters = {};
        this.lastUpdateCall = null;
        this.p = el.doc().node.createSVGPoint();
    }

    ResizeHandler.prototype.transformPoint = function(x, y, m){

        this.p.x = x - (this.offset.x - window.pageXOffset);
        this.p.y = y - (this.offset.y - window.pageYOffset);

        return this.p.matrixTransform(m || this.m);

    };

    ResizeHandler.prototype._extractPosition = function(event) {
        // Extract a position from a mouse/touch event.
        // Returns { x: .., y: .. }
        return {
            x: event.clientX != null ? event.clientX : event.touches[0].clientX,
            y: event.clientY != null ? event.clientY : event.touches[0].clientY
        }
    };

    ResizeHandler.prototype.init = function (options) {

        var _this = this;

        this.stop();

        if (options === 'stop') {
            return;
        }

        this.options = {};

        // Merge options and defaults
        for (var i in this.el.resize.defaults) {
            this.options[i] = this.el.resize.defaults[i];
            if (typeof options[i] !== 'undefined') {
                this.options[i] = options[i];
            }
        }

        // We listen to all these events which are specifying different edges
        this.el.on('lt.resize', function(e){ _this.resize(e || window.event); });  // Left-Top
        this.el.on('rt.resize', function(e){ _this.resize(e || window.event); });  // Right-Top
        this.el.on('rb.resize', function(e){ _this.resize(e || window.event); });  // Right-Bottom
        this.el.on('lb.resize', function(e){ _this.resize(e || window.event); });  // Left-Bottom

        this.el.on('t.resize', function(e){ _this.resize(e || window.event); });   // Top
        this.el.on('r.resize', function(e){ _this.resize(e || window.event); });   // Right
        this.el.on('b.resize', function(e){ _this.resize(e || window.event); });   // Bottom
        this.el.on('l.resize', function(e){ _this.resize(e || window.event); });   // Left

        this.el.on('rot.resize', function(e){ _this.resize(e || window.event); }); // Rotation

        this.el.on('point.resize', function(e){ _this.resize(e || window.event); }); // Point-Moving

        // This call ensures, that the plugin reacts to a change of snapToGrid immediately
        this.update();

    };

    ResizeHandler.prototype.stop = function(){
        this.el.off('lt.resize');
        this.el.off('rt.resize');
        this.el.off('rb.resize');
        this.el.off('lb.resize');

        this.el.off('t.resize');
        this.el.off('r.resize');
        this.el.off('b.resize');
        this.el.off('l.resize');

        this.el.off('rot.resize');

        this.el.off('point.resize');

        return this;
    };

    ResizeHandler.prototype.resize = function (event) {

        var _this = this;

        this.m = this.el.node.getScreenCTM().inverse();
        this.offset = { x: window.pageXOffset, y: window.pageYOffset };

        var txPt = this._extractPosition(event.detail.event);
        this.parameters = {
            type: this.el.type, // the type of element
            p: this.transformPoint(txPt.x, txPt.y),
            x: event.detail.x,      // x-position of the mouse when resizing started
            y: event.detail.y,      // y-position of the mouse when resizing started
            box: this.el.bbox(),    // The bounding-box of the element
            rotation: this.el.transform().rotation  // The current rotation of the element
        };

        // Add font-size parameter if the element type is text
        if (this.el.type === "text") {
            this.parameters.fontSize = this.el.attr()["font-size"];
        }

        // the i-param in the event holds the index of the point which is moved, when using `deepSelect`
        if (event.detail.i !== undefined) {

            // get the point array
            var array = this.el.array().valueOf();

            // Save the index and the point which is moved
            this.parameters.i = event.detail.i;
            this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];
        }

        // Lets check which edge of the bounding-box was clicked and resize the this.el according to this
        switch (event.type) {

            // Left-Top-Edge
            case 'lt':
                // We build a calculating function for every case which gives us the new position of the this.el
                this.calc = function (diffX, diffY) {
                    // The procedure is always the same
                    // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)
                    var snap = this.snapToGrid(diffX, diffY);

                    // Now we check if the new height and width still valid (> 0)
                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                        // ...if valid, we resize the this.el (which can include moving because the coord-system starts at the left-top and this edge is moving sometimes when resized)

                        /*
                         * but first check if the element is text box, so we can change the font size instead of
                         * the width and height
                         */

                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize - snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1]).size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right-Top
            case 'rt':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);
                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize + snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap, true);

                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right-Bottom
            case 'rb':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize + snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Left-Bottom
            case 'lb':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1);
                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize - snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap, true);

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Top
            case 't':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);
                    if (this.parameters.box.height - snap[1] > 0) {
                        // Disable the font-resizing if it is not from the corner of bounding-box
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).height(this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right
            case 'r':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.width + snap[0] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + snap[0]);
                    }
                };
                break;

            // Bottom
            case 'b':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Left
            case 'l':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1);
                    if (this.parameters.box.width - snap[0] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).width(this.parameters.box.width - snap[0]);
                    }
                };
                break;

            // Rotation
            case 'rot':
                // s.a.
                this.calc = function (diffX, diffY) {

                    // yes this is kinda stupid but we need the mouse coords back...
                    var current = {x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y};

                    // start minus middle
                    var sAngle = Math.atan2((this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2), (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2));

                    // end minus middle
                    var pAngle = Math.atan2((current.y - this.parameters.box.y - this.parameters.box.height / 2), (current.x - this.parameters.box.x - this.parameters.box.width / 2));

                    var angle = this.parameters.rotation + (pAngle - sAngle) * 180 / Math.PI + this.options.snapToAngle / 2;

                    // We have to move the element to the center of the box first and change the rotation afterwards
                    // because rotation always works around a rotation-center, which is changed when moving the element
                    // We also set the new rotation center to the center of the box.
                    this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(angle - (angle % this.options.snapToAngle), this.parameters.box.cx, this.parameters.box.cy);
                };
                break;

            // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)
            case 'point':
                this.calc = function (diffX, diffY) {

                    // Snapping the point to the grid
                    var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);

                    // Get the point array
                    var array = this.el.array().valueOf();

                    // Changing the moved point in the array
                    array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];
                    array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];

                    // And plot the new this.el
                    this.el.plot(array);
                };
        }

        this.el.fire('resizestart', {dx: this.parameters.x, dy: this.parameters.y, event: event});
        // When resizing started, we have to register events for...
        // Touches.
        SVG.on(window, 'touchmove.resize', function(e) {
            _this.update(e || window.event);
        });
        SVG.on(window, 'touchend.resize', function() {
            _this.done();
        });
        // Mouse.
        SVG.on(window, 'mousemove.resize', function (e) {
            _this.update(e || window.event);
        });
        SVG.on(window, 'mouseup.resize', function () {
            _this.done();
        });

    };

    // The update-function redraws the element every time the mouse is moving
    ResizeHandler.prototype.update = function (event) {

        if (!event) {
            if (this.lastUpdateCall) {
                this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
            }
            return;
        }

        // Calculate the difference between the mouseposition at start and now
        var txPt = this._extractPosition(event);
        var p = this.transformPoint(txPt.x, txPt.y);

        var diffX = p.x - this.parameters.p.x,
            diffY = p.y - this.parameters.p.y;

        this.lastUpdateCall = [diffX, diffY];

        // Calculate the new position and height / width of the element
        this.calc(diffX, diffY);

       // Emit an event to say we have changed.
        this.el.fire('resizing', {dx: diffX, dy: diffY, event: event});
    };

    // Is called on mouseup.
    // Removes the update-function from the mousemove event
    ResizeHandler.prototype.done = function () {
        this.lastUpdateCall = null;
        SVG.off(window, 'mousemove.resize');
        SVG.off(window, 'mouseup.resize');
        SVG.off(window, 'touchmove.resize');
        SVG.off(window, 'touchend.resize');
        this.el.fire('resizedone');
    };

    // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)
    // In this cases the temp-values are calculated differently
    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {

        var temp;

        // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value
        if (typeof pointCoordsY !== 'undefined') {
            // Note that flag = pointCoordsX in this case
            temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];
        } else {
            // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)
            flag = flag == null ? 1 | 1 << 1 : flag;
            temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid];
        }

        if(diffX < 0) {
            temp[0] -= this.options.snapToGrid;
        }
        if(diffY < 0) {
            temp[1] -= this.options.snapToGrid;
        }

        diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2 ?
                  temp[0] :
                  temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));
        diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2 ?
                  temp[1] :
                  temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));

        return this.constraintToBox(diffX, diffY, flag, pointCoordsY);

    };

    // keep element within constrained box
    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {
        //return [diffX, diffY]
        var c = this.options.constraint || {};
        var orgX, orgY;

        if (typeof pointCoordsY !== 'undefined') {
          orgX = flag;
          orgY = pointCoordsY;
        } else {
          orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);
          orgY = this.parameters.box.y + (flag & (1<<1) ? 0 : this.parameters.box.height);
        }

        if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {
          diffX = c.minX - orgX;
        }

        if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {
          diffX = c.maxX - orgX;
        }

        if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {
          diffY = c.minY - orgY;
        }

        if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {
          diffY = c.maxY - orgY;
        }

        return [diffX, diffY];
    };

    ResizeHandler.prototype.checkAspectRatio = function (snap, isReverse) {
        if (!this.options.saveAspectRatio) {
            return snap;
        }

        var updatedSnap = snap.slice();
        var aspectRatio = this.parameters.box.width / this.parameters.box.height;
        var newW = this.parameters.box.width + snap[0];
        var newH = this.parameters.box.height - snap[1];
        var newAspectRatio = newW / newH;

        if (newAspectRatio < aspectRatio) {
            // Height is too big. Adapt it
            updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;
            isReverse && (updatedSnap[1] = -updatedSnap[1]);
        } else if (newAspectRatio > aspectRatio) {
            // Width is too big. Adapt it
            updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;
            isReverse && (updatedSnap[0] = -updatedSnap[0]);
        }

        return updatedSnap;
    };

    SVG.extend(SVG.Element, {
        // Resize element with mouse
        resize: function (options) {

            (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});

            return this;

        }

    });

    SVG.Element.prototype.resize.defaults = {
        snapToAngle: 0.1,       // Specifies the speed the rotation is happening when moving the mouse
        snapToGrid: 1,          // Snaps to a grid of `snapToGrid` Pixels
        constraint: {},         // keep element within constrained box
        saveAspectRatio: false  // Save aspect ratio when resizing using lt, rt, rb or lb points
    };

}).call(this);
}());

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n.apexcharts-canvas.dark {\n  background: #343F57;\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-gridline, .apexcharts-text {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n.apexcharts-tooltip.light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n.apexcharts-tooltip.dark {\n  color: #fff;\n  background: rgba(30,30,30, 0.8);\n}\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n.apexcharts-tooltip.light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n.apexcharts-tooltip.dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value, \n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n.apexcharts-tooltip-series-group.active, .apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n.apexcharts-tooltip-candlestick > div {\n  margin: 4px 0;\n}\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n\tbackground: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\n\tleft: 50%;\n\tborder: solid transparent;\n\tcontent: \" \";\n\theight: 0;\n\twidth: 0;\n\tposition: absolute;\n\tpointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n\tborder-color: rgba(236, 239, 241, 0);\n\tborder-width: 6px;\n\tmargin-left: -6px;\n}\n.apexcharts-xaxistooltip:before {\n\tborder-color: rgba(144, 164, 174, 0);\n\tborder-width: 7px;\n\tmargin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-bottom.dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color:#ECEFF1\n}\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n.apexcharts-xaxistooltip-top.dark:after {\n  border-top-color:rgba(0, 0, 0, 0.5);\n}\n.apexcharts-xaxistooltip-top.dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n\n.apexcharts-xaxistooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n\tbackground: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\n\ttop: 50%;\n\tborder: solid transparent;\n\tcontent: \" \";\n\theight: 0;\n\twidth: 0;\n\tposition: absolute;\n\tpointer-events: none;\n}\n.apexcharts-yaxistooltip:after {\n\tborder-color: rgba(236, 239, 241, 0);\n\tborder-width: 6px;\n\tmargin-top: -6px;\n}\n.apexcharts-yaxistooltip:before {\n\tborder-color: rgba(144, 164, 174, 0);\n\tborder-width: 7px;\n\tmargin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-left.dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-left.dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n.apexcharts-yaxistooltip-right.dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n.apexcharts-yaxistooltip-right.dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.active {\n  opacity: 1;\n}\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.active, .apexcharts-ycrosshairs.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-zoom-rect {\n  pointer-events: none;\n}\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_points, .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n.svg_select_points_l, .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n  fill: #888;\n}\n.apexcharts-canvas.zoomable .hovering-zoom {\n  cursor: crosshair\n}\n.apexcharts-canvas.zoomable .hovering-pan {\n  cursor: move\n}\n\n.apexcharts-xaxis,\n.apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.apexcharts-zoom-icon, \n.apexcharts-zoom-in-icon,\n.apexcharts-zoom-out-icon,\n.apexcharts-reset-zoom-icon, \n.apexcharts-pan-icon, \n.apexcharts-selection-icon,\n.apexcharts-menu-icon, \n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n\n.apexcharts-zoom-icon svg, \n.apexcharts-zoom-in-icon svg,\n.apexcharts-zoom-out-icon svg,\n.apexcharts-reset-zoom-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.dark .apexcharts-zoom-icon svg, \n.dark .apexcharts-zoom-in-icon svg,\n.dark .apexcharts-zoom-out-icon svg,\n.dark .apexcharts-reset-zoom-icon svg, \n.dark .apexcharts-pan-icon svg, \n.dark .apexcharts-selection-icon svg,\n.dark .apexcharts-menu-icon svg, \n.dark .apexcharts-toolbar-custom-icon svg{\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.selected svg, \n.apexcharts-canvas .apexcharts-selection-icon.selected svg, \n.apexcharts-canvas .apexcharts-reset-zoom-icon.selected svg {\n  fill: #008FFB;\n}\n.light .apexcharts-selection-icon:not(.selected):hover svg,\n.light .apexcharts-zoom-icon:not(.selected):hover svg, \n.light .apexcharts-zoom-in-icon:hover svg, \n.light .apexcharts-zoom-out-icon:hover svg, \n.light .apexcharts-reset-zoom-icon:hover svg, \n.light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon, .apexcharts-menu-icon {\n  position: relative;\n}\n.apexcharts-reset-zoom-icon {\n  margin-left: 5px;\n}\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoom-out-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n.apexcharts-pan-icon.selected svg {\n  stroke: #008FFB;\n}\n.apexcharts-pan-icon:not(.selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  top: 0px;\n  right: 3px;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center; \n}\n\n.apexcharts-toolbar svg {\n  pointer-events: none;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n.light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n.dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-toolbar {\n    /*opacity: 0;*/\n  }\n\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  } \n}\n\n.apexcharts-datalabel.hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}";
styleInject(css);

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.2.20171210
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */
if ("document" in self) {
  // Full polyfill for browsers with no classList support
  // Including IE < Edge missing SVGElement.classList
  if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
    (function (view) {

      if (!('Element' in view)) return;

      var classListProp = "classList",
          protoProp = "prototype",
          elemCtrProto = view.Element[protoProp],
          objCtr = Object,
          strTrim = String[protoProp].trim || function () {
        return this.replace(/^\s+|\s+$/g, "");
      },
          arrIndexOf = Array[protoProp].indexOf || function (item) {
        var i = 0,
            len = this.length;

        for (; i < len; i++) {
          if (i in this && this[i] === item) {
            return i;
          }
        }

        return -1;
      } // Vendors: please allow content code to instantiate DOMExceptions
      ,
          DOMEx = function DOMEx(type, message) {
        this.name = type;
        this.code = DOMException[type];
        this.message = message;
      },
          checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
        if (token === "") {
          throw new DOMEx("SYNTAX_ERR", "The token must not be empty.");
        }

        if (/\s/.test(token)) {
          throw new DOMEx("INVALID_CHARACTER_ERR", "The token must not contain space characters.");
        }

        return arrIndexOf.call(classList, token);
      },
          ClassList = function ClassList(elem) {
        var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
            classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
            i = 0,
            len = classes.length;

        for (; i < len; i++) {
          this.push(classes[i]);
        }

        this._updateClassName = function () {
          elem.setAttribute("class", this.toString());
        };
      },
          classListProto = ClassList[protoProp] = [],
          classListGetter = function classListGetter() {
        return new ClassList(this);
      }; // Most DOMException implementations don't allow calling DOMException's toString()
      // on non-DOMExceptions. Error's toString() is sufficient here.


      DOMEx[protoProp] = Error[protoProp];

      classListProto.item = function (i) {
        return this[i] || null;
      };

      classListProto.contains = function (token) {
        return ~checkTokenAndGetIndex(this, token + "");
      };

      classListProto.add = function () {
        var tokens = arguments,
            i = 0,
            l = tokens.length,
            token,
            updated = false;

        do {
          token = tokens[i] + "";

          if (!~checkTokenAndGetIndex(this, token)) {
            this.push(token);
            updated = true;
          }
        } while (++i < l);

        if (updated) {
          this._updateClassName();
        }
      };

      classListProto.remove = function () {
        var tokens = arguments,
            i = 0,
            l = tokens.length,
            token,
            updated = false,
            index;

        do {
          token = tokens[i] + "";
          index = checkTokenAndGetIndex(this, token);

          while (~index) {
            this.splice(index, 1);
            updated = true;
            index = checkTokenAndGetIndex(this, token);
          }
        } while (++i < l);

        if (updated) {
          this._updateClassName();
        }
      };

      classListProto.toggle = function (token, force) {
        var result = this.contains(token),
            method = result ? force !== true && "remove" : force !== false && "add";

        if (method) {
          this[method](token);
        }

        if (force === true || force === false) {
          return force;
        } else {
          return !result;
        }
      };

      classListProto.replace = function (token, replacement_token) {
        var index = checkTokenAndGetIndex(token + "");

        if (~index) {
          this.splice(index, 1, replacement_token);

          this._updateClassName();
        }
      };

      classListProto.toString = function () {
        return this.join(" ");
      };

      if (objCtr.defineProperty) {
        var classListPropDesc = {
          get: classListGetter,
          enumerable: true,
          configurable: true
        };

        try {
          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        } catch (ex) {
          // IE 8 doesn't support enumerable:true
          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
          if (ex.number === undefined || ex.number === -0x7FF5EC54) {
            classListPropDesc.enumerable = false;
            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
          }
        }
      } else if (objCtr[protoProp].__defineGetter__) {
        elemCtrProto.__defineGetter__(classListProp, classListGetter);
      }
    })(self);
  } // There is full or partial native classList support, so just check if we need
  // to normalize the add/remove and toggle APIs.


  (function () {

    var testElement = document.createElement("_");
    testElement.classList.add("c1", "c2"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and
    // classList.remove exist but support only one argument at a time.

    if (!testElement.classList.contains("c2")) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          var i,
              len = arguments.length;

          for (i = 0; i < len; i++) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle("c3", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
    // support the second argument.

    if (testElement.classList.contains("c3")) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        } else {
          return _toggle.call(this, token);
        }
      };
    } // replace() polyfill


    if (!("replace" in document.createElement("_").classList)) {
      DOMTokenList.prototype.replace = function (token, replacement_token) {
        var tokens = this.toString().split(" "),
            index = tokens.indexOf(token + "");

        if (~index) {
          tokens = tokens.slice(index);
          this.remove.apply(this, tokens);
          this.add(replacement_token);
          this.add.apply(this, tokens.slice(1));
        }
      };
    }

    testElement = null;
  })();
}

/**
* Detect Element Resize
*
* https://github.com/sdecima/javascript-detect-element-resize
* Sebastian Decima
*
* version: 0.5.3
**/
(function () {
  var stylesCreated = false;

  function resetTriggers(element) {
    var triggers = element.__resizeTriggers__,
        expand = triggers.firstElementChild,
        contract = triggers.lastElementChild,
        expandChild = expand.firstElementChild;
    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + 'px';
    expandChild.style.height = expand.offsetHeight + 1 + 'px';
    expand.scrollLeft = expand.scrollWidth;
    expand.scrollTop = expand.scrollHeight;
  }

  function checkTriggers(element) {
    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
  }

  function scrollListener(e) {
    var element = this;
    resetTriggers(this);
    if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
    this.__resizeRAF__ = requestFrame(function () {
      if (checkTriggers(element)) {
        element.__resizeLast__.width = element.offsetWidth;
        element.__resizeLast__.height = element.offsetHeight;

        element.__resizeListeners__.forEach(function (fn) {
          fn.call(e);
        });
      }
    });
  }

  function createStyles() {
    if (!stylesCreated) {
      // opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
      var css = (animationKeyframes || '') + '.resize-triggers { ' + (animationStyle || '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');
      style.type = 'text/css';

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }

      head.appendChild(style);
      stylesCreated = true;
    }
  }

  var requestFrame = function () {
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
      return window.setTimeout(fn, 20);
    };

    return function (fn) {
      return raf(fn);
    };
  }();

  var cancelFrame = function () {
    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
    return function (id) {
      return cancel(id);
    };
  }();
  /* Detect CSS Animations support to detect element display/re-attach */


  var animation = false,
      keyframeprefix = '',
      animationstartevent = 'animationstart',
      domPrefixes = 'Webkit Moz O ms'.split(' '),
      startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
      pfx = '';
  {
    var elm = document.createElement('fakeelement');

    if (elm.style.animationName !== undefined) {
      animation = true;
    }

    if (animation === false) {
      for (var i = 0; i < domPrefixes.length; i++) {
        if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
          pfx = domPrefixes[i];
          keyframeprefix = '-' + pfx.toLowerCase() + '-';
          animationstartevent = startEvents[i];
          break;
        }
      }
    }
  }
  var animationName = 'resizeanim';
  var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
  var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';

  window.addResizeListener = function (element, fn) {
    if (!element.__resizeTriggers__) {
      if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
      createStyles();
      element.__resizeLast__ = {};
      element.__resizeListeners__ = [];
      (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
      element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';
      element.appendChild(element.__resizeTriggers__);
      resetTriggers(element);
      element.addEventListener('scroll', scrollListener, true);
      /* Listen for a css animation to detect element display/re-attach */

      animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function (e) {
        if (e.animationName == animationName) {
          resetTriggers(element);
        }
      });
    }

    element.__resizeListeners__.push(fn);
  };

  window.removeResizeListener = function (element, fn) {
    if (element) {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

      if (!element.__resizeListeners__.length) {
        element.removeEventListener('scroll', scrollListener);
        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
      }
    }
  };
})();

window.Apex = {};
/**
 *
 * @module ApexCharts
 **/

var ApexCharts$1 =
/*#__PURE__*/
function () {
  function ApexCharts(el, opts) {
    _classCallCheck(this, ApexCharts);

    this.opts = opts;
    this.ctx = this; // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.

    this.w = new Base(opts).init();
    this.el = el;
    this.w.globals.cuid = (Math.random() + 1).toString(36).substring(4);
    this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid;
    this.eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];
    this.initModules();
    this.create = Utils.bind(this.create, this);
    this.documentEvent = Utils.bind(this.documentEvent, this);
    this.windowResizeHandler = this.windowResize.bind(this);
  }
  /**
   * The primary method user will call to render the chart.
   */


  _createClass(ApexCharts, [{
    key: "render",
    value: function render() {
      var _this = this;

      // main method
      return new Promise$1(function (resolve, reject) {
        // only draw chart, if element found
        if (_this.el !== null) {
          if (typeof Apex._chartInstances === 'undefined') {
            Apex._chartInstances = [];
          }

          if (_this.w.config.chart.id) {
            Apex._chartInstances.push({
              id: _this.w.globals.chartID,
              group: _this.w.config.chart.group,
              chart: _this
            });
          } // set the locale here


          _this.setLocale(_this.w.config.chart.defaultLocale);

          var beforeMount = _this.w.config.chart.events.beforeMount;

          if (typeof beforeMount === 'function') {
            beforeMount(_this, _this.w);
          }

          _this.fireEvent('beforeMount', [_this, _this.w]);

          window.addEventListener('resize', _this.windowResizeHandler);
          window.addResizeListener(_this.el.parentNode, _this.parentResizeCallback.bind(_this));

          var graphData = _this.create(_this.w.config.series, {});

          if (!graphData) return resolve(_this);

          _this.mount(graphData).then(function () {
            resolve(graphData);

            if (typeof _this.w.config.chart.events.mounted === 'function') {
              _this.w.config.chart.events.mounted(_this, _this.w);
            }

            _this.fireEvent('mounted', [_this, _this.w]);
          }).catch(function (e) {
            reject(e); // handle error in case no data or element not found
          });
        } else {
          reject(new Error('Element not found'));
        }
      });
    }
  }, {
    key: "initModules",
    value: function initModules() {
      this.animations = new Animations(this);
      this.core = new Core(this.el, this);
      this.grid = new Grid(this);
      this.coreUtils = new CoreUtils(this);
      this.config = new Config({});
      this.crosshairs = new Crosshairs(this);
      this.options = new Options();
      this.responsive = new Responsive(this);
      this.series = new Series(this);
      this.theme = new Theme(this);
      this.formatters = new Formatters(this);
      this.titleSubtitle = new TitleSubtitle(this);
      this.legend = new Legend(this);
      this.toolbar = new Toolbar(this);
      this.dimensions = new Dimensions(this);
      this.zoomPanSelection = new ZoomPanSelection(this);
      this.w.globals.tooltip = new Tooltip(this);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(name$$1, handler) {
      var w = this.w;

      if (w.globals.events.hasOwnProperty(name$$1)) {
        w.globals.events[name$$1].push(handler);
      } else {
        w.globals.events[name$$1] = [handler];
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(name$$1, handler) {
      var w = this.w;

      if (!w.globals.events.hasOwnProperty(name$$1)) {
        return;
      }

      var index = w.globals.events[name$$1].indexOf(handler);

      if (index !== -1) {
        w.globals.events[name$$1].splice(index, 1);
      }
    }
  }, {
    key: "fireEvent",
    value: function fireEvent(name$$1, args) {
      var w = this.w;

      if (!w.globals.events.hasOwnProperty(name$$1)) {
        return;
      }

      if (!args || !args.length) {
        args = [];
      }

      var evs = w.globals.events[name$$1];
      var l = evs.length;

      for (var i = 0; i < l; i++) {
        evs[i].apply(null, args);
      }
    }
  }, {
    key: "create",
    value: function create(ser, opts) {
      var w = this.w;
      this.initModules();
      var gl = this.w.globals;
      gl.noData = false;
      gl.animationEnded = false;
      this.responsive.checkResponsiveConfig(opts);

      if (this.el === null) {
        gl.animationEnded = true;
        return null;
      }

      this.core.setupElements();

      if (gl.svgWidth === 0) {
        // if the element is hidden, skip drawing
        gl.animationEnded = true;
        return null;
      }

      var combo = CoreUtils.checkComboSeries(ser);
      gl.comboCharts = combo.comboCharts;
      gl.comboChartsHasBars = combo.comboChartsHasBars;

      if (ser.length === 0 || ser.length === 1 && ser[0].data && ser[0].data.length === 0) {
        this.series.handleNoData();
      }

      this.setupEventHandlers(); // Handle the data inputted by user and set some of the global variables (for eg, if data is datetime / numeric / category). Don't calculate the range / min / max at this time

      this.core.parseData(ser); // this is a good time to set theme colors first

      this.theme.init(); // as markers accepts array, we need to setup global markers for easier access

      var markers = new Markers(this);
      markers.setGlobalMarkerSize(); // labelFormatters should be called before dimensions as in dimensions we need text labels width

      this.formatters.setLabelFormatters();
      this.titleSubtitle.draw(); // legend is calculated here before coreCalculations because it affects the plottable area

      if (!w.globals.noData) {
        this.legend.init();
      } // check whether in multiple series, all series share the same X


      this.series.hasAllSeriesEqualX(); // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals

      if (gl.axisCharts) {
        this.core.coreCalculations();

        if (w.config.xaxis.type !== 'category') {
          // as we have minX and maxX values, determine the default DateTimeFormat for time series
          this.formatters.setLabelFormatters();
        }
      } // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function
      // Also we need to do this before calcuting Dimentions plotCoords() method of Dimensions


      this.formatters.heatmapLabelFormatters(); // We got plottable area here, next task would be to calculate axis areas

      this.dimensions.plotCoords();
      var xyRatios = this.core.xySettings();
      this.grid.createGridMask();
      var elGraph = this.core.plotChartType(ser, xyRatios); // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends

      this.core.shiftGraphPosition();
      var dim = {
        plot: {
          left: w.globals.translateX,
          top: w.globals.translateY,
          width: w.globals.gridWidth,
          height: w.globals.gridHeight
        }
      };
      return {
        elGraph: elGraph,
        xyRatios: xyRatios,
        elInner: w.globals.dom.elGraphical,
        dimensions: dim
      };
    }
  }, {
    key: "mount",
    value: function mount() {
      var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var me = this;
      var w = me.w;
      return new Promise$1(function (resolve, reject) {
        // no data to display
        if (me.el === null) {
          return reject(new Error('Not enough data to display or target element not found'));
        } else if (graphData === null || w.globals.allSeriesCollapsed) {
          me.series.handleNoData();
        }

        me.annotations = new Annotations(me);
        me.core.drawAxis(w.config.chart.type, graphData.xyRatios);
        me.grid = new Grid(me);

        if (w.config.grid.position === 'back') {
          me.grid.drawGrid();
        }

        if (w.config.annotations.position === 'back') {
          me.annotations.drawAnnotations();
        }

        if (graphData.elGraph instanceof Array) {
          for (var g = 0; g < graphData.elGraph.length; g++) {
            w.globals.dom.elGraphical.add(graphData.elGraph[g]);
          }
        } else {
          w.globals.dom.elGraphical.add(graphData.elGraph);
        }

        if (w.config.grid.position === 'front') {
          me.grid.drawGrid();
        }

        if (w.config.xaxis.crosshairs.position === 'front') {
          me.crosshairs.drawXCrosshairs();
        }

        if (w.config.yaxis[0].crosshairs.position === 'front') {
          me.crosshairs.drawYCrosshairs();
        }

        if (w.config.annotations.position === 'front') {
          me.annotations.drawAnnotations();
        }

        if (!w.globals.noData) {
          // draw tooltips at the end
          if (w.config.tooltip.enabled && !w.globals.noData) {
            me.w.globals.tooltip.drawTooltip(graphData.xyRatios);
          }

          if (w.globals.axisCharts && w.globals.isXNumeric) {
            if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {
              me.zoomPanSelection.init({
                xyRatios: graphData.xyRatios
              });
            }
          } else {
            var tools = w.config.chart.toolbar.tools;
            tools.zoom = false;
            tools.zoomin = false;
            tools.zoomout = false;
            tools.selection = false;
            tools.pan = false;
            tools.reset = false;
          }

          if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {
            me.toolbar.createToolbar();
          }
        }

        if (w.globals.memory.methodsToExec.length > 0) {
          w.globals.memory.methodsToExec.forEach(function (fn) {
            fn.method(fn.params, false, fn.context);
          });
        }

        if (!w.globals.axisCharts && !w.globals.noData) {
          me.core.resizeNonAxisCharts();
        }

        resolve(me);
      });
    }
  }, {
    key: "clearPreviousPaths",
    value: function clearPreviousPaths() {
      var w = this.w;
      w.globals.previousPaths = [];
      w.globals.allSeriesCollapsed = false;
      w.globals.collapsedSeries = [];
      w.globals.collapsedSeriesIndices = [];
    }
    /**
     * Allows users to update Options after the chart has rendered.
     *
     * @param {object} options - A new config object can be passed which will be merged with the existing config object
     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
     * @param {boolean} animate - should animate or not on updating Options
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options$$1) {
      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var w = this.w;

      if (options$$1.series) {
        this.resetSeries(false);

        if (options$$1.series[0].data) {
          options$$1.series = options$$1.series.map(function (s, i) {
            return _objectSpread({}, w.config.series[i], {
              name: s.name ? s.name : w.config.series[i] && w.config.series[i].name,
              type: s.type ? s.type : w.config.series[i] && w.config.series[i].type,
              data: s.data ? s.data : w.config.series[i] && w.config.series[i].data
            });
          });
        } // user updated the series via updateOptions() function.
        // Hence, we need to reset axis min/max to avoid zooming issues


        this.revertDefaultAxisMinMax();
      } // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max


      if (options$$1.xaxis) {
        if (options$$1.xaxis.min || options$$1.xaxis.max) {
          this.forceXAxisUpdate(options$$1);
        }
        /* fixes apexcharts.js#369 and react-apexcharts#46 */


        if (options$$1.xaxis.categories && options$$1.xaxis.categories.length && w.config.xaxis.convertedCatToNumeric) {
          options$$1 = Defaults.convertCatToNumeric(options$$1);
        }
      }

      if (w.globals.collapsedSeriesIndices.length > 0) {
        this.clearPreviousPaths();
      }
      /* update theme mode#459 */


      if (options$$1.theme) {
        options$$1 = this.theme.updateThemeOptions(options$$1);
      }

      return this._updateOptions(options$$1, redraw, animate, updateSyncedCharts, overwriteInitialConfig);
    }
    /**
     * private method to update Options.
     *
     * @param {object} options - A new config object can be passed which will be merged with the existing config object
     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
     * @param {boolean} animate - should animate or not on updating Options
     * @param {boolean} overwriteInitialConfig - should update the initial config or not
     */

  }, {
    key: "_updateOptions",
    value: function _updateOptions(options$$1) {
      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var charts = [this];

      if (updateSyncedCharts) {
        charts = this.getSyncedCharts();
      }

      if (this.w.globals.isExecCalled) {
        // If the user called exec method, we don't want to get grouped charts as user specifically provided a chartID to update
        charts = [this];
        this.w.globals.isExecCalled = false;
      }

      charts.forEach(function (ch) {
        var w = ch.w;
        w.globals.shouldAnimate = animate;

        if (!redraw) {
          w.globals.resized = true;
          w.globals.dataChanged = true;

          if (animate) {
            ch.series.getPreviousPaths();
          }
        }

        if (options$$1 && _typeof(options$$1) === 'object') {
          ch.config = new Config(options$$1);
          options$$1 = CoreUtils.extendArrayProps(ch.config, options$$1);
          w.config = Utils.extend(w.config, options$$1);

          if (overwriteInitialConfig) {
            // we need to forget the lastXAxis and lastYAxis is user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.
            w.globals.lastXAxis = [];
            w.globals.lastYAxis = []; // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries

            w.globals.initialConfig = Utils.extend({}, w.config);
            w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));
          }
        }

        return ch.update(options$$1);
      });
    }
    /**
     * Allows users to update Series after the chart has rendered.
     *
     * @param {array} series - New series which will override the existing
     */

  }, {
    key: "updateSeries",
    value: function updateSeries() {
      var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.resetSeries(false);
      this.revertDefaultAxisMinMax();
      return this._updateSeries(newSeries, animate, overwriteInitialSeries);
    }
    /**
     * Allows users to append a new series after the chart has rendered.
     *
     * @param {array} newSerie - New serie which will be appended to the existing series
     */

  }, {
    key: "appendSeries",
    value: function appendSeries(newSerie) {
      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var newSeries = this.w.config.series.slice();
      newSeries.push(newSerie);
      this.resetSeries(false);
      this.revertDefaultAxisMinMax();
      return this._updateSeries(newSeries, animate, overwriteInitialSeries);
    }
    /**
     * Private method to update Series.
     *
     * @param {array} series - New series which will override the existing
     */

  }, {
    key: "_updateSeries",
    value: function _updateSeries(newSeries, animate) {
      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var w = this.w;
      this.w.globals.shouldAnimate = animate;
      w.globals.dataChanged = true; // if user has collapsed some series with legend, we need to clear those

      if (w.globals.allSeriesCollapsed) {
        w.globals.allSeriesCollapsed = false;
      }

      if (animate) {
        this.series.getPreviousPaths();
      }

      var existingSeries; // axis charts

      if (w.globals.axisCharts) {
        existingSeries = newSeries.map(function (s, i) {
          return _objectSpread({}, w.config.series[i], {
            name: s.name ? s.name : w.config.series[i] && w.config.series[i].name,
            type: s.type ? s.type : w.config.series[i] && w.config.series[i].type,
            data: s.data ? s.data : w.config.series[i] && w.config.series[i].data
          });
        });

        if (existingSeries.length === 0) {
          existingSeries = [{
            data: []
          }];
        }

        w.config.series = existingSeries;
      } else {
        // non-axis chart (pie/radialbar)
        w.config.series = newSeries.slice();
      }

      if (overwriteInitialSeries) {
        w.globals.initialConfig.series = JSON.parse(JSON.stringify(w.config.series));
        w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));
      }

      return this.update();
    }
    /**
     * Get all charts in the same "group" (including the instance which is called upon) to sync them when user zooms in/out or pan.
     */

  }, {
    key: "getSyncedCharts",
    value: function getSyncedCharts() {
      var chartGroups = this.getGroupedCharts();
      var allCharts = [this];

      if (chartGroups.length) {
        allCharts = [];
        chartGroups.forEach(function (ch) {
          allCharts.push(ch);
        });
      }

      return allCharts;
    }
    /**
     * Get charts in the same "group" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)
     */

  }, {
    key: "getGroupedCharts",
    value: function getGroupedCharts() {
      var _this2 = this;

      return Apex._chartInstances.filter(function (ch) {
        if (ch.group) {
          return true;
        }
      }).map(function (ch) {
        return _this2.w.config.chart.group === ch.group ? ch.chart : _this2;
      });
    }
    /**
     * Allows users to append Data to series.
     *
     * @param {array} newData - New data in the same format as series
     */

  }, {
    key: "appendData",
    value: function appendData(newData) {
      var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var me = this;
      me.w.globals.dataChanged = true;
      me.series.getPreviousPaths();
      var newSeries = me.w.config.series.slice();

      for (var i = 0; i < newSeries.length; i++) {
        if (typeof newData[i] !== 'undefined') {
          for (var j = 0; j < newData[i].data.length; j++) {
            newSeries[i].data.push(newData[i].data[j]);
          }
        }
      }

      me.w.config.series = newSeries;

      if (overwriteInitialSeries) {
        me.w.globals.initialSeries = JSON.parse(JSON.stringify(me.w.config.series));
      }

      return this.update();
    }
  }, {
    key: "update",
    value: function update(options$$1) {
      var _this3 = this;

      return new Promise$1(function (resolve, reject) {
        _this3.clear();

        var graphData = _this3.create(_this3.w.config.series, options$$1);

        if (!graphData) return resolve(_this3);

        _this3.mount(graphData).then(function () {
          if (typeof _this3.w.config.chart.events.updated === 'function') {
            _this3.w.config.chart.events.updated(_this3, _this3.w);
          }

          _this3.fireEvent('updated', [_this3, _this3.w]);

          _this3.w.globals.isDirty = true;
          resolve(_this3);
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "forceXAxisUpdate",
    value: function forceXAxisUpdate(options$$1) {
      var w = this.w;

      if (typeof options$$1.xaxis.min !== 'undefined') {
        w.config.xaxis.min = options$$1.xaxis.min;
        w.globals.lastXAxis.min = options$$1.xaxis.min;
      }

      if (typeof options$$1.xaxis.max !== 'undefined') {
        w.config.xaxis.max = options$$1.xaxis.max;
        w.globals.lastXAxis.max = options$$1.xaxis.max;
      }
    }
    /**
     * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.
     * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max
     * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally
     */

  }, {
    key: "revertDefaultAxisMinMax",
    value: function revertDefaultAxisMinMax() {
      var w = this.w;
      w.config.xaxis.min = w.globals.lastXAxis.min;
      w.config.xaxis.max = w.globals.lastXAxis.max;
      w.config.yaxis.map(function (yaxe, index) {
        if (w.globals.zoomed) {
          // if user has zoomed, and this function is called
          // then we need to get the lastAxis min and max
          if (typeof w.globals.lastYAxis[index] !== 'undefined') {
            yaxe.min = w.globals.lastYAxis[index].min;
            yaxe.max = w.globals.lastYAxis[index].max;
          }
        }
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.zoomPanSelection) {
        this.zoomPanSelection.destroy();
      }

      if (this.toolbar) {
        this.toolbar.destroy();
      }

      this.animations = null;
      this.annotations = null;
      this.core = null;
      this.grid = null;
      this.series = null;
      this.responsive = null;
      this.theme = null;
      this.formatters = null;
      this.titleSubtitle = null;
      this.legend = null;
      this.dimensions = null;
      this.options = null;
      this.crosshairs = null;
      this.zoomPanSelection = null;
      this.toolbar = null;
      this.w.globals.tooltip = null;
      this.clearDomElements();
    }
  }, {
    key: "killSVG",
    value: function killSVG(draw) {
      return new Promise$1(function (resolve, reject) {
        draw.each(function (i, children) {
          this.removeClass('*');
          this.off();
          this.stop();
        }, true);
        draw.ungroup();
        draw.clear();
        resolve('done');
      });
    }
  }, {
    key: "clearDomElements",
    value: function clearDomElements() {
      var _this4 = this;

      // detach document event
      this.eventList.forEach(function (event) {
        document.removeEventListener(event, _this4.documentEvent);
      });
      var domEls = this.w.globals.dom;

      if (this.el !== null) {
        // remove all child elements - resetting the whole chart
        while (this.el.firstChild) {
          this.el.removeChild(this.el.firstChild);
        }
      }

      this.killSVG(domEls.Paper);
      domEls.Paper.remove();
      domEls.elWrap = null;
      domEls.elGraphical = null;
      domEls.elLegendWrap = null;
      domEls.baseEl = null;
      domEls.elGridRect = null;
      domEls.elGridRectMask = null;
      domEls.elGridRectMarkerMask = null;
      domEls.elDefs = null;
    }
    /**
     * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.clear(); // remove the chart's instance from the global Apex._chartInstances

      var chartID = this.w.config.chart.id;

      if (chartID) {
        Apex._chartInstances.forEach(function (c, i) {
          if (c.id === chartID) {
            Apex._chartInstances.splice(i, 1);
          }
        });
      }

      window.removeEventListener('resize', this.windowResizeHandler);
      window.removeResizeListener(this.el.parentNode, this.parentResizeCallback.bind(this));
    }
    /**
     * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute
     */

  }, {
    key: "toggleSeries",
    value: function toggleSeries(seriesName) {
      var targetElement = this.series.getSeriesByName(seriesName);
      var seriesCnt = parseInt(targetElement.getAttribute('data:realIndex'));
      var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');
      this.legend.toggleDataSeries(seriesCnt, isHidden);
    }
  }, {
    key: "resetSeries",
    value: function resetSeries() {
      var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.series.resetSeries(shouldUpdateChart);
    }
  }, {
    key: "setupEventHandlers",
    value: function setupEventHandlers() {
      var _this5 = this;

      var w = this.w;
      var me = this;
      var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);
      this.eventListHandlers = [];
      this.eventList.forEach(function (event) {
        clickableArea.addEventListener(event, function (e) {
          if (e.type === 'mousedown' && e.which === 1) ; else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {
            if (typeof w.config.chart.events.click === 'function') {
              w.config.chart.events.click(e, me, w);
            }

            me.fireEvent('click', [e, me, w]);
          }
        }, {
          capture: false,
          passive: true
        });
      });
      this.eventList.forEach(function (event) {
        document.addEventListener(event, _this5.documentEvent);
      });
      this.core.setupBrushHandler();
    }
  }, {
    key: "documentEvent",
    value: function documentEvent(e) {
      var w = this.w;
      w.globals.clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
      w.globals.clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
    }
  }, {
    key: "addXaxisAnnotation",
    value: function addXaxisAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "addYaxisAnnotation",
    value: function addYaxisAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "addPointAnnotation",
    value: function addPointAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "clearAnnotations",
    value: function clearAnnotations() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.clearAnnotations(me);
    } // This method is never used internally and will be only called externally on the chart instance.
    // Hence, we need to keep all these elements in memory when the chart gets updated and redraw again

  }, {
    key: "addText",
    value: function addText(options$$1) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addText(options$$1, pushToMemory, me);
    }
  }, {
    key: "getChartArea",
    value: function getChartArea() {
      var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');
      return el;
    }
  }, {
    key: "getSeriesTotalXRange",
    value: function getSeriesTotalXRange(minX, maxX) {
      return this.coreUtils.getSeriesTotalsXRange(minX, maxX);
    }
  }, {
    key: "getHighestValueInSeries",
    value: function getHighestValueInSeries() {
      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var range = new Range$1(this.ctx);
      var minYmaxY = range.getMinYMaxY(seriesIndex);
      return minYmaxY.highestY;
    }
  }, {
    key: "getLowestValueInSeries",
    value: function getLowestValueInSeries() {
      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var range = new Range$1(this.ctx);
      var minYmaxY = range.getMinYMaxY(seriesIndex);
      return minYmaxY.lowestY;
    }
  }, {
    key: "getSeriesTotal",
    value: function getSeriesTotal() {
      return this.w.globals.seriesTotals;
    }
  }, {
    key: "setLocale",
    value: function setLocale(localeName) {
      this.setCurrentLocaleValues(localeName);
    }
  }, {
    key: "toggleDataPointSelection",
    value: function toggleDataPointSelection(seriesIndex, dataPointIndex) {
      var w = this.w;
      var elPath = null;

      if (w.globals.axisCharts) {
        elPath = w.globals.dom.Paper.select(".apexcharts-series[data\\:realIndex='".concat(seriesIndex, "'] path[j='").concat(dataPointIndex, "'], .apexcharts-series[data\\:realIndex='").concat(seriesIndex, "'] circle[j='").concat(dataPointIndex, "'], .apexcharts-series[data\\:realIndex='").concat(seriesIndex, "'] rect[j='").concat(dataPointIndex, "']")).members[0];
      } else {
        elPath = w.globals.dom.Paper.select(".apexcharts-series[data\\:realIndex='".concat(seriesIndex, "']")).members[0];
      }

      if (elPath) {
        var graphics = new Graphics(this.ctx);
        graphics.pathMouseDown(elPath, null);
      } else {
        console.warn('toggleDataPointSelection: Element not found');
      }

      return elPath.node ? elPath.node : null;
    }
  }, {
    key: "setCurrentLocaleValues",
    value: function setCurrentLocaleValues(localeName) {
      var locales = this.w.config.chart.locales; // check if user has specified locales in global Apex variable
      // if yes - then extend those with local chart's locale

      if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {
        locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);
      } // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)


      var selectedLocale = locales.filter(function (c) {
        return c.name === localeName;
      })[0];

      if (selectedLocale) {
        // create a complete locale object by extending defaults so you don't get undefined errors.
        var ret = Utils.extend(en, selectedLocale); // store these locale options in global var for ease access

        this.w.globals.locale = ret.options;
      } else {
        throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');
      }
    }
  }, {
    key: "dataURI",
    value: function dataURI() {
      var exp = new Exports(this.ctx);
      return exp.dataURI();
    }
  }, {
    key: "paper",
    value: function paper() {
      return this.w.globals.dom.Paper;
    }
  }, {
    key: "parentResizeCallback",
    value: function parentResizeCallback() {
      if (this.w.globals.animationEnded) {
        this.windowResize();
      }
    }
    /**
     * Handle window resize and re-draw the whole chart.
     */

  }, {
    key: "windowResize",
    value: function windowResize() {
      var _this6 = this;

      clearTimeout(this.w.globals.resizeTimer);
      this.w.globals.resizeTimer = window.setTimeout(function () {
        _this6.w.globals.resized = true;
        _this6.w.globals.dataChanged = false; // we need to redraw the whole chart on window resize (with a small delay).

        _this6.update();
      }, 150);
    }
  }], [{
    key: "initOnLoad",
    value: function initOnLoad() {
      var els = document.querySelectorAll('[data-apexcharts]');

      for (var i = 0; i < els.length; i++) {
        var el = els[i];
        var options$$1 = JSON.parse(els[i].getAttribute('data-options'));
        var apexChart = new ApexCharts(el, options$$1);
        apexChart.render();
      }
    }
    /**
     * This static method allows users to call chart methods without necessarily from the
     * instance of the chart in case user has assigned chartID to the targetted chart.
     * The chartID is used for mapping the instance stored in Apex._chartInstances global variable
     *
     * This is helpful in cases when you don't have reference of the chart instance
     * easily and need to call the method from anywhere.
     * For eg, in React/Vue applications when you have many parent/child components,
     * and need easy reference to other charts for performing dynamic operations
     *
     * @param {string} chartID - The unique identifier which will be used to call methods
     * on that chart instance
     * @param {function} fn - The method name to call
     * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.
     */

  }, {
    key: "exec",
    value: function exec(chartID, fn) {
      var chart = this.getChartByID(chartID);
      if (!chart) return; // turn on the global exec flag to indicate this method was called

      chart.w.globals.isExecCalled = true;

      for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        opts[_key - 2] = arguments[_key];
      }

      switch (fn) {
        case 'updateOptions':
          {
            return chart.updateOptions.apply(chart, opts);
          }

        case 'updateSeries':
          {
            return chart.updateSeries.apply(chart, opts);
          }

        case 'appendData':
          {
            return chart.appendData.apply(chart, opts);
          }

        case 'appendSeries':
          {
            return chart.appendSeries.apply(chart, opts);
          }

        case 'toggleSeries':
          {
            return chart.toggleSeries.apply(chart, opts);
          }

        case 'resetSeries':
          {
            return chart.resetSeries.apply(chart, opts);
          }

        case 'toggleDataPointSelection':
          {
            return chart.toggleDataPointSelection.apply(chart, opts);
          }

        case 'dataURI':
          {
            return chart.dataURI.apply(chart, opts);
          }

        case 'addXaxisAnnotation':
          {
            return chart.addXaxisAnnotation.apply(chart, opts);
          }

        case 'addYaxisAnnotation':
          {
            return chart.addYaxisAnnotation.apply(chart, opts);
          }

        case 'addPointAnnotation':
          {
            return chart.addPointAnnotation.apply(chart, opts);
          }

        case 'addText':
          {
            return chart.addText.apply(chart, opts);
          }

        case 'clearAnnotations':
          {
            return chart.clearAnnotations.apply(chart, opts);
          }

        case 'paper':
          {
            return chart.paper.apply(chart, opts);
          }

        case 'destroy':
          {
            return chart.destroy();
          }
      }
    }
  }, {
    key: "merge",
    value: function merge(target, source) {
      return Utils.extend(target, source);
    }
  }, {
    key: "getChartByID",
    value: function getChartByID(chartID) {
      var c = Apex._chartInstances.filter(function (ch) {
        return ch.id === chartID;
      })[0];

      return c.chart;
    }
  }]);

  return ApexCharts;
}();

/* harmony default export */ __webpack_exports__["default"] = (ApexCharts$1);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__("./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    fields: {
      type: Array,
      required: true
    },
    loadOnStart: {
      type: Boolean,
      "default": true
    },
    apiUrl: {
      type: String,
      "default": ''
    },
    httpMethod: {
      type: String,
      "default": 'get',
      validator: function validator(value) {
        return ['get', 'post'].indexOf(value) > -1;
      }
    },
    reactiveApiUrl: {
      type: Boolean,
      "default": true
    },
    apiMode: {
      type: Boolean,
      "default": true
    },
    data: {
      type: [Array, Object],
      "default": null
    },
    dataTotal: {
      type: Number,
      "default": 0
    },
    dataManager: {
      type: Function,
      "default": null
    },
    dataPath: {
      type: String,
      "default": 'data'
    },
    paginationPath: {
      type: [String],
      "default": 'links.pagination'
    },
    queryParams: {
      type: [Object, Function],
      "default": function _default() {
        return {
          sort: 'sort',
          page: 'page',
          perPage: 'per_page'
        };
      }
    },
    appendParams: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    httpOptions: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    httpFetch: {
      type: Function,
      "default": null
    },
    perPage: {
      type: Number,
      "default": 10
    },
    initialPage: {
      type: Number,
      "default": 1
    },
    sortOrder: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    multiSort: {
      type: Boolean,
      "default": function _default() {
        return false;
      }
    },
    tableHeight: {
      type: String,
      "default": null
    },

    /*
     * physical key that will trigger multi-sort option
     * possible values: 'alt', 'ctrl', 'meta', 'shift'
     * 'ctrl' might not work as expected on Mac
     */
    multiSortKey: {
      type: String,
      "default": 'alt'
    },

    /* deprecated */
    rowClassCallback: {
      type: [String, Function],
      "default": ''
    },
    rowClass: {
      type: [String, Function],
      "default": ''
    },
    detailRowComponent: {
      type: String,
      "default": ''
    },
    detailRowTransition: {
      type: String,
      "default": ''
    },
    trackBy: {
      type: String,
      "default": 'id'
    },
    css: {
      type: Object,
      "default": function _default() {
        return {
          tableClass: 'ui blue selectable celled stackable attached table',
          loadingClass: 'loading',
          ascendingIcon: 'blue chevron up icon',
          descendingIcon: 'blue chevron down icon',
          ascendingClass: 'sorted-asc',
          descendingClass: 'sorted-desc',
          sortableIcon: '',
          detailRowClass: 'vuetable-detail-row',
          handleIcon: 'grey sidebar icon',
          tableBodyClass: 'vuetable-semantic-no-top vuetable-fixed-layout',
          tableHeaderClass: 'vuetable-fixed-layout'
        };
      }
    },
    minRows: {
      type: Number,
      "default": 0
    },
    silent: {
      type: Boolean,
      "default": false
    },
    noDataTemplate: {
      type: String,
      "default": function _default() {
        return 'No Data Available';
      }
    },
    showSortIcons: {
      type: Boolean,
      "default": true
    }
  },
  data: function data() {
    return {
      eventPrefix: 'vuetable:',
      tableFields: [],
      tableData: null,
      tablePagination: null,
      currentPage: this.initialPage,
      selectedTo: [],
      visibleDetailRows: [],
      lastScrollPosition: 0,
      scrollBarWidth: '17px',
      //chrome default
      scrollVisible: false
    };
  },
  mounted: function mounted() {
    this.normalizeFields();
    this.normalizeSortOrder();

    if (this.isFixedHeader) {
      this.scrollBarWidth = this.getScrollBarWidth() + 'px';
    }

    this.$nextTick(function () {
      this.fireEvent('initialized', this.tableFields);
    });

    if (this.loadOnStart) {
      this.loadData();
    }

    if (this.isFixedHeader) {
      var elem = this.$el.getElementsByClassName('vuetable-body-wrapper')[0];

      if (elem != null) {
        elem.addEventListener('scroll', this.handleScroll);
      }
    }
  },
  destroyed: function destroyed() {
    var elem = this.$el.getElementsByClassName('vuetable-body-wrapper')[0];

    if (elem != null) {
      elem.removeEventListener('scroll', this.handleScroll);
    }
  },
  computed: {
    version: function version() {
      return VERSION;
    },
    useDetailRow: function useDetailRow() {
      if (this.tableData && this.tableData[0] && this.detailRowComponent !== '' && typeof this.tableData[0][this.trackBy] === 'undefined') {
        this.warn('You need to define unique row identifier in order for detail-row feature to work. Use `track-by` prop to define one!');
        return false;
      }

      return this.detailRowComponent !== '';
    },
    countVisibleFields: function countVisibleFields() {
      return this.tableFields.filter(function (field) {
        return field.visible;
      }).length;
    },
    countTableData: function countTableData() {
      if (this.tableData === null) {
        return 0;
      }

      return this.tableData.length;
    },
    displayEmptyDataRow: function displayEmptyDataRow() {
      return this.countTableData === 0 && this.noDataTemplate.length > 0;
    },
    lessThanMinRows: function lessThanMinRows() {
      if (this.tableData === null || this.tableData.length === 0) {
        return true;
      }

      return this.tableData.length < this.minRows;
    },
    blankRows: function blankRows() {
      if (this.tableData === null || this.tableData.length === 0) {
        return this.minRows;
      }

      if (this.tableData.length >= this.minRows) {
        return 0;
      }

      return this.minRows - this.tableData.length;
    },
    isApiMode: function isApiMode() {
      return this.apiMode;
    },
    isDataMode: function isDataMode() {
      return !this.apiMode;
    },
    isFixedHeader: function isFixedHeader() {
      return this.tableHeight != null;
    }
  },
  methods: {
    getScrollBarWidth: function getScrollBarWidth() {
      var outer = document.createElement('div');
      var inner = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.width = '100px';
      inner.style.width = '100%';
      outer.appendChild(inner);
      document.body.appendChild(outer);
      var widthWithoutScrollbar = outer.offsetWidth;
      outer.style.overflow = 'scroll';
      var widthWithScrollbar = inner.offsetWidth;
      document.body.removeChild(outer);
      return widthWithoutScrollbar - widthWithScrollbar;
    },
    handleScroll: function handleScroll(e) {
      //make sure that the header and the body are aligned when scrolling horizontally on a table that is wider than the viewport
      var horizontal = e.currentTarget.scrollLeft;

      if (horizontal != this.lastScrollPosition) {
        //don't modify header scroll if we are scrolling vertically
        var header = this.$el.getElementsByClassName('vuetable-head-wrapper')[0];

        if (header != null) {
          header.scrollLeft = horizontal;
        }

        this.lastScrollPosition = horizontal;
      }
    },
    normalizeFields: function normalizeFields() {
      if (typeof this.fields === 'undefined') {
        this.warn('You need to provide "fields" prop.');
        return;
      }

      this.tableFields = [];
      var self = this;
      var obj;
      this.fields.forEach(function (field, i) {
        if (typeof field === 'string') {
          obj = {
            name: field,
            title: self.setTitle(field),
            titleClass: '',
            dataClass: '',
            callback: null,
            visible: true
          };
        } else {
          obj = {
            name: field.name,
            width: field.width,
            title: field.title === undefined ? self.setTitle(field.name) : field.title,
            sortField: field.sortField,
            titleClass: field.titleClass === undefined ? '' : field.titleClass,
            dataClass: field.dataClass === undefined ? '' : field.dataClass,
            callback: field.callback === undefined ? '' : field.callback,
            visible: field.visible === undefined ? true : field.visible
          };
        }

        self.tableFields.push(obj);
      });
    },
    setData: function setData(data) {
      if (data === null || typeof data === 'undefined') return;
      this.fireEvent('loading');

      if (Array.isArray(data)) {
        this.tableData = data;
        this.fireEvent('loaded');
        return;
      }

      this.tableData = this.getObjectValue(data, this.dataPath, null);
      this.tablePagination = this.getObjectValue(data, this.paginationPath, null);
      this.$nextTick(function () {
        this.fixHeader();
        this.fireEvent('pagination-data', this.tablePagination);
        this.fireEvent('loaded');
      });
    },
    setTitle: function setTitle(str) {
      if (this.isSpecialField(str)) {
        return '';
      }

      return this.titleCase(str);
    },
    getTitle: function getTitle(field) {
      if (typeof field.title === 'function') return field.title();
      return typeof field.title === 'undefined' ? field.name.replace('.', ' ') : field.title;
    },
    renderTitle: function renderTitle(field) {
      var title = this.getTitle(field);

      if (title.length > 0 && this.isInCurrentSortGroup(field) || this.hasSortableIcon(field)) {
        var style = "opacity:".concat(this.sortIconOpacity(field), ";position:relative;float:right");
        var iconTag = this.showSortIcons ? this.renderIconTag(['sort-icon', this.sortIcon(field)], "style=\"".concat(style, "\"")) : '';
        return title + ' ' + iconTag;
      }

      return title;
    },
    renderSequence: function renderSequence(index) {
      return this.tablePagination ? this.tablePagination.from + index : index;
    },
    renderNormalField: function renderNormalField(field, item) {
      return this.hasCallback(field) ? this.callCallback(field, item) : this.getObjectValue(item, field.name, '');
    },
    isSpecialField: function isSpecialField(fieldName) {
      return fieldName.slice(0, 2) === '__';
    },
    titleCase: function titleCase(str) {
      return str.replace(/\w+/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    },
    camelCase: function camelCase(str) {
      var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_';
      var self = this;
      return str.split(delimiter).map(function (item) {
        return self.titleCase(item);
      }).join('');
    },
    notIn: function notIn(str, arr) {
      return arr.indexOf(str) === -1;
    },
    loadData: function loadData() {
      var success = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.loadSuccess;
      var failed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.loadFailed;

      if (this.isDataMode) {
        this.callDataManager();
        return;
      }

      this.fireEvent('loading');
      this.httpOptions['params'] = this.getAppendParams(this.getAllQueryParams());
      return this.fetch(this.apiUrl, this.httpOptions).then(success, failed)["catch"](function () {
        return failed();
      });
    },
    fetch: function fetch(apiUrl, httpOptions) {
      return this.httpFetch ? this.httpFetch(apiUrl, httpOptions) : __WEBPACK_IMPORTED_MODULE_0_axios___default.a[this.httpMethod](apiUrl, httpOptions);
    },
    loadSuccess: function loadSuccess(response) {
      this.fireEvent('load-success', response);
      var body = this.transform(response.data);
      this.tableData = this.getObjectValue(body, this.dataPath, null);
      this.tablePagination = this.getObjectValue(body, this.paginationPath, null);

      if (this.tablePagination === null) {
        this.warn('vuetable: pagination-path "' + this.paginationPath + '" not found. ' + 'It looks like the data returned from the sever does not have pagination information ' + "or you may have set it incorrectly.\n" + 'You can explicitly suppress this warning by setting pagination-path="".');
      }

      this.$nextTick(function () {
        this.fixHeader();
        this.fireEvent('pagination-data', this.tablePagination);
        this.fireEvent('loaded');
      });
    },
    fixHeader: function fixHeader() {
      if (!this.isFixedHeader) {
        return;
      }

      var elem = this.$el.getElementsByClassName('vuetable-body-wrapper')[0];

      if (elem != null) {
        if (elem.scrollHeight > elem.clientHeight) {
          this.scrollVisible = true;
        } else {
          this.scrollVisible = false;
        }
      }
    },
    loadFailed: function loadFailed(response) {
      console.error('load-error', response);
      this.fireEvent('load-error', response);
      this.fireEvent('loaded');
    },
    transform: function transform(data) {
      var func = 'transform';

      if (this.parentFunctionExists(func)) {
        return this.$parent[func].call(this.$parent, data);
      }

      return data;
    },
    parentFunctionExists: function parentFunctionExists(func) {
      return func !== '' && typeof this.$parent[func] === 'function';
    },
    callParentFunction: function callParentFunction(func, args) {
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (this.parentFunctionExists(func)) {
        return this.$parent[func].call(this.$parent, args);
      }

      return defaultValue;
    },
    fireEvent: function fireEvent(eventName, args) {
      this.$emit(this.eventPrefix + eventName, args);
    },
    warn: function warn(msg) {
      if (!this.silent) {
        console.warn(msg);
      }
    },
    getAllQueryParams: function getAllQueryParams() {
      var params = {};

      if (typeof this.queryParams === 'function') {
        params = this.queryParams(this.sortOrder, this.currentPage, this.perPage);
        return _typeof(params) !== 'object' ? {} : params;
      }

      params[this.queryParams.sort] = this.getSortParam();
      params[this.queryParams.page] = this.currentPage;
      params[this.queryParams.perPage] = this.perPage;
      return params;
    },
    getSortParam: function getSortParam() {
      if (!this.sortOrder || this.sortOrder.field == '') {
        return '';
      }

      if (typeof this.$parent['getSortParam'] === 'function') {
        return this.$parent['getSortParam'].call(this.$parent, this.sortOrder);
      }

      return this.getDefaultSortParam();
    },
    getDefaultSortParam: function getDefaultSortParam() {
      var result = '';

      for (var i = 0; i < this.sortOrder.length; i++) {
        var fieldName = typeof this.sortOrder[i].sortField === 'undefined' ? this.sortOrder[i].field : this.sortOrder[i].sortField;
        result += fieldName + '|' + this.sortOrder[i].direction + (i + 1 < this.sortOrder.length ? ',' : '');
      }

      return result;
    },
    getAppendParams: function getAppendParams(params) {
      for (var x in this.appendParams) {
        params[x] = this.appendParams[x];
      }

      return params;
    },
    extractName: function extractName(string) {
      return string.split(':')[0].trim();
    },
    extractArgs: function extractArgs(string) {
      return string.split(':')[1];
    },
    isSortable: function isSortable(field) {
      return !(typeof field.sortField === 'undefined');
    },
    isInCurrentSortGroup: function isInCurrentSortGroup(field) {
      return this.currentSortOrderPosition(field) !== false;
    },
    hasSortableIcon: function hasSortableIcon(field) {
      return this.isSortable(field) && this.css.sortableIcon != '';
    },
    currentSortOrderPosition: function currentSortOrderPosition(field) {
      if (!this.isSortable(field)) {
        return false;
      }

      for (var i = 0; i < this.sortOrder.length; i++) {
        if (this.fieldIsInSortOrderPosition(field, i)) {
          return i;
        }
      }

      return false;
    },
    fieldIsInSortOrderPosition: function fieldIsInSortOrderPosition(field, i) {
      return this.sortOrder[i].field === field.name && this.sortOrder[i].sortField === field.sortField;
    },
    orderBy: function orderBy(field, event) {
      if (!this.isSortable(field)) return;
      var key = this.multiSortKey.toLowerCase() + 'Key';

      if (this.multiSort && event[key]) {
        //adding column to multisort
        this.multiColumnSort(field);
      } else {
        //no multisort, or resetting sort
        this.singleColumnSort(field);
      }

      this.currentPage = 1; // reset page index

      if (this.apiMode || this.dataManager) {
        this.loadData();
      }
    },
    multiColumnSort: function multiColumnSort(field) {
      var i = this.currentSortOrderPosition(field);

      if (i === false) {
        //this field is not in the sort array yet
        this.sortOrder.push({
          field: field.name,
          sortField: field.sortField,
          direction: 'asc'
        });
      } else {
        //this field is in the sort array, now we change its state
        if (this.sortOrder[i].direction === 'asc') {
          // switch direction
          this.sortOrder[i].direction = 'desc';
        } else {
          //remove sort condition
          this.sortOrder.splice(i, 1);
        }
      }
    },
    singleColumnSort: function singleColumnSort(field) {
      if (this.sortOrder.length === 0) {
        this.clearSortOrder();
      }

      this.sortOrder.splice(1); //removes additional columns

      if (this.fieldIsInSortOrderPosition(field, 0)) {
        // change sort direction
        this.sortOrder[0].direction = this.sortOrder[0].direction === 'asc' ? 'desc' : 'asc';
      } else {
        // reset sort direction
        this.sortOrder[0].direction = 'asc';
      }

      this.sortOrder[0].field = field.name;
      this.sortOrder[0].sortField = field.sortField;
    },
    clearSortOrder: function clearSortOrder() {
      this.sortOrder.push({
        field: '',
        sortField: '',
        direction: 'asc'
      });
    },
    sortClass: function sortClass(field) {
      var cls = '';
      var i = this.currentSortOrderPosition(field);

      if (i !== false) {
        cls = this.sortOrder[i].direction == 'asc' ? this.css.ascendingClass : this.css.descendingClass;
      }

      return cls;
    },
    sortIcon: function sortIcon(field) {
      var cls = this.css.sortableIcon;
      var i = this.currentSortOrderPosition(field);

      if (i !== false) {
        cls = this.sortOrder[i].direction == 'asc' ? this.css.ascendingIcon : this.css.descendingIcon;
      }

      return cls;
    },
    sortIconOpacity: function sortIconOpacity(field) {
      /*
       * fields with stronger precedence have darker color
       *
       * if there are few fields, we go down by 0.3
       * ex. 2 fields are selected: 1.0, 0.7
       *
       * if there are more we go down evenly on the given spectrum
       * ex. 6 fields are selected: 1.0, 0.86, 0.72, 0.58, 0.44, 0.3
       */
      var max = 1.0,
          min = 0.3,
          step = 0.3;
      var count = this.sortOrder.length;
      var current = this.currentSortOrderPosition(field);

      if (max - count * step < min) {
        step = (max - min) / (count - 1);
      }

      var opacity = max - current * step;
      return opacity;
    },
    hasCallback: function hasCallback(item) {
      return item.callback ? true : false;
    },
    callCallback: function callCallback(field, item) {
      if (!this.hasCallback(field)) return;

      if (typeof field.callback == 'function') {
        return field.callback(this.getObjectValue(item, field.name));
      }

      var args = field.callback.split('|');
      var func = args.shift();

      if (typeof this.$parent[func] === 'function') {
        var value = this.getObjectValue(item, field.name);
        return args.length > 0 ? this.$parent[func].apply(this.$parent, [value].concat(args)) : this.$parent[func].call(this.$parent, value);
      }

      return null;
    },
    getObjectValue: function getObjectValue(object, path, defaultValue) {
      defaultValue = typeof defaultValue === 'undefined' ? null : defaultValue;
      var obj = object;

      if (path.trim() != '') {
        var keys = path.split('.');
        keys.forEach(function (key) {
          if (obj !== null && typeof obj[key] !== 'undefined' && obj[key] !== null) {
            obj = obj[key];
          } else {
            obj = defaultValue;
            return;
          }
        });
      }

      return obj;
    },
    toggleCheckbox: function toggleCheckbox(dataItem, fieldName, event) {
      var isChecked = event.target.checked;
      var idColumn = this.trackBy;

      if (dataItem[idColumn] === undefined) {
        this.warn('__checkbox field: The "' + this.trackBy + '" field does not exist! Make sure the field you specify in "track-by" prop does exist.');
        return;
      }

      var key = dataItem[idColumn];

      if (isChecked) {
        this.selectId(key);
      } else {
        this.unselectId(key);
      }

      this.$emit('vuetable:checkbox-toggled', isChecked, dataItem);
    },
    selectId: function selectId(key) {
      if (!this.isSelectedRow(key)) {
        this.selectedTo.push(key);
      }
    },
    unselectId: function unselectId(key) {
      this.selectedTo = this.selectedTo.filter(function (item) {
        return item !== key;
      });
    },
    isSelectedRow: function isSelectedRow(key) {
      return this.selectedTo.indexOf(key) >= 0;
    },
    rowSelected: function rowSelected(dataItem, fieldName) {
      var idColumn = this.trackBy;
      var key = dataItem[idColumn];
      return this.isSelectedRow(key);
    },
    checkCheckboxesState: function checkCheckboxesState(fieldName) {
      if (!this.tableData) return;
      var self = this;
      var idColumn = this.trackBy;
      var selector = 'th.vuetable-th-checkbox-' + idColumn + ' input[type=checkbox]';
      var els = document.querySelectorAll(selector); //fixed:document.querySelectorAll return the typeof nodeList not array

      if (els.forEach === undefined) els.forEach = function (cb) {
        [].forEach.call(els, cb);
      }; // count how many checkbox row in the current page has been checked

      var selected = this.tableData.filter(function (item) {
        return self.selectedTo.indexOf(item[idColumn]) >= 0;
      }); // count == 0, clear the checkbox

      if (selected.length <= 0) {
        els.forEach(function (el) {
          el.indeterminate = false;
        });
        return false;
      } // count > 0 and count < perPage, set checkbox state to 'indeterminate'
      else if (selected.length < this.perPage) {
          els.forEach(function (el) {
            el.indeterminate = true;
          });
          return true;
        } // count == perPage, set checkbox state to 'checked'
        else {
            els.forEach(function (el) {
              el.indeterminate = false;
            });
            return true;
          }
    },
    toggleAllCheckboxes: function toggleAllCheckboxes(fieldName, event) {
      var self = this;
      var isChecked = event.target.checked;
      var idColumn = this.trackBy;

      if (isChecked) {
        this.tableData.forEach(function (dataItem) {
          self.selectId(dataItem[idColumn]);
        });
      } else {
        this.tableData.forEach(function (dataItem) {
          self.unselectId(dataItem[idColumn]);
        });
      }

      this.$emit('vuetable:checkbox-toggled-all', isChecked);
    },
    gotoPreviousPage: function gotoPreviousPage() {
      if (this.currentPage > 1) {
        this.currentPage--;
        this.loadData();
      }
    },
    gotoNextPage: function gotoNextPage() {
      if (this.currentPage < this.tablePagination.last_page) {
        this.currentPage++;
        this.loadData();
      }
    },
    gotoPage: function gotoPage(page) {
      if (page != this.currentPage && page > 0 && page <= this.tablePagination.last_page) {
        this.currentPage = page;
        this.loadData();
      }
    },
    isVisibleDetailRow: function isVisibleDetailRow(rowId) {
      return this.visibleDetailRows.indexOf(rowId) >= 0;
    },
    showDetailRow: function showDetailRow(rowId) {
      if (!this.isVisibleDetailRow(rowId)) {
        this.visibleDetailRows.push(rowId);
      }
    },
    hideDetailRow: function hideDetailRow(rowId) {
      if (this.isVisibleDetailRow(rowId)) {
        this.visibleDetailRows.splice(this.visibleDetailRows.indexOf(rowId), 1);
      }
    },
    toggleDetailRow: function toggleDetailRow(rowId) {
      if (this.isVisibleDetailRow(rowId)) {
        this.hideDetailRow(rowId);
      } else {
        this.showDetailRow(rowId);
      }
    },
    showField: function showField(index) {
      if (index < 0 || index > this.tableFields.length) return;
      this.tableFields[index].visible = true;
    },
    hideField: function hideField(index) {
      if (index < 0 || index > this.tableFields.length) return;
      this.tableFields[index].visible = false;
    },
    toggleField: function toggleField(index) {
      if (index < 0 || index > this.tableFields.length) return;
      this.tableFields[index].visible = !this.tableFields[index].visible;
    },
    renderIconTag: function renderIconTag(classes) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return typeof this.css.renderIcon === 'undefined' ? "<i class=\"".concat(classes.join(' '), "\" ").concat(options, "></i>") : this.css.renderIcon(classes, options);
    },
    makePagination: function makePagination() {
      var total = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var perPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var currentPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var pagination = {};
      total = total === null ? this.dataTotal : total;
      perPage = perPage === null ? this.perPage : perPage;
      currentPage = currentPage === null ? this.currentPage : currentPage;
      return {
        'total': total,
        'per_page': perPage,
        'current_page': currentPage,
        'last_page': Math.ceil(total / perPage) || 0,
        'next_page_url': '',
        'prev_page_url': '',
        'from': (currentPage - 1) * perPage + 1,
        'to': Math.min(currentPage * perPage, total)
      };
    },
    normalizeSortOrder: function normalizeSortOrder() {
      this.sortOrder.forEach(function (item) {
        item.sortField = item.sortField || item.field;
      });
    },
    callDataManager: function callDataManager() {
      if (this.dataManager === null && this.data === null) return;

      if (Array.isArray(this.data)) {
        return this.setData(this.data);
      }

      this.normalizeSortOrder();
      return this.setData(this.dataManager ? this.dataManager(this.sortOrder, this.makePagination()) : this.data);
    },
    onRowClass: function onRowClass(dataItem, index) {
      if (this.rowClassCallback !== '') {
        this.warn('"row-class-callback" prop is deprecated, please use "row-class" prop instead.');
        return;
      }

      if (typeof this.rowClass === 'function') {
        return this.rowClass(dataItem, index);
      }

      return this.rowClass;
    },
    onRowChanged: function onRowChanged(dataItem) {
      this.fireEvent('row-changed', dataItem);
      return true;
    },
    onRowClicked: function onRowClicked(dataItem, event) {
      this.$emit(this.eventPrefix + 'row-clicked', dataItem, event);
      return true;
    },
    onRowDoubleClicked: function onRowDoubleClicked(dataItem, event) {
      this.$emit(this.eventPrefix + 'row-dblclicked', dataItem, event);
    },
    onDetailRowClick: function onDetailRowClick(dataItem, event) {
      this.$emit(this.eventPrefix + 'detail-row-clicked', dataItem, event);
    },
    onCellClicked: function onCellClicked(dataItem, field, event) {
      this.$emit(this.eventPrefix + 'cell-clicked', dataItem, field, event);
    },
    onCellDoubleClicked: function onCellDoubleClicked(dataItem, field, event) {
      this.$emit(this.eventPrefix + 'cell-dblclicked', dataItem, field, event);
    },
    onCellRightClicked: function onCellRightClicked(dataItem, field, event) {
      this.$emit(this.eventPrefix + 'cell-rightclicked', dataItem, field, event);
    },

    /*
     * API for externals
     */
    changePage: function changePage(page) {
      if (page === 'prev') {
        this.gotoPreviousPage();
      } else if (page === 'next') {
        this.gotoNextPage();
      } else {
        this.gotoPage(page);
      }
    },
    reload: function reload() {
      return this.loadData();
    },
    refresh: function refresh() {
      this.currentPage = 1;
      return this.loadData();
    },
    resetData: function resetData() {
      this.tableData = null;
      this.tablePagination = null;
      this.fireEvent('data-reset');
    }
  },
  // end: methods
  watch: {
    'multiSort': function multiSort(newVal, oldVal) {
      if (newVal === false && this.sortOrder.length > 1) {
        this.sortOrder.splice(1);
        this.loadData();
      }
    },
    'apiUrl': function apiUrl(newVal, oldVal) {
      if (this.reactiveApiUrl && newVal !== oldVal) this.refresh();
    },
    'data': function data(newVal, oldVal) {
      this.setData(newVal);
    },
    'tableHeight': function tableHeight(newVal, oldVal) {
      this.fixHeader();
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePagination.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VuetablePaginationMixin_vue__ = __webpack_require__("./node_modules/vuetable-2/src/components/VuetablePaginationMixin.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VuetablePaginationMixin_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__VuetablePaginationMixin_vue__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  mixins: [__WEBPACK_IMPORTED_MODULE_0__VuetablePaginationMixin_vue___default.a]
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VuetablePaginationInfoMixin_vue__ = __webpack_require__("./node_modules/vuetable-2/src/components/VuetablePaginationInfoMixin.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VuetablePaginationInfoMixin_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__VuetablePaginationInfoMixin_vue__);
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  mixins: [__WEBPACK_IMPORTED_MODULE_0__VuetablePaginationInfoMixin_vue___default.a]
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfoMixin.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    css: {
      type: Object,
      "default": function _default() {
        return {
          infoClass: 'left floated left aligned six wide column'
        };
      }
    },
    infoTemplate: {
      type: String,
      "default": function _default() {
        return "Displaying {from} to {to} of {total} items";
      }
    },
    noDataTemplate: {
      type: String,
      "default": function _default() {
        return 'No relevant data';
      }
    }
  },
  data: function data() {
    return {
      tablePagination: null
    };
  },
  computed: {
    paginationInfo: function paginationInfo() {
      if (this.tablePagination == null || this.tablePagination.total == 0) {
        return this.noDataTemplate;
      }

      return this.infoTemplate.replace('{from}', this.tablePagination.from || 0).replace('{to}', this.tablePagination.to || 0).replace('{total}', this.tablePagination.total || 0);
    }
  },
  methods: {
    setPaginationData: function setPaginationData(tablePagination) {
      this.tablePagination = tablePagination;
    },
    resetData: function resetData() {
      this.tablePagination = null;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationMixin.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    css: {
      type: Object,
      "default": function _default() {
        return {
          wrapperClass: 'ui right floated pagination menu',
          activeClass: 'active large',
          disabledClass: 'disabled',
          pageClass: 'item',
          linkClass: 'icon item',
          paginationClass: 'ui bottom attached segment grid',
          paginationInfoClass: 'left floated left aligned six wide column',
          dropdownClass: 'ui search dropdown',
          icons: {
            first: 'angle double left icon',
            prev: 'left chevron icon',
            next: 'right chevron icon',
            last: 'angle double right icon'
          }
        };
      }
    },
    onEachSide: {
      type: Number,
      "default": function _default() {
        return 2;
      }
    }
  },
  data: function data() {
    return {
      eventPrefix: 'vuetable-pagination:',
      tablePagination: null
    };
  },
  computed: {
    totalPage: function totalPage() {
      return this.tablePagination === null ? 0 : this.tablePagination.last_page;
    },
    isOnFirstPage: function isOnFirstPage() {
      return this.tablePagination === null ? false : this.tablePagination.current_page === 1;
    },
    isOnLastPage: function isOnLastPage() {
      return this.tablePagination === null ? false : this.tablePagination.current_page === this.tablePagination.last_page;
    },
    notEnoughPages: function notEnoughPages() {
      return this.totalPage < this.onEachSide * 2 + 4;
    },
    windowSize: function windowSize() {
      return this.onEachSide * 2 + 1;
    },
    windowStart: function windowStart() {
      if (!this.tablePagination || this.tablePagination.current_page <= this.onEachSide) {
        return 1;
      } else if (this.tablePagination.current_page >= this.totalPage - this.onEachSide) {
        return this.totalPage - this.onEachSide * 2;
      }

      return this.tablePagination.current_page - this.onEachSide;
    }
  },
  methods: {
    loadPage: function loadPage(page) {
      this.$emit(this.eventPrefix + 'change-page', page);
    },
    isCurrentPage: function isCurrentPage(page) {
      return page === this.tablePagination.current_page;
    },
    setPaginationData: function setPaginationData(tablePagination) {
      this.tablePagination = tablePagination;
    },
    resetData: function resetData() {
      this.tablePagination = null;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/CollectionTable.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_runtime_regenerator__ = __webpack_require__("./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios__ = __webpack_require__("./node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__svg_icons_compiled_square_down_js__ = __webpack_require__("./resources/svg-icons/compiled/square_down.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__svg_icons_compiled_square_down_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__svg_icons_compiled_square_down_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__svg_icons_compiled_plus_js__ = __webpack_require__("./resources/svg-icons/compiled/plus.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__svg_icons_compiled_plus_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__svg_icons_compiled_plus_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__svg_icons_compiled_details_js__ = __webpack_require__("./resources/svg-icons/compiled/details.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__svg_icons_compiled_details_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__svg_icons_compiled_details_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__svg_icons_compiled_delete_js__ = __webpack_require__("./resources/svg-icons/compiled/delete.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__svg_icons_compiled_delete_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__svg_icons_compiled_delete_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__svg_icons_compiled_edit_js__ = __webpack_require__("./resources/svg-icons/compiled/edit.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__svg_icons_compiled_edit_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__svg_icons_compiled_edit_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__svg_icons_compiled_actions_js__ = __webpack_require__("./resources/svg-icons/compiled/actions.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__svg_icons_compiled_actions_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__svg_icons_compiled_actions_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__helpers__ = __webpack_require__("./resources/assets/js/helpers.js");


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    model: {
      type: String,
      required: true
    }
  },
  data: function data() {
    return {
      sortBy: 'name',
      sortDesc: false,
      fields: [{
        key: 'name',
        label: 'Name',
        sortable: true
      }, {
        key: 'manufacturer',
        label: 'Manufacturer',
        sortable: true
      }, {
        key: 'material',
        sortable: true
      }, {
        key: 'diameter',
        sortable: true
      }, {
        key: 'price',
        sortable: false
      }, {
        key: 'actions',
        label: ''
      }],
      filter: null,
      totalRows: 0,
      currentPage: 1,
      perPage: 5,
      collection: []
    };
  },
  mounted: function mounted() {
    this.getCollection();
  },
  methods: {
    onFiltered: function onFiltered(filteredItems) {
      // Trigger pagination to update the number of buttons/pages due to filtering
      this.totalRows = filteredItems.length;
      this.currentPage = 1;
    },
    deleteInstance: function deleteInstance(id) {
      var _this = this;

      var conf = confirm('Do you really want to delete this machine?');
      var index = this.collection.findIndex(function (x) {
        return x.id === id;
      });

      if (conf === true) {
        __WEBPACK_IMPORTED_MODULE_1_axios___default.a["delete"]('/api/filamentspools/' + id).then(function (response) {
          _this.collection.splice(index, 1);
        })["catch"](function (error) {
          console.log(error);
        });
      }
    },
    getCollection: function () {
      var _getCollection = _asyncToGenerator(
      /*#__PURE__*/
      __WEBPACK_IMPORTED_MODULE_0__babel_runtime_regenerator___default.a.mark(function _callee() {
        var response, collectionData, i, o, attr, key;
        return __WEBPACK_IMPORTED_MODULE_0__babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return __WEBPACK_IMPORTED_MODULE_1_axios___default.a.get('/api/filamentspools');

              case 3:
                response = _context.sent;
                // Remap JSON:API data to simple array with objects as its elements
                collectionData = response.data.data;

                for (i = 0; i < collectionData.length; i++) {
                  o = {};
                  o.id = collectionData[i].id; // Need to fetch primary key
                  // Fetch all the attributes

                  attr = collectionData[i].attributes;

                  for (key in attr) {
                    if (attr.hasOwnProperty(key)) o[key] = attr[key];
                  }

                  this.collection.push(o);
                }

                _context.next = 12;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);
                console.log(_context.t0);
                return _context.abrupt("return", []);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 8]]);
      }));

      function getCollection() {
        return _getCollection.apply(this, arguments);
      }

      return getCollection;
    }(),
    moneyFormat: __WEBPACK_IMPORTED_MODULE_8__helpers__["b" /* moneyFormat */]
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/CreateScreen.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__svg_icons_compiled_details_js__ = __webpack_require__("./resources/svg-icons/compiled/details.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__svg_icons_compiled_details_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__svg_icons_compiled_details_js__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  props: ['resource', 'title'],
  mounted: function mounted() {
    document.title = this.title + ' - Volta';
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/IndexScreen.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable__ = __webpack_require__("./node_modules/vuetable-2/src/components/Vuetable.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuetable_2_src_components_VuetablePagination__ = __webpack_require__("./node_modules/vuetable-2/src/components/VuetablePagination.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuetable_2_src_components_VuetablePagination___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_vuetable_2_src_components_VuetablePagination__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vuetable_2_src_components_VuetablePaginationInfo__ = __webpack_require__("./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vuetable_2_src_components_VuetablePaginationInfo___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vuetable_2_src_components_VuetablePaginationInfo__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parts_FilterBar__ = __webpack_require__("./resources/assets/js/components/parts/FilterBar.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parts_FilterBar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__parts_FilterBar__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_axios__ = __webpack_require__("./node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue__ = __webpack_require__("./node_modules/vue/dist/vue.common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_events__ = __webpack_require__("./node_modules/vue-events/dist/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_vue_events__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







__WEBPACK_IMPORTED_MODULE_5_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_6_vue_events___default.a);
/* harmony default export */ __webpack_exports__["default"] = ({
  props: ['resource', 'title', 'fields', 'sort-order'],
  components: {
    Vuetable: __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable___default.a,
    VuetablePagination: __WEBPACK_IMPORTED_MODULE_1_vuetable_2_src_components_VuetablePagination___default.a,
    VuetablePaginationInfo: __WEBPACK_IMPORTED_MODULE_2_vuetable_2_src_components_VuetablePaginationInfo___default.a,
    FilterBar: __WEBPACK_IMPORTED_MODULE_3__parts_FilterBar___default.a
  },

  /**
   * The component's data.
   */
  data: function data() {
    return {
      filterText: '',
      moreParams: {},
      http_options: {
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRF-TOKEN': document.head.querySelector('meta[name="csrf-token"]').content
        }
      },
      css: {
        table: {
          ascendingIcon: 'glyphicon glyphicon-chevron-up',
          descendingIcon: 'glyphicon glyphicon-chevron-down'
        },
        pagination: {
          infoClass: 'pull-left',
          wrapperClass: 'vuetable-pagination pull-right',
          activeClass: 'btn-primary',
          disabledClass: 'disabled',
          pageClass: 'btn',
          linkClass: 'btn',
          icons: {
            first: '',
            prev: '',
            next: '',
            last: ''
          }
        }
      }
    };
  },

  /**
   * Prepare the component.
   */
  mounted: function mounted() {
    var _this = this;

    document.title = this.title + ' - Volta';
    this.$events.$on('filter-set', function (eventData) {
      return _this.onFilterSet(eventData);
    });
    this.$events.$on('filter-reset', function (e) {
      return _this.onFilterReset();
    });
  },
  methods: {
    transform: function transform(data) {
      var transformed = {};
      transformed.pagination = {
        total: data.meta.total,
        per_page: data.meta.per_page,
        current_page: data.meta.current_page,
        last_page: data.meta.last_page,
        next_page_url: data.meta.next_page_url,
        prev_page_url: data.meta.prev_page_url,
        from: data.meta.from,
        to: data.meta.to
      };
      transformed.resourcedata = []; // Remap JSON:API data to simple array with objects as its elements

      var collectionData = data.data;

      for (var i = 0; i < collectionData.length; i++) {
        var o = {};
        o.id = collectionData[i].id; // Need to fetch primary key
        // Fetch all the attributes

        var attr = collectionData[i].attributes;

        for (var key in attr) {
          if (attr.hasOwnProperty(key)) o[key] = attr[key]; // Apply name code -> name mapping based on meta element

          if (collectionData[i].hasOwnProperty('meta')) {
            var meta = collectionData[i]['meta'];

            if (meta.hasOwnProperty(key + '.name') && meta[key + '.name']) {
              o[key] = meta[key + '.name'];
            }
          }
        }

        transformed.resourcedata.push(o);
      }

      return transformed;
    },
    onPaginationData: function onPaginationData(paginationData) {
      this.$refs.pagination.setPaginationData(paginationData);
      this.$refs.paginationInfo.setPaginationData(paginationData);
    },
    onChangePage: function onChangePage(page) {
      this.$refs.vuetable.changePage(page);
    },
    onFilterSet: function onFilterSet(filterText) {
      var _this2 = this;

      this.moreParams = {
        filter: filterText
      };
      __WEBPACK_IMPORTED_MODULE_5_vue___default.a.nextTick(function () {
        return _this2.$refs.vuetable.refresh();
      });
    },
    onFilterReset: function onFilterReset() {
      var _this3 = this;

      this.moreParams = {};
      __WEBPACK_IMPORTED_MODULE_5_vue___default.a.nextTick(function () {
        return _this3.$refs.vuetable.refresh();
      });
    },
    deleteInstance: function deleteInstance(id) {
      var _this4 = this;

      var conf = confirm(this.$t('confirm.delete', {
        resource: this.$tc('resources.' + this.resource, 1)
      }));

      if (conf === true) {
        __WEBPACK_IMPORTED_MODULE_4_axios___default.a["delete"]('/api/' + this.resource + '/' + id).then(function (response) {
          _this4.moreParams = {};
          __WEBPACK_IMPORTED_MODULE_5_vue___default.a.nextTick(function () {
            return _this4.$refs.vuetable.reload();
          });
        })["catch"](function (error) {
          console.log(error);
        });
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/parts/FilterBar.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ __webpack_exports__["default"] = ({
  props: ['resource'],
  data: function data() {
    return {
      filterText: ''
    };
  },
  watch: {
    filterText: function filterText() {
      this.$events.fire('filter-set', this.filterText);
    }
  },
  methods: {
    resetFilter: function resetFilter() {
      this.filterText = '';
      this.$events.fire('filter-reset');
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/create.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__("./node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  i18n: __webpack_require__("./resources/assets/js/screens/products/i18n.js"),
  data: function data() {
    return {
      form: {
        name: '',
        manufacturer: '',
        "class": 'machine'
      },
      errors: [],
      success: false,
      manufacturers: [],
      show: true
    };
  },
  created: function created() {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_0_axios___default.a.get('/api/meta/manufacturers').then(function (response) {
      _this.manufacturers = response.data;
    });
  },
  methods: {
    onSubmit: function onSubmit(evt) {
      var _this2 = this;

      evt.preventDefault();
      __WEBPACK_IMPORTED_MODULE_0_axios___default.a.post('/api/products', this.form).then(function (response) {
        if (response.data.success) {
          _this2.$router.push('/products');
        }
      })["catch"](function (error) {
        _this2.errors = error.response.data.errors;
        _this2.success = false;
      });
    },
    onReset: function onReset(evt) {
      var _this3 = this;

      evt.preventDefault();
      this.clearForm();
      this.errors = [];
      this.success = true;
      /* Trick to reset/clear native browser form validation state */

      this.show = false;
      this.$nextTick(function () {
        _this3.show = true;
      });
    },
    clearForm: function clearForm() {
      for (var key in this.form) {
        this.form[key] = null;
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/edit.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__("./node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  i18n: __webpack_require__("./resources/assets/js/screens/products/i18n.js"),
  data: function data() {
    return {
      form: {
        name: '',
        manufacturer: ''
      },
      errors: [],
      success: false,
      manufacturers: [],
      show: true
    };
  },
  created: function created() {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_0_axios___default.a.get('/api/meta/manufacturers').then(function (response) {
      _this.manufacturers = response.data;
    });
    __WEBPACK_IMPORTED_MODULE_0_axios___default.a.get('/api/products/' + this.$route.params.id).then(function (response) {
      _this.form = response.data.data.attributes;
      _this.form.manufacturer = _this.form.manufacturer.attributes.id;
    });
  },
  methods: {
    onSubmit: function onSubmit(evt) {
      var _this2 = this;

      evt.preventDefault();
      __WEBPACK_IMPORTED_MODULE_0_axios___default.a.patch('/api/products/' + this.$route.params.id, this.form).then(function (response) {
        if (response.data.success) {
          _this2.$router.push('/products');
        }
      })["catch"](function (error) {
        console.log(error.response.data);
        _this2.errors = error.response.data.errors;
        _this2.success = false;
      });
    },
    onReset: function onReset(evt) {
      var _this3 = this;

      evt.preventDefault();
      this.errors = [];
      this.success = true;
      /* Trick to reset/clear native browser form validation state */

      this.show = false;
      this.$nextTick(function () {
        _this3.show = true;
      });
    },
    clearForm: function clearForm() {
      for (var key in this.form) {
        this.form[key] = null;
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/index.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fieldDefs_js__ = __webpack_require__("./resources/assets/js/screens/products/fieldDefs.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  i18n: __webpack_require__("./resources/assets/js/screens/products/i18n.js"),
  data: function data() {
    return {
      sortOrder: [{
        field: 'name',
        direction: 'asc'
      }],
      fields: Object(__WEBPACK_IMPORTED_MODULE_0__fieldDefs_js__["a" /* default */])(this.$i18n)
    };
  }
});

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/alert/alert.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _buttonClose = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button-close.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BAlert'; // @vue/component

var _default2 = {
  name: NAME,
  components: {
    BButtonClose: _buttonClose.default
  },
  model: {
    prop: 'show',
    event: 'input'
  },
  props: {
    variant: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'variant');
      }
    },
    dismissible: {
      type: Boolean,
      default: false
    },
    dismissLabel: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'dismissLabel');
      }
    },
    show: {
      type: [Boolean, Number],
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      countDownTimerId: null,
      dismissed: false,
      localShow: this.show,
      showClass: this.fade && this.show
    };
  },
  watch: {
    show: function show(newVal) {
      this.showChanged(newVal);
    },
    dismissed: function dismissed(newVal) {
      if (newVal) {
        this.localShow = false;
        this.$emit('dismissed');
      }
    }
  },
  mounted: function mounted() {
    this.showChanged(this.show);
  },
  destroyed
  /* istanbul ignore next */
  : function destroyed() {
    this.clearCounter();
  },
  methods: {
    dismiss: function dismiss() {
      this.clearCounter();

      if (typeof this.show === 'number') {
        this.$emit('dismiss-count-down', 0);
        this.$emit('input', 0);
      } else {
        this.$emit('input', false);
      }

      this.dismissed = true;
    },
    clearCounter: function clearCounter() {
      if (this.countDownTimerId) {
        clearInterval(this.countDownTimerId);
        this.countDownTimerId = null;
      }
    },
    showChanged: function showChanged(show) {
      var _this = this;

      // Reset counter status
      this.clearCounter(); // Reset dismiss status

      this.dismissed = false; // Set localShow state

      this.localShow = Boolean(show); // No timer for boolean values

      if (show === true || show === false || show === null || show === 0) {
        return;
      } // Start counter (ensure we have an integer value)


      var dismissCountDown = parseInt(show, 10) || 1;
      this.countDownTimerId = setInterval(function () {
        if (dismissCountDown < 1) {
          _this.dismiss();

          return;
        }

        dismissCountDown--;

        _this.$emit('dismiss-count-down', dismissCountDown);

        _this.$emit('input', dismissCountDown);
      }, 1000);
    },
    onBeforeEnter: function onBeforeEnter() {
      var _this2 = this;

      if (this.fade) {
        // Add show class one frame after inserted, to make transitions work
        (0, _dom.requestAF)(function () {
          _this2.showClass = true;
        });
      }
    },
    onBeforeLeave: function onBeforeLeave()
    /* istanbul ignore next: does not appear to be called in vue-test-utils */
    {
      this.showClass = false;
    }
  },
  render: function render(h) {
    var $slots = this.$slots;
    var $alert = h(false);

    if (this.localShow) {
      var $dismissBtn = h(false);

      if (this.dismissible) {
        $dismissBtn = h('b-button-close', {
          attrs: {
            'aria-label': this.dismissLabel
          },
          on: {
            click: this.dismiss
          }
        }, [$slots.dismiss]);
      }

      $alert = h('div', {
        staticClass: 'alert',
        class: _defineProperty({
          fade: this.fade,
          show: this.showClass,
          'alert-dismissible': this.dismissible
        }, "alert-".concat(this.variant), this.variant),
        attrs: {
          role: 'alert',
          'aria-live': 'polite',
          'aria-atomic': true
        }
      }, [$dismissBtn, $slots.default]);
      $alert = [$alert];
    }

    return h('transition', {
      props: {
        mode: 'out-in',
        // Disable use of built-in transition classes
        'enter-class': '',
        'enter-active-class': '',
        'enter-to-class': '',
        'leave-class': 'show',
        'leave-active-class': '',
        'leave-to-class': ''
      },
      on: {
        beforeEnter: this.onBeforeEnter,
        beforeLeave: this.onBeforeLeave
      }
    }, $alert);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/alert/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _alert = __webpack_require__("./node_modules/bootstrap-vue/es/components/alert/alert.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BAlert: _alert.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/badge/badge.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BBadge';
var linkProps = (0, _link.propsFactory)();
delete linkProps.href.default;
delete linkProps.to.default;

var props = _objectSpread({}, linkProps, {
  tag: {
    type: String,
    default: 'span'
  },
  variant: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'variant');
    }
  },
  pill: {
    type: Boolean,
    default: false
  } // @vue/component

});

exports.props = props;
var _default2 = {
  name: NAME,
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var tag = !props.href && !props.to ? props.tag : _link.default;
    var componentData = {
      staticClass: 'badge',
      class: ["badge-".concat(props.variant || (0, _config.getComponentConfig)(NAME, 'variant')), {
        'badge-pill': Boolean(props.pill),
        active: props.active,
        disabled: props.disabled
      }],
      props: (0, _pluckProps.default)(linkProps, props)
    };
    return h(tag, (0, _vueFunctionalDataMerge.mergeData)(data, componentData), children);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/badge/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _badge = __webpack_require__("./node_modules/bootstrap-vue/es/components/badge/badge.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BBadge: _badge.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-item.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _breadcrumbLink = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-link.js");

// @vue/component
var _default = {
  name: 'BBreadcrumbItem',
  functional: true,
  props: _breadcrumbLink.props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h('li', (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'breadcrumb-item',
      class: {
        active: props.active
      },
      attrs: {
        role: 'presentation'
      }
    }), [h(_breadcrumbLink.default, {
      props: props
    }, children)]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-link.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = _objectSpread({}, (0, _link.propsFactory)(), {
  text: {
    type: String,
    default: null
  },
  html: {
    type: String,
    default: null
  },
  ariaCurrent: {
    type: String,
    default: 'location'
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BBreadcrumbLink',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var suppliedProps = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var tag = suppliedProps.active ? 'span' : _link.default;
    var componentData = {
      props: (0, _pluckProps.default)(props, suppliedProps)
    };

    if (suppliedProps.active) {
      componentData.attrs = {
        'aria-current': suppliedProps.ariaCurrent
      };
    }

    if (!children) {
      componentData.domProps = (0, _html.htmlOrText)(suppliedProps.html, suppliedProps.text);
    }

    return h(tag, (0, _vueFunctionalDataMerge.mergeData)(data, componentData), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _toString = __webpack_require__("./node_modules/bootstrap-vue/es/utils/to-string.js");

var _breadcrumbItem = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-item.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var props = {
  items: {
    type: Array,
    default: null
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BBreadcrumb',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var childNodes = children; // Build child nodes from items if given.

    if ((0, _array.isArray)(props.items)) {
      var activeDefined = false;
      childNodes = props.items.map(function (item, idx) {
        if (_typeof(item) !== 'object') {
          item = {
            text: (0, _toString.default)(item)
          };
        } // Copy the value here so we can normalize it.


        var active = item.active;

        if (active) {
          activeDefined = true;
        }

        if (!active && !activeDefined) {
          // Auto-detect active by position in list.
          active = idx + 1 === props.items.length;
        }

        return h(_breadcrumbItem.default, {
          props: _objectSpread({}, item, {
            active: active
          })
        });
      });
    }

    return h('ol', (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'breadcrumb'
    }), childNodes);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/breadcrumb/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _breadcrumb = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb.js");

var _breadcrumbItem = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-item.js");

var _breadcrumbLink = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/breadcrumb-link.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BBreadcrumb: _breadcrumb.default,
  BBreadcrumbItem: _breadcrumbItem.default,
  BBreadcrumbLink: _breadcrumbLink.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button-group/button-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  vertical: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'div'
  },
  ariaRole: {
    type: String,
    default: 'group'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BButtonGroup',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: _defineProperty({
        'btn-group': !props.vertical,
        'btn-group-vertical': props.vertical
      }, "btn-group-".concat(props.size), Boolean(props.size)),
      attrs: {
        role: props.ariaRole
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button-group/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _buttonGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/button-group/button-group.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BButtonGroup: _buttonGroup.default,
  BBtnGroup: _buttonGroup.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button-toolbar/button-toolbar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var ITEM_SELECTOR = ['.btn:not(.disabled):not([disabled]):not(.dropdown-item)', '.form-control:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'input[type="checkbox"]:not(.disabled)', 'input[type="radio"]:not(.disabled)'].join(','); // @vue/component

var _default = {
  name: 'BButtonToolbar',
  props: {
    justify: {
      type: Boolean,
      default: false
    },
    keyNav: {
      type: Boolean,
      default: false
    }
  },
  mounted: function mounted() {
    if (this.keyNav) {
      // Pre-set the tabindexes if the markup does not include tabindex="-1" on the toolbar items
      this.getItems();
    }
  },
  methods: {
    onFocusin: function onFocusin(evt) {
      if (evt.target === this.$el) {
        evt.preventDefault();
        evt.stopPropagation();
        this.focusFirst(evt);
      }
    },
    stop: function stop(evt) {
      evt.preventDefault();
      evt.stopPropagation();
    },
    onKeydown: function onKeydown(evt) {
      if (!this.keyNav) {
        /* istanbul ignore next: should never happen */
        return;
      }

      var key = evt.keyCode;
      var shift = evt.shiftKey;

      if (key === _keyCodes.default.UP || key === _keyCodes.default.LEFT) {
        this.stop(evt);
        shift ? this.focusFirst(evt) : this.focusPrev(evt);
      } else if (key === _keyCodes.default.DOWN || key === _keyCodes.default.RIGHT) {
        this.stop(evt);
        shift ? this.focusLast(evt) : this.focusNext(evt);
      }
    },
    setItemFocus: function setItemFocus(item) {
      item && item.focus && item.focus();
    },
    focusFirst: function focusFirst(evt) {
      var items = this.getItems();
      this.setItemFocus(items[0]);
    },
    focusPrev: function focusPrev(evt) {
      var items = this.getItems();
      var index = items.indexOf(evt.target);

      if (index > -1) {
        items = items.slice(0, index).reverse();
        this.setItemFocus(items[0]);
      }
    },
    focusNext: function focusNext(evt) {
      var items = this.getItems();
      var index = items.indexOf(evt.target);

      if (index > -1) {
        items = items.slice(index + 1);
        this.setItemFocus(items[0]);
      }
    },
    focusLast: function focusLast(evt) {
      var items = this.getItems().reverse();
      this.setItemFocus(items[0]);
    },
    getItems: function getItems() {
      var items = (0, _dom.selectAll)(ITEM_SELECTOR, this.$el);
      items.forEach(function (item) {
        // Ensure tabfocus is -1 on any new elements
        item.tabIndex = -1;
      });
      return items.filter(function (el) {
        return (0, _dom.isVisible)(el);
      });
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'btn-toolbar',
      class: {
        'justify-content-between': this.justify
      },
      attrs: {
        role: 'toolbar',
        tabindex: this.keyNav ? '0' : null
      },
      on: this.keyNav ? {
        focusin: this.onFocusin,
        keydown: this.onKeydown
      } : {}
    }, [this.$slots.default]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button-toolbar/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _buttonToolbar = __webpack_require__("./node_modules/bootstrap-vue/es/components/button-toolbar/button-toolbar.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BButtonToolbar: _buttonToolbar.default,
  BBtnToolbar: _buttonToolbar.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button/button-close.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BButtonClose';
var props = {
  disabled: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'ariaLabel');
    }
  },
  textVariant: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'textVariant');
    }
  } // @vue/component

};
var _default2 = {
  name: NAME,
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        slots = _ref.slots;
    var componentData = {
      staticClass: 'close',
      class: _defineProperty({}, "text-".concat(props.textVariant), props.textVariant),
      attrs: {
        type: 'button',
        disabled: props.disabled,
        'aria-label': props.ariaLabel ? String(props.ariaLabel) : null
      },
      on: {
        click: function click(e) {
          // Ensure click on button HTML content is also disabled

          /* istanbul ignore if: bug in JSDOM still emits click on inner element */
          if (props.disabled && e instanceof Event) {
            e.stopPropagation();
            e.preventDefault();
          }
        }
      } // Careful not to override the default slot with innerHTML

    };

    if (!slots().default) {
      componentData.domProps = {
        innerHTML: '&times;'
      };
    }

    return h('button', (0, _vueFunctionalDataMerge.mergeData)(data, componentData), slots().default);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button/button.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BButton';
var btnProps = {
  block: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: null
  },
  variant: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'variant');
    }
  },
  type: {
    type: String,
    default: 'button'
  },
  tag: {
    type: String,
    default: 'button'
  },
  pressed: {
    // tri-state prop: true, false or null
    // => on, off, not a toggle
    type: Boolean,
    default: null
  }
};
var linkProps = (0, _link.propsFactory)();
delete linkProps.href.default;
delete linkProps.to.default;
var linkPropKeys = (0, _object.keys)(linkProps);

var props = _objectSpread({}, linkProps, btnProps); // Focus handler for toggle buttons.  Needs class of 'focus' when focused.


exports.props = props;

function handleFocus(evt) {
  if (evt.type === 'focusin') {
    (0, _dom.addClass)(evt.target, 'focus');
  } else if (evt.type === 'focusout') {
    (0, _dom.removeClass)(evt.target, 'focus');
  }
} // Helper functons to minimize runtime memory footprint when lots of buttons on page
// Is the requested button a link?


function isLink(props) {
  // If tag prop is set to `a`, we use a b-link to get proper disabled handling
  return Boolean(props.href || props.to || props.tag && String(props.tag).toLowerCase() === 'a');
} // Is the button to be a toggle button?


function isToggle(props) {
  return typeof props.pressed === 'boolean';
} // Is the button "really" a button?


function isButton(props) {
  if (isLink(props)) {
    return false;
  } else if (props.tag && String(props.tag).toLowerCase() !== 'button') {
    return false;
  }

  return true;
} // Is the requested tag not a button or link?


function isNonStandardTag(props) {
  return !isLink(props) && !isButton(props);
} // Compute required classes (non static classes)


function computeClass(props) {
  var _ref;

  return ["btn-".concat(props.variant || (0, _config.getComponentConfig)(NAME, 'variant')), (_ref = {}, _defineProperty(_ref, "btn-".concat(props.size), Boolean(props.size)), _defineProperty(_ref, 'btn-block', props.block), _defineProperty(_ref, "disabled", props.disabled), _defineProperty(_ref, "active", props.pressed), _ref)];
} // Compute the link props to pass to b-link (if required)


function computeLinkProps(props) {
  return isLink(props) ? (0, _pluckProps.default)(linkPropKeys, props) : null;
} // Compute the attributes for a button


function computeAttrs(props, data) {
  var button = isButton(props);
  var link = isLink(props);
  var toggle = isToggle(props);
  var nonStdTag = isNonStandardTag(props);
  var role = data.attrs && data.attrs['role'] ? data.attrs['role'] : null;
  var tabindex = data.attrs ? data.attrs['tabindex'] : null;

  if (nonStdTag) {
    tabindex = '0';
  }

  return {
    // Type only used for "real" buttons
    type: button && !link ? props.type : null,
    // Disabled only set on "real" buttons
    disabled: button ? props.disabled : null,
    // We add a role of button when the tag is not a link or button for ARIA.
    // Don't bork any role provided in data.attrs when isLink or isButton
    role: nonStdTag ? 'button' : role,
    // We set the aria-disabled state for non-standard tags
    'aria-disabled': nonStdTag ? String(props.disabled) : null,
    // For toggles, we need to set the pressed state for ARIA
    'aria-pressed': toggle ? String(props.pressed) : null,
    // autocomplete off is needed in toggle mode to prevent some browsers from
    // remembering the previous setting when using the back button.
    autocomplete: toggle ? 'off' : null,
    // Tab index is used when the component is not a button.
    // Links are tabbable, but don't allow disabled, while non buttons or links
    // are not tabbable, so we mimic that functionality by disabling tabbing
    // when disabled, and adding a tabindex of '0' to non buttons or non links.
    tabindex: props.disabled && !button ? '-1' : tabindex
  };
} // @vue/component


var _default2 = {
  name: NAME,
  functional: true,
  props: props,
  render: function render(h, _ref2) {
    var props = _ref2.props,
        data = _ref2.data,
        listeners = _ref2.listeners,
        children = _ref2.children;
    var toggle = isToggle(props);
    var link = isLink(props);
    var on = {
      click: function click(e) {
        /* istanbul ignore if: blink/button disabled should handle this */
        if (props.disabled && e instanceof Event) {
          e.stopPropagation();
          e.preventDefault();
        } else if (toggle && listeners && listeners['update:pressed']) {
          // Send .sync updates to any "pressed" prop (if .sync listeners)
          // Concat will normalize the value to an array
          // without double wrapping an array value in an array.
          (0, _array.concat)(listeners['update:pressed']).forEach(function (fn) {
            if (typeof fn === 'function') {
              fn(!props.pressed);
            }
          });
        }
      }
    };

    if (toggle) {
      on.focusin = handleFocus;
      on.focusout = handleFocus;
    }

    var componentData = {
      staticClass: 'btn',
      class: computeClass(props),
      props: computeLinkProps(props),
      attrs: computeAttrs(props, data),
      on: on
    };
    return h(link ? _link.default : props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, componentData), children);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/button/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _button = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button.js");

var _buttonClose = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button-close.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BButton: _button.default,
  BBtn: _button.default,
  BButtonClose: _buttonClose.default,
  BBtnClose: _buttonClose.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-body.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _prefixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/prefix-prop-name.js");

var _copyProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/copy-props.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _cardMixin = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/card-mixin.js");

var _cardTitle = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-title.js");

var _cardSubTitle = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-sub-title.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = _objectSpread({}, (0, _copyProps.default)(_cardMixin.default.props, _prefixPropName.default.bind(null, 'body')), {
  bodyClass: {
    type: [String, Object, Array],
    default: null
  }
}, _cardTitle.props, _cardSubTitle.props, {
  overlay: {
    type: Boolean,
    default: false
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BCardBody',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _ref2;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var cardTitle = h(false);
    var cardSubTitle = h(false);
    var cardContent = children || [h(false)];

    if (props.title) {
      cardTitle = h(_cardTitle.default, {
        props: (0, _pluckProps.default)(_cardTitle.props, props)
      });
    }

    if (props.subTitle) {
      cardSubTitle = h(_cardSubTitle.default, {
        props: (0, _pluckProps.default)(_cardSubTitle.props, props),
        class: ['mb-2']
      });
    }

    return h(props.bodyTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-body',
      class: [(_ref2 = {
        'card-img-overlay': props.overlay
      }, _defineProperty(_ref2, "bg-".concat(props.bodyBgVariant), Boolean(props.bodyBgVariant)), _defineProperty(_ref2, "border-".concat(props.bodyBorderVariant), Boolean(props.bodyBorderVariant)), _defineProperty(_ref2, "text-".concat(props.bodyTextVariant), Boolean(props.bodyTextVariant)), _ref2), props.bodyClass || {}]
    }), [cardTitle, cardSubTitle].concat(_toConsumableArray(cardContent)));
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-footer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _prefixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/prefix-prop-name.js");

var _copyProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/copy-props.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _cardMixin = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/card-mixin.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = _objectSpread({}, (0, _copyProps.default)(_cardMixin.default.props, _prefixPropName.default.bind(null, 'footer')), {
  footer: {
    type: String,
    default: null
  },
  footerHtml: {
    type: String,
    default: null
  },
  footerClass: {
    type: [String, Object, Array],
    default: null
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BCardFooter',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _ref2;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.footerTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-footer',
      class: [props.footerClass, (_ref2 = {}, _defineProperty(_ref2, "bg-".concat(props.footerBgVariant), Boolean(props.footerBgVariant)), _defineProperty(_ref2, "border-".concat(props.footerBorderVariant), Boolean(props.footerBorderVariant)), _defineProperty(_ref2, "text-".concat(props.footerTextVariant), Boolean(props.footerTextVariant)), _ref2)]
    }), children || [h('div', {
      domProps: (0, _html.htmlOrText)(props.footerHtml, props.footer)
    })]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  },
  deck: {
    type: Boolean,
    default: false
  },
  columns: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BCardGroup',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var baseClass = 'card-group';

    if (props.deck) {
      baseClass = 'card-deck';
    } else if (props.columns) {
      baseClass = 'card-columns';
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: baseClass
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-header.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _prefixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/prefix-prop-name.js");

var _copyProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/copy-props.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _cardMixin = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/card-mixin.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = _objectSpread({}, (0, _copyProps.default)(_cardMixin.default.props, _prefixPropName.default.bind(null, 'header')), {
  header: {
    type: String,
    default: null
  },
  headerHtml: {
    type: String,
    default: null
  },
  headerClass: {
    type: [String, Object, Array],
    default: null
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BCardHeader',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _ref2;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.headerTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-header',
      class: [props.headerClass, (_ref2 = {}, _defineProperty(_ref2, "bg-".concat(props.headerBgVariant), Boolean(props.headerBgVariant)), _defineProperty(_ref2, "border-".concat(props.headerBorderVariant), Boolean(props.headerBorderVariant)), _defineProperty(_ref2, "text-".concat(props.headerTextVariant), Boolean(props.headerTextVariant)), _ref2)]
    }), children || [h('div', {
      domProps: (0, _html.htmlOrText)(props.headerHtml, props.header)
    })]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-img-lazy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _imgLazy = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/img-lazy.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copy of `<b-img-lazy>` props, and remove conflicting/non-applicable props
// The `omit()` util creates a new object, so we can just pass the original props
var lazyProps = (0, _object.omit)(_imgLazy.default.props, ['left', 'right', 'center', 'block', 'rounded', 'thumbnail', 'fluid', 'fluidGrow']);

var props = _objectSpread({}, lazyProps, {
  top: {
    type: Boolean,
    default: false
  },
  bottom: {
    type: Boolean,
    default: false
  },
  left: {
    type: Boolean,
    default: false
  },
  start: {
    type: Boolean,
    default: false // alias of 'left'

  },
  right: {
    type: Boolean,
    default: false
  },
  end: {
    type: Boolean,
    default: false // alias of 'right'

  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BCardImgLazy',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    var baseClass = 'card-img';

    if (props.top) {
      baseClass += '-top';
    } else if (props.right || props.end) {
      baseClass += '-right';
    } else if (props.bottom) {
      baseClass += '-bottom';
    } else if (props.left || props.start) {
      baseClass += '-left';
    } // False out the left/center/right props before passing to b-img-lazy


    var lazyProps = _objectSpread({}, props, {
      left: false,
      right: false,
      center: false
    });

    return h(_imgLazy.default, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: [baseClass],
      props: lazyProps
    }));
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-img.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  src: {
    type: String,
    default: null,
    required: true
  },
  alt: {
    type: String,
    default: null
  },
  top: {
    type: Boolean,
    default: false
  },
  bottom: {
    type: Boolean,
    default: false
  },
  left: {
    type: Boolean,
    default: false
  },
  start: {
    type: Boolean,
    default: false // alias of 'left'

  },
  right: {
    type: Boolean,
    default: false
  },
  end: {
    type: Boolean,
    default: false // alias of 'right'

  },
  height: {
    type: String,
    default: null
  },
  width: {
    type: String,
    default: null
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BCardImg',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    var baseClass = 'card-img';

    if (props.top) {
      baseClass += '-top';
    } else if (props.right || props.end) {
      baseClass += '-right';
    } else if (props.bottom) {
      baseClass += '-bottom';
    } else if (props.left || props.start) {
      baseClass += '-left';
    }

    return h('img', (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: [baseClass],
      attrs: {
        src: props.src,
        alt: props.alt,
        height: props.height,
        width: props.width
      }
    }));
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-sub-title.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var NAME = 'BCardSubTitle';
var props = {
  subTitle: {
    type: String,
    default: ''
  },
  subTitleTag: {
    type: String,
    default: 'h6'
  },
  subTitleTextVariant: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'subTitleTextVariant');
    }
  } // @vue/component

};
exports.props = props;
var _default2 = {
  name: NAME,
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.subTitleTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-subtitle',
      class: [props.subTitleTextVariant ? "text-".concat(props.subTitleTextVariant) : null]
    }), children || props.subTitle);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  textTag: {
    type: String,
    default: 'p'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BCardText',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.textTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-text'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card-title.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  title: {
    type: String,
    default: ''
  },
  titleTag: {
    type: String,
    default: 'h4'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BCardTitle',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.titleTag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card-title'
    }), children || props.title);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/card.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _prefixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/prefix-prop-name.js");

var _unprefixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/unprefix-prop-name.js");

var _copyProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/copy-props.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _cardMixin = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/card-mixin.js");

var _cardBody = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-body.js");

var _cardHeader = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-header.js");

var _cardFooter = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-footer.js");

var _cardImg = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-img.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var cardImgProps = (0, _copyProps.default)(_cardImg.props, _prefixPropName.default.bind(null, 'img'));
cardImgProps.imgSrc.required = false;

var props = _objectSpread({}, _cardBody.props, _cardHeader.props, _cardFooter.props, cardImgProps, (0, _copyProps.default)(_cardMixin.default.props), {
  align: {
    type: String,
    default: null
  },
  noBody: {
    type: Boolean,
    default: false
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BCard',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots;
    var $slots = slots(); // Create placeholder elements for each section

    var imgFirst = h(false);
    var header = h(false);
    var content = h(false);
    var footer = h(false);
    var imgLast = h(false);

    if (props.imgSrc) {
      var img = h(_cardImg.default, {
        props: (0, _pluckProps.default)(cardImgProps, props, _unprefixPropName.default.bind(null, 'img'))
      });

      if (props.imgBottom) {
        imgLast = img;
      } else {
        imgFirst = img;
      }
    }

    if (props.header || $slots.header) {
      header = h(_cardHeader.default, {
        props: (0, _pluckProps.default)(_cardHeader.props, props)
      }, $slots.header);
    }

    if (props.noBody) {
      content = $slots.default || [];
    } else {
      // Wrap content in card-body
      content = [h(_cardBody.default, {
        props: (0, _pluckProps.default)(_cardBody.props, props)
      }, $slots.default)];
    }

    if (props.footer || $slots.footer) {
      footer = h(_cardFooter.default, {
        props: (0, _pluckProps.default)(_cardFooter.props, props)
      }, $slots.footer);
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'card',
      class: (_class = {
        'flex-row': props.imgLeft || props.imgStart,
        'flex-row-reverse': (props.imgRight || props.imgEnd) && !(props.imgLeft || props.imgStart)
      }, _defineProperty(_class, "text-".concat(props.align), Boolean(props.align)), _defineProperty(_class, "bg-".concat(props.bgVariant), Boolean(props.bgVariant)), _defineProperty(_class, "border-".concat(props.borderVariant), Boolean(props.borderVariant)), _defineProperty(_class, "text-".concat(props.textVariant), Boolean(props.textVariant)), _class)
    }), [imgFirst, header].concat(_toConsumableArray(content), [footer, imgLast]));
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/card/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _card = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card.js");

var _cardHeader = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-header.js");

var _cardBody = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-body.js");

var _cardTitle = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-title.js");

var _cardSubTitle = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-sub-title.js");

var _cardFooter = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-footer.js");

var _cardImg = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-img.js");

var _cardImgLazy = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-img-lazy.js");

var _cardText = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-text.js");

var _cardGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/card-group.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BCard: _card.default,
  BCardHeader: _cardHeader.default,
  BCardBody: _cardBody.default,
  BCardTitle: _cardTitle.default,
  BCardSubTitle: _cardSubTitle.default,
  BCardFooter: _cardFooter.default,
  BCardImg: _cardImg.default,
  BCardImgLazy: _cardImgLazy.default,
  BCardText: _cardText.default,
  BCardGroup: _cardGroup.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/carousel/carousel-slide.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _img = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/img.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

// @vue/component
var _default2 = {
  name: 'BCarouselSlide',
  components: {
    BImg: _img.default
  },
  mixins: [_id.default],
  inject: {
    bvCarousel: {
      default: function _default() {
        return {
          // Explicitly disable touch if not a child of carousel
          noTouch: true
        };
      }
    }
  },
  props: {
    imgSrc: {
      type: String // default: undefined

    },
    imgAlt: {
      type: String // default: undefined

    },
    imgWidth: {
      type: [Number, String] // default: undefined

    },
    imgHeight: {
      type: [Number, String] // default: undefined

    },
    imgBlank: {
      type: Boolean,
      default: false
    },
    imgBlankColor: {
      type: String,
      default: 'transparent'
    },
    contentVisibleUp: {
      type: String
    },
    contentTag: {
      type: String,
      default: 'div'
    },
    caption: {
      type: String
    },
    captionHtml: {
      type: String
    },
    captionTag: {
      type: String,
      default: 'h3'
    },
    text: {
      type: String
    },
    textHtml: {
      type: String
    },
    textTag: {
      type: String,
      default: 'p'
    },
    background: {
      type: String
    }
  },
  data: function data() {
    return {};
  },
  computed: {
    contentClasses: function contentClasses() {
      return [this.contentVisibleUp ? 'd-none' : '', this.contentVisibleUp ? "d-".concat(this.contentVisibleUp, "-block") : ''];
    },
    computedWidth: function computedWidth() {
      // Use local width, or try parent width
      return this.imgWidth || this.bvCarousel.imgWidth || null;
    },
    computedHeight: function computedHeight() {
      // Use local height, or try parent height
      return this.imgHeight || this.bvCarousel.imgHeight || null;
    }
  },
  render: function render(h) {
    var $slots = this.$slots;
    var noDrag = !this.bvCarousel.noTouch && _env.hasTouchSupport;
    var img = $slots.img;

    if (!img && (this.imgSrc || this.imgBlank)) {
      img = h('b-img', {
        props: {
          fluidGrow: true,
          block: true,
          src: this.imgSrc,
          blank: this.imgBlank,
          blankColor: this.imgBlankColor,
          width: this.computedWidth,
          height: this.computedHeight,
          alt: this.imgAlt
        },
        // Touch support event handler
        on: noDrag ? {
          dragstart: function dragstart(e) {
            /* istanbul ignore next: difficult to test in JSDOM */
            e.preventDefault();
          }
        } : {}
      });
    }

    if (!img) {
      img = h(false);
    }

    var content = h(this.contentTag, {
      staticClass: 'carousel-caption',
      class: this.contentClasses
    }, [this.caption || this.captionHtml ? h(this.captionTag, {
      domProps: (0, _html.htmlOrText)(this.captionHtml, this.caption)
    }) : h(false), this.text || this.textHtml ? h(this.textTag, {
      domProps: (0, _html.htmlOrText)(this.textHtml, this.text)
    }) : h(false), $slots.default]);
    return h('div', {
      staticClass: 'carousel-item',
      style: {
        background: this.background || this.bvCarousel.background || null
      },
      attrs: {
        id: this.safeId(),
        role: 'listitem'
      }
    }, [img, content]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/carousel/carousel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _observeDom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/observe-dom.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _noop = __webpack_require__("./node_modules/bootstrap-vue/es/utils/noop.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

// Slide directional classes
var DIRECTION = {
  next: {
    dirClass: 'carousel-item-left',
    overlayClass: 'carousel-item-next'
  },
  prev: {
    dirClass: 'carousel-item-right',
    overlayClass: 'carousel-item-prev'
  } // Fallback Transition duration (with a little buffer) in ms

};
var TRANS_DURATION = 600 + 50; // Time for mouse compat events to fire after touch

var TOUCH_EVENT_COMPAT_WAIT = 500; // Number of pixels to consider touch move a swipe

var SWIPE_THRESHOLD = 40; // PointerEvent pointer types

var PointerType = {
  TOUCH: 'touch',
  PEN: 'pen' // Transition Event names

};
var TransitionEndEvents = {
  WebkitTransition: 'webkitTransitionEnd',
  MozTransition: 'transitionend',
  OTransition: 'otransitionend oTransitionEnd',
  transition: 'transitionend'
};
var EventOptions = {
  passive: true,
  capture: false // Return the browser specific transitionEnd event name

};

function getTransitionEndEvent(el) {
  for (var name in TransitionEndEvents) {
    if (el.style[name] !== undefined) {
      return TransitionEndEvents[name];
    }
  } // fallback

  /* istanbul ignore next */


  return null;
} // @vue/component


var _default = {
  name: 'BCarousel',
  mixins: [_id.default],
  provide: function provide() {
    return {
      bvCarousel: this
    };
  },
  model: {
    prop: 'value',
    event: 'input'
  },
  props: {
    labelPrev: {
      type: String,
      default: 'Previous Slide'
    },
    labelNext: {
      type: String,
      default: 'Next Slide'
    },
    labelGotoSlide: {
      type: String,
      default: 'Goto Slide'
    },
    labelIndicators: {
      type: String,
      default: 'Select a slide to display'
    },
    interval: {
      type: Number,
      default: 5000
    },
    indicators: {
      type: Boolean,
      default: false
    },
    controls: {
      type: Boolean,
      default: false
    },
    noAnimation: {
      // Disable slide/fade animation
      type: Boolean,
      default: false
    },
    fade: {
      // Enable cross-fade animation instead of slide animation
      type: Boolean,
      default: false
    },
    noTouch: {
      // Sniffed by carousel-slide
      type: Boolean,
      default: false
    },
    noHoverPause: {
      // Disable pause on hover
      type: Boolean,
      default: false
    },
    imgWidth: {
      // Sniffed by carousel-slide
      type: [Number, String] // default: undefined

    },
    imgHeight: {
      // Sniffed by carousel-slide
      type: [Number, String] // default: undefined

    },
    background: {
      type: String // default: undefined

    },
    value: {
      type: Number,
      default: 0
    }
  },
  data: function data() {
    return {
      index: this.value || 0,
      isSliding: false,
      transitionEndEvent: null,
      slides: [],
      direction: null,
      isPaused: !(parseInt(this.interval, 10) > 0),
      // Touch event handling values
      touchStartX: 0,
      touchDeltaX: 0
    };
  },
  watch: {
    value: function value(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.setSlide(newVal);
      }
    },
    interval: function interval(newVal, oldVal) {
      if (newVal === oldVal) {
        /* istanbul ignore next */
        return;
      }

      if (!newVal) {
        // Pausing slide show
        this.pause(false);
      } else {
        // Restarting or Changing interval
        this.pause(true);
        this.start(false);
      }
    },
    isPaused: function isPaused(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit(newVal ? 'paused' : 'unpaused');
      }
    },
    index: function index(to, from) {
      if (to === from || this.isSliding) {
        /* istanbul ignore next */
        return;
      }

      this.doSlide(to, from);
    }
  },
  created: function created() {
    // Create private non-reactive props
    this._intervalId = null;
    this._animationTimeout = null;
    this._touchTimeout = null; // Set initial paused state

    this.isPaused = !(parseInt(this.interval, 10) > 0);
  },
  mounted: function mounted() {
    // Cache current browser transitionend event name
    this.transitionEndEvent = getTransitionEndEvent(this.$el) || null; // Get all slides

    this.updateSlides(); // Observe child changes so we can update slide list

    (0, _observeDom.default)(this.$refs.inner, this.updateSlides.bind(this), {
      subtree: false,
      childList: true,
      attributes: true,
      attributeFilter: ['id']
    });
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next: difficult to test */
  {
    clearTimeout(this._animationTimeout);
    clearTimeout(this._touchTimeout);
    clearInterval(this._intervalId);
    this._intervalId = null;
    this._animationTimeout = null;
    this._touchTimeout = null;
  },
  methods: {
    // Set slide
    setSlide: function setSlide(slide) {
      var _this = this;

      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // Don't animate when page is not visible

      /* istanbul ignore if: difficult to test */
      if (_env.inBrowser && document.visibilityState && document.hidden) {
        return;
      }

      var len = this.slides.length; // Don't do anything if nothing to slide to

      if (len === 0) {
        return;
      } // Don't change slide while transitioning, wait until transition is done


      if (this.isSliding) {
        // Schedule slide after sliding complete
        this.$once('sliding-end', function () {
          return _this.setSlide(slide, direction);
        });
        return;
      }

      this.direction = direction; // Make sure we have an integer (you never know!)

      slide = Math.floor(slide); // Set new slide index. Wrap around if necessary

      this.index = slide >= len ? 0 : slide >= 0 ? slide : len - 1;
    },
    // Previous slide
    prev: function prev() {
      this.setSlide(this.index - 1, 'prev');
    },
    // Next slide
    next: function next() {
      this.setSlide(this.index + 1, 'next');
    },
    // Pause auto rotation
    pause: function pause(evt) {
      if (!evt) {
        this.isPaused = true;
      }

      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    },
    // Start auto rotate slides
    start: function start(evt) {
      if (!evt) {
        this.isPaused = false;
      }
      /* istanbul ignore next: most likely will never happen, but just in case */


      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      } // Don't start if no interval, or less than 2 slides


      if (this.interval && this.slides.length > 1) {
        this._intervalId = setInterval(this.next, Math.max(1000, this.interval));
      }
    },
    // Restart auto rotate slides when focus/hover leaves the carousel
    restart: function restart(evt) {
      /* istanbul ignore if: difficult to test */
      if (!this.$el.contains(document.activeElement)) {
        this.start();
      }
    },
    doSlide: function doSlide(to, from) {
      var _this2 = this;

      var isCycling = Boolean(this.interval); // Determine sliding direction

      var direction = this.calcDirection(this.direction, from, to);
      var overlayClass = direction.overlayClass;
      var dirClass = direction.dirClass; // Determine current and next slides

      var currentSlide = this.slides[from];
      var nextSlide = this.slides[to]; // Don't do anything if there aren't any slides to slide to

      if (!currentSlide || !nextSlide) {
        /* istanbul ignore next */
        return;
      } // Start animating


      this.isSliding = true;

      if (isCycling) {
        this.pause(false);
      }

      this.$emit('sliding-start', to); // Update v-model

      this.$emit('input', this.index);

      if (this.noAnimation) {
        (0, _dom.addClass)(nextSlide, 'active');
        (0, _dom.removeClass)(currentSlide, 'active');
        this.isSliding = false; // Notify ourselves that we're done sliding (slid)

        this.$nextTick(function () {
          return _this2.$emit('sliding-end', to);
        });
      } else {
        (0, _dom.addClass)(nextSlide, overlayClass); // Trigger a reflow of next slide

        (0, _dom.reflow)(nextSlide);
        (0, _dom.addClass)(currentSlide, dirClass);
        (0, _dom.addClass)(nextSlide, dirClass); // Transition End handler

        var called = false;
        /* istanbul ignore next: difficult to test */

        var onceTransEnd = function onceTransEnd(evt) {
          if (called) {
            return;
          }

          called = true;
          /* istanbul ignore if: transition events cant be tested in JSDOM */

          if (_this2.transitionEndEvent) {
            var events = _this2.transitionEndEvent.split(/\s+/);

            events.forEach(function (evt) {
              return (0, _dom.eventOff)(currentSlide, evt, onceTransEnd, EventOptions);
            });
          }

          _this2._animationTimeout = null;
          (0, _dom.removeClass)(nextSlide, dirClass);
          (0, _dom.removeClass)(nextSlide, overlayClass);
          (0, _dom.addClass)(nextSlide, 'active');
          (0, _dom.removeClass)(currentSlide, 'active');
          (0, _dom.removeClass)(currentSlide, dirClass);
          (0, _dom.removeClass)(currentSlide, overlayClass);
          (0, _dom.setAttr)(currentSlide, 'aria-current', 'false');
          (0, _dom.setAttr)(nextSlide, 'aria-current', 'true');
          (0, _dom.setAttr)(currentSlide, 'aria-hidden', 'true');
          (0, _dom.setAttr)(nextSlide, 'aria-hidden', 'false');
          _this2.isSliding = false;
          _this2.direction = null; // Notify ourselves that we're done sliding (slid)

          _this2.$nextTick(function () {
            return _this2.$emit('sliding-end', to);
          });
        }; // Set up transitionend handler

        /* istanbul ignore if: transition events cant be tested in JSDOM */


        if (this.transitionEndEvent) {
          var events = this.transitionEndEvent.split(/\s+/);
          events.forEach(function (event) {
            return (0, _dom.eventOn)(currentSlide, event, onceTransEnd, EventOptions);
          });
        } // Fallback to setTimeout()


        this._animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);
      }

      if (isCycling) {
        this.start(false);
      }
    },
    // Update slide list
    updateSlides: function updateSlides() {
      this.pause(true); // Get all slides as DOM elements

      this.slides = (0, _dom.selectAll)('.carousel-item', this.$refs.inner);
      var numSlides = this.slides.length; // Keep slide number in range

      var index = Math.max(0, Math.min(Math.floor(this.index), numSlides - 1));
      this.slides.forEach(function (slide, idx) {
        var n = idx + 1;

        if (idx === index) {
          (0, _dom.addClass)(slide, 'active');
          (0, _dom.setAttr)(slide, 'aria-current', 'true');
        } else {
          (0, _dom.removeClass)(slide, 'active');
          (0, _dom.setAttr)(slide, 'aria-current', 'false');
        }

        (0, _dom.setAttr)(slide, 'aria-posinset', String(n));
        (0, _dom.setAttr)(slide, 'aria-setsize', String(numSlides));
      }); // Set slide as active

      this.setSlide(index);
      this.start(this.isPaused);
    },
    calcDirection: function calcDirection() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var curIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var nextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!direction) {
        return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;
      }

      return DIRECTION[direction];
    },
    handleClick: function handleClick(evt, fn) {
      var keyCode = evt.keyCode;

      if (evt.type === 'click' || keyCode === _keyCodes.default.SPACE || keyCode === _keyCodes.default.ENTER) {
        evt.preventDefault();
        evt.stopPropagation();
        fn();
      }
    },
    handleSwipe: function handleSwipe()
    /* istanbul ignore next: JSDOM doesn't support touch events */
    {
      var absDeltaX = Math.abs(this.touchDeltaX);

      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltaX / this.touchDeltaX;

      if (direction > 0) {
        // Swipe left
        this.prev();
      } else if (direction < 0) {
        // Swipe right
        this.next();
      }
    },
    touchStart: function touchStart(evt)
    /* istanbul ignore next: JSDOM doesn't support touch events */
    {
      if (_env.hasPointerEvent && PointerType[evt.pointerType.toUpperCase()]) {
        this.touchStartX = evt.clientX;
      } else if (!_env.hasPointerEvent) {
        this.touchStartX = evt.touches[0].clientX;
      }
    },
    touchMove: function touchMove(evt)
    /* istanbul ignore next: JSDOM doesn't support touch events */
    {
      // Ensure swiping with one touch and not pinching
      if (evt.touches && evt.touches.length > 1) {
        this.touchDeltaX = 0;
      } else {
        this.touchDeltaX = evt.touches[0].clientX - this.touchStartX;
      }
    },
    touchEnd: function touchEnd(evt)
    /* istanbul ignore next: JSDOM doesn't support touch events */
    {
      if (_env.hasPointerEvent && PointerType[evt.pointerType.toUpperCase()]) {
        this.touchDeltaX = evt.clientX - this.touchStartX;
      }

      this.handleSwipe(); // If it's a touch-enabled device, mouseenter/leave are fired as
      // part of the mouse compatibility events on first tap - the carousel
      // would stop cycling until user tapped out of it;
      // here, we listen for touchend, explicitly pause the carousel
      // (as if it's the second time we tap on it, mouseenter compat event
      // is NOT fired) and after a timeout (to allow for mouse compatibility
      // events to fire) we explicitly restart cycling

      this.pause(false);

      if (this._touchTimeout) {
        clearTimeout(this._touchTimeout);
      }

      this._touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + Math.max(1000, this.interval));
    }
  },
  render: function render(h) {
    var _this3 = this;

    // Wrapper for slides
    var inner = h('div', {
      ref: 'inner',
      class: ['carousel-inner'],
      attrs: {
        id: this.safeId('__BV_inner_'),
        role: 'list'
      }
    }, [this.$slots.default]); // Prev and next controls

    var controls = h(false);

    if (this.controls) {
      controls = [h('a', {
        class: ['carousel-control-prev'],
        attrs: {
          href: '#',
          role: 'button',
          'aria-controls': this.safeId('__BV_inner_')
        },
        on: {
          click: function click(evt) {
            _this3.handleClick(evt, _this3.prev);
          },
          keydown: function keydown(evt) {
            _this3.handleClick(evt, _this3.prev);
          }
        }
      }, [h('span', {
        class: ['carousel-control-prev-icon'],
        attrs: {
          'aria-hidden': 'true'
        }
      }), h('span', {
        class: ['sr-only']
      }, [this.labelPrev])]), h('a', {
        class: ['carousel-control-next'],
        attrs: {
          href: '#',
          role: 'button',
          'aria-controls': this.safeId('__BV_inner_')
        },
        on: {
          click: function click(evt) {
            _this3.handleClick(evt, _this3.next);
          },
          keydown: function keydown(evt) {
            _this3.handleClick(evt, _this3.next);
          }
        }
      }, [h('span', {
        class: ['carousel-control-next-icon'],
        attrs: {
          'aria-hidden': 'true'
        }
      }), h('span', {
        class: ['sr-only']
      }, [this.labelNext])])];
    } // Indicators


    var indicators = h('ol', {
      class: ['carousel-indicators'],
      directives: [{
        name: 'show',
        rawName: 'v-show',
        value: this.indicators,
        expression: 'indicators'
      }],
      attrs: {
        id: this.safeId('__BV_indicators_'),
        'aria-hidden': this.indicators ? 'false' : 'true',
        'aria-label': this.labelIndicators,
        'aria-owns': this.safeId('__BV_inner_')
      }
    }, this.slides.map(function (slide, n) {
      return h('li', {
        key: "slide_".concat(n),
        class: {
          active: n === _this3.index
        },
        attrs: {
          role: 'button',
          id: _this3.safeId("__BV_indicator_".concat(n + 1, "_")),
          tabindex: _this3.indicators ? '0' : '-1',
          'aria-current': n === _this3.index ? 'true' : 'false',
          'aria-label': "".concat(_this3.labelGotoSlide, " ").concat(n + 1),
          'aria-describedby': _this3.slides[n].id || null,
          'aria-controls': _this3.safeId('__BV_inner_')
        },
        on: {
          click: function click(evt) {
            _this3.handleClick(evt, function () {
              _this3.setSlide(n);
            });
          },
          keydown: function keydown(evt) {
            _this3.handleClick(evt, function () {
              _this3.setSlide(n);
            });
          }
        }
      });
    }));
    var on = {
      mouseenter: this.noHoverPause ? _noop.default : this.pause,
      mouseleave: this.noHoverPause ? _noop.default : this.restart,
      focusin: this.pause,
      focusout: this.restart,
      keydown: function keydown(evt) {
        if (/input|textarea/i.test(evt.target.tagName)) {
          /* istanbul ignore next */
          return;
        }

        var keyCode = evt.keyCode;

        if (keyCode === _keyCodes.default.LEFT || keyCode === _keyCodes.default.RIGHT) {
          evt.preventDefault();
          evt.stopPropagation();

          _this3[keyCode === _keyCodes.default.LEFT ? 'prev' : 'next']();
        }
      } // Touch support event handlers for environment

    };

    if (!this.noTouch && _env.hasTouchSupport) {
      // Attach appropriate listeners (passive mode)

      /* istanbul ignore next: JSDOM doesn't support touch events */
      if (_env.hasPointerEvent) {
        on['&pointerdown'] = this.touchStart;
        on['&pointerup'] = this.touchEnd;
      } else {
        on['&touchstart'] = this.touchStart;
        on['&touchmove'] = this.touchMove;
        on['&touchend'] = this.touchEnd;
      }
    } // Return the carousel


    return h('div', {
      staticClass: 'carousel',
      class: {
        slide: !this.noAnimation,
        'carousel-fade': !this.noAnimation && this.fade,
        'pointer-event': !this.noTouch && _env.hasTouchSupport && _env.hasPointerEvent
      },
      style: {
        background: this.background
      },
      attrs: {
        role: 'region',
        id: this.safeId(),
        'aria-busy': this.isSliding ? 'true' : 'false'
      },
      on: on
    }, [inner, controls, indicators]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/carousel/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _carousel = __webpack_require__("./node_modules/bootstrap-vue/es/components/carousel/carousel.js");

var _carouselSlide = __webpack_require__("./node_modules/bootstrap-vue/es/components/carousel/carousel-slide.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BCarousel: _carousel.default,
  BCarouselSlide: _carouselSlide.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/collapse/collapse.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _listenOnRoot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/listen-on-root.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

// Events we emit on $root
var EVENT_STATE = 'bv::collapse::state';
var EVENT_ACCORDION = 'bv::collapse::accordion'; // Events we listen to on $root

var EVENT_TOGGLE = 'bv::toggle::collapse'; // Event Listener options

var EventOptions = {
  passive: true,
  capture: false // @vue/component

};
var _default = {
  name: 'BCollapse',
  mixins: [_listenOnRoot.default],
  model: {
    prop: 'visible',
    event: 'input'
  },
  props: {
    id: {
      type: String,
      required: true
    },
    isNav: {
      type: Boolean,
      default: false
    },
    accordion: {
      type: String,
      default: null
    },
    visible: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'div'
    }
  },
  data: function data() {
    return {
      show: this.visible,
      transitioning: false
    };
  },
  computed: {
    classObject: function classObject() {
      return {
        'navbar-collapse': this.isNav,
        collapse: !this.transitioning,
        show: this.show && !this.transitioning
      };
    }
  },
  watch: {
    visible: function visible(newVal) {
      if (newVal !== this.show) {
        this.show = newVal;
      }
    },
    show: function show(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.emitState();
      }
    }
  },
  created: function created() {
    // Listen for toggle events to open/close us
    this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt); // Listen to other collapses for accordion events

    this.listenOnRoot(EVENT_ACCORDION, this.handleAccordionEvt);
  },
  mounted: function mounted() {
    if (this.isNav && _env.inBrowser) {
      // Set up handlers
      this.setWindowEvents(true);
      this.handleResize();
    }

    this.emitState();
  },
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    if (this.isNav && _env.inBrowser) {
      this.setWindowEvents(false);
    }
  },
  activated: function activated()
  /* istanbul ignore next */
  {
    if (this.isNav && _env.inBrowser) {
      this.setWindowEvents(true);
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    // Trigger state emit if needed
    this.show = false;

    if (this.isNav && _env.inBrowser) {
      this.setWindowEvents(false);
    }
  },
  methods: {
    setWindowEvents: function setWindowEvents(on) {
      var method = on ? _dom.eventOn : _dom.eventOff;
      method(window, 'resize', this.handleResize, EventOptions);
      method(window, 'orientationchange', this.handleResize, EventOptions);
    },
    toggle: function toggle() {
      this.show = !this.show;
    },
    onEnter: function onEnter(el) {
      el.style.height = 0;
      (0, _dom.reflow)(el);
      el.style.height = el.scrollHeight + 'px';
      this.transitioning = true; // This should be moved out so we can add cancellable events

      this.$emit('show');
    },
    onAfterEnter: function onAfterEnter(el) {
      el.style.height = null;
      this.transitioning = false;
      this.$emit('shown');
    },
    onLeave: function onLeave(el) {
      el.style.height = 'auto';
      el.style.display = 'block';
      el.style.height = (0, _dom.getBCR)(el).height + 'px';
      (0, _dom.reflow)(el);
      this.transitioning = true;
      el.style.height = 0; // This should be moved out so we can add cancellable events

      this.$emit('hide');
    },
    onAfterLeave: function onAfterLeave(el) {
      el.style.height = null;
      this.transitioning = false;
      this.$emit('hidden');
    },
    emitState: function emitState() {
      this.$emit('input', this.show); // Let v-b-toggle know the state of this collapse

      this.$root.$emit(EVENT_STATE, this.id, this.show);

      if (this.accordion && this.show) {
        // Tell the other collapses in this accordion to close
        this.$root.$emit(EVENT_ACCORDION, this.id, this.accordion);
      }
    },
    clickHandler: function clickHandler(evt) {
      // If we are in a nav/navbar, close the collapse when non-disabled link clicked
      var el = evt.target;

      if (!this.isNav || !el || (0, _dom.getCS)(this.$el).display !== 'block') {
        /* istanbul ignore next: can't test getComputedStyle in JSDOM */
        return;
      }

      if ((0, _dom.matches)(el, '.nav-link,.dropdown-item') || (0, _dom.closest)('.nav-link,.dropdown-item', el)) {
        this.show = false;
      }
    },
    handleToggleEvt: function handleToggleEvt(target) {
      if (target !== this.id) {
        return;
      }

      this.toggle();
    },
    handleAccordionEvt: function handleAccordionEvt(openedId, accordion) {
      if (!this.accordion || accordion !== this.accordion) {
        return;
      }

      if (openedId === this.id) {
        // Open this collapse if not shown
        if (!this.show) {
          this.toggle();
        }
      } else {
        // Close this collapse if shown
        if (this.show) {
          this.toggle();
        }
      }
    },
    handleResize: function handleResize() {
      // Handler for orientation/resize to set collapsed state in nav/navbar
      this.show = (0, _dom.getCS)(this.$el).display === 'block';
    }
  },
  render: function render(h) {
    var content = h(this.tag, {
      class: this.classObject,
      directives: [{
        name: 'show',
        value: this.show
      }],
      attrs: {
        id: this.id || null
      },
      on: {
        click: this.clickHandler
      }
    }, [this.$slots.default]);
    return h('transition', {
      props: {
        enterClass: '',
        enterActiveClass: 'collapsing',
        enterToClass: '',
        leaveClass: '',
        leaveActiveClass: 'collapsing',
        leaveToClass: ''
      },
      on: {
        enter: this.onEnter,
        afterEnter: this.onAfterEnter,
        leave: this.onLeave,
        afterLeave: this.onAfterLeave
      }
    }, [content]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/collapse/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _collapse = __webpack_require__("./node_modules/bootstrap-vue/es/components/collapse/collapse.js");

var _toggle = __webpack_require__("./node_modules/bootstrap-vue/es/directives/toggle/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BCollapse: _collapse.default
};
var plugins = {
  BToggleDirectivePlugin: _toggle.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-divider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BDropdownDivider',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'dropdown-divider',
      attrs: {
        role: 'separator'
      }
    }));
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-form.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form.js");

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'BDropdownForm',
  functional: true,
  props: _objectSpread({}, _form.props),
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(_form.default, (0, _vueFunctionalDataMerge.mergeData)(data, {
      props: props,
      staticClass: 'b-dropdown-form'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-header.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  id: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'h6'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BDropdownHeader',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'dropdown-header',
      attrs: {
        id: props.id || null
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-item-button.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  active: {
    type: Boolean,
    default: false
  },
  activeClass: {
    type: String,
    default: 'active'
  },
  disabled: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BDropdownItemButton',
  inject: {
    bvDropdown: {
      default: null
    }
  },
  props: props,
  methods: {
    closeDropdown: function closeDropdown() {
      if (this.bvDropdown) {
        this.bvDropdown.hide(true);
      }
    },
    onClick: function onClick(evt) {
      this.$emit('click', evt);
      this.closeDropdown();
    }
  },
  render: function render(h) {
    return h('button', {
      staticClass: 'dropdown-item',
      class: _defineProperty({}, this.activeClass, this.active),
      attrs: {
        role: 'menuitem',
        type: 'button',
        disabled: this.disabled
      },
      on: {
        click: this.onClick
      }
    }, this.$slots.default);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-item.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

var props = (0, _link.propsFactory)(); // @vue/component

exports.props = props;
var _default = {
  name: 'BDropdownItem',
  inject: {
    bvDropdown: {
      default: null
    }
  },
  props: props,
  methods: {
    closeDropdown: function closeDropdown() {
      if (this.bvDropdown) {
        this.bvDropdown.hide(true);
      }
    },
    onClick: function onClick(evt) {
      this.$emit('click', evt);
      this.closeDropdown();
    }
  },
  render: function render(h) {
    return h(_link.default, {
      props: this.$props,
      staticClass: 'dropdown-item',
      attrs: {
        role: 'menuitem'
      },
      on: {
        click: this.onClick
      }
    }, this.$slots.default);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _default = {
  name: 'BDropdownText',
  functional: true,
  props: {
    tag: {
      type: String,
      default: 'p'
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      props: props,
      staticClass: 'b-dropdown-text'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/dropdown.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/dropdown.js");

var _button = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button.js");

var NAME = 'BDropdown'; // @vue/component

var _default2 = {
  name: NAME,
  components: {
    BButton: _button.default
  },
  mixins: [_id.default, _dropdown.default],
  props: {
    toggleText: {
      // This really should be toggleLabel
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'toggleText');
      }
    },
    size: {
      type: String,
      default: null
    },
    variant: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'variant');
      }
    },
    menuClass: {
      type: [String, Array],
      default: null
    },
    toggleTag: {
      type: String,
      default: 'button'
    },
    toggleClass: {
      type: [String, Array],
      default: null
    },
    noCaret: {
      type: Boolean,
      default: false
    },
    split: {
      type: Boolean,
      default: false
    },
    splitHref: {
      type: String // default: undefined

    },
    splitTo: {
      type: [String, Object] // default: undefined

    },
    splitVariant: {
      type: String,
      default: null
    },
    role: {
      type: String,
      default: 'menu'
    },
    boundary: {
      // String: `scrollParent`, `window` or `viewport`
      // Object: HTML Element reference
      type: [String, Object],
      default: 'scrollParent'
    }
  },
  computed: {
    dropdownClasses: function dropdownClasses() {
      // Position `static` is needed to allow menu to "breakout" of the scrollParent boundaries
      // when boundary is anything other than `scrollParent`
      // See https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786
      var positionStatic = this.boundary !== 'scrollParent' || !this.boundary;
      var direction = '';

      if (this.dropup) {
        direction = 'dropup';
      } else if (this.dropright) {
        direction = 'dropright';
      } else if (this.dropleft) {
        direction = 'dropleft';
      }

      return ['btn-group', 'b-dropdown', 'dropdown', direction, {
        show: this.visible,
        'position-static': positionStatic
      }];
    },
    menuClasses: function menuClasses() {
      return ['dropdown-menu', {
        'dropdown-menu-right': this.right,
        show: this.visible
      }, this.menuClass];
    },
    toggleClasses: function toggleClasses() {
      return ['dropdown-toggle', {
        'dropdown-toggle-split': this.split,
        'dropdown-toggle-no-caret': this.noCaret && !this.split
      }, this.toggleClass];
    }
  },
  render: function render(h) {
    var split = h(false);

    if (this.split) {
      var btnProps = {
        disabled: this.disabled,
        variant: this.splitVariant || this.variant,
        size: this.size // We add these as needed due to router-link issues with defined property with undefined/null values

      };

      if (this.splitTo) {
        btnProps.to = this.splitTo;
      }

      if (this.splitHref) {
        btnProps.href = this.splitHref;
      }

      split = h('b-button', {
        ref: 'button',
        props: btnProps,
        attrs: {
          id: this.safeId('_BV_button_')
        },
        on: {
          click: this.click
        }
      }, [this.$slots['button-content'] || this.$slots.text || this.html || (0, _html.stripTags)(this.text)]);
    }

    var toggle = h('b-button', {
      ref: 'toggle',
      class: this.toggleClasses,
      props: {
        variant: this.variant,
        size: this.size,
        disabled: this.disabled,
        tag: this.toggleTag
      },
      attrs: {
        id: this.safeId('_BV_toggle_'),
        'aria-haspopup': 'true',
        'aria-expanded': this.visible ? 'true' : 'false'
      },
      on: {
        click: this.toggle,
        // click
        keydown: this.toggle // enter, space, down

      }
    }, [this.split ? h('span', {
      class: ['sr-only']
    }, [this.toggleText]) : this.$slots['button-content'] || this.$slots.text || this.html || (0, _html.stripTags)(this.text)]);
    var menu = h('div', {
      ref: 'menu',
      class: this.menuClasses,
      attrs: {
        role: this.role,
        tabindex: '-1',
        'aria-labelledby': this.safeId(this.split ? '_BV_button_' : '_BV_toggle_')
      },
      on: {
        mouseover: this.onMouseOver,
        keydown: this.onKeydown // tab, up, down, esc

      }
    }, [this.$slots.default]);
    return h('div', {
      attrs: {
        id: this.safeId()
      },
      class: this.dropdownClasses
    }, [split, toggle, menu]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/dropdown/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown.js");

var _dropdownItem = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-item.js");

var _dropdownItemButton = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-item-button.js");

var _dropdownHeader = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-header.js");

var _dropdownDivider = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-divider.js");

var _dropdownForm = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-form.js");

var _dropdownText = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/dropdown-text.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BDropdown: _dropdown.default,
  BDd: _dropdown.default,
  BDropdownItem: _dropdownItem.default,
  BDdItem: _dropdownItem.default,
  BDropdownItemButton: _dropdownItemButton.default,
  BDropdownItemBtn: _dropdownItemButton.default,
  BDdItemButton: _dropdownItemButton.default,
  BDdItemBtn: _dropdownItemButton.default,
  BDropdownHeader: _dropdownHeader.default,
  BDdHeader: _dropdownHeader.default,
  BDropdownDivider: _dropdownDivider.default,
  BDdDivider: _dropdownDivider.default,
  BDropdownForm: _dropdownForm.default,
  BDdForm: _dropdownForm.default,
  BDropdownText: _dropdownText.default,
  BDdText: _dropdownText.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/embed/embed.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  type: {
    type: String,
    default: 'iframe',
    validator: function validator(str) {
      return (0, _array.arrayIncludes)(['iframe', 'embed', 'video', 'object', 'img', 'b-img', 'b-img-lazy'], str);
    }
  },
  tag: {
    type: String,
    default: 'div'
  },
  aspect: {
    type: String,
    default: '16by9'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BEmbed',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, {
      ref: data.ref,
      staticClass: 'embed-responsive',
      class: _defineProperty({}, "embed-responsive-".concat(props.aspect), Boolean(props.aspect))
    }, [h(props.type, (0, _vueFunctionalDataMerge.mergeData)(data, {
      ref: '',
      staticClass: 'embed-responsive-item'
    }), children)]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/embed/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _embed = __webpack_require__("./node_modules/bootstrap-vue/es/components/embed/embed.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BEmbed: _embed.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-checkbox/form-checkbox-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formOptions = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-options.js");

var _formRadioCheckGroup = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-radio-check-group.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formCheckbox = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-checkbox/form-checkbox.js");

// @vue/component
var _default = {
  name: 'BFormCheckboxGroup',
  components: {
    BFormCheckbox: _formCheckbox.default
  },
  mixins: [_id.default, _form.default, _formRadioCheckGroup.default, // Includes render function
  _formOptions.default, _formSize.default, _formState.default],
  provide: function provide() {
    return {
      bvCheckGroup: this
    };
  },
  props: {
    switches: {
      // Custom switch styling
      type: Boolean,
      default: false
    },
    checked: {
      type: [String, Number, Object, Array, Boolean],
      default: null
    }
  },
  data: function data() {
    return {
      localChecked: this.checked || []
    };
  },
  computed: {
    is_RadioGroup: function is_RadioGroup() {
      return false;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-checkbox/form-checkbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _formRadioCheck = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-radio-check.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _looseIndexOf = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-index-of.js");

// @vue/component
var _default = {
  name: 'BFormCheckbox',
  mixins: [_formRadioCheck.default, // Includes shared render function
  _id.default, _form.default, _formSize.default, _formState.default],
  inject: {
    bvGroup: {
      from: 'bvCheckGroup',
      default: false
    }
  },
  props: {
    value: {
      // type: [Object, Boolean],
      default: true
    },
    uncheckedValue: {
      // type: [Object, Boolean],
      // Not applicable in multi-check mode
      default: false
    },
    indeterminate: {
      // Not applicable in multi-check mode
      type: Boolean,
      default: false
    },
    switch: {
      // Custom switch styling
      type: Boolean,
      default: false
    },
    checked: {
      // v-model
      type: [String, Number, Object, Array, Boolean],
      default: null
    }
  },
  computed: {
    is_Checked: function is_Checked() {
      var checked = this.computedLocalChecked;
      var value = this.value;

      if ((0, _array.isArray)(checked)) {
        return (0, _looseIndexOf.default)(checked, value) > -1;
      } else {
        return (0, _looseEqual.default)(checked, value);
      }
    },
    is_Radio: function is_Radio() {
      return false;
    },
    is_Check: function is_Check() {
      return true;
    }
  },
  watch: {
    computedLocalChecked: function computedLocalChecked(newVal, oldVal) {
      this.$emit('input', newVal);

      if (this.$refs && this.$refs.input) {
        this.$emit('update:indeterminate', this.$refs.input.indeterminate);
      }
    },
    indeterminate: function indeterminate(newVal, oldVal) {
      this.setIndeterminate(newVal);
    }
  },
  mounted: function mounted() {
    // Set initial indeterminate state
    this.setIndeterminate(this.indeterminate);
  },
  methods: {
    handleChange: function handleChange(_ref) {
      var _ref$target = _ref.target,
          checked = _ref$target.checked,
          indeterminate = _ref$target.indeterminate;
      var localChecked = this.computedLocalChecked;
      var value = this.value;
      var isArr = (0, _array.isArray)(localChecked);
      var uncheckedValue = isArr ? null : this.uncheckedValue; // Update computedLocalChecked

      if (isArr) {
        var idx = (0, _looseIndexOf.default)(localChecked, value);

        if (checked && idx < 0) {
          // Add value to array
          localChecked = localChecked.concat(value);
        } else if (!checked && idx > -1) {
          // Remove value from array
          localChecked = localChecked.slice(0, idx).concat(localChecked.slice(idx + 1));
        }
      } else {
        localChecked = checked ? value : uncheckedValue;
      }

      this.computedLocalChecked = localChecked; // Change is only emitted on user interaction

      this.$emit('change', checked ? value : uncheckedValue); // If this is a child of form-checkbox-group, we emit a change event on it as well

      if (this.is_Group) {
        this.bvGroup.$emit('change', localChecked);
      }

      this.$emit('update:indeterminate', indeterminate);
    },
    setIndeterminate: function setIndeterminate(state) {
      // Indeterminate only supported in single checkbox mode
      if ((0, _array.isArray)(this.computedLocalChecked)) {
        state = false;
      }

      if (this.$refs && this.$refs.input) {
        this.$refs.input.indeterminate = state; // Emit update event to prop

        this.$emit('update:indeterminate', state);
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-checkbox/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formCheckbox = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-checkbox/form-checkbox.js");

var _formCheckboxGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-checkbox/form-checkbox-group.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormCheckbox: _formCheckbox.default,
  BCheckbox: _formCheckbox.default,
  BCheck: _formCheckbox.default,
  BFormCheckboxGroup: _formCheckboxGroup.default,
  BCheckboxGroup: _formCheckboxGroup.default,
  BCheckGroup: _formCheckboxGroup.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-file/form-file.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formCustom = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-custom.js");

var _normalizeSlot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/normalize-slot.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var NAME = 'BFormFile'; // @vue/component

var _default2 = {
  name: NAME,
  mixins: [_id.default, _form.default, _formState.default, _formCustom.default, _normalizeSlot.default],
  model: {
    prop: 'value',
    event: 'input'
  },
  props: {
    value: {
      // type: Object,
      default: null
    },
    accept: {
      type: String,
      default: ''
    },
    // Instruct input to capture from camera
    capture: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'placeholder');
      }
    },
    browseText: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'browseText');
      }
    },
    dropPlaceholder: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'dropPlaceholder');
      }
    },
    multiple: {
      type: Boolean,
      default: false
    },
    directory: {
      type: Boolean,
      default: false
    },
    noTraverse: {
      type: Boolean,
      default: false
    },
    noDrop: {
      type: Boolean,
      default: false
    },
    fileNameFormatter: {
      type: Function,
      default: null
    }
  },
  data: function data() {
    return {
      selectedFile: null,
      dragging: false,
      hasFocus: false
    };
  },
  computed: {
    selectLabel: function selectLabel() {
      // Draging active
      if (this.dragging && this.dropPlaceholder) {
        return this.dropPlaceholder;
      } // No file chosen


      if (!this.selectedFile || this.selectedFile.length === 0) {
        return this.placeholder;
      } // Convert selectedFile to an array (if not already one)


      var files = (0, _array.concat)(this.selectedFile).filter(Boolean);

      if (this.hasNormalizedSlot('file-name')) {
        // There is a slot for formatting the files/names
        return [this.normalizeSlot('file-name', {
          files: files,
          names: files.map(function (f) {
            return f.name;
          })
        })];
      } else {
        // Use the user supplied formatter, or the built in one.
        return typeof this.fileNameFormatter === 'function' ? String(this.fileNameFormatter(files)) : files.map(function (file) {
          return file.name;
        }).join(', ');
      }
    }
  },
  watch: {
    selectedFile: function selectedFile(newVal, oldVal) {
      // The following test is needed when the file input is "reset" or the
      // exact same file(s) are selected to prevent an infinite loop.
      // When in `multiple` mode we need to check for two empty arrays or
      // two arrays with identical files
      if (newVal === oldVal || (0, _array.isArray)(newVal) && (0, _array.isArray)(oldVal) && newVal.length === oldVal.length && newVal.every(function (v, i) {
        return v === oldVal[i];
      })) {
        return;
      }

      if (!newVal && this.multiple) {
        this.$emit('input', []);
      } else {
        this.$emit('input', newVal);
      }
    },
    value: function value(newVal) {
      if (!newVal || (0, _array.isArray)(newVal) && newVal.length === 0) {
        this.reset();
      }
    }
  },
  methods: {
    focusHandler: function focusHandler(evt) {
      // Bootstrap v4 doesn't have focus styling for custom file input
      // Firefox has a '[type=file]:focus ~ sibling' selector issue,
      // so we add a 'focus' class to get around these bugs
      if (this.plain || evt.type === 'focusout') {
        this.hasFocus = false;
      } else {
        // Add focus styling for custom file input
        this.hasFocus = true;
      }
    },
    reset: function reset() {
      try {
        // Wrapped in try in case IE 11 craps out
        this.$refs.input.value = '';
      } catch (e) {} // IE 11 doesn't support setting `input.value` to '' or null
      // So we use this little extra hack to reset the value, just in case.
      // This also appears to work on modern browsers as well.


      this.$refs.input.type = '';
      this.$refs.input.type = 'file';
      this.selectedFile = this.multiple ? [] : null;
    },
    onFileChange: function onFileChange(evt) {
      var _this = this;

      // Always emit original event
      this.$emit('change', evt); // Check if special `items` prop is available on event (drop mode)
      // Can be disabled by setting no-traverse

      var items = evt.dataTransfer && evt.dataTransfer.items;
      /* istanbul ignore next: not supported in JSDOM */

      if (items && !this.noTraverse) {
        var queue = [];

        for (var i = 0; i < items.length; i++) {
          var item = items[i].webkitGetAsEntry();

          if (item) {
            queue.push(this.traverseFileTree(item));
          }
        }

        Promise.all(queue).then(function (filesArr) {
          _this.setFiles((0, _array.from)(filesArr));
        });
        return;
      } // Normal handling


      this.setFiles(evt.target.files || evt.dataTransfer.files);
    },
    setFiles: function setFiles() {
      var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (!files) {
        /* istanbul ignore next: this will probably not happen */
        this.selectedFile = null;
      } else if (this.multiple) {
        // Convert files to array
        var filesArray = [];

        for (var i = 0; i < files.length; i++) {
          filesArray.push(files[i]);
        } // Return file(s) as array


        this.selectedFile = filesArray;
      } else {
        // Return single file object
        this.selectedFile = files[0] || null;
      }
    },
    onReset: function onReset() {
      // Triggered when the parent form (if any) is reset
      this.selectedFile = this.multiple ? [] : null;
    },
    onDragover: function onDragover(evt)
    /* istanbul ignore next: difficult to test in JSDOM */
    {
      evt.preventDefault();
      evt.stopPropagation();

      if (this.noDrop || !this.custom) {
        return;
      }

      this.dragging = true;
      evt.dataTransfer.dropEffect = 'copy';
    },
    onDragleave: function onDragleave(evt)
    /* istanbul ignore next: difficult to test in JSDOM */
    {
      evt.preventDefault();
      evt.stopPropagation();
      this.dragging = false;
    },
    onDrop: function onDrop(evt)
    /* istanbul ignore next: difficult to test in JSDOM */
    {
      evt.preventDefault();
      evt.stopPropagation();

      if (this.noDrop) {
        return;
      }

      this.dragging = false;

      if (evt.dataTransfer.files && evt.dataTransfer.files.length > 0) {
        this.onFileChange(evt);
      }
    },
    traverseFileTree: function traverseFileTree(item, path)
    /* istanbul ignore next: not supported in JSDOM */
    {
      var _this2 = this;

      // Based on http://stackoverflow.com/questions/3590058
      return new Promise(function (resolve) {
        path = path || '';

        if (item.isFile) {
          // Get file
          item.file(function (file) {
            file.$path = path; // Inject $path to file obj

            resolve(file);
          });
        } else if (item.isDirectory) {
          // Get folder contents
          item.createReader().readEntries(function (entries) {
            var queue = [];

            for (var i = 0; i < entries.length; i++) {
              queue.push(_this2.traverseFileTree(entries[i], path + item.name + '/'));
            }

            Promise.all(queue).then(function (filesArr) {
              resolve((0, _array.from)(filesArr));
            });
          });
        }
      });
    }
  },
  render: function render(h) {
    // Form Input
    var input = h('input', {
      ref: 'input',
      class: [{
        'form-control-file': this.plain,
        'custom-file-input': this.custom,
        focus: this.custom && this.hasFocus
      }, this.stateClass],
      attrs: {
        type: 'file',
        id: this.safeId(),
        name: this.name,
        disabled: this.disabled,
        required: this.required,
        form: this.form || null,
        capture: this.capture || null,
        accept: this.accept || null,
        multiple: this.multiple,
        webkitdirectory: this.directory,
        'aria-required': this.required ? 'true' : null
      },
      on: {
        change: this.onFileChange,
        focusin: this.focusHandler,
        focusout: this.focusHandler,
        reset: this.onReset
      }
    });

    if (this.plain) {
      return input;
    } // Overlay Labels


    var label = h('label', {
      staticClass: 'custom-file-label',
      class: [this.dragging ? 'dragging' : null],
      attrs: {
        for: this.safeId(),
        'data-browse': this.browseText || null
      }
    }, this.selectLabel); // Return rendered custom file input

    return h('div', {
      staticClass: 'custom-file b-form-file',
      class: this.stateClass,
      attrs: {
        id: this.safeId('_BV_file_outer_')
      },
      on: {
        dragover: this.onDragover,
        dragleave: this.onDragleave,
        drop: this.onDrop
      }
    }, [input, label]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-file/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formFile = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-file/form-file.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormFile: _formFile.default,
  BFile: _formFile.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-group/form-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _upperFirst = __webpack_require__("./node_modules/bootstrap-vue/es/utils/upper-first.js");

var _memoize = __webpack_require__("./node_modules/bootstrap-vue/es/utils/memoize.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _formRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/form-row.js");

var _col = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/col.js");

var _formText = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-text.js");

var _formInvalidFeedback = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-invalid-feedback.js");

var _formValidFeedback = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-valid-feedback.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Selector for finding first input in the form-group
var SELECTOR = 'input:not(:disabled),textarea:not(:disabled),select:not(:disabled)'; // Memoize this function to return cached values to save time in computed functions

var makePropName = (0, _memoize.default)(function () {
  var breakpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var prefix = arguments.length > 1 ? arguments[1] : undefined;
  return "".concat(prefix).concat((0, _upperFirst.default)(breakpoint));
});
var DEPRECATED_MSG = 'Props "horizontal" and "breakpoint" are deprecated. Use "label-cols(-{breakpoint})" props instead.'; // render helper functions (here rather than polluting the instance with more methods)

function renderInvalidFeedback(h, ctx) {
  var content = ctx.$slots['invalid-feedback'] || ctx.invalidFeedback;
  var invalidFeedback = h(false);

  if (content) {
    invalidFeedback = h('b-form-invalid-feedback', {
      props: {
        id: ctx.invalidFeedbackId,
        // If state is explicitly false, always show the feedback
        state: ctx.computedState,
        tooltip: ctx.tooltip
      },
      attrs: {
        tabindex: content ? '-1' : null,
        role: 'alert',
        'aria-live': 'assertive',
        'aria-atomic': 'true'
      }
    }, [content]);
  }

  return invalidFeedback;
}

function renderValidFeedback(h, ctx) {
  var content = ctx.$slots['valid-feedback'] || ctx.validFeedback;
  var validFeedback = h(false);

  if (content) {
    validFeedback = h('b-form-valid-feedback', {
      props: {
        id: ctx.validFeedbackId,
        // If state is explicitly true, always show the feedback
        state: ctx.computedState,
        tooltip: ctx.tooltip
      },
      attrs: {
        tabindex: '-1',
        role: 'alert',
        'aria-live': 'assertive',
        'aria-atomic': 'true'
      }
    }, [content]);
  }

  return validFeedback;
}

function renderHelpText(h, ctx) {
  // Form help text (description)
  var content = ctx.$slots['description'] || ctx.description;
  var description = h(false);

  if (content) {
    description = h('b-form-text', {
      attrs: {
        id: ctx.descriptionId,
        tabindex: '-1'
      }
    }, [content]);
  }

  return description;
}

function renderLabel(h, ctx) {
  // render label/legend inside b-col if necessary
  var content = ctx.$slots['label'] || ctx.label;
  var labelFor = ctx.labelFor;
  var isLegend = !labelFor;
  var isHorizontal = ctx.isHorizontal;
  var labelTag = isLegend ? 'legend' : 'label';

  if (!content && !isHorizontal) {
    return h(false);
  } else if (ctx.labelSrOnly) {
    var label = h(false);

    if (content) {
      label = h(labelTag, {
        class: 'sr-only',
        attrs: {
          id: ctx.labelId,
          for: labelFor || null
        }
      }, [content]);
    }

    return h(isHorizontal ? 'b-col' : 'div', {
      props: isHorizontal ? ctx.labelColProps : {}
    }, [label]);
  } else {
    return h(isHorizontal ? 'b-col' : labelTag, {
      on: isLegend ? {
        click: ctx.legendClick
      } : {},
      props: isHorizontal ? _objectSpread({
        tag: labelTag
      }, ctx.labelColProps) : {},
      attrs: {
        id: ctx.labelId,
        for: labelFor || null,
        // We add a tab index to legend so that screen readers will properly read the aria-labelledby in IE.
        tabindex: isLegend ? '-1' : null
      },
      class: [// When horizontal or if a legend is rendered, add col-form-label for correct sizing
      // as Bootstrap has inconsitent font styling for legend in non-horiontal form-groups.
      // See: https://github.com/twbs/bootstrap/issues/27805
      isHorizontal || isLegend ? 'col-form-label' : '', // Emulate label padding top of 0 on legend when not horizontal
      !isHorizontal && isLegend ? 'pt-0' : '', // If not horizontal and not a legend, we add d-block to label so that label-align works
      !isHorizontal && !isLegend ? 'd-block' : '', ctx.labelSize ? "col-form-label-".concat(ctx.labelSize) : '', ctx.labelAlignClasses, ctx.labelClass]
    }, [content]);
  }
} //
// Async (lazy) component for BFormGroup
// Needed so that the breakpoint specific props can be computed once hte config is created
//


var _default = function _default(resolve, reject) {
  // Grab the current config for breakpoints
  var BREAKPOINTS = (0, _config.getBreakpointsUp)(); // Generate the labelCol breakpoint props

  var bpLabelColProps = BREAKPOINTS.reduce(function (props, breakpoint) {
    // i.e. label-cols, label-cols-sm, label-cols-md, ...
    props[makePropName(breakpoint, 'labelCols')] = {
      type: [Number, String, Boolean],
      default: breakpoint ? false : null
    };
    return props;
  }, (0, _object.create)(null)); // Generate the labelAlign breakpoint props

  var bpLabelAlignProps = BREAKPOINTS.reduce(function (props, breakpoint) {
    // label-align, label-align-sm, label-align-md, ...
    props[makePropName(breakpoint, 'labelAlign')] = {
      type: String,
      // left, right, center
      default: null
    };
    return props;
  }, (0, _object.create)(null)); // @vue/component

  var BFormGroup = {
    name: 'BFormGroup',
    components: {
      BFormRow: _formRow.default,
      BCol: _col.default,
      BFormInvalidFeedback: _formInvalidFeedback.default,
      BFormValidFeedback: _formValidFeedback.default,
      BFormText: _formText.default
    },
    mixins: [_id.default, _formState.default],
    props: _objectSpread({
      label: {
        type: String,
        default: null
      },
      labelFor: {
        type: String,
        default: null
      },
      labelSize: {
        type: String,
        default: null
      },
      labelSrOnly: {
        type: Boolean,
        default: false
      }
    }, bpLabelColProps, bpLabelAlignProps, {
      labelClass: {
        type: [String, Array, Object],
        default: null
      },
      description: {
        type: String,
        default: null
      },
      invalidFeedback: {
        type: String,
        default: null
      },
      validFeedback: {
        type: String,
        default: null
      },
      tooltip: {
        // Enable tooltip style feedback
        type: Boolean,
        default: false
      },
      validated: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      horizontal: {
        // Deprecated
        type: Boolean,
        default: false,
        deprecated: DEPRECATED_MSG
      },
      breakpoint: {
        // Deprecated (ignored if horizontal is not true)
        type: String,
        default: null,
        // legacy value 'sm',
        deprecated: DEPRECATED_MSG
      }
    }),
    computed: {
      labelColProps: function labelColProps() {
        var _this = this;

        var props = {};
        /* istanbul ignore next: deprecated */

        if (this.horizontal) {
          // Deprecated setting of horizontal/breakpoint props

          /* istanbul ignore next */
          (0, _warn.default)("b-form-group: ".concat(DEPRECATED_MSG)); // Legacy default is breakpoint sm and cols 3

          var bp = this.breakpoint || BREAKPOINTS[1]; // 'sm'

          var cols = parseInt(this.labelCols, 10) || 3;
          props[bp] = cols > 0 ? cols : 3; // We then return the single breakpoint prop for legacy compatability

          return props;
        }

        BREAKPOINTS.forEach(function (breakpoint) {
          // Grab the value if the label column breakpoint prop
          var propVal = _this[makePropName(breakpoint, 'labelCols')]; // Handle case where the prop's value is an empty string, which represents true


          propVal = propVal === '' ? true : propVal || false;

          if (typeof propVal !== 'boolean') {
            // Convert to column size to number
            propVal = parseInt(propVal, 10) || 0; // Ensure column size is greater than 0

            propVal = propVal > 0 ? propVal : false;
          }

          if (propVal) {
            // Add the prop to the list of props to give to b-col.
            // if breakpoint is '' (labelCols=true), then we use the col prop to make equal width at xs
            var bColPropName = breakpoint || (typeof propVal === 'boolean' ? 'col' : 'cols'); // Add it to the props

            props[bColPropName] = propVal;
          }
        });
        return props;
      },
      labelAlignClasses: function labelAlignClasses() {
        var _this2 = this;

        var classes = [];
        BREAKPOINTS.forEach(function (breakpoint) {
          // assemble the label column breakpoint align classes
          var propVal = _this2[makePropName(breakpoint, 'labelAlign')] || null;

          if (propVal) {
            var className = breakpoint ? "text-".concat(breakpoint, "-").concat(propVal) : "text-".concat(propVal);
            classes.push(className);
          }
        });
        return classes;
      },
      isHorizontal: function isHorizontal() {
        // Determine if the resultant form-group will be rendered
        // horizontal (meaning it has label-col breakpoints)
        return (0, _object.keys)(this.labelColProps).length > 0;
      },
      labelId: function labelId() {
        return this.$slots['label'] || this.label ? this.safeId('_BV_label_') : null;
      },
      descriptionId: function descriptionId() {
        return this.$slots['description'] || this.description ? this.safeId('_BV_description_') : null;
      },
      hasInvalidFeedback: function hasInvalidFeedback() {
        // used for computing aria-describedby
        var $slots = this.$slots;
        return this.computedState === false && ($slots['invalid-feedback'] || this.invalidFeedback);
      },
      invalidFeedbackId: function invalidFeedbackId() {
        return this.hasInvalidFeedback ? this.safeId('_BV_feedback_invalid_') : null;
      },
      hasValidFeedback: function hasValidFeedback() {
        // used for computing aria-describedby
        return this.computedState === true && (this.$slots['valid-feedback'] || this.validFeedback);
      },
      validFeedbackId: function validFeedbackId() {
        return this.hasValidFeedback ? this.safeId('_BV_feedback_valid_') : null;
      },
      describedByIds: function describedByIds() {
        // Screen readers will read out any content linked to by aria-describedby
        // even if the content is hidden with 'display: none', hence we only include
        // feedback IDs if the form-group's state is explicitly valid or invalid.
        return [this.descriptionId, this.invalidFeedbackId, this.validFeedbackId].filter(function (i) {
          return i;
        }).join(' ') || null;
      }
    },
    watch: {
      describedByIds: function describedByIds(add, remove) {
        if (add !== remove) {
          this.setInputDescribedBy(add, remove);
        }
      }
    },
    mounted: function mounted() {
      var _this3 = this;

      this.$nextTick(function () {
        // Set the adia-describedby IDs on the input specified by label-for
        // We do this in a nextTick to ensure the children have finished rendering
        _this3.setInputDescribedBy(_this3.describedByIds);
      });
    },
    methods: {
      legendClick: function legendClick(evt) {
        if (this.labelFor) {
          // don't do anything if labelFor is set

          /* istanbul ignore next: clicking a label will focus the input, so no need to test */
          return;
        }

        var tagName = evt.target ? evt.target.tagName : '';

        if (/^(input|select|textarea|label|button|a)$/i.test(tagName)) {
          // If clicked an interactive element inside legend, we just let the default happen

          /* istanbul ignore next */
          return;
        }

        var inputs = (0, _dom.selectAll)(SELECTOR, this.$refs.content).filter(_dom.isVisible);

        if (inputs && inputs.length === 1 && inputs[0].focus) {
          // if only a single input, focus it, emulating label behaviour
          inputs[0].focus();
        }
      },
      setInputDescribedBy: function setInputDescribedBy(add, remove) {
        // Sets the `aria-describedby` attribute on the input if label-for is set.
        // Optionally accepts a string of IDs to remove as the second parameter
        if (this.labelFor && typeof document !== 'undefined') {
          var input = (0, _dom.select)("#".concat(this.labelFor), this.$refs.content);

          if (input) {
            var adb = 'aria-describedby';
            var ids = ((0, _dom.getAttr)(input, adb) || '').split(/\s+/);
            remove = (remove || '').split(/\s+/); // Update ID list, preserving any original IDs

            ids = ids.filter(function (id) {
              return !(0, _array.arrayIncludes)(remove, id);
            }).concat(add || '').join(' ').trim();

            if (ids) {
              (0, _dom.setAttr)(input, adb, ids);
            } else {
              // No IDs, so remove the attribute
              (0, _dom.removeAttr)(input, adb);
            }
          }
        }
      }
    },
    render: function render(h) {
      var isFieldset = !this.labelFor;
      var isHorizontal = this.isHorizontal; // Generate the label

      var label = renderLabel(h, this); // Generate the content

      var content = h(isHorizontal ? 'b-col' : 'div', {
        ref: 'content',
        attrs: {
          tabindex: isFieldset ? '-1' : null,
          role: isFieldset ? 'group' : null,
          'aria-labelledby': isFieldset ? this.labelId : null,
          'aria-describedby': isFieldset ? this.ariaDescribedBy : null
        }
      }, [this.$slots['default'] || h(false), renderInvalidFeedback(h, this), renderValidFeedback(h, this), renderHelpText(h, this)]); // Create the form-group

      var data = {
        staticClass: 'form-group',
        class: [this.validated ? 'was-validated' : null, this.stateClass],
        attrs: {
          id: this.safeId(),
          disabled: isFieldset ? this.disabled : null,
          role: isFieldset ? null : 'group',
          'aria-invalid': this.computedState === false ? 'true' : null,
          'aria-labelledby': this.labelId || null,
          'aria-describedby': this.describedByIds || null
        } // Return it wrapped in a form-group.
        // Note: fieldsets do not support adding `row` or `form-row` directly to them
        // due to browser specific render issues, so we move the form-row to an
        // inner wrapper div when horizontal and using a fieldset

      };
      return h(isFieldset ? 'fieldset' : isHorizontal ? 'b-form-row' : 'div', data, isHorizontal && isFieldset ? [h('b-form-row', {}, [label, content])] : [label, content]);
    }
  }; // Return the componwent options reference

  resolve(BFormGroup);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-group/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-group/form-group.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormGroup: _formGroup.default,
  BFormFieldset: _formGroup.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-input/form-input.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formText = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-text.js");

var _formSelection = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-selection.js");

var _formValidity = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-validity.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Valid supported input types
var TYPES = ['text', 'password', 'email', 'number', 'url', 'tel', 'search', 'range', 'color', 'date', 'time', 'datetime', 'datetime-local', 'month', 'week']; // @vue/component

var _default = {
  name: 'BFormInput',
  mixins: [_id.default, _form.default, _formSize.default, _formState.default, _formText.default, _formSelection.default, _formValidity.default],
  props: {
    // value prop defined in form-text mixin
    // value: { },
    type: {
      type: String,
      default: 'text',
      validator: function validator(type) {
        return (0, _array.arrayIncludes)(TYPES, type);
      }
    },
    noWheel: {
      // Disable mousewheel to prevent wheel from changing values (i.e. number/date).
      type: Boolean,
      default: false
    },
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: {
      type: [String, Number],
      default: null
    },
    list: {
      type: String,
      default: null
    }
  },
  computed: {
    localType: function localType() {
      // We only allow certain types
      return (0, _array.arrayIncludes)(TYPES, this.type) ? this.type : 'text';
    }
  },
  watch: {
    noWheel: function noWheel(newVal) {
      this.setWheelStopper(newVal);
    }
  },
  mounted: function mounted() {
    this.setWheelStopper(this.noWheel);
  },
  deactivated: function deactivated() {
    // Turn off listeners when keep-alive component deactivated

    /* istanbul ignore next */
    this.setWheelStopper(false);
  },
  activated: function activated() {
    // Turn on listeners (if no-wheel) when keep-alive component activated

    /* istanbul ignore next */
    this.setWheelStopper(this.noWheel);
  },
  beforeDestroy: function beforeDestroy() {
    /* istanbul ignore next */
    this.setWheelStopper(false);
  },
  methods: {
    setWheelStopper: function setWheelStopper(on) {
      var input = this.$el; // We use native events, so that we don't interfere with propgation

      if (on) {
        (0, _dom.eventOn)(input, 'focus', this.onWheelFocus);
        (0, _dom.eventOn)(input, 'blur', this.onWheelBlur);
      } else {
        (0, _dom.eventOff)(input, 'focus', this.onWheelFocus);
        (0, _dom.eventOff)(input, 'blur', this.onWheelBlur);
        (0, _dom.eventOff)(document, 'wheel', this.stopWheel);
      }
    },
    onWheelFocus: function onWheelFocus(evt) {
      (0, _dom.eventOn)(document, 'wheel', this.stopWheel);
    },
    onWheelBlur: function onWheelBlur(evt) {
      (0, _dom.eventOff)(document, 'wheel', this.stopWheel);
    },
    stopWheel: function stopWheel(evt) {
      evt.preventDefault();
      this.$el.blur();
    }
  },
  render: function render(h) {
    var self = this;
    return h('input', {
      ref: 'input',
      class: self.computedClass,
      directives: [{
        name: 'model',
        rawName: 'v-model',
        value: self.localValue,
        expression: 'localValue'
      }],
      attrs: {
        id: self.safeId(),
        name: self.name,
        form: self.form || null,
        type: self.localType,
        disabled: self.disabled,
        placeholder: self.placeholder,
        required: self.required,
        autocomplete: self.autocomplete || null,
        readonly: self.readonly || self.plaintext,
        min: self.min,
        max: self.max,
        step: self.step,
        list: self.localType !== 'password' ? self.list : null,
        'aria-required': self.required ? 'true' : null,
        'aria-invalid': self.computedAriaInvalid
      },
      domProps: {
        value: self.localValue
      },
      on: _objectSpread({}, self.$listeners, {
        input: self.onInput,
        change: self.onChange,
        blur: self.onBlur
      })
    });
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-input/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formInput = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-input/form-input.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormInput: _formInput.default,
  BInput: _formInput.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-radio/form-radio-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formOptions = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-options.js");

var _formRadioCheckGroup = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-radio-check-group.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formRadio = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-radio/form-radio.js");

// @vue/component
var _default = {
  name: 'BFormRadioGroup',
  components: {
    BFormRadio: _formRadio.default
  },
  mixins: [_id.default, _form.default, _formRadioCheckGroup.default, // Includes render function
  _formOptions.default, _formSize.default, _formState.default],
  provide: function provide() {
    return {
      bvRadioGroup: this
    };
  },
  props: {
    checked: {
      type: [String, Object, Number, Boolean],
      default: null
    }
  },
  data: function data() {
    return {
      localChecked: this.checked
    };
  },
  computed: {
    is_RadioGroup: function is_RadioGroup() {
      return true;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-radio/form-radio.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formRadioCheck = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-radio-check.js");

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

// @vue/component
var _default = {
  name: 'BFormRadio',
  mixins: [_id.default, _formRadioCheck.default, // Includes shared render function
  _form.default, _formSize.default, _formState.default],
  inject: {
    bvGroup: {
      from: 'bvRadioGroup',
      default: false
    }
  },
  props: {
    checked: {
      // v-model
      type: [String, Object, Number, Boolean],
      default: null
    }
  },
  computed: {
    // Radio Groups can only have a single value, so determining if checked is simple
    is_Checked: function is_Checked() {
      return (0, _looseEqual.default)(this.value, this.computedLocalChecked);
    },
    // Flags for form-radio-check mixin
    is_Radio: function is_Radio() {
      return true;
    },
    is_Check: function is_Check() {
      return false;
    }
  },
  watch: {
    // Radio Groups can only have a single value, so our watchers are simple
    computedLocalChecked: function computedLocalChecked(newVal, oldVal) {
      this.$emit('input', this.computedLocalChecked);
    }
  },
  methods: {
    handleChange: function handleChange(_ref) {
      var checked = _ref.target.checked;
      var value = this.value;
      this.computedLocalChecked = value; // Change is only emitted on user interaction

      this.$emit('change', checked ? value : null); // If this is a child of form-radio-group, we emit a change event on it as well

      if (this.is_Group) {
        this.bvGroup.$emit('change', checked ? value : null);
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-radio/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formRadio = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-radio/form-radio.js");

var _formRadioGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-radio/form-radio-group.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormRadio: _formRadio.default,
  BRadio: _formRadio.default,
  BFormRadioGroup: _formRadioGroup.default,
  BRadioGroup: _formRadioGroup.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-select/form-select.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _formOptions = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-options.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formCustom = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-custom.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BFormSelect',
  mixins: [_id.default, _form.default, _formSize.default, _formState.default, _formCustom.default, _formOptions.default],
  model: {
    prop: 'value',
    event: 'input'
  },
  props: {
    value: {// type: [Object, Array, String, Number, Boolean],
      // default: undefined
    },
    multiple: {
      type: Boolean,
      default: false
    },
    selectSize: {
      // Browsers default size to 0, which shows 4 rows in most browsers in multiple mode
      // Size of 1 can bork out Firefox
      type: Number,
      default: 0
    },
    ariaInvalid: {
      type: [Boolean, String],
      default: false
    }
  },
  data: function data() {
    return {
      localValue: this.value
    };
  },
  computed: {
    computedSelectSize: function computedSelectSize() {
      // Custom selects with a size of zero causes the arrows to be hidden,
      // so dont render the size attribute in this case
      return !this.plain && this.selectSize === 0 ? null : this.selectSize;
    },
    inputClass: function inputClass() {
      return [this.plain ? 'form-control' : 'custom-select', this.size && this.plain ? "form-control-".concat(this.size) : null, this.size && !this.plain ? "custom-select-".concat(this.size) : null, this.stateClass];
    },
    computedAriaInvalid: function computedAriaInvalid() {
      if (this.ariaInvalid === true || this.ariaInvalid === 'true') {
        return 'true';
      }

      return this.stateClass === 'is-invalid' ? 'true' : null;
    }
  },
  watch: {
    value: function value(newVal, oldVal) {
      this.localValue = newVal;
    },
    localValue: function localValue(newVal, oldVal) {
      this.$emit('input', this.localValue);
    }
  },
  methods: {
    focus: function focus() {
      this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input.blur();
    }
  },
  render: function render(h) {
    var _this = this;

    var $slots = this.$slots;
    var options = this.formOptions.map(function (option, index) {
      return h('option', {
        key: "option_".concat(index, "_opt"),
        attrs: {
          disabled: Boolean(option.disabled)
        },
        domProps: _objectSpread({}, (0, _html.htmlOrText)(option.html, option.text), {
          value: option.value
        })
      });
    });
    return h('select', {
      ref: 'input',
      class: this.inputClass,
      directives: [{
        name: 'model',
        rawName: 'v-model',
        value: this.localValue,
        expression: 'localValue'
      }],
      attrs: {
        id: this.safeId(),
        name: this.name,
        form: this.form || null,
        multiple: this.multiple || null,
        size: this.computedSelectSize,
        disabled: this.disabled,
        required: this.required,
        'aria-required': this.required ? 'true' : null,
        'aria-invalid': this.computedAriaInvalid
      },
      on: {
        change: function change(evt) {
          var target = evt.target;
          var selectedVal = (0, _array.from)(target.options).filter(function (o) {
            return o.selected;
          }).map(function (o) {
            return '_value' in o ? o._value : o.value;
          });
          _this.localValue = target.multiple ? selectedVal : selectedVal[0];

          _this.$nextTick(function () {
            _this.$emit('change', _this.localValue);
          });
        }
      }
    }, [$slots.first, options, $slots.default]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-select/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formSelect = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-select/form-select.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormSelect: _formSelect.default,
  BSelect: _formSelect.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-textarea/form-textarea.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form.js");

var _formSize = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-size.js");

var _formState = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-state.js");

var _formText = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-text.js");

var _formSelection = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-selection.js");

var _formValidity = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-validity.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BFormTextarea',
  mixins: [_id.default, _form.default, _formSize.default, _formState.default, _formText.default, _formSelection.default, _formValidity.default],
  props: {
    rows: {
      type: [Number, String],
      default: 2
    },
    maxRows: {
      type: [Number, String],
      default: null
    },
    wrap: {
      // 'soft', 'hard' or 'off'. Browser default is 'soft'
      type: String,
      default: 'soft'
    },
    noResize: {
      // Disable the resize handle of textarea
      type: Boolean,
      default: false
    },
    noAutoShrink: {
      // When in auto resize mode, disable shrinking to content height
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      dontResize: true
    };
  },
  computed: {
    computedStyle: function computedStyle() {
      var styles = {
        // Setting `noResize` to true will disable the ability for the user to
        // manually resize the textarea. We also disable when in auto resize mode
        resize: !this.computedRows || this.noResize ? 'none' : null
      };

      if (!this.computedRows) {
        // The computed height for auto resize.
        // We avoid setting the style to null, which can override user manual resize.
        styles.height = this.computedHeight;
      }

      return styles;
    },
    computedMinRows: function computedMinRows() {
      // Ensure rows is at least 2 and positive (2 is the native textarea value).
      // A value of 1 can cause issues in some browsers, and most browsers only support
      // 2 as the smallest value.
      return Math.max(parseInt(this.rows, 10) || 2, 2);
    },
    computedMaxRows: function computedMaxRows() {
      return Math.max(this.computedMinRows, parseInt(this.maxRows, 10) || 0);
    },
    computedRows: function computedRows() {
      // This is used to set the attribute 'rows' on the textarea.
      // If auto-resize is enabled, then we return null as we use CSS to control height.
      return this.computedMinRows === this.computedMaxRows ? this.computedMinRows : null;
    },
    computedHeight: function computedHeight()
    /* istanbul ignore next: can't test getComputedProperties */
    {
      // We compare `computedRows` and `localValue` to `true`, a value
      // they both can't have at any time, to ensure reactivity
      if (this.$isServer || this.dontResize || this.computedRows === true || this.localValue === true) {
        return null;
      }

      var el = this.$el; // Element must be visible (not hidden) and in document
      // *Must* be checked after above checks

      if (!(0, _dom.isVisible)(el)) {
        return null;
      } // Remember old height (includes `px` units) and reset it temporarily to `auto`


      var oldHeight = el.style.height;
      el.style.height = 'auto'; // Get current computed styles

      var computedStyle = (0, _dom.getCS)(el); // Height of one line of text in px

      var lineHeight = parseFloat(computedStyle.lineHeight); // Minimum height for min rows (browser dependant)

      var minHeight = parseInt(computedStyle.height, 10) || lineHeight * this.computedMinRows; // Calculate height of content

      var offset = (parseFloat(computedStyle.borderTopWidth) || 0) + (parseFloat(computedStyle.borderBottomWidth) || 0) + (parseFloat(computedStyle.paddingTop) || 0) + (parseFloat(computedStyle.paddingBottom) || 0); // Calculate content height in "rows"

      var contentRows = Math.max((el.scrollHeight - offset) / lineHeight, 2); // Calculate number of rows to display (limited within min/max rows)

      var rows = Math.min(Math.max(contentRows, this.computedMinRows), this.computedMaxRows); // Calculate the required height of the textarea including border and padding (in pixels)

      var height = Math.max(Math.ceil(rows * lineHeight + offset), minHeight); // Place old height back on element, just in case this computed prop returns the same value

      el.style.height = oldHeight; // Value of previous height (without px units appended)

      var oldHeightPx = parseFloat(oldHeight) || 0;

      if (this.noAutoShrink && oldHeightPx > height) {
        // Computed height remains the larger of oldHeight and new height
        // When height is `sticky` (no-auto-shrink is true)
        return oldHeight;
      } // Return the new computed height in px units


      return "".concat(height, "px");
    }
  },
  mounted: function mounted() {
    var _this = this;

    // Enable opt-in resizing once mounted
    this.$nextTick(function () {
      _this.dontResize = false;
    });
  },
  activated: function activated() {
    var _this2 = this;

    // If we are being re-activated in <keep-alive>, enable opt-in resizing
    this.$nextTick(function () {
      _this2.dontResize = false;
    });
  },
  deactivated: function deactivated() {
    // If we are in a deactivated <keep-alive>, disable opt-in resizing
    this.dontResize = true;
  },
  beforeDestroy: function beforeDestroy() {
    /* istanbul ignore next */
    this.dontResize = true;
  },
  render: function render(h) {
    // Using self instead of this helps reduce code size during minification
    var self = this;
    return h('textarea', {
      ref: 'input',
      class: self.computedClass,
      style: self.computedStyle,
      directives: [{
        name: 'model',
        rawName: 'v-model',
        value: self.localValue,
        expression: 'localValue'
      }],
      attrs: {
        id: self.safeId(),
        name: self.name,
        form: self.form || null,
        disabled: self.disabled,
        placeholder: self.placeholder,
        required: self.required,
        autocomplete: self.autocomplete || null,
        readonly: self.readonly || self.plaintext,
        rows: self.computedRows,
        wrap: self.wrap || null,
        'aria-required': self.required ? 'true' : null,
        'aria-invalid': self.computedAriaInvalid
      },
      domProps: {
        value: self.localValue
      },
      on: _objectSpread({}, self.$listeners, {
        input: self.onInput,
        change: self.onChange,
        blur: self.onBlur
      })
    });
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form-textarea/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formTextarea = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-textarea/form-textarea.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BFormTextarea: _formTextarea.default,
  BTextarea: _formTextarea.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form-datalist.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formOptions = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/form-options.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BFormDatalist',
  mixins: [_formOptions.default],
  props: {
    id: {
      type: String,
      default: null,
      required: true
    }
  },
  render: function render(h) {
    var options = this.formOptions.map(function (option, index) {
      return h('option', {
        key: "option_".concat(index, "_opt"),
        attrs: {
          disabled: option.disabled
        },
        domProps: _objectSpread({}, (0, _html.htmlOrText)(option.html, option.text), {
          value: option.value
        })
      });
    });
    return h('datalist', {
      attrs: {
        id: this.id
      }
    }, [options, this.$slots.default]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form-invalid-feedback.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  id: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'div'
  },
  tooltip: {
    type: Boolean,
    default: false
  },
  forceShow: {
    type: Boolean,
    default: false
  },
  state: {
    type: [Boolean, String],
    default: null
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BFormInvalidFeedback',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var show = props.forceShow === true || props.state === false || props.state === 'invalid';
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        'invalid-feedback': !props.tooltip,
        'invalid-tooltip': props.tooltip,
        'd-block': show
      },
      attrs: {
        id: props.id
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _formRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/form-row.js");

var _default = _formRow.default;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BFormText';
var props = {
  id: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'small'
  },
  textVariant: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'textVariant');
    }
  },
  inline: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default2 = {
  name: NAME,
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: _defineProperty({
        'form-text': !props.inline
      }, "text-".concat(props.textVariant), Boolean(props.textVariant)),
      attrs: {
        id: props.id
      }
    }), children);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form-valid-feedback.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  id: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'div'
  },
  tooltip: {
    type: Boolean,
    default: false
  },
  forceShow: {
    type: Boolean,
    default: false
  },
  state: {
    type: [Boolean, String],
    default: null
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BFormValidFeedback',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var show = props.forceShow === true || props.state === true || props.state === 'valid';
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        'valid-feedback': !props.tooltip,
        'valid-tooltip': props.tooltip,
        'd-block': show
      },
      attrs: {
        id: props.id
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/form.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  id: {
    type: String,
    default: null
  },
  inline: {
    type: Boolean,
    default: false
  },
  novalidate: {
    type: Boolean,
    default: false
  },
  validated: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BForm',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h('form', (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        'form-inline': props.inline,
        'was-validated': props.validated
      },
      attrs: {
        id: props.id,
        novalidate: props.novalidate
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/form/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form.js");

var _formDatalist = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-datalist.js");

var _formRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-row.js");

var _formText = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-text.js");

var _formInvalidFeedback = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-invalid-feedback.js");

var _formValidFeedback = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form-valid-feedback.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BForm: _form.default,
  BFormDatalist: _formDatalist.default,
  BDatalist: _formDatalist.default,
  BFormRow: _formRow.default,
  BFormText: _formText.default,
  BFormInvalidFeedback: _formInvalidFeedback.default,
  BFormFeedback: _formInvalidFeedback.default,
  BFormValidFeedback: _formValidFeedback.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/image/img-lazy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _img = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/img.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var NAME = 'BImgLazy';
var THROTTLE = 100;
var EventOptions = {
  passive: true,
  capture: false // @vue/component

};
var _default2 = {
  name: NAME,
  components: {
    BImg: _img.default
  },
  props: {
    src: {
      type: String,
      default: null,
      required: true
    },
    alt: {
      type: String,
      default: null
    },
    width: {
      type: [Number, String],
      default: null
    },
    height: {
      type: [Number, String],
      default: null
    },
    blankSrc: {
      // If null, a blank image is generated
      type: String,
      default: null
    },
    blankColor: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'blankColor');
      }
    },
    blankWidth: {
      type: [Number, String],
      default: null
    },
    blankHeight: {
      type: [Number, String],
      default: null
    },
    show: {
      type: Boolean,
      default: false
    },
    fluid: {
      type: Boolean,
      default: false
    },
    fluidGrow: {
      type: Boolean,
      default: false
    },
    block: {
      type: Boolean,
      default: false
    },
    thumbnail: {
      type: Boolean,
      default: false
    },
    rounded: {
      type: [Boolean, String],
      default: false
    },
    left: {
      type: Boolean,
      default: false
    },
    right: {
      type: Boolean,
      default: false
    },
    center: {
      type: Boolean,
      default: false
    },
    offset: {
      type: [Number, String],
      default: 360
    },
    throttle: {
      type: [Number, String],
      default: THROTTLE
    }
  },
  data: function data() {
    return {
      isShown: false,
      scrollTimeout: null
    };
  },
  computed: {
    computedSrc: function computedSrc() {
      return !this.blankSrc || this.isShown ? this.src : this.blankSrc;
    },
    computedBlank: function computedBlank() {
      return !(this.isShown || this.blankSrc);
    },
    computedWidth: function computedWidth() {
      return this.isShown ? this.width : this.blankWidth || this.width;
    },
    computedHeight: function computedHeight() {
      return this.isShown ? this.height : this.blankHeight || this.height;
    }
  },
  watch: {
    show: function show(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.isShown = newVal;

        if (!newVal) {
          // Make sure listeners are re-enabled if img is force set to blank
          this.setListeners(true);
        }
      }
    },
    isShown: function isShown(newVal, oldVal) {
      if (newVal !== oldVal) {
        // Update synched show prop
        this.$emit('update:show', newVal);
      }
    }
  },
  created: function created() {
    this.isShown = this.show;
  },
  mounted: function mounted() {
    if (this.isShown) {
      this.setListeners(false);
    } else {
      this.setListeners(true);
      this.$nextTick(this.checkView);
    }
  },
  activated: function activated()
  /* istanbul ignore next */
  {
    if (!this.isShown) {
      this.setListeners(true);
      this.$nextTick(this.checkView);
    }
  },
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    this.setListeners(false);
  },
  beforeDestroy: function beforeDestroy() {
    this.setListeners(false);
  },
  methods: {
    setListeners: function setListeners(on) {
      if (this.scrollTimeout) {
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = null;
      }

      var root = window;

      if (on) {
        (0, _dom.eventOn)(this.$el, 'load', this.checkView);
        (0, _dom.eventOn)(root, 'scroll', this.onScroll, EventOptions);
        (0, _dom.eventOn)(root, 'resize', this.onScroll, EventOptions);
        (0, _dom.eventOn)(root, 'orientationchange', this.onScroll, EventOptions);
        (0, _dom.eventOn)(document, 'transitionend', this.onScroll, EventOptions);
      } else {
        (0, _dom.eventOff)(this.$el, 'load', this.checkView);
        (0, _dom.eventOff)(root, 'scroll', this.onScroll, EventOptions);
        (0, _dom.eventOff)(root, 'resize', this.onScroll, EventOptions);
        (0, _dom.eventOff)(root, 'orientationchange', this.onScroll, EventOptions);
        (0, _dom.eventOff)(document, 'transitionend', this.onScroll, EventOptions);
      }
    },
    checkView: function checkView() {
      // check bounding box + offset to see if we should show
      if (this.isShown) {
        this.setListeners(false);
        return;
      }

      var offset = parseInt(this.offset, 10) || 0;
      var docElement = document.documentElement;
      var view = {
        l: 0 - offset,
        t: 0 - offset,
        b: docElement.clientHeight + offset,
        r: docElement.clientWidth + offset
        /* istanbul ignore next */

      };
      var box = (0, _dom.getBCR)(this.$el);
      /* istanbul ignore next: can't test getBoundingClientRect in JSDOM */

      if (box.right >= view.l && box.bottom >= view.t && box.left <= view.r && box.top <= view.b) {
        // image is in view (or about to be in view)
        this.isShown = true;
        this.setListeners(false);
      }
    },
    onScroll: function onScroll() {
      if (this.isShown) {
        this.setListeners(false);
      } else {
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout(this.checkView, parseInt(this.throttle, 10) || THROTTLE);
      }
    }
  },
  render: function render(h) {
    return h('b-img', {
      props: {
        src: this.computedSrc,
        alt: this.alt,
        blank: this.computedBlank,
        blankColor: this.blankColor,
        width: this.computedWidth,
        height: this.computedHeight,
        fluid: this.fluid,
        fluidGrow: this.fluidGrow,
        block: this.block,
        thumbnail: this.thumbnail,
        rounded: this.rounded,
        left: this.left,
        right: this.right,
        center: this.center
      }
    });
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/image/img.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BImg'; // Blank image with fill template

var BLANK_TEMPLATE = '<svg width="%{w}" height="%{h}" ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'viewBox="0 0 %{w} %{h}" preserveAspectRatio="none">' + '<rect width="100%" height="100%" style="fill:%{f};"></rect>' + '</svg>';

function makeBlankImgSrc(width, height, color) {
  var src = encodeURIComponent(BLANK_TEMPLATE.replace('%{w}', String(width)).replace('%{h}', String(height)).replace('%{f}', color));
  return "data:image/svg+xml;charset=UTF-8,".concat(src);
}

var props = {
  src: {
    type: String,
    default: null
  },
  alt: {
    type: String,
    default: null
  },
  width: {
    type: [Number, String],
    default: null
  },
  height: {
    type: [Number, String],
    default: null
  },
  block: {
    type: Boolean,
    default: false
  },
  fluid: {
    type: Boolean,
    default: false
  },
  fluidGrow: {
    // Gives fluid images class `w-100` to make them grow to fit container
    type: Boolean,
    default: false
  },
  rounded: {
    // rounded can be:
    //   false: no rounding of corners
    //   true: slightly rounded corners
    //   'top': top corners rounded
    //   'right': right corners rounded
    //   'bottom': bottom corners rounded
    //   'left': left corners rounded
    //   'circle': circle/oval
    //   '0': force rounding off
    type: [Boolean, String],
    default: false
  },
  thumbnail: {
    type: Boolean,
    default: false
  },
  left: {
    type: Boolean,
    default: false
  },
  right: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  blank: {
    type: Boolean,
    default: false
  },
  blankColor: {
    type: String,
    default: function _default() {
      return (0, _config.getComponentConfig)(NAME, 'blankColor');
    }
  } // @vue/component

};
exports.props = props;
var _default2 = {
  name: 'BImg',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data;
    var src = props.src;
    var width = parseInt(props.width, 10) ? parseInt(props.width, 10) : null;
    var height = parseInt(props.height, 10) ? parseInt(props.height, 10) : null;
    var align = null;
    var block = props.block;

    if (props.blank) {
      if (!height && Boolean(width)) {
        height = width;
      } else if (!width && Boolean(height)) {
        width = height;
      }

      if (!width && !height) {
        width = 1;
        height = 1;
      } // Make a blank SVG image


      src = makeBlankImgSrc(width, height, props.blankColor || 'transparent');
    }

    if (props.left) {
      align = 'float-left';
    } else if (props.right) {
      align = 'float-right';
    } else if (props.center) {
      align = 'mx-auto';
      block = true;
    }

    return h('img', (0, _vueFunctionalDataMerge.mergeData)(data, {
      attrs: {
        src: src,
        alt: props.alt,
        width: width ? String(width) : null,
        height: height ? String(height) : null
      },
      class: (_class = {
        'img-thumbnail': props.thumbnail,
        'img-fluid': props.fluid || props.fluidGrow,
        'w-100': props.fluidGrow,
        rounded: props.rounded === '' || props.rounded === true
      }, _defineProperty(_class, "rounded-".concat(props.rounded), typeof props.rounded === 'string' && props.rounded !== ''), _defineProperty(_class, align, Boolean(align)), _defineProperty(_class, 'd-block', block), _class)
    }));
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/image/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _img = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/img.js");

var _imgLazy = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/img-lazy.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BImg: _img.default,
  BImgLazy: _imgLazy.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _alert = __webpack_require__("./node_modules/bootstrap-vue/es/components/alert/index.js");

exports.Alert = _alert.default;

var _badge = __webpack_require__("./node_modules/bootstrap-vue/es/components/badge/index.js");

exports.Badge = _badge.default;

var _breadcrumb = __webpack_require__("./node_modules/bootstrap-vue/es/components/breadcrumb/index.js");

exports.Breadcrumb = _breadcrumb.default;

var _button = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/index.js");

exports.Button = _button.default;

var _buttonGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/button-group/index.js");

exports.ButtonGroup = _buttonGroup.default;

var _buttonToolbar = __webpack_require__("./node_modules/bootstrap-vue/es/components/button-toolbar/index.js");

exports.ButtonToolbar = _buttonToolbar.default;

var _inputGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/index.js");

exports.InputGroup = _inputGroup.default;

var _card = __webpack_require__("./node_modules/bootstrap-vue/es/components/card/index.js");

exports.Card = _card.default;

var _carousel = __webpack_require__("./node_modules/bootstrap-vue/es/components/carousel/index.js");

exports.Carousel = _carousel.default;

var _layout = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/index.js");

exports.Layout = _layout.default;

var _collapse = __webpack_require__("./node_modules/bootstrap-vue/es/components/collapse/index.js");

exports.Collapse = _collapse.default;

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/index.js");

exports.Dropdown = _dropdown.default;

var _embed = __webpack_require__("./node_modules/bootstrap-vue/es/components/embed/index.js");

exports.Embed = _embed.default;

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/index.js");

exports.Form = _form.default;

var _formGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-group/index.js");

exports.FormGroup = _formGroup.default;

var _formCheckbox = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-checkbox/index.js");

exports.FormCheckbox = _formCheckbox.default;

var _formRadio = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-radio/index.js");

exports.FormRadio = _formRadio.default;

var _formInput = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-input/index.js");

exports.FormInput = _formInput.default;

var _formTextarea = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-textarea/index.js");

exports.FormTextarea = _formTextarea.default;

var _formFile = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-file/index.js");

exports.FormFile = _formFile.default;

var _formSelect = __webpack_require__("./node_modules/bootstrap-vue/es/components/form-select/index.js");

exports.FormSelect = _formSelect.default;

var _image = __webpack_require__("./node_modules/bootstrap-vue/es/components/image/index.js");

exports.Image = _image.default;

var _jumbotron = __webpack_require__("./node_modules/bootstrap-vue/es/components/jumbotron/index.js");

exports.Jumbotron = _jumbotron.default;

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/index.js");

exports.Link = _link.default;

var _listGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/list-group/index.js");

exports.ListGroup = _listGroup.default;

var _media = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/index.js");

exports.Media = _media.default;

var _modal = __webpack_require__("./node_modules/bootstrap-vue/es/components/modal/index.js");

exports.Modal = _modal.default;

var _nav = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/index.js");

exports.Nav = _nav.default;

var _navbar = __webpack_require__("./node_modules/bootstrap-vue/es/components/navbar/index.js");

exports.Navbar = _navbar.default;

var _pagination = __webpack_require__("./node_modules/bootstrap-vue/es/components/pagination/index.js");

exports.Pagination = _pagination.default;

var _paginationNav = __webpack_require__("./node_modules/bootstrap-vue/es/components/pagination-nav/index.js");

exports.PaginationNav = _paginationNav.default;

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/components/popover/index.js");

exports.Popover = _popover.default;

var _progress = __webpack_require__("./node_modules/bootstrap-vue/es/components/progress/index.js");

exports.Progress = _progress.default;

var _spinner = __webpack_require__("./node_modules/bootstrap-vue/es/components/spinner/index.js");

exports.Spinner = _spinner.default;

var _table = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/index.js");

exports.Table = _table.default;

var _tabs = __webpack_require__("./node_modules/bootstrap-vue/es/components/tabs/index.js");

exports.Tabs = _tabs.default;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/components/tooltip/index.js");

exports.Tooltip = _tooltip.default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _inputGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group.js");

var _inputGroupAddon = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-addon.js");

var _inputGroupPrepend = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-prepend.js");

var _inputGroupAppend = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-append.js");

var _inputGroupText = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-text.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BInputGroup: _inputGroup.default,
  BInputGroupAddon: _inputGroupAddon.default,
  BInputGroupPrepend: _inputGroupPrepend.default,
  BInputGroupAppend: _inputGroupAppend.default,
  BInputGroupText: _inputGroupText.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/input-group-addon.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.commonProps = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _inputGroupText = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-text.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var commonProps = {
  id: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: 'div'
  },
  isText: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.commonProps = commonProps;
var _default = {
  name: 'BInputGroupAddon',
  functional: true,
  props: _objectSpread({}, commonProps, {
    append: {
      type: Boolean,
      default: false
    }
  }),
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        'input-group-append': props.append,
        'input-group-prepend': !props.append
      },
      attrs: {
        id: props.id
      }
    }), props.isText ? [h(_inputGroupText.default, children)] : children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/input-group-append.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _inputGroupAddon = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-addon.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BInputGroupAppend',
  functional: true,
  props: _inputGroupAddon.commonProps,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    // pass all our props/attrs down to child, and set`append` to true
    return h(_inputGroupAddon.default, (0, _vueFunctionalDataMerge.mergeData)(data, {
      props: _objectSpread({}, props, {
        append: true
      })
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/input-group-prepend.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _inputGroupAddon = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-addon.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BInputGroupPrepend',
  functional: true,
  props: _inputGroupAddon.commonProps,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    // pass all our props/attrs down to child, and set`append` to false
    return h(_inputGroupAddon.default, (0, _vueFunctionalDataMerge.mergeData)(data, {
      props: _objectSpread({}, props, {
        append: false
      })
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/input-group-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BInputGroupText',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'input-group-text'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/input-group/input-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _inputGroupPrepend = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-prepend.js");

var _inputGroupAppend = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-append.js");

var _inputGroupText = __webpack_require__("./node_modules/bootstrap-vue/es/components/input-group/input-group-text.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var props = {
  id: {
    type: String
  },
  size: {
    type: String
  },
  prepend: {
    type: String
  },
  prependHTML: {
    type: String
  },
  append: {
    type: String
  },
  appendHTML: {
    type: String
  },
  tag: {
    type: String,
    default: 'div'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BInputGroup',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots;
    var $slots = slots();
    var childNodes = []; // Prepend prop

    if (props.prepend) {
      childNodes.push(h(_inputGroupPrepend.default, [h(_inputGroupText.default, {
        domProps: (0, _html.htmlOrText)(props.prependHTML, props.prepend)
      })]));
    } else {
      childNodes.push(h(false));
    } // Prepend slot


    if ($slots.prepend) {
      childNodes.push(h(_inputGroupPrepend.default, $slots.prepend));
    } else {
      childNodes.push(h(false));
    } // Default slot


    if ($slots.default) {
      childNodes.push.apply(childNodes, _toConsumableArray($slots.default));
    } else {
      childNodes.push(h(false));
    } // Append prop


    if (props.append) {
      childNodes.push(h(_inputGroupAppend.default, [h(_inputGroupText.default, {
        domProps: (0, _html.htmlOrText)(props.appendHTML, props.append)
      })]));
    } else {
      childNodes.push(h(false));
    } // Append slot


    if ($slots.append) {
      childNodes.push(h(_inputGroupAppend.default, $slots.append));
    } else {
      childNodes.push(h(false));
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'input-group',
      class: _defineProperty({}, "input-group-".concat(props.size), Boolean(props.size)),
      attrs: {
        id: props.id || null,
        role: 'group'
      }
    }), childNodes);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/jumbotron/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _jumbotron = __webpack_require__("./node_modules/bootstrap-vue/es/components/jumbotron/jumbotron.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BJumbotron: _jumbotron.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/jumbotron/jumbotron.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _container = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/container.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  fluid: {
    type: Boolean,
    default: false
  },
  containerFluid: {
    type: Boolean,
    default: false
  },
  header: {
    type: String,
    default: null
  },
  headerHtml: {
    type: String,
    default: null
  },
  headerTag: {
    type: String,
    default: 'h1'
  },
  headerLevel: {
    type: [Number, String],
    default: '3'
  },
  lead: {
    type: String,
    default: null
  },
  leadHtml: {
    type: String,
    default: null
  },
  leadTag: {
    type: String,
    default: 'p'
  },
  tag: {
    type: String,
    default: 'div'
  },
  bgVariant: {
    type: String,
    default: null
  },
  borderVariant: {
    type: String,
    default: null
  },
  textVariant: {
    type: String,
    default: null
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BJumbotron',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class2;

    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots;
    // The order of the conditionals matter.
    // We are building the component markup in order.
    var childNodes = [];
    var $slots = slots(); // Header

    if (props.header || $slots.header || props.headerHtml) {
      childNodes.push(h(props.headerTag, {
        class: _defineProperty({}, "display-".concat(props.headerLevel), Boolean(props.headerLevel))
      }, $slots.header || props.headerHtml || (0, _html.stripTags)(props.header)));
    } // Lead


    if (props.lead || $slots.lead || props.leadHtml) {
      childNodes.push(h(props.leadTag, {
        staticClass: 'lead'
      }, $slots.lead || props.leadHtml || (0, _html.stripTags)(props.lead)));
    } // Default slot


    if ($slots.default) {
      childNodes.push($slots.default);
    } // If fluid, wrap content in a container/container-fluid


    if (props.fluid) {
      // Children become a child of a container
      childNodes = [h(_container.default, {
        props: {
          fluid: props.containerFluid
        }
      }, childNodes)];
    } // Return the jumbotron


    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'jumbotron',
      class: (_class2 = {
        'jumbotron-fluid': props.fluid
      }, _defineProperty(_class2, "text-".concat(props.textVariant), Boolean(props.textVariant)), _defineProperty(_class2, "bg-".concat(props.bgVariant), Boolean(props.bgVariant)), _defineProperty(_class2, "border-".concat(props.borderVariant), Boolean(props.borderVariant)), _defineProperty(_class2, "border", Boolean(props.borderVariant)), _class2)
    }), childNodes);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/layout/col.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _memoize = __webpack_require__("./node_modules/bootstrap-vue/es/utils/memoize.js");

var _suffixPropName = __webpack_require__("./node_modules/bootstrap-vue/es/utils/suffix-prop-name.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Generates a prop object with a type of
 * [Boolean, String, Number]
 */
function boolStrNum() {
  return {
    type: [Boolean, String, Number],
    default: false
  };
}
/**
 * Generates a prop object with a type of
 * [String, Number]
 */


function strNum() {
  return {
    type: [String, Number],
    default: null
  };
} // Async (lazy) component
// So that we can generate breakpoint specific props once the config has been updated.
//
// See: https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components


var _default = function _default(resolve, reject) {
  // Grab the breakpoints from the config (exclude the '' (xs) breakpoint)
  var breakpoints = (0, _config.getBreakpointsUp)().filter(Boolean); // Memoized function for better performance on generating class names

  var computeBkPtClass = (0, _memoize.default)(function computeBkPt(type, breakpoint, val) {
    var className = type;

    if (val === false || val === null || val === undefined) {
      return undefined;
    }

    if (breakpoint) {
      className += "-".concat(breakpoint);
    } // Handling the boolean style prop when accepting [Boolean, String, Number]
    // means Vue will not convert <b-col sm></b-col> to sm: true for us.
    // Since the default is false, an empty string indicates the prop's presence.


    if (type === 'col' && (val === '' || val === true)) {
      // .col-md
      return className.toLowerCase();
    } // .order-md-6


    className += "-".concat(val);
    return className.toLowerCase();
  }); // Supports classes like: .col-sm, .col-md-6, .col-lg-auto

  var breakpointCol = breakpoints.reduce(function (propMap, breakpoint) {
    if (breakpoint) {
      // We filter out the '' breakpoint (xs), as making a prop name ''
      // would not work. The `cols` prop is used for `xs`
      propMap[breakpoint] = boolStrNum();
    }

    return propMap;
  }, (0, _object.create)(null)); // Supports classes like: .offset-md-1, .offset-lg-12

  var breakpointOffset = breakpoints.reduce(function (propMap, breakpoint) {
    propMap[(0, _suffixPropName.default)(breakpoint, 'offset')] = strNum();
    return propMap;
  }, (0, _object.create)(null)); // Supports classes like: .order-md-1, .order-lg-12

  var breakpointOrder = breakpoints.reduce(function (propMap, breakpoint) {
    propMap[(0, _suffixPropName.default)(breakpoint, 'order')] = strNum();
    return propMap;
  }, (0, _object.create)(null)); // For loop doesn't need to check hasOwnProperty
  // when using an object created from null

  var breakpointPropMap = (0, _object.assign)((0, _object.create)(null), {
    col: (0, _object.keys)(breakpointCol),
    offset: (0, _object.keys)(breakpointOffset),
    order: (0, _object.keys)(breakpointOrder)
  });
  /**
   * We need ".col" to default in when no other props are passed,
   * but always render when col=true.
   */
  // @vue/component

  var BCol = {
    name: 'BCol',
    functional: true,
    props: _objectSpread({
      // Generic flexbox .col (xs)
      col: {
        type: Boolean,
        default: false
      },
      // .col-[1-12]|auto  (xs)
      cols: strNum()
    }, breakpointCol, {
      offset: strNum()
    }, breakpointOffset, {
      order: strNum()
    }, breakpointOrder, {
      // Flex alignment
      alignSelf: {
        type: String,
        default: null,
        validator: function validator(str) {
          return (0, _array.arrayIncludes)(['auto', 'start', 'end', 'center', 'baseline', 'stretch'], str);
        }
      },
      tag: {
        type: String,
        default: 'div'
      }
    }),
    render: function render(h, _ref) {
      var _classList$push;

      var props = _ref.props,
          data = _ref.data,
          children = _ref.children;
      var classList = []; // Loop through `col`, `offset`, `order` breakpoint props

      for (var type in breakpointPropMap) {
        // Returns colSm, offset, offsetSm, orderMd, etc.
        var _keys = breakpointPropMap[type];

        for (var i = 0; i < _keys.length; i++) {
          // computeBkPt(col, colSm => Sm, value=[String, Number, Boolean])
          var c = computeBkPtClass(type, _keys[i].replace(type, ''), props[_keys[i]]); // If a class is returned, push it onto the array.

          if (c) {
            classList.push(c);
          }
        }
      }

      classList.push((_classList$push = {
        // Default to .col if no other classes generated nor `cols` specified.
        col: props.col || classList.length === 0 && !props.cols
      }, _defineProperty(_classList$push, "col-".concat(props.cols), props.cols), _defineProperty(_classList$push, "offset-".concat(props.offset), props.offset), _defineProperty(_classList$push, "order-".concat(props.order), props.order), _defineProperty(_classList$push, "align-self-".concat(props.alignSelf), props.alignSelf), _classList$push));
      return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
        class: classList
      }), children);
    }
  }; // Return the config on demand

  resolve(BCol);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/layout/container.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  },
  fluid: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BContainer',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        container: !props.fluid,
        'container-fluid': props.fluid
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/layout/form-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BFormRow',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'form-row'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/layout/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/container.js");

var _row = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/row.js");

var _col = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/col.js");

var _formRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/layout/form-row.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BContainer: _container.default,
  BRow: _row.default,
  BCol: _col.default,
  BFormRow: _formRow.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/layout/row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var COMMON_ALIGNMENT = ['start', 'end', 'center'];
var props = {
  tag: {
    type: String,
    default: 'div'
  },
  noGutters: {
    type: Boolean,
    default: false
  },
  alignV: {
    type: String,
    default: null,
    validator: function validator(str) {
      return (0, _array.arrayIncludes)(COMMON_ALIGNMENT.concat(['baseline', 'stretch']), str);
    }
  },
  alignH: {
    type: String,
    default: null,
    validator: function validator(str) {
      return (0, _array.arrayIncludes)(COMMON_ALIGNMENT.concat(['between', 'around']), str);
    }
  },
  alignContent: {
    type: String,
    default: null,
    validator: function validator(str) {
      return (0, _array.arrayIncludes)(COMMON_ALIGNMENT.concat(['between', 'around', 'stretch']), str);
    }
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BRow',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'row',
      class: (_class = {
        'no-gutters': props.noGutters
      }, _defineProperty(_class, "align-items-".concat(props.alignV), props.alignV), _defineProperty(_class, "justify-content-".concat(props.alignH), props.alignH), _defineProperty(_class, "align-content-".concat(props.alignContent), props.alignContent), _class)
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/link/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BLink: _link.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/link/link.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.propsFactory = propsFactory;
exports.pickLinkProps = pickLinkProps;
exports.omitLinkProps = omitLinkProps;
exports.default = exports.props = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _router = __webpack_require__("./node_modules/bootstrap-vue/es/utils/router.js");

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * The Link component is used in many other BV components.
 * As such, sharing its props makes supporting all its features easier.
 * However, some components need to modify the defaults for their own purpose.
 * Prefer sharing a fresh copy of the props to ensure mutations
 * do not affect other component references to the props.
 *
 * https://github.com/vuejs/vue-router/blob/dev/src/components/link.js
 * @return {{}}
 */
function propsFactory() {
  return {
    href: {
      type: String,
      default: null
    },
    rel: {
      type: String,
      default: null
    },
    target: {
      type: String,
      default: '_self'
    },
    active: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    // router-link specific props
    to: {
      type: [String, Object],
      default: null
    },
    append: {
      type: Boolean,
      default: false
    },
    replace: {
      type: Boolean,
      default: false
    },
    event: {
      type: [String, Array],
      default: 'click'
    },
    activeClass: {
      type: String // default: undefined

    },
    exact: {
      type: Boolean,
      default: false
    },
    exactActiveClass: {
      type: String // default: undefined

    },
    routerTag: {
      type: String,
      default: 'a'
    },
    // nuxt-link specific prop(s)
    noPrefetch: {
      type: Boolean,
      default: false
    }
  };
}

var props = propsFactory(); // Return a fresh copy of BLink props, containing only the specifeid prop(s)

exports.props = props;

function pickLinkProps(propsToPick) {
  var freshLinkProps = propsFactory(); // Normalize everything to array.

  propsToPick = (0, _array.concat)(propsToPick);
  return (0, _object.keys)(freshLinkProps).reduce(function (memo, prop) {
    if ((0, _array.arrayIncludes)(propsToPick, prop)) {
      memo[prop] = freshLinkProps[prop];
    }

    return memo;
  }, {});
} // Return a fresh copy of BLink props, keeping all but the specified omitting prop(s)


function omitLinkProps(propsToOmit) {
  var freshLinkProps = propsFactory(); // Normalize everything to array.

  propsToOmit = (0, _array.concat)(propsToOmit);
  return (0, _object.keys)(props).reduce(function (memo, prop) {
    if (!(0, _array.arrayIncludes)(propsToOmit, prop)) {
      memo[prop] = freshLinkProps[prop];
    }

    return memo;
  }, {});
}

function clickHandlerFactory(_ref) {
  var disabled = _ref.disabled,
      tag = _ref.tag,
      href = _ref.href,
      suppliedHandler = _ref.suppliedHandler,
      parent = _ref.parent;
  return function onClick(evt) {
    if (disabled && evt instanceof Event) {
      // Stop event from bubbling up.
      evt.stopPropagation(); // Kill the event loop attached to this specific EventTarget.

      evt.stopImmediatePropagation();
    } else {
      if ((0, _router.isRouterLink)(tag) && evt.target.__vue__) {
        // Router links do not emit instance 'click' events, so we
        // add in an $emit('click', evt) on it's vue instance
        evt.target.__vue__.$emit('click', evt);
      }

      if (typeof suppliedHandler === 'function') {
        suppliedHandler.apply(void 0, arguments);
      }

      parent.$root.$emit('clicked::link', evt);
    }

    if (!(0, _router.isRouterLink)(tag) && href === '#' || disabled) {
      // Stop scroll-to-top behavior or navigation on regular links
      // when href is just '#'
      evt.preventDefault();
    }
  };
} // @vue/component


var _default = {
  name: 'BLink',
  functional: true,
  props: propsFactory(),
  render: function render(h, _ref2) {
    var props = _ref2.props,
        data = _ref2.data,
        parent = _ref2.parent,
        children = _ref2.children;
    var tag = (0, _router.computeTag)(props, parent);
    var rel = (0, _router.computeRel)(props);
    var href = (0, _router.computeHref)(props, tag);
    var eventType = (0, _router.isRouterLink)(tag) ? 'nativeOn' : 'on';
    var suppliedHandler = (data[eventType] || {}).click;
    var handlers = {
      click: clickHandlerFactory({
        tag: tag,
        href: href,
        disabled: props.disabled,
        suppliedHandler: suppliedHandler,
        parent: parent
      })
    };
    var componentData = (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        active: props.active,
        disabled: props.disabled
      },
      attrs: {
        rel: rel,
        target: props.target,
        tabindex: props.disabled ? '-1' : data.attrs ? data.attrs.tabindex : null,
        'aria-disabled': props.disabled ? 'true' : null
      },
      props: _objectSpread({}, props, {
        tag: props.routerTag
      })
    }); // If href attribute exists on router-link (even undefined or null) it fails working on SSR
    // So we explicitly add it here if needed (i.e. if computeHref() is truthy)

    if (href) {
      componentData.attrs.href = href;
    } // We want to overwrite any click handler since our callback
    // will invoke the user supplied handler if !props.disabled


    componentData[eventType] = _objectSpread({}, componentData[eventType] || {}, handlers);
    return h(tag, componentData, children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/list-group/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _listGroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/list-group/list-group.js");

var _listGroupItem = __webpack_require__("./node_modules/bootstrap-vue/es/components/list-group/list-group-item.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BListGroup: _listGroup.default,
  BListGroupItem: _listGroupItem.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/list-group/list-group-item.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var actionTags = ['a', 'router-link', 'button', 'b-link'];
var linkProps = (0, _link.propsFactory)();
delete linkProps.href.default;
delete linkProps.to.default;

var props = _objectSpread({
  tag: {
    type: String,
    default: 'div'
  },
  action: {
    type: Boolean,
    default: null
  },
  button: {
    type: Boolean,
    default: null
  },
  variant: {
    type: String,
    default: null
  }
}, linkProps); // @vue/component


exports.props = props;
var _default = {
  name: 'BListGroupItem',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var tag = props.button ? 'button' : !props.href && !props.to ? props.tag : _link.default;
    var isAction = Boolean(props.href || props.to || props.action || props.button || (0, _array.arrayIncludes)(actionTags, props.tag));
    var attrs = {};
    var itemProps = {};

    if (tag === 'button') {
      if (!data.attrs || !data.attrs.type) {
        // Add a type for button is one not provided in passed attributes
        attrs.type = 'button';
      }

      if (props.disabled) {
        // Set disabled attribute if button and disabled
        attrs.disabled = true;
      }
    } else {
      itemProps = (0, _pluckProps.default)(linkProps, props);
    }

    var componentData = {
      attrs: attrs,
      props: itemProps,
      staticClass: 'list-group-item',
      class: (_class = {}, _defineProperty(_class, "list-group-item-".concat(props.variant), Boolean(props.variant)), _defineProperty(_class, 'list-group-item-action', isAction), _defineProperty(_class, "active", props.active), _defineProperty(_class, "disabled", props.disabled), _class)
    };
    return h(tag, (0, _vueFunctionalDataMerge.mergeData)(data, componentData), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/list-group/list-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  tag: {
    type: String,
    default: 'div'
  },
  flush: {
    type: Boolean,
    default: false
  },
  horizontal: {
    type: [Boolean, String],
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BListGroup',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var horizontal = props.horizontal === '' ? true : props.horizontal;
    horizontal = props.flush ? false : horizontal;
    var componentData = {
      staticClass: 'list-group',
      class: _defineProperty({
        'list-group-flush': props.flush,
        'list-group-horizontal': horizontal === true
      }, "list-group-horizontal-".concat(horizontal), typeof horizontal === 'string')
    };
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, componentData), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/media/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _media = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/media.js");

var _mediaAside = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/media-aside.js");

var _mediaBody = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/media-body.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BMedia: _media.default,
  BMediaAside: _mediaAside.default,
  BMediaBody: _mediaBody.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/media/media-aside.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  tag: {
    type: String,
    default: 'div'
  },
  verticalAlign: {
    type: String,
    default: 'top'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BMediaAside',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'd-flex',
      class: _defineProperty({}, "align-self-".concat(props.verticalAlign), props.verticalAlign)
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/media/media-body.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  }
};
exports.props = props;
var _default = {
  name: 'BMediaBody',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'media-body'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/media/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _mediaBody = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/media-body.js");

var _mediaAside = __webpack_require__("./node_modules/bootstrap-vue/es/components/media/media-aside.js");

var props = {
  tag: {
    type: String,
    default: 'div'
  },
  rightAlign: {
    type: Boolean,
    default: false
  },
  verticalAlign: {
    type: String,
    default: 'top'
  },
  noBody: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BMedia',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots,
        children = _ref.children;
    var childNodes = props.noBody ? children : [];
    var $slots = slots();

    if (!props.noBody) {
      if ($slots.aside && !props.rightAlign) {
        childNodes.push(h(_mediaAside.default, {
          staticClass: 'mr-3',
          props: {
            verticalAlign: props.verticalAlign
          }
        }, $slots.aside));
      }

      childNodes.push(h(_mediaBody.default, $slots.default));

      if ($slots.aside && props.rightAlign) {
        childNodes.push(h(_mediaAside.default, {
          staticClass: 'ml-3',
          props: {
            verticalAlign: props.verticalAlign
          }
        }, $slots.aside));
      }
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'media'
    }), childNodes);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/modal/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _modal = __webpack_require__("./node_modules/bootstrap-vue/es/components/modal/modal.js");

var _modal2 = __webpack_require__("./node_modules/bootstrap-vue/es/directives/modal/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BModal: _modal.default
};
var plugins = {
  BModalDirectivePlugin: _modal2.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/modal/modal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _button = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button.js");

var _buttonClose = __webpack_require__("./node_modules/bootstrap-vue/es/components/button/button-close.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _listenOnRoot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/listen-on-root.js");

var _observeDom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/observe-dom.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _bvEvent = __webpack_require__("./node_modules/bootstrap-vue/es/utils/bv-event.class.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'BModal'; // Selectors for padding/margin adjustments

var Selector = {
  FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
  STICKY_CONTENT: '.sticky-top',
  NAVBAR_TOGGLER: '.navbar-toggler' // ObserveDom config

};
var OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true,
  attributes: true,
  attributeFilter: ['style', 'class'] // modal wrapper ZINDEX offset incrememnt

};
var ZINDEX_OFFSET = 2000; // Modal open count helpers

function getModalOpenCount() {
  return parseInt((0, _dom.getAttr)(document.body, 'data-modal-open-count') || 0, 10);
}

function setModalOpenCount(count) {
  (0, _dom.setAttr)(document.body, 'data-modal-open-count', String(count));
  return count;
}

function incrementModalOpenCount() {
  return setModalOpenCount(getModalOpenCount() + 1);
}

function decrementModalOpenCount() {
  return setModalOpenCount(Math.max(getModalOpenCount() - 1, 0));
} // Returns the current visible modal highest z-index


function getModalMaxZIndex() {
  return (0, _dom.selectAll)('div.modal')
  /* find all modals that are in document */
  .filter(_dom.isVisible)
  /* filter only visible ones */
  .map(function (m) {
    return m.parentElement;
  })
  /* select the outer div */
  .reduce(function (max, el) {
    /* compute the highest z-index */
    return Math.max(max, parseInt(el.style.zIndex || 0, 10));
  }, 0);
} // Returns the next z-index to be used by a modal to ensure proper stacking
// regardless of document order. Increments by 2000


function getModalNextZIndex() {
  return getModalMaxZIndex() + ZINDEX_OFFSET;
} // @vue/component


var _default2 = {
  name: NAME,
  components: {
    BButton: _button.default,
    BButtonClose: _buttonClose.default
  },
  mixins: [_id.default, _listenOnRoot.default],
  model: {
    prop: 'visible',
    event: 'change'
  },
  props: {
    title: {
      type: String,
      default: ''
    },
    titleHtml: {
      type: String
    },
    titleTag: {
      type: String,
      default: 'h5'
    },
    size: {
      type: String,
      default: 'md'
    },
    centered: {
      type: Boolean,
      default: false
    },
    scrollable: {
      type: Boolean,
      default: false
    },
    buttonSize: {
      type: String,
      default: ''
    },
    noStacking: {
      type: Boolean,
      default: false
    },
    noFade: {
      type: Boolean,
      default: false
    },
    noCloseOnBackdrop: {
      type: Boolean,
      default: false
    },
    noCloseOnEsc: {
      type: Boolean,
      default: false
    },
    noEnforceFocus: {
      type: Boolean,
      default: false
    },
    headerBgVariant: {
      type: String,
      default: null
    },
    headerBorderVariant: {
      type: String,
      default: null
    },
    headerTextVariant: {
      type: String,
      default: null
    },
    headerCloseVariant: {
      type: String,
      default: null
    },
    headerClass: {
      type: [String, Array],
      default: null
    },
    bodyBgVariant: {
      type: String,
      default: null
    },
    bodyTextVariant: {
      type: String,
      default: null
    },
    modalClass: {
      type: [String, Array],
      default: null
    },
    dialogClass: {
      type: [String, Array],
      default: null
    },
    contentClass: {
      type: [String, Array],
      default: null
    },
    bodyClass: {
      type: [String, Array],
      default: null
    },
    footerBgVariant: {
      type: String,
      default: null
    },
    footerBorderVariant: {
      type: String,
      default: null
    },
    footerTextVariant: {
      type: String,
      default: null
    },
    footerClass: {
      type: [String, Array],
      default: null
    },
    hideHeader: {
      type: Boolean,
      default: false
    },
    hideFooter: {
      type: Boolean,
      default: false
    },
    hideHeaderClose: {
      type: Boolean,
      default: false
    },
    hideBackdrop: {
      type: Boolean,
      default: false
    },
    okOnly: {
      type: Boolean,
      default: false
    },
    okDisabled: {
      type: Boolean,
      default: false
    },
    cancelDisabled: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: false
    },
    returnFocus: {
      // type: Object,
      default: null
    },
    headerCloseLabel: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'headerCloseLabel');
      }
    },
    cancelTitle: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'cancelTitle');
      }
    },
    cancelTitleHtml: {
      type: String
    },
    okTitle: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'okTitle');
      }
    },
    okTitleHtml: {
      type: String
    },
    cancelVariant: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'cancelVariant');
      }
    },
    okVariant: {
      type: String,
      default: function _default() {
        return (0, _config.getComponentConfig)(NAME, 'okVariant');
      }
    },
    lazy: {
      type: Boolean,
      default: false
    },
    busy: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      is_hidden: this.lazy || false,
      // for lazy modals
      is_visible: false,
      // controls modal visible state
      is_transitioning: false,
      // Used for style control
      is_show: false,
      // Used for style control
      is_block: false,
      // Used for style control
      is_opening: false,
      // Semaphore for previnting incorrect modal open counts
      is_closing: false,
      // Semapbore for preventing incorrect modal open counts
      scrollbarWidth: 0,
      zIndex: ZINDEX_OFFSET,
      // z-index for modal stacking
      isTop: true,
      // If the modal is the topmost opened modal
      isBodyOverflowing: false,
      return_focus: this.returnFocus || null
    };
  },
  computed: {
    contentClasses: function contentClasses() {
      return ['modal-content', this.contentClass];
    },
    modalClasses: function modalClasses() {
      return [{
        fade: !this.noFade,
        show: this.is_show,
        'd-block': this.is_block
      }, this.modalClass];
    },
    dialogClasses: function dialogClasses() {
      var _ref;

      return [(_ref = {}, _defineProperty(_ref, "modal-".concat(this.size), Boolean(this.size)), _defineProperty(_ref, 'modal-dialog-centered', this.centered), _defineProperty(_ref, 'modal-dialog-scrollable', this.scrollable), _ref), this.dialogClass];
    },
    backdropClasses: function backdropClasses() {
      return {
        fade: !this.noFade,
        show: this.is_show || this.noFade
      };
    },
    headerClasses: function headerClasses() {
      var _ref2;

      return [(_ref2 = {}, _defineProperty(_ref2, "bg-".concat(this.headerBgVariant), Boolean(this.headerBgVariant)), _defineProperty(_ref2, "text-".concat(this.headerTextVariant), Boolean(this.headerTextVariant)), _defineProperty(_ref2, "border-".concat(this.headerBorderVariant), Boolean(this.headerBorderVariant)), _ref2), this.headerClass];
    },
    bodyClasses: function bodyClasses() {
      var _ref3;

      return [(_ref3 = {}, _defineProperty(_ref3, "bg-".concat(this.bodyBgVariant), Boolean(this.bodyBgVariant)), _defineProperty(_ref3, "text-".concat(this.bodyTextVariant), Boolean(this.bodyTextVariant)), _ref3), this.bodyClass];
    },
    footerClasses: function footerClasses() {
      var _ref4;

      return [(_ref4 = {}, _defineProperty(_ref4, "bg-".concat(this.footerBgVariant), Boolean(this.footerBgVariant)), _defineProperty(_ref4, "text-".concat(this.footerTextVariant), Boolean(this.footerTextVariant)), _defineProperty(_ref4, "border-".concat(this.footerBorderVariant), Boolean(this.footerBorderVariant)), _ref4), this.footerClass];
    },
    modalOuterStyle: function modalOuterStyle() {
      return {
        // We only set these styles on the stacked modals (ones with next z-index > 0).
        position: 'absolute',
        zIndex: this.zIndex
      };
    }
  },
  watch: {
    visible: function visible(newVal, oldVal) {
      if (newVal === oldVal) {
        /* istanbul ignore next */
        return;
      }

      this[newVal ? 'show' : 'hide']();
    }
  },
  created: function created() {
    // create non-reactive property
    this._observer = null;
  },
  mounted: function mounted() {
    // Listen for events from others to either open or close ourselves
    // And listen to all modals to enable/disable enforce focus
    this.listenOnRoot('bv::show::modal', this.showHandler);
    this.listenOnRoot('bv::modal::shown', this.shownHandler);
    this.listenOnRoot('bv::hide::modal', this.hideHandler);
    this.listenOnRoot('bv::modal::hidden', this.hiddenHandler);
    this.listenOnRoot('bv::toggle::modal', this.toggleHandler); // Listen for bv:modal::show events, and close ourselves if the opening modal not us

    this.listenOnRoot('bv::modal::show', this.modalListener); // Initially show modal?

    if (this.visible === true) {
      this.show();
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    // Ensure everything is back to normal
    if (this._observer) {
      this._observer.disconnect();

      this._observer = null;
    } // Ensure our root "once" listener is gone


    this.$root.$off('bv::modal::hidden', this.doShow);
    this.setEnforceFocus(false);
    this.setResizeEvent(false);

    if (this.is_visible) {
      this.is_visible = false;
      this.is_show = false;
      this.is_transitioning = false;
      var count = decrementModalOpenCount();

      if (count === 0) {
        // Re-adjust body/navbar/fixed padding/margins (as we were the last modal open)
        this.setModalOpenClass(false);
        this.resetScrollbar();
        this.resetDialogAdjustments();
      }
    }
  },
  methods: {
    // Public Methods
    show: function show() {
      if (this.is_visible || this.is_opening) {
        // if already open, on in the process of opening, do nothing
        return;
      }

      if (this.is_closing) {
        // if we are in the process of closing, wait until hidden before re-opening
        this.$once('hidden', this.show);
        return;
      }

      this.is_opening = true;
      var showEvt = new _bvEvent.default('show', {
        cancelable: true,
        vueTarget: this,
        target: this.$refs.modal,
        modalId: this.safeId(),
        relatedTarget: null
      });
      this.emitEvent(showEvt); // Don't show if canceled

      if (showEvt.defaultPrevented || this.is_visible) {
        this.is_opening = false;
        return;
      }

      if (!this.noStacking) {
        // Find the z-index to use
        this.zIndex = getModalNextZIndex(); // Show the modal

        this.doShow();
        return;
      }

      if ((0, _dom.hasClass)(document.body, 'modal-open')) {
        // If another modal is already open, wait for it to close
        this.$root.$once('bv::modal::hidden', this.doShow);
        return;
      } // Show the modal


      this.doShow();
    },
    hide: function hide(trigger) {
      if (!this.is_visible || this.is_closing) {
        return;
      }

      this.is_closing = true;
      var hideEvt = new _bvEvent.default('hide', {
        cancelable: true,
        vueTarget: this,
        target: this.$refs.modal,
        modalId: this.safeId(),
        // this could be the trigger element/component reference
        relatedTarget: null,
        isOK: trigger || null,
        trigger: trigger || null,
        cancel: function cancel()
        /* istanbul ignore next */
        {
          // Backwards compatibility
          (0, _warn.default)('b-modal: evt.cancel() is deprecated. Please use evt.preventDefault().');
          this.preventDefault();
        }
      });

      if (trigger === 'ok') {
        this.$emit('ok', hideEvt);
      } else if (trigger === 'cancel') {
        this.$emit('cancel', hideEvt);
      }

      this.emitEvent(hideEvt); // Hide if not canceled

      if (hideEvt.defaultPrevented || !this.is_visible) {
        this.is_closing = false;
        return;
      } // stop observing for content changes


      if (this._observer) {
        this._observer.disconnect();

        this._observer = null;
      }

      this.is_visible = false;
      this.$emit('change', false);
    },
    // Public method to toggle modal visibility
    toggle: function toggle(triggerEl) {
      if (triggerEl) {
        this.return_focus = triggerEl;
      }

      if (this.is_visible) {
        this.hide('toggle');
      } else {
        this.show();
      }
    },
    // Private method to finish showing modal
    doShow: function doShow() {
      var _this = this;

      // Place modal in DOM if lazy
      this.is_hidden = false;
      this.$nextTick(function () {
        // We do this in nextTick to ensure the modal is in DOM first before we show it
        _this.is_visible = true;
        _this.is_opening = false;

        _this.$emit('change', true); // Observe changes in modal content and adjust if necessary


        _this._observer = (0, _observeDom.default)(_this.$refs.content, _this.adjustDialog.bind(_this), OBSERVER_CONFIG);
      });
    },
    // Transition Handlers
    onBeforeEnter: function onBeforeEnter() {
      this.getScrollbarWidth();
      this.is_transitioning = true;
      this.checkScrollbar();
      var count = incrementModalOpenCount();

      if (count === 1) {
        this.setScrollbar();
      }

      this.adjustDialog();
      this.setModalOpenClass(true);
      this.setResizeEvent(true);
    },
    onEnter: function onEnter() {
      this.is_block = true;
    },
    onAfterEnter: function onAfterEnter() {
      var _this2 = this;

      this.is_show = true;
      this.is_transitioning = false;
      this.$nextTick(function () {
        var shownEvt = new _bvEvent.default('shown', {
          cancelable: false,
          vueTarget: _this2,
          target: _this2.$refs.modal,
          modalId: _this2.safeId(),
          relatedTarget: null
        });

        _this2.emitEvent(shownEvt);

        _this2.focusFirst();

        _this2.setEnforceFocus(true);
      });
    },
    onBeforeLeave: function onBeforeLeave() {
      this.is_transitioning = true;
      this.setResizeEvent(false);
    },
    onLeave: function onLeave() {
      // Remove the 'show' class
      this.is_show = false;
    },
    onAfterLeave: function onAfterLeave() {
      var _this3 = this;

      this.is_block = false;
      this.resetDialogAdjustments();
      this.is_transitioning = false;
      var count = decrementModalOpenCount();

      if (count === 0) {
        this.resetScrollbar();
        this.setModalOpenClass(false);
      }

      this.setEnforceFocus(false);
      this.$nextTick(function () {
        _this3.is_hidden = _this3.lazy || false;
        _this3.zIndex = ZINDEX_OFFSET;

        _this3.returnFocusTo();

        _this3.is_closing = false;
        var hiddenEvt = new _bvEvent.default('hidden', {
          cancelable: false,
          vueTarget: _this3,
          target: _this3.lazy ? null : _this3.$refs.modal,
          modalId: _this3.safeId(),
          relatedTarget: null
        });

        _this3.emitEvent(hiddenEvt);
      });
    },
    // Event emitter
    emitEvent: function emitEvent(bvEvt) {
      var type = bvEvt.type;
      this.$emit(type, bvEvt);
      this.$root.$emit("bv::modal::".concat(type), bvEvt, this.safeId());
    },
    // UI Event Handlers
    onClickOut: function onClickOut(evt) {
      // Do nothing if not visible, backdrop click disabled, or element that generated
      // click event is no longer in document
      if (!this.is_visible || this.noCloseOnBackdrop || !(0, _dom.contains)(document, evt.target)) {
        return;
      } // If backdrop clicked, hide modal


      if (!(0, _dom.contains)(this.$refs.content, evt.target)) {
        this.hide('backdrop');
      }
    },
    onEsc: function onEsc(evt) {
      // If ESC pressed, hide modal
      if (evt.keyCode === _keyCodes.default.ESC && this.is_visible && !this.noCloseOnEsc) {
        this.hide('esc');
      }
    },
    // Document focusin listener
    focusHandler: function focusHandler(evt) {
      // If focus leaves modal, bring it back
      var modal = this.$refs.modal;

      if (!this.noEnforceFocus && this.isTop && this.is_visible && modal && document !== evt.target && !(0, _dom.contains)(modal, evt.target)) {
        modal.focus({
          preventScroll: true
        });
      }
    },
    // Turn on/off focusin listener
    setEnforceFocus: function setEnforceFocus(on) {
      var options = {
        passive: true,
        capture: false
      };

      if (on) {
        (0, _dom.eventOn)(document, 'focusin', this.focusHandler, options);
      } else {
        (0, _dom.eventOff)(document, 'focusin', this.focusHandler, options);
      }
    },
    // Resize Listener
    setResizeEvent: function setResizeEvent(on)
    /* istanbul ignore next: can't easily test in JSDOM */
    {
      var _this4 = this;

      ;
      ['resize', 'orientationchange'].forEach(function (evtName) {
        var options = {
          passive: true,
          capture: false
        };

        if (on) {
          (0, _dom.eventOn)(window, evtName, _this4.adjustDialog, options);
        } else {
          (0, _dom.eventOff)(window, evtName, _this4.adjustDialog, options);
        }
      });
    },
    // Root Listener handlers
    showHandler: function showHandler(id, triggerEl) {
      if (id === this.id) {
        this.return_focus = triggerEl || null;
        this.show();
      }
    },
    hideHandler: function hideHandler(id) {
      if (id === this.id) {
        this.hide('event');
      }
    },
    toggleHandler: function toggleHandler(id, triggerEl) {
      if (id === this.id) {
        this.toggle(triggerEl);
      }
    },
    shownHandler: function shownHandler() {
      this.setTop();
    },
    hiddenHandler: function hiddenHandler() {
      this.setTop();
    },
    setTop: function setTop() {
      // Determine if we are the topmost visible modal
      this.isTop = this.zIndex >= getModalMaxZIndex();
    },
    modalListener: function modalListener(bvEvt) {
      // If another modal opens, close this one
      if (this.noStacking && bvEvt.vueTarget !== this) {
        this.hide();
      }
    },
    // Focus control handlers
    focusFirst: function focusFirst() {
      // Don't try and focus if we are SSR
      if (typeof document === 'undefined') {
        return;
      }

      var modal = this.$refs.modal;
      var activeElement = document.activeElement;

      if (activeElement && (0, _dom.contains)(modal, activeElement)) {
        // If activeElement is child of modal or is modal, no need to change focus
        return;
      }

      if (modal) {
        // make sure top of modal is showing (if longer than the viewport) and
        // focus the modal content wrapper
        this.$nextTick(function () {
          modal.scrollTop = 0;
          modal.focus();
        });
      }
    },
    returnFocusTo: function returnFocusTo() {
      // Prefer returnFocus prop over event specified return_focus value
      var el = this.returnFocus || this.return_focus || null;

      if (typeof el === 'string') {
        // CSS Selector
        el = (0, _dom.select)(el);
      }

      if (el) {
        el = el.$el || el;

        if ((0, _dom.isVisible)(el)) {
          el.focus();
        }
      }
    },
    // Utility methods
    getScrollbarWidth: function getScrollbarWidth() {
      var scrollDiv = document.createElement('div');
      scrollDiv.className = 'modal-scrollbar-measure';
      document.body.appendChild(scrollDiv);
      this.scrollbarWidth = (0, _dom.getBCR)(scrollDiv).width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
    },
    setModalOpenClass: function setModalOpenClass(open) {
      if (open) {
        (0, _dom.addClass)(document.body, 'modal-open');
      } else {
        (0, _dom.removeClass)(document.body, 'modal-open');
      }
    },
    adjustDialog: function adjustDialog() {
      if (!this.is_visible) {
        return;
      }

      var modal = this.$refs.modal;
      var isModalOverflowing = modal.scrollHeight > document.documentElement.clientHeight;

      if (!this.isBodyOverflowing && isModalOverflowing) {
        modal.style.paddingLeft = "".concat(this.scrollbarWidth, "px");
      } else {
        modal.style.paddingLeft = '';
      }

      if (this.isBodyOverflowing && !isModalOverflowing) {
        modal.style.paddingRight = "".concat(this.scrollbarWidth, "px");
      } else {
        modal.style.paddingRight = '';
      }
    },
    resetDialogAdjustments: function resetDialogAdjustments() {
      var modal = this.$refs.modal;

      if (modal) {
        modal.style.paddingLeft = '';
        modal.style.paddingRight = '';
      }
    },
    checkScrollbar: function checkScrollbar()
    /* istanbul ignore next: getBCR can't be tested in JSDOM */
    {
      var _getBCR = (0, _dom.getBCR)(document.body),
          left = _getBCR.left,
          right = _getBCR.right,
          height = _getBCR.height; // Extra check for body.height needed for stacked modals


      this.isBodyOverflowing = left + right < window.innerWidth || height > window.innerHeight;
    },
    setScrollbar: function setScrollbar() {
      /* istanbul ignore if: get Computed Style can't be tested in JSDOM */
      if (this.isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var body = document.body;
        var scrollbarWidth = this.scrollbarWidth;
        body._paddingChangedForModal = [];
        body._marginChangedForModal = []; // Adjust fixed content padding

        (0, _dom.selectAll)(Selector.FIXED_CONTENT).forEach(function (el) {
          var actualPadding = el.style.paddingRight;
          var calculatedPadding = (0, _dom.getCS)(el).paddingRight || 0;
          (0, _dom.setAttr)(el, 'data-padding-right', actualPadding);
          el.style.paddingRight = "".concat(parseFloat(calculatedPadding) + scrollbarWidth, "px");

          body._paddingChangedForModal.push(el);
        }); // Adjust sticky content margin

        (0, _dom.selectAll)(Selector.STICKY_CONTENT).forEach(function (el) {
          var actualMargin = el.style.marginRight;
          var calculatedMargin = (0, _dom.getCS)(el).marginRight || 0;
          (0, _dom.setAttr)(el, 'data-margin-right', actualMargin);
          el.style.marginRight = "".concat(parseFloat(calculatedMargin) - scrollbarWidth, "px");

          body._marginChangedForModal.push(el);
        }); // Adjust navbar-toggler margin

        (0, _dom.selectAll)(Selector.NAVBAR_TOGGLER).forEach(function (el) {
          var actualMargin = el.style.marginRight;
          var calculatedMargin = (0, _dom.getCS)(el).marginRight || 0;
          (0, _dom.setAttr)(el, 'data-margin-right', actualMargin);
          el.style.marginRight = "".concat(parseFloat(calculatedMargin) + scrollbarWidth, "px");

          body._marginChangedForModal.push(el);
        }); // Adjust body padding

        var actualPadding = body.style.paddingRight;
        var calculatedPadding = (0, _dom.getCS)(body).paddingRight;
        (0, _dom.setAttr)(body, 'data-padding-right', actualPadding);
        body.style.paddingRight = "".concat(parseFloat(calculatedPadding) + scrollbarWidth, "px");
      }
    },
    resetScrollbar: function resetScrollbar() {
      var body = document.body;

      if (body._paddingChangedForModal) {
        // Restore fixed content padding
        body._paddingChangedForModal.forEach(function (el) {
          if ((0, _dom.hasAttr)(el, 'data-padding-right')) {
            el.style.paddingRight = (0, _dom.getAttr)(el, 'data-padding-right') || '';
            (0, _dom.removeAttr)(el, 'data-padding-right');
          }
        });
      }

      if (body._marginChangedForModal) {
        // Restore sticky content and navbar-toggler margin
        body._marginChangedForModal.forEach(function (el) {
          if ((0, _dom.hasAttr)(el, 'data-margin-right')) {
            el.style.marginRight = (0, _dom.getAttr)(el, 'data-margin-right') || '';
            (0, _dom.removeAttr)(el, 'data-margin-right');
          }
        });
      }

      body._paddingChangedForModal = null;
      body._marginChangedForModal = null; // Restore body padding

      if ((0, _dom.hasAttr)(body, 'data-padding-right')) {
        body.style.paddingRight = (0, _dom.getAttr)(body, 'data-padding-right') || '';
        (0, _dom.removeAttr)(body, 'data-padding-right');
      }
    }
  },
  render: function render(h) {
    var _this5 = this;

    var $slots = this.$slots; // Modal Header

    var header = h(false);

    if (!this.hideHeader) {
      var modalHeader = $slots['modal-header'];

      if (!modalHeader) {
        var closeButton = h(false);

        if (!this.hideHeaderClose) {
          closeButton = h('b-button-close', {
            props: {
              disabled: this.is_transitioning,
              ariaLabel: this.headerCloseLabel,
              textVariant: this.headerCloseVariant || this.headerTextVariant
            },
            on: {
              click: function click(evt) {
                _this5.hide('headerclose');
              }
            }
          }, [$slots['modal-header-close']]);
        }

        modalHeader = [h(this.titleTag, {
          class: ['modal-title']
        }, [$slots['modal-title'] || this.titleHtml || (0, _html.stripTags)(this.title)]), closeButton];
      }

      header = h('header', {
        ref: 'header',
        staticClass: 'modal-header',
        class: this.headerClasses,
        attrs: {
          id: this.safeId('__BV_modal_header_')
        }
      }, [modalHeader]);
    } // Modal Body


    var body = h('div', {
      ref: 'body',
      staticClass: 'modal-body',
      class: this.bodyClasses,
      attrs: {
        id: this.safeId('__BV_modal_body_')
      }
    }, [$slots.default]); // Modal Footer

    var footer = h(false);

    if (!this.hideFooter) {
      var modalFooter = $slots['modal-footer'];

      if (!modalFooter) {
        var cancelButton = h(false);

        if (!this.okOnly) {
          cancelButton = h('b-button', {
            props: {
              variant: this.cancelVariant,
              size: this.buttonSize,
              disabled: this.cancelDisabled || this.busy || this.is_transitioning
            },
            on: {
              click: function click(evt) {
                _this5.hide('cancel');
              }
            }
          }, [$slots['modal-cancel'] || this.cancelTitleHtml || (0, _html.stripTags)(this.cancelTitle)]);
        }

        var okButton = h('b-button', {
          props: {
            variant: this.okVariant,
            size: this.buttonSize,
            disabled: this.okDisabled || this.busy || this.is_transitioning
          },
          on: {
            click: function click(evt) {
              _this5.hide('ok');
            }
          }
        }, [$slots['modal-ok'] || this.okTitleHtml || (0, _html.stripTags)(this.okTitle)]);
        modalFooter = [cancelButton, okButton];
      }

      footer = h('footer', {
        ref: 'footer',
        staticClass: 'modal-footer',
        class: this.footerClasses,
        attrs: {
          id: this.safeId('__BV_modal_footer_')
        }
      }, [modalFooter]);
    } // Assemble Modal Content


    var modalContent = h('div', {
      ref: 'content',
      class: this.contentClasses,
      attrs: {
        role: 'document',
        id: this.safeId('__BV_modal_content_'),
        'aria-labelledby': this.hideHeader ? null : this.safeId('__BV_modal_header_'),
        'aria-describedby': this.safeId('__BV_modal_body_')
      }
    }, [header, body, footer]); // Modal Dialog wrapper

    var modalDialog = h('div', {
      staticClass: 'modal-dialog',
      class: this.dialogClasses
    }, [modalContent]); // Modal

    var modal = h('div', {
      ref: 'modal',
      staticClass: 'modal',
      class: this.modalClasses,
      directives: [{
        name: 'show',
        rawName: 'v-show',
        value: this.is_visible,
        expression: 'is_visible'
      }],
      attrs: {
        id: this.safeId(),
        role: 'dialog',
        tabindex: '-1',
        'aria-hidden': this.is_visible ? null : 'true',
        'aria-modal': this.is_visible ? 'true' : null
      },
      on: {
        keydown: this.onEsc,
        click: this.onClickOut
      }
    }, [modalDialog]); // Wrap modal in transition

    modal = h('transition', {
      props: {
        enterClass: '',
        enterToClass: '',
        enterActiveClass: '',
        leaveClass: '',
        leaveActiveClass: '',
        leaveToClass: ''
      },
      on: {
        'before-enter': this.onBeforeEnter,
        enter: this.onEnter,
        'after-enter': this.onAfterEnter,
        'before-leave': this.onBeforeLeave,
        leave: this.onLeave,
        'after-leave': this.onAfterLeave
      }
    }, [modal]); // Modal Backdrop

    var backdrop = h(false);

    if (!this.hideBackdrop && (this.is_visible || this.is_transitioning)) {
      backdrop = h('div', {
        staticClass: 'modal-backdrop',
        class: this.backdropClasses,
        attrs: {
          id: this.safeId('__BV_modal_backdrop_')
        }
      }, [$slots['modal-backdrop']]);
    } // Tab trap to prevent page from scrolling to next element in tab index during enforce focus tab cycle


    var tabTrap = h(false);

    if (this.is_visible && this.isTop && !this.noEnforceFocus) {
      tabTrap = h('div', {
        attrs: {
          tabindex: '0'
        }
      });
    } // Assemble modal and backdrop in an outer div needed for lazy modals


    var outer = h(false);

    if (!this.is_hidden) {
      outer = h('div', {
        key: 'modal-outer',
        style: this.modalOuterStyle,
        attrs: {
          id: this.safeId('__BV_modal_outer_')
        }
      }, [modal, tabTrap, backdrop]);
    } // Wrap in DIV to maintain thi.$el reference for hide/show method aceess


    return h('div', {}, [outer]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _nav = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/nav.js");

var _navItem = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/nav-item.js");

var _navText = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/nav-text.js");

var _navForm = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/nav-form.js");

var _navItemDropdown = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/nav-item-dropdown.js");

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BNav: _nav.default,
  BNavItem: _navItem.default,
  BNavText: _navText.default,
  BNavForm: _navForm.default,
  BNavItemDropdown: _navItemDropdown.default,
  BNavItemDd: _navItemDropdown.default,
  BNavDropdown: _navItemDropdown.default,
  BNavDd: _navItemDropdown.default
};
var plugins = {
  DropdownPlugin: _dropdown.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/nav-form.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _form = __webpack_require__("./node_modules/bootstrap-vue/es/components/form/form.js");

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

// @vue/component
var _default = {
  name: 'BNavForm',
  functional: true,
  props: {
    id: {
      type: String,
      default: null
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(_form.default, (0, _vueFunctionalDataMerge.mergeData)(data, {
      attrs: {
        id: props.id
      },
      props: {
        inline: true
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/nav-item-dropdown.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/dropdown.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

// @vue/component
var _default = {
  name: 'BNavItemDropdown',
  mixins: [_id.default, _dropdown.default],
  props: {
    noCaret: {
      type: Boolean,
      default: false
    },
    extraToggleClasses: {
      // Extra Toggle classes
      type: String,
      default: ''
    },
    extraMenuClasses: {
      // Extra Menu classes
      type: String,
      default: ''
    },
    role: {
      type: String,
      default: 'menu'
    }
  },
  computed: {
    isNav: function isNav() {
      // Signal to dropdown mixin that we are in a navbar
      return true;
    },
    dropdownClasses: function dropdownClasses() {
      return ['nav-item', 'b-nav-dropdown', 'dropdown', this.dropup ? 'dropup' : '', this.visible ? 'show' : ''];
    },
    toggleClasses: function toggleClasses() {
      return ['nav-link', this.noCaret ? '' : 'dropdown-toggle', this.disabled ? 'disabled' : '', this.extraToggleClasses ? this.extraToggleClasses : ''];
    },
    menuClasses: function menuClasses() {
      return ['dropdown-menu', this.right ? 'dropdown-menu-right' : 'dropdown-menu-left', this.visible ? 'show' : '', this.extraMenuClasses ? this.extraMenuClasses : ''];
    }
  },
  render: function render(h) {
    var button = h('a', {
      class: this.toggleClasses,
      ref: 'toggle',
      attrs: {
        href: '#',
        id: this.safeId('_BV_button_'),
        disabled: this.disabled,
        'aria-haspopup': 'true',
        'aria-expanded': this.visible ? 'true' : 'false'
      },
      on: {
        click: this.toggle,
        keydown: this.toggle // space, enter, down

      }
    }, [this.$slots['button-content'] || this.$slots.text || h('span', {
      domProps: (0, _html.htmlOrText)(this.html, this.text)
    })]);
    var menu = h('div', {
      class: this.menuClasses,
      ref: 'menu',
      attrs: {
        tabindex: '-1',
        'aria-labelledby': this.safeId('_BV_button_')
      },
      on: {
        mouseover: this.onMouseOver,
        keydown: this.onKeydown // tab, up, down, esc

      }
    }, [this.$slots.default]);
    return h('li', {
      attrs: {
        id: this.safeId()
      },
      class: this.dropdownClasses
    }, [button, menu]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/nav-item.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = (0, _link.propsFactory)(); // @vue/component

exports.props = props;
var _default2 = {
  name: 'BNavItem',
  functional: true,
  props: _objectSpread({}, props, {
    linkAttrs: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    linkClasses: {
      type: [String, Object, Array],
      default: null
    }
  }),
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        children = _ref.children;
    // We transfer the listeners to the link
    delete data.on;
    return h('li', (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'nav-item'
    }), [h(_link.default, {
      staticClass: 'nav-link',
      class: props.linkClasses,
      attrs: props.linkAttrs,
      props: props,
      on: listeners
    }, children)]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/nav-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'span'
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BNavText',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'navbar-text'
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/nav/nav.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var props = {
  tag: {
    type: String,
    default: 'ul'
  },
  fill: {
    type: Boolean,
    default: false
  },
  justified: {
    type: Boolean,
    default: false
  },
  tabs: {
    type: Boolean,
    default: false
  },
  pills: {
    type: Boolean,
    default: false
  },
  vertical: {
    type: Boolean,
    default: false
  },
  isNavBar: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BNav',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.isNavBar) {
      /* istanbul ignore next */
      (0, _warn.default)("b-nav: Prop 'is-nav-bar' is deprecated. Please use component '<b-navbar-nav>' instead.");
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      class: {
        nav: !props.isNavBar,
        'navbar-nav': props.isNavBar,
        'nav-tabs': props.tabs && !props.isNavBar,
        'nav-pills': props.pills && !props.isNavBar,
        'flex-column': props.vertical && !props.isNavBar,
        'nav-fill': props.fill,
        'nav-justified': props.justified
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/navbar/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _navbar = __webpack_require__("./node_modules/bootstrap-vue/es/components/navbar/navbar.js");

var _navbarNav = __webpack_require__("./node_modules/bootstrap-vue/es/components/navbar/navbar-nav.js");

var _navbarBrand = __webpack_require__("./node_modules/bootstrap-vue/es/components/navbar/navbar-brand.js");

var _navbarToggle = __webpack_require__("./node_modules/bootstrap-vue/es/components/navbar/navbar-toggle.js");

var _nav = __webpack_require__("./node_modules/bootstrap-vue/es/components/nav/index.js");

var _collapse = __webpack_require__("./node_modules/bootstrap-vue/es/components/collapse/index.js");

var _dropdown = __webpack_require__("./node_modules/bootstrap-vue/es/components/dropdown/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BNavbar: _navbar.default,
  BNavbarNav: _navbarNav.default,
  BNavbarBrand: _navbarBrand.default,
  BNavbarToggle: _navbarToggle.default,
  BNavToggle: _navbarToggle.default
};
var plugins = {
  NavPlugin: _nav.default,
  CollapsePlugin: _collapse.default,
  DropdownPlugin: _dropdown.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/navbar/navbar-brand.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _pluckProps = __webpack_require__("./node_modules/bootstrap-vue/es/utils/pluck-props.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var linkProps = (0, _link.propsFactory)();
linkProps.href.default = undefined;
linkProps.to.default = undefined;

var props = _objectSpread({}, linkProps, {
  tag: {
    type: String,
    default: 'div'
  } // @vue/component

});

exports.props = props;
var _default = {
  name: 'BNavbarBrand',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var isLink = Boolean(props.to || props.href);
    var tag = isLink ? _link.default : props.tag;
    return h(tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'navbar-brand',
      props: isLink ? (0, _pluckProps.default)(linkProps, props) : {}
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/navbar/navbar-nav.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var props = {
  tag: {
    type: String,
    default: 'ul'
  },
  fill: {
    type: Boolean,
    default: false
  },
  justified: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BNavbarNav',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'navbar-nav',
      class: {
        'nav-fill': props.fill,
        'nav-justified': props.justified
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/navbar/navbar-toggle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _listenOnRoot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/listen-on-root.js");

// @vue/component
var _default = {
  name: 'BNavbarToggle',
  mixins: [_listenOnRoot.default],
  props: {
    label: {
      type: String,
      default: 'Toggle navigation'
    },
    target: {
      type: String,
      required: true
    }
  },
  data: function data() {
    return {
      toggleState: false
    };
  },
  created: function created() {
    this.listenOnRoot('bv::collapse::state', this.handleStateEvt);
  },
  methods: {
    onClick: function onClick(evt) {
      this.$emit('click', evt);
      /* istanbul ignore next */

      if (!evt.defaultPrevented) {
        this.$root.$emit('bv::toggle::collapse', this.target);
      }
    },
    handleStateEvt: function handleStateEvt(id, state) {
      if (id === this.target) {
        this.toggleState = state;
      }
    }
  },
  render: function render(h) {
    return h('button', {
      class: ['navbar-toggler'],
      attrs: {
        type: 'button',
        'aria-label': this.label,
        'aria-controls': this.target,
        'aria-expanded': this.toggleState ? 'true' : 'false'
      },
      on: {
        click: this.onClick
      }
    }, [this.$slots.default || h('span', {
      class: ['navbar-toggler-icon']
    })]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/navbar/navbar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.props = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props = {
  tag: {
    type: String,
    default: 'nav'
  },
  type: {
    type: String,
    default: 'light'
  },
  variant: {
    type: String
  },
  toggleable: {
    type: [Boolean, String],
    default: false
  },
  fixed: {
    type: String
  },
  sticky: {
    type: Boolean,
    default: false
  },
  print: {
    type: Boolean,
    default: false
  } // @vue/component

};
exports.props = props;
var _default = {
  name: 'BNavbar',
  functional: true,
  props: props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var breakpoint = '';
    var xs = (0, _config.getBreakpoints)()[0];

    if (props.toggleable && typeof props.toggleable === 'string' && props.toggleable !== xs) {
      breakpoint = "navbar-expand-".concat(props.toggleable);
    } else if (props.toggleable === false) {
      breakpoint = 'navbar-expand';
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      staticClass: 'navbar',
      class: (_class = {
        'd-print': props.print,
        'sticky-top': props.sticky
      }, _defineProperty(_class, "navbar-".concat(props.type), Boolean(props.type)), _defineProperty(_class, "bg-".concat(props.variant), Boolean(props.variant)), _defineProperty(_class, "fixed-".concat(props.fixed), Boolean(props.fixed)), _defineProperty(_class, "".concat(breakpoint), Boolean(breakpoint)), _class),
      attrs: {
        role: props.tag === 'nav' ? null : 'navigation'
      }
    }), children);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/pagination-nav/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _paginationNav = __webpack_require__("./node_modules/bootstrap-vue/es/components/pagination-nav/pagination-nav.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BPaginationNav: _paginationNav.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/pagination-nav/pagination-nav.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _toString = __webpack_require__("./node_modules/bootstrap-vue/es/utils/to-string.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _router = __webpack_require__("./node_modules/bootstrap-vue/es/utils/router.js");

var _pagination = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/pagination.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// TODO: move this to an instance method in pagination mixin
function sanitizeNumPages(value) {
  var num = parseInt(value, 10) || 1;
  return num < 1 ? 1 : num;
} // Props object


var props = {
  // pagination-nav specific props
  numberOfPages: {
    type: [Number, String],
    default: 1,
    validator: function validator(value) {
      var num = parseInt(value, 10);
      /* istanbul ignore if */

      if (isNaN(num) || num < 1) {
        (0, _warn.default)('b-pagination: prop "number-of-pages" must be a number greater than 0');
        return false;
      }

      return true;
    }
  },
  baseUrl: {
    type: String,
    default: '/'
  },
  useRouter: {
    type: Boolean,
    default: false
  },
  linkGen: {
    type: Function,
    default: null
  },
  pageGen: {
    type: Function,
    default: null
  },
  pages: {
    // Optional array of page links
    type: Array,
    default: null
  },
  noPageDetect: {
    // Disable auto page number detection if true
    type: Boolean,
    default: false
  },
  // router-link specific props
  activeClass: {
    type: String // default: undefined

  },
  exact: {
    type: Boolean,
    default: false
  },
  exactActiveClass: {
    type: String // default: undefined

  },
  // nuxt-link specific prop(s)
  noPrefetch: {
    type: Boolean,
    default: false
  } // Our render function is brought in via the pagination mixin
  // @vue/component

};
var _default = {
  name: 'BPaginationNav',
  mixins: [_pagination.default],
  props: props,
  computed: {
    // Used by render function to trigger wrapping in '<nav>' element
    isNav: function isNav() {
      return true;
    },
    computedValue: function computedValue() {
      // Returns the value prop as a number or `null` if undefined or < 1
      var val = parseInt(this.value, 10);
      return isNaN(val) || val < 1 ? null : val;
    }
  },
  watch: {
    numberOfPages: function numberOfPages(newVal, oldVal) {
      var _this = this;

      this.$nextTick(function () {
        _this.setNumPages();
      });
    },
    pages: function pages(newVal, oldVal) {
      var _this2 = this;

      this.$nextTick(function () {
        _this2.setNumPages();
      });
    }
  },
  created: function created() {
    var _this3 = this;

    this.setNumPages(); // For SSR, assuming a page URL can be detected

    this.$nextTick(function () {
      _this3.guessCurrentPage();
    });
  },
  mounted: function mounted() {
    var _this4 = this;

    if (this.$router) {
      // We only add the watcher if vue router is detected
      this.$watch('$route', function (to, from) {
        _this4.$nextTick(function () {
          (0, _dom.requestAF)(function () {
            _this4.guessCurrentPage();
          });
        });
      });
    }
  },
  methods: {
    setNumPages: function setNumPages() {
      if ((0, _array.isArray)(this.pages) && this.pages.length > 0) {
        this.localNumPages = this.pages.length;
      } else {
        this.localNumPages = sanitizeNumPages(this.numberOfPages);
      }
    },
    onClick: function onClick(pageNum, evt) {
      var _this5 = this;

      // Dont do anything if clicking the current active page
      if (pageNum === this.currentPage) {
        return;
      }

      (0, _dom.requestAF)(function () {
        // Update the v-model
        // Done in in requestAF() to allow browser to complete the
        // native browser click handling of a link
        _this5.currentPage = pageNum;

        _this5.$emit('change', pageNum);
      });
      this.$nextTick(function () {
        // Done in a nextTick() to ensure rendering complete
        try {
          // Emulate native link click page reloading behaviour by blurring the
          // paginator and returning focus to the document
          var target = evt.currentTarget || evt.target;
          target.blur();
        } catch (e) {}
      });
    },
    getPageInfo: function getPageInfo(pageNum) {
      if (!(0, _array.isArray)(this.pages) || this.pages.length === 0 || this.pages[pageNum - 1] === undefined) {
        var link = "".concat(this.baseUrl).concat(pageNum);
        return {
          link: this.useRouter ? {
            path: link
          } : link,
          text: (0, _toString.default)(pageNum)
        };
      }

      var info = this.pages[pageNum - 1];

      if ((0, _object.isObject)(info)) {
        var _link = info.link;
        return {
          // Mormalize link for router use
          link: (0, _object.isObject)(_link) ? _link : this.useRouter ? {
            path: _link
          } : _link,
          // Make sure text has a value
          text: (0, _toString.default)(info.text || pageNum)
        };
      } else {
        return {
          link: (0, _toString.default)(info),
          text: (0, _toString.default)(pageNum)
        };
      }
    },
    makePage: function makePage(pageNum) {
      var info = this.getPageInfo(pageNum);

      if (this.pageGen && typeof this.pageGen === 'function') {
        return this.pageGen(pageNum, info);
      }

      return info.text;
    },
    makeLink: function makeLink(pageNum) {
      var info = this.getPageInfo(pageNum);

      if (this.linkGen && typeof this.linkGen === 'function') {
        return this.linkGen(pageNum, info);
      }

      return info.link;
    },
    linkProps: function linkProps(pageNum) {
      var link = this.makeLink(pageNum);
      var props = {
        target: this.target || null,
        rel: this.rel || null,
        disabled: this.disabled,
        // The following props are only used if BLink detects router
        exact: this.exact,
        activeClass: this.activeClass,
        exactActiveClass: this.exactActiveClass,
        append: this.append,
        replace: this.replace,
        // nuxt-link specific prop
        noPrefetch: this.noPrefetch
      };

      if (this.useRouter || _typeof(link) === 'object') {
        props.to = link;
      } else {
        props.href = link;
      }

      return props;
    },
    resolveLink: function resolveLink() {
      var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      // Given a to (or href string), convert to normalized route-like structure
      // Works only client side!!
      try {
        var link = document.createElement('a'); // Convert the `to` to a HREF via a temporary `a` tag

        link.href = (0, _router.computeHref)({
          to: to
        }, 'a', '/', '/'); // Once href is assigned, the returned href will be normalized to the full URL bits

        return {
          path: link.pathname,
          hash: link.hash,
          query: (0, _router.parseQuery)(link.search)
        };
      } catch (e) {
        /* istanbul ignore next */
        return {};
      }
    },
    resolveRoute: function resolveRoute() {
      var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      // Given a to (or href string), convert to normalized route location structure
      // works only when router available!!
      try {
        var route = this.$router.resolve(to, this.$route).route;
        return {
          path: route.path,
          hash: route.hash,
          query: route.query
        };
      } catch (e) {
        /* istanbul ignore next */
        return {};
      }
    },
    guessCurrentPage: function guessCurrentPage() {
      var guess = this.computedValue;
      var $router = this.$router;
      var $route = this.$route; // This section only occurs if we are client side, or server-side with $router

      /* istanbul ignore else */

      if (!this.noPageDetect && !guess && (_env.inBrowser || !_env.inBrowser && $router)) {
        // Current route (if router available)
        var currRoute = $router ? {
          path: $route.path,
          hash: $route.hash,
          query: $route.query
        } : {}; // Current page full HREF (if client side). Can't be done as a computed prop!

        var loc = _env.inBrowser ? window.location || document.location : null;
        var currLink = loc ? {
          path: loc.pathname,
          hash: loc.hash,
          query: (0, _router.parseQuery)(loc.search)
        } : {}; // Loop through the possible pages looking for a match until found

        for (var page = 1; !guess && page <= this.localNumPages; page++) {
          var to = this.makeLink(page);

          if ($router && ((0, _object.isObject)(to) || this.useRouter)) {
            // Resolve the page via the $router
            guess = (0, _looseEqual.default)(this.resolveRoute(to), currRoute) ? page : null;
          } else if (_env.inBrowser) {
            // If no $router available (or !this.useRouter when `to` is a string)
            // we compare using parsed URIs
            guess = (0, _looseEqual.default)(this.resolveLink(to), currLink) ? page : null;
          } else {
            // probably SSR, but no $router so we can't guess, so lets break out of loop

            /* istanbul ignore next */
            guess = -1;
          }
        }
      } // We set currentPage to 0 to trigger an $emit('input', null)
      // As the default for this.currentPage is -1 when no value is specified
      // And valid page numbers are greater than 0


      this.currentPage = guess > 0 ? guess : 0;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/pagination/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _pagination = __webpack_require__("./node_modules/bootstrap-vue/es/components/pagination/pagination.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BPagination: _pagination.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/pagination/pagination.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _pagination = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/pagination.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var DEFAULT_PER_PAGE = 20;
var DEFAULT_TOTAL_ROWS = 0;

function sanitizePerPage(value) {
  var perPage = parseInt(value, 10) || DEFAULT_PER_PAGE;
  return perPage < 1 ? 1 : perPage;
}

function sanitizeTotalRows(value) {
  var totalRows = parseInt(value, 10) || DEFAULT_TOTAL_ROWS;
  return totalRows < 0 ? 0 : totalRows;
}

var props = {
  perPage: {
    type: [Number, String],
    default: DEFAULT_PER_PAGE
  },
  totalRows: {
    type: [Number, String],
    default: DEFAULT_TOTAL_ROWS
  },
  ariaControls: {
    type: String,
    default: null
  } // Our render function is brought in from the pagination mixin
  // @vue/component

};
var _default = {
  name: 'BPagination',
  mixins: [_pagination.default],
  props: props,
  computed: {
    numberOfPages: function numberOfPages() {
      var result = Math.ceil(sanitizeTotalRows(this.totalRows) / sanitizePerPage(this.perPage));
      return result < 1 ? 1 : result;
    }
  },
  watch: {
    numberOfPages: function numberOfPages(newVal, OldVal) {
      this.localNumPages = newVal;
    }
  },
  created: function created() {
    var _this = this;

    // Set the initial page count
    this.localNumPages = this.numberOfPages; // Set the initial page value

    var curr = parseInt(this.value, 10) || 0;

    if (curr > 0) {
      this.currentPage = curr;
    } else {
      this.$nextTick(function () {
        // If this value parses to NaN or a value less than 1
        // Trigger an initial emit of 'null' if no page specified
        _this.currentPage = 0;
      });
    }
  },
  mounted: function mounted() {
    // Set the initial page count
    this.localNumPages = this.numberOfPages;
  },
  methods: {
    // These methods are used by the render function
    onClick: function onClick(num, evt) {
      var _this2 = this;

      // Handle edge cases where number of pages has changed (i.e. if perPage changes)
      // This should normally not happen, but just in case.
      if (num > this.numberOfPages) {
        /* istanbul ignore next */
        num = this.numberOfPages;
      } else if (num < 1) {
        /* istanbul ignore next */
        num = 1;
      } // Update the v-model


      this.currentPage = num; // Emit event triggered by user interaction

      this.$emit('change', this.currentPage);
      this.$nextTick(function () {
        // Keep the current button focused if possible
        var target = evt.target;

        if ((0, _dom.isVisible)(target) && _this2.$el.contains(target) && target.focus) {
          target.focus();
        } else {
          _this2.focusCurrent();
        }
      });
    },
    makePage: function makePage(pageNum) {
      return pageNum;
    },
    linkProps: function linkProps(pageNum) {
      // Always '#' for pagination component
      return {
        href: '#'
      };
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/popover/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/components/popover/popover.js");

var _popover2 = __webpack_require__("./node_modules/bootstrap-vue/es/directives/popover/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BPopover: _popover.default
};
var plugins = {
  BPopoverDirectivePlugin: _popover2.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/popover/popover.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/utils/popover.class.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _toolpop = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/toolpop.js");

// @vue/component
var _default = {
  name: 'BPopover',
  mixins: [_toolpop.default],
  props: {
    title: {
      type: String,
      default: ''
    },
    content: {
      type: String,
      default: ''
    },
    triggers: {
      type: [String, Array],
      default: 'click'
    },
    placement: {
      type: String,
      default: 'right'
    }
  },
  data: function data() {
    return {};
  },
  methods: {
    createToolpop: function createToolpop() {
      // getTarget is in toolpop mixin
      var target = this.getTarget();

      if (target) {
        this._toolpop = new _popover.default(target, this.getConfig(), this.$root);
      } else {
        this._toolpop = null;
        (0, _warn.default)("b-popover: 'target' element not found!");
      }

      return this._toolpop;
    }
  },
  render: function render(h) {
    return h('div', {
      class: ['d-none'],
      style: {
        display: 'none'
      },
      attrs: {
        'aria-hidden': true
      }
    }, [h('div', {
      ref: 'title'
    }, this.$slots.title), h('div', {
      ref: 'content'
    }, this.$slots.default)]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/progress/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _progress = __webpack_require__("./node_modules/bootstrap-vue/es/components/progress/progress.js");

var _progressBar = __webpack_require__("./node_modules/bootstrap-vue/es/components/progress/progress-bar.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BProgress: _progress.default,
  BProgressBar: _progressBar.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/progress/progress-bar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

// @vue/component
var _default2 = {
  name: 'BProgressBar',
  inject: {
    bvProgress: {
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: {
    value: {
      type: Number,
      default: 0
    },
    label: {
      type: String,
      default: null
    },
    labelHtml: {
      type: String
    },
    // $parent (this.bvProgress) prop values may take precedence over the following props
    // Which is why they are defaulted to null
    max: {
      type: Number,
      default: null
    },
    precision: {
      type: Number,
      default: null
    },
    variant: {
      type: String,
      default: null
    },
    striped: {
      type: Boolean,
      default: null
    },
    animated: {
      type: Boolean,
      default: null
    },
    showProgress: {
      type: Boolean,
      default: null
    },
    showValue: {
      type: Boolean,
      default: null
    }
  },
  computed: {
    progressBarClasses: function progressBarClasses() {
      return [this.computedVariant ? "bg-".concat(this.computedVariant) : '', this.computedStriped || this.computedAnimated ? 'progress-bar-striped' : '', this.computedAnimated ? 'progress-bar-animated' : ''];
    },
    progressBarStyles: function progressBarStyles() {
      return {
        width: 100 * (this.value / this.computedMax) + '%'
      };
    },
    computedProgress: function computedProgress() {
      var p = Math.pow(10, this.computedPrecision);
      return Math.round(100 * p * this.value / this.computedMax) / p;
    },
    computedMax: function computedMax() {
      // Prefer our max over parent setting
      return typeof this.max === 'number' ? this.max : this.bvProgress.max || 100;
    },
    computedVariant: function computedVariant() {
      // Prefer our variant over parent setting
      return this.variant || this.bvProgress.variant;
    },
    computedPrecision: function computedPrecision() {
      // Prefer our precision over parent setting
      return typeof this.precision === 'number' ? this.precision : this.bvProgress.precision || 0;
    },
    computedStriped: function computedStriped() {
      // Prefer our striped over parent setting
      return typeof this.striped === 'boolean' ? this.striped : this.bvProgress.striped || false;
    },
    computedAnimated: function computedAnimated() {
      // Prefer our animated over parent setting
      return typeof this.animated === 'boolean' ? this.animated : this.bvProgress.animated || false;
    },
    computedShowProgress: function computedShowProgress() {
      // Prefer our showProgress over parent setting
      return typeof this.showProgress === 'boolean' ? this.showProgress : this.bvProgress.showProgress || false;
    },
    computedShowValue: function computedShowValue() {
      // Prefer our showValue over parent setting
      return typeof this.showValue === 'boolean' ? this.showValue : this.bvProgress.showValue || false;
    }
  },
  render: function render(h) {
    var childNodes = h(false);

    if (this.$slots.default) {
      childNodes = this.$slots.default;
    } else if (this.label || this.labelHtml) {
      childNodes = h('span', {
        domProps: (0, _html.htmlOrText)(this.labelHtml, this.label)
      });
    } else if (this.computedShowProgress) {
      childNodes = this.computedProgress.toFixed(this.computedPrecision);
    } else if (this.computedShowValue) {
      childNodes = this.value.toFixed(this.computedPrecision);
    }

    return h('div', {
      staticClass: 'progress-bar',
      class: this.progressBarClasses,
      style: this.progressBarStyles,
      attrs: {
        role: 'progressbar',
        'aria-valuemin': '0',
        'aria-valuemax': this.computedMax.toString(),
        'aria-valuenow': this.value.toFixed(this.computedPrecision)
      }
    }, [childNodes]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/progress/progress.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _progressBar = __webpack_require__("./node_modules/bootstrap-vue/es/components/progress/progress-bar.js");

// @vue/component
var _default = {
  name: 'BProgress',
  components: {
    BProgressBar: _progressBar.default
  },
  provide: function provide() {
    return {
      bvProgress: this
    };
  },
  props: {
    // These props can be inherited via the child b-progress-bar(s)
    variant: {
      type: String,
      default: null
    },
    striped: {
      type: Boolean,
      default: false
    },
    animated: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: null
    },
    precision: {
      type: Number,
      default: 0
    },
    showProgress: {
      type: Boolean,
      default: false
    },
    showValue: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: 100
    },
    // This prop is not inherited by child b-progress-bar(s)
    value: {
      type: Number,
      default: 0
    }
  },
  computed: {
    progressHeight: function progressHeight() {
      return {
        height: this.height || null
      };
    }
  },
  render: function render(h) {
    var childNodes = this.$slots.default;

    if (!childNodes) {
      childNodes = h('b-progress-bar', {
        props: {
          value: this.value,
          max: this.max,
          precision: this.precision,
          variant: this.variant,
          animated: this.animated,
          striped: this.striped,
          showProgress: this.showProgress,
          showValue: this.showValue
        }
      });
    }

    return h('div', {
      class: ['progress'],
      style: this.progressHeight
    }, [childNodes]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/spinner/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _spinner = __webpack_require__("./node_modules/bootstrap-vue/es/components/spinner/spinner.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BSpinner: _spinner.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/spinner/spinner.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _vueFunctionalDataMerge = __webpack_require__("./node_modules/vue-functional-data-merge/dist/lib.esm.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  name: 'BSpinner',
  functional: true,
  props: {
    type: {
      type: String,
      default: 'border' // SCSS currently supports 'border' or 'grow'

    },
    label: {
      type: String,
      default: null
    },
    variant: {
      type: String,
      default: null
    },
    small: {
      type: Boolean,
      default: false
    },
    role: {
      type: String,
      default: 'status'
    },
    tag: {
      type: String,
      default: 'span'
    }
  },
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots;
    var label = h(false);
    var hasLabel = slots().label || props.label;

    if (hasLabel) {
      label = h('span', {
        staticClass: 'sr-only'
      }, hasLabel);
    }

    return h(props.tag, (0, _vueFunctionalDataMerge.mergeData)(data, {
      attrs: {
        role: hasLabel ? props.role || 'status' : null,
        'aria-hidden': hasLabel ? null : 'true'
      },
      class: (_class = {}, _defineProperty(_class, "spinner-".concat(props.type), Boolean(props.type)), _defineProperty(_class, "spinner-".concat(props.type, "-sm"), props.small), _defineProperty(_class, "text-".concat(props.variant), Boolean(props.variant)), _class)
    }), [label]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.EVENT_FILTER = exports.IGNORED_FIELD_KEYS = void 0;
// Constants used by table helpers
// Object of item keys that should be ignored for headers and stringification and filter events
var IGNORED_FIELD_KEYS = {
  _rowVariant: true,
  _cellVariants: true,
  _showDetails: true // Filter CSS Selector for click/dblclick/etc events
  // If any of these selectors match the clicked element, we ignore the event

};
exports.IGNORED_FIELD_KEYS = IGNORED_FIELD_KEYS;
var EVENT_FILTER = ['a', 'a *', // include content inside links
'button', 'button *', // include content inside buttons
'input:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'textarea:not(.disabled):not([disabled])', '[role="link"]', '[role="link"] *', '[role="button"]', '[role="button"] *', '[tabindex]:not(.disabled):not([disabled])'].join(',');
exports.EVENT_FILTER = EVENT_FILTER;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/default-sort-compare.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = defaultSortCompare;

var _get = __webpack_require__("./node_modules/bootstrap-vue/es/utils/get.js");

var _stringifyObjectValues = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/stringify-object-values.js");

// Default sort compare routine
//
// TODO: add option to sort by multiple columns (tri-state per column, plus order of columns in sort)
//  where sprtBy could be an array of objects [ {key: 'foo', sortDir: 'asc'}, {key:'bar', sortDir: 'desc'} ...]
//  or an array of arrays [ ['foo','asc'], ['bar','desc'] ]
function defaultSortCompare(a, b, sortBy) {
  a = (0, _get.default)(a, sortBy, '');
  b = (0, _get.default)(b, sortBy, '');

  if (a instanceof Date && b instanceof Date || typeof a === 'number' && typeof b === 'number') {
    // Special case for comparing Dates and Numbers
    // Internally dates are compared via their epoch number values
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  } else {
    // Do localized string comparison
    return (0, _stringifyObjectValues.default)(a).localeCompare((0, _stringifyObjectValues.default)(b), undefined, {
      numeric: true
    });
  }
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/filter-event.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = filterEvent;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _constants = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/constants.js");

// Returns true of we should ignore the click/dbclick/keypress event
// Avoids having the user need to use @click.stop on the form control
function filterEvent(evt) {
  if (!evt || !evt.target) {
    /* istanbul ignore next */
    return;
  }

  var el = evt.target;

  if (el.tagName === 'TD' || el.tagName === 'TH' || el.tagName === 'TR' || el.disabled) {
    // Shortut all the following tests for efficiency
    return false;
  }

  if ((0, _dom.closest)('.dropdown-menu', el)) {
    // Click was in a dropdown menu, so ignore
    return true;
  }

  var label = el.tagName === 'LABEL' ? el : (0, _dom.closest)('label', el);

  if (label && label.control && !label.control.disabled) {
    // If the label's form control is not disabled then we don't propagate evt
    return true;
  } // Else check to see if the event target matches one of the selectors in the event filter
  // i.e. anchors, non disabled inputs, etc. Return true if we should ignore the event.


  return (0, _dom.matches)(el, _constants.EVENT_FILTER);
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-bottom-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  methods: {
    renderBottomRow: function renderBottomRow() {
      var h = this.$createElement; // Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)
      // If in always stacked mode, we don't bother rendering the row

      if (!this.hasNormalizedSlot('bottom-row') || this.isStacked === true) {
        return h(false);
      }

      var fields = this.computedFields;
      return h('tr', {
        key: '__b-table-bottom-row__',
        staticClass: 'b-table-bottom-row',
        class: [typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(null, 'row-bottom') : this.tbodyTrClass],
        attrs: {
          role: 'row'
        }
      }, this.normalizeSlot('bottom-row', {
        columns: fields.length,
        fields: fields
      }));
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-busy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  props: {
    busy: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localBusy: false
    };
  },
  computed: {
    computedBusy: function computedBusy() {
      return this.busy || this.localBusy;
    }
  },
  watch: {
    localBusy: function localBusy(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit('update:busy', newVal);
      }
    }
  },
  methods: {
    // Event handler helper
    stopIfBusy: function stopIfBusy(evt) {
      if (this.computedBusy) {
        // If table is busy (via provider) then don't propagate
        evt.preventDefault();
        evt.stopPropagation();
        return true;
      }

      return false;
    },
    // Renter the busy indecator or return null if not busy
    renderBusy: function renderBusy() {
      var h = this.$createElement; // Return a busy indicator row, or null if not busy

      if (this.computedBusy && this.hasNormalizedSlot('table-busy')) {
        // Show the busy slot
        var trAttrs = {
          role: this.isStacked ? 'row' : null
        };
        var tdAttrs = {
          colspan: String(this.computedFields.length),
          role: this.isStacked ? 'cell' : null
        };
        return h('tr', {
          key: 'table-busy-slot',
          staticClass: 'b-table-busy-slot',
          class: [typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(null, 'table-busy') : this.tbodyTrClass],
          attrs: trAttrs
        }, [h('td', {
          attrs: tdAttrs
        }, [this.normalizeSlot('table-busy', {})])]);
      } else {
        // We return null here so that we can determine if we need to
        // render the table items rows or not.
        return null;
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-caption.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _default = {
  props: {
    caption: {
      type: String,
      default: null
    },
    captionHtml: {
      type: String
    },
    captionTop: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    captionClasses: function captionClasses() {
      return {
        'b-table-caption-top': this.captionTop
      };
    },
    captionId: function captionId() {
      // Even though this.safeId looks like a method, it is a computed prop
      // that returns a new function if the underlying ID changes
      return this.isStacked ? this.safeId('_caption_') : null;
    }
  },
  methods: {
    renderCaption: function renderCaption() {
      var h = this.$createElement; // Build the caption

      var $captionSlot = this.normalizeSlot('table-caption', {});
      var $caption = h(false);

      if ($captionSlot || this.caption || this.captionHtml) {
        var data = {
          key: 'caption',
          class: this.captionClasses,
          attrs: {
            id: this.captionId
          }
        };

        if (!$captionSlot) {
          data.domProps = (0, _html.htmlOrText)(this.captionHtml, this.caption);
        }

        $caption = h('caption', data, [$captionSlot]);
      }

      return $caption;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-colgroup.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  methods: {
    renderColgroup: function renderColgroup() {
      var h = this.$createElement;
      var fields = this.computedFields;
      var $colgroup = h(false);

      if (this.hasNormalizedSlot('table-colgroup')) {
        $colgroup = h('colgroup', {
          key: 'colgroup'
        }, [this.normalizeSlot('table-colgroup', {
          columns: fields.length,
          fields: fields
        })]);
      }

      return $colgroup;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-empty.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _default = {
  props: {
    showEmpty: {
      type: Boolean,
      default: false
    },
    emptyText: {
      type: String,
      default: 'There are no records to show'
    },
    emptyHtml: {
      type: String
    },
    emptyFilteredText: {
      type: String,
      default: 'There are no records matching your request'
    },
    emptyFilteredHtml: {
      type: String
    }
  },
  methods: {
    renderEmpty: function renderEmpty() {
      var h = this.$createElement;
      var items = this.computedItems;
      var $empty;

      if (this.showEmpty && (!items || items.length === 0) && !(this.computedBusy && this.hasNormalizedSlot('table-busy'))) {
        $empty = this.normalizeSlot(this.isFiltered ? 'emptyfiltered' : 'empty', {
          emptyFilteredHtml: this.emptyFilteredHtml,
          emptyFilteredText: this.emptyFilteredText,
          emptyHtml: this.emptyHtml,
          emptyText: this.emptyText,
          fields: this.computedFields,
          // Not sure why this is included, as it will always be an empty array
          items: this.computedItems
        });

        if (!$empty) {
          $empty = h('div', {
            class: ['text-center', 'my-2'],
            domProps: this.isFiltered ? (0, _html.htmlOrText)(this.emptyFilteredHtml, this.emptyFilteredText) : (0, _html.htmlOrText)(this.emptyHtml, this.emptyText)
          });
        }

        $empty = h('td', {
          attrs: {
            colspan: String(this.computedFields.length),
            role: 'cell'
          }
        }, [h('div', {
          attrs: {
            role: 'alert',
            'aria-live': 'polite'
          }
        }, [$empty])]);
        $empty = h('tr', {
          key: this.isFiltered ? '_b-table-empty-filtered-row_' : '_b-table-empty-row_',
          staticClass: 'b-table-empty-row',
          class: [typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(null, 'row-empty') : this.tbodyTrClass],
          attrs: {
            role: 'row'
          }
        }, [$empty]);
      }

      return $empty || h(false);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-filtering.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _stringifyRecordValues = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/stringify-record-values.js");

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var DEPRECATION_MSG = 'Supplying a function to prop "filter" is deprecated. Use "filter-function" instead.';
var _default = {
  props: {
    filter: {
      // Pasing a function to filter is deprecated and should be avoided
      type: [String, RegExp, Object, Array, Function],
      default: null,
      deprecated: DEPRECATION_MSG
    },
    filterFunction: {
      type: Function,
      default: null
    }
  },
  data: function data() {
    return {
      // Flag for displaying which empty slot to show, and for some event triggering.
      isFiltered: false
    };
  },
  computed: {
    localFiltering: function localFiltering() {
      return this.hasProvider ? !!this.noProviderFiltering : true;
    },
    filteredCheck: function filteredCheck() {
      // For watching changes to filteredItems vs localItems
      return {
        filteredItems: this.filteredItems,
        localItems: this.localItems,
        localFilter: this.localFilter
      };
    },
    localFilter: function localFilter() {
      // Returns a sanitized/normalized version of filter prop
      if (typeof this.filter === 'function') {
        // this.localFilterFn will contain the correct function ref.
        // Deprecate setting prop filter to a function

        /* istanbul ignore next */
        return '';
      } else if (typeof this.filterFunction !== 'function' && !(typeof this.filter === 'string' || this.filter instanceof RegExp)) {
        // Using internal filter function, which only accepts string or regexp at the moment
        return '';
      } else {
        // Could be a string, object or array, as needed by external filter function
        return this.filter;
      }
    },
    localFilterFn: function localFilterFn() {
      var filter = this.filter;
      var filterFn = this.filterFunction; // Sanitized/normalize filter-function prop

      if (typeof filterFn === 'function') {
        return filterFn;
      } else if (typeof filter === 'function') {
        // Deprecate setting prop filter to a function

        /* istanbul ignore next */
        (0, _warn.default)("b-table: ".concat(DEPRECATION_MSG));
        /* istanbul ignore next */

        return filter;
      } else {
        // no filterFunction, so signal to use internal filter function
        return null;
      }
    },
    filteredItems: function filteredItems() {
      // Returns the records in localItems that match the filter criteria.
      // Returns the original localItems array if not sorting
      var items = this.localItems || [];
      var criteria = this.localFilter;
      var filterFn = this.filterFnFactory(this.localFilterFn, criteria) || this.defaultFilterFnFactory(criteria); // We only do local filtering if requested, and if the are records to filter and
      // if a filter criteria was specified

      if (this.localFiltering && filterFn && items.length > 0) {
        items = items.filter(filterFn);
      }

      return items;
    }
  },
  watch: {
    // Watch for changes to the filter criteria and filtered items vs localItems).
    // And set visual state and emit events as required
    filteredCheck: function filteredCheck(_ref) {
      var filteredItems = _ref.filteredItems,
          localItems = _ref.localItems,
          localFilter = _ref.localFilter;
      // Determine if the dataset is filtered or not
      var isFiltered;

      if (!localFilter) {
        // If filter criteria is falsey
        isFiltered = false;
      } else if ((0, _looseEqual.default)(localFilter, []) || (0, _looseEqual.default)(localFilter, {})) {
        // If filter criteria is an empty array or object
        isFiltered = false;
      } else if (localFilter) {
        // if Filter criteria is truthy
        isFiltered = true;
      } else {
        /* istanbul ignore next: rare chance of reaching this else */
        isFiltered = false;
      }

      if (isFiltered) {
        this.$emit('filtered', filteredItems, filteredItems.length);
      }

      this.isFiltered = isFiltered;
    },
    isFiltered: function isFiltered(newVal, oldVal) {
      if (newVal === false && oldVal === true) {
        // We need to emit a filtered event if isFiltered transitions from true to
        // false so that users can update their pagination controls.
        this.$emit('filtered', this.localItems, this.localItems.length);
      }
    }
  },
  created: function created() {
    var _this = this;

    // Set the initial filtered state.
    // In a nextTick so that we trigger a filtered event if needed
    this.$nextTick(function () {
      _this.isFiltered = Boolean(_this.localFilter);
    });
  },
  methods: {
    // Filter Function factories
    filterFnFactory: function filterFnFactory(filterFn, criteria) {
      // Wrapper factory for external filter functions.
      // Wrap the provided filter-function and return a new function.
      // Returns null if no filter-function defined or if criteria is falsey.
      // Rather than directly grabbing this.computedLocalFilterFn or this.filterFunction
      // we have it passed, so that the caller computed prop will be reactive to changes
      // in the original filter-function (as this routine is a method)
      if (!filterFn || typeof filterFn !== 'function' || !criteria || (0, _looseEqual.default)(criteria, []) || (0, _looseEqual.default)(criteria, {})) {
        return null;
      } // Build the wrapped filter test function, passing the criteria to the provided function


      var fn = function fn(item) {
        // Generated function returns true if the criteria matches part
        // of the serialized data, otherwise false
        return filterFn(item, criteria);
      }; // Return the wrapped function


      return fn;
    },
    defaultFilterFnFactory: function defaultFilterFnFactory(criteria) {
      // Generates the default filter function, using the given filter criteria
      if (!criteria || !(typeof criteria === 'string' || criteria instanceof RegExp)) {
        // Built in filter can only support strings or RegExp criteria (at the moment)
        return null;
      } // Build the regexp needed for filtering


      var regexp = criteria;

      if (typeof regexp === 'string') {
        // Escape special RegExp characters in the string and convert contiguous
        // whitespace to \s+ matches
        var pattern = criteria.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&').replace(/[\s\uFEFF\xA0]+/g, '\\s+'); // Build the RegExp (no need for global flag, as we only need
        // to find the value once in the string)

        regexp = new RegExp(".*".concat(pattern, ".*"), 'i');
      } // Generate the wrapped filter test function to use


      var fn = function fn(item) {
        // This searches all row values (and sub property values) in the entire (excluding
        // special _ prefixed keys), because we convert the record to a space-separated
        // string containing all the value properties (recursively), even ones that are
        // not visible (not specified in this.fields).
        //
        // TODO: Enable searching on formatted fields and scoped slots
        // TODO: Should we filter only on visible fields (i.e. ones in this.fields) by default?
        // TODO: Allow for searching on specific fields/key, this could be combined with the previous TODO
        // TODO: Give stringifyRecordValues extra options for filtering (i.e. passing the
        //       fields definition and a reference to $scopedSlots)
        //
        // Generated function returns true if the criteria matches part of
        // the serialized data, otherwise false
        // We set lastIndex = 0 on regex in case someone uses the /g global flag
        regexp.lastIndex = 0;
        return regexp.test((0, _stringifyRecordValues.default)(item));
      }; // Return the generated function


      return fn;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-items.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _normalizeFields = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/normalize-fields.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _default2 = {
  props: {
    items: {
      type: [Array, Function],
      default: function _default()
      /* istanbul ignore next */
      {
        return [];
      }
    },
    fields: {
      // Object format is deprecated and should be avoided
      type: [Array, Object],
      default: null
    },
    primaryKey: {
      // Primary key for record.
      // If provided the value in each row must be unique!!!
      type: String,
      default: null
    }
  },
  data: function data() {
    return {
      // Our local copy of the items. Must be an array
      localItems: (0, _array.isArray)(this.items) ? this.items.slice() : []
    };
  },
  computed: {
    computedFields: function computedFields() {
      // We normalize fields into an array of objects
      // [ { key:..., label:..., ...}, {...}, ..., {..}]
      return (0, _normalizeFields.default)(this.fields, this.localItems);
    },
    computedFieldsObj: function computedFieldsObj()
    /* istanbul ignore next: not using at the moment */
    {
      // Fields as a simple lookup hash object
      // Mainly for scopedSlots for convenience
      return this.computedFields.reduce(function (f, obj) {
        obj[f.key] = f;
        return obj;
      }, {});
    }
  },
  watch: {
    items: function items(newItems) {
      /* istanbul ignore else */
      if ((0, _array.isArray)(newItems)) {
        // Set localItems/filteredItems to a copy of the provided array
        this.localItems = newItems.slice();
      } else if (newItems === null || newItems === undefined) {
        /* istanbul ignore next */
        this.localItems = [];
      }
    }
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-pagination.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  props: {
    perPage: {
      type: [Number, String],
      default: 0
    },
    currentPage: {
      type: [Number, String],
      default: 1
    }
  },
  computed: {
    localPaging: function localPaging() {
      return this.hasProvider ? !!this.noProviderPaging : true;
    },
    paginatedItems: function paginatedItems() {
      var items = this.sortedItems || [];
      var currentPage = Math.max(parseInt(this.currentPage, 10) || 1, 1);
      var perPage = Math.max(parseInt(this.perPage, 10) || 0, 0); // Apply local pagination

      if (this.localPaging && !!perPage) {
        // Grab the current page of data (which may be past filtered items limit)
        items = items.slice((currentPage - 1) * perPage, currentPage * perPage);
      } // Return the items to display in the table


      return items;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-provider.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _listenOnRoot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/listen-on-root.js");

var _default = {
  mixins: [_listenOnRoot.default],
  props: {
    noProviderPaging: {
      type: Boolean,
      default: false
    },
    noProviderSorting: {
      type: Boolean,
      default: false
    },
    noProviderFiltering: {
      type: Boolean,
      default: false
    },
    apiUrl: {
      // Passthrough prop. Passed to the context object. Not used by b-table directly
      type: String,
      default: ''
    }
  },
  computed: {
    hasProvider: function hasProvider() {
      return this.items instanceof Function;
    },
    providerTriggerContext: function providerTriggerContext() {
      // Used to trigger the provider function via a watcher. Only the fields that
      // are needed for triggering a provider update are included. Note that the
      // regular this.context is sent to the provider during fetches though, as they
      // may neeed all the prop info.
      var ctx = {
        apiUrl: this.apiUrl
      };

      if (!this.noProviderFiltering) {
        // Either a string, or could be an object or array.
        ctx.filter = this.localFilter;
      }

      if (!this.noProviderSorting) {
        ctx.sortBy = this.localSortBy;
        ctx.sortDesc = this.localSortDesc;
      }

      if (!this.noProviderPaging) {
        ctx.perPage = this.perPage;
        ctx.currentPage = this.currentPage;
      }

      return ctx;
    }
  },
  watch: {
    // Provider update triggering
    items: function items(newVal, oldVal) {
      // If a new provider has been specified, trigger an update
      if (this.hasProvider || newVal instanceof Function) {
        this.$nextTick(this._providerUpdate);
      }
    },
    providerTriggerContext: function providerTriggerContext(newVal, oldVal) {
      // Trigger the provider to update as the relevant context values have changed.
      if (!(0, _looseEqual.default)(newVal, oldVal)) {
        this.$nextTick(this._providerUpdate);
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    // Call the items provider if necessary
    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {
      // Fetch on mount if localItems is empty
      this._providerUpdate();
    } // Listen for global messages to tell us to force refresh the table


    this.listenOnRoot('bv::refresh::table', function (id) {
      if (id === _this.id || id === _this) {
        _this.refresh();
      }
    });
  },
  methods: {
    refresh: function refresh() {
      // Public Method: Force a refresh of the provider function
      this.$off('refreshed', this.refresh);

      if (this.computedBusy) {
        // Can't force an update when forced busy by user (busy prop === true)
        if (this.localBusy && this.hasProvider) {
          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted
          this.$on('refreshed', this.refresh);
        }
      } else {
        this.clearSelected();

        if (this.hasProvider) {
          this.$nextTick(this._providerUpdate);
        } else {
          /* istanbul ignore next */
          this.localItems = (0, _array.isArray)(this.items) ? this.items.slice() : [];
        }
      }
    },
    // Provider related methods
    _providerSetLocal: function _providerSetLocal(items) {
      this.localItems = (0, _array.isArray)(items) ? items.slice() : [];
      this.localBusy = false;
      this.$emit('refreshed'); // New root emit

      if (this.id) {
        this.emitOnRoot('bv::table::refreshed', this.id);
      }
    },
    _providerUpdate: function _providerUpdate() {
      // Refresh the provider function items.
      if (!this.hasProvider) {
        // Do nothing if no provider
        return;
      } // If table is busy, wait until refereshed before calling again


      if (this.computedBusy) {
        // Schedule a new refresh once `refreshed` is emitted
        this.$nextTick(this.refresh);
        return;
      } // Set internal busy state


      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated

      this.$nextTick(function () {
        var _this2 = this;

        try {
          // Call provider function passing it the context and optional callback
          var data = this.items(this.context, this._providerSetLocal);

          if (data && data.then && typeof data.then === 'function') {
            // Provider returned Promise
            data.then(function (items) {
              // Provider resolved with items
              _this2._providerSetLocal(items);
            });
          } else if ((0, _array.isArray)(data)) {
            // Provider returned Array data
            this._providerSetLocal(data);
          } else if (this.items.length !== 2) {
            // Check number of arguments provider function requested
            // Provider not using callback (didn't request second argument), so we clear
            // busy state as most likely there was an error in the provider function

            /* istanbul ignore next */
            (0, _warn.default)("b-table provider function didn't request calback and did not return a promise or data");
            /* istanbul ignore next */

            this.localBusy = false;
          }
        } catch (e)
        /* istanbul ignore next */
        {
          // Provider function borked on us, so we spew out a warning
          // and clear the busy state
          (0, _warn.default)("b-table provider function error [".concat(e.name, "] ").concat(e.message));
          this.localBusy = false;
          this.$off('refreshed', this.refresh);
        }
      });
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-selectable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _sanitizeRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/sanitize-row.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: {
    selectable: {
      type: Boolean,
      default: false
    },
    selectMode: {
      type: String,
      default: 'multi'
    },
    selectedVariant: {
      type: String,
      default: 'primary'
    }
  },
  data: function data() {
    return {
      selectedRows: [],
      selectedLastRow: -1
    };
  },
  computed: {
    selectableTableClasses: function selectableTableClasses() {
      var _ref;

      var selectable = this.selectable;
      var isSelecting = selectable && this.selectedRows && this.selectedRows.some(Boolean);
      return _ref = {
        'b-table-selectable': selectable
      }, _defineProperty(_ref, "b-table-select-".concat(this.selectMode), selectable), _defineProperty(_ref, 'b-table-selecting', isSelecting), _ref;
    },
    selectableTableAttrs: function selectableTableAttrs() {
      return {
        'aria-multiselectable': this.selectableIsMultiSelect
      };
    },
    selectableIsMultiSelect: function selectableIsMultiSelect() {
      if (this.selectable) {
        return (0, _array.arrayIncludes)(['range', 'multi'], this.selectMode) ? 'true' : 'false';
      } else {
        return null;
      }
    }
  },
  watch: {
    computedItems: function computedItems(newVal, oldVal) {
      // Reset for selectable
      // TODO: Should selectedLastClicked be reset here?
      //       As changes to _showDetails would trigger it to reset
      this.selectedLastRow = -1;
      var equal = false;

      if (this.selectable && this.selectedRows.length > 0) {
        // Quick check against array length
        equal = (0, _array.isArray)(newVal) && (0, _array.isArray)(oldVal) && newVal.length === oldVal.length;

        for (var i = 0; equal && i < newVal.length; i++) {
          // Look for the first non-loosely equal row, after ignoring reserved fields
          equal = (0, _looseEqual.default)((0, _sanitizeRow.default)(newVal[i]), (0, _sanitizeRow.default)(oldVal[i]));
        }
      }

      if (!equal) {
        this.clearSelected();
      }
    },
    selectable: function selectable(newVal, oldVal) {
      this.clearSelected();
      this.setSelectionHandlers(newVal);
    },
    selectMode: function selectMode(newVal, oldVal) {
      this.clearSelected();
    },
    selectedRows: function selectedRows(_selectedRows, oldVal) {
      var _this = this;

      if (this.selectable && !(0, _looseEqual.default)(_selectedRows, oldVal)) {
        var items = []; // forEach skips over non-existant indicies (on sparse arrays)

        _selectedRows.forEach(function (v, idx) {
          if (v) {
            items.push(_this.computedItems[idx]);
          }
        });

        this.$emit('row-selected', items);
      }
    }
  },
  beforeMount: function beforeMount() {
    // Set up handlers
    if (this.selectable) {
      this.setSelectionHandlers(true);
    }
  },
  methods: {
    isRowSelected: function isRowSelected(idx) {
      return Boolean(this.selectedRows[idx]);
    },
    selectableRowClasses: function selectableRowClasses(idx) {
      var rowSelected = this.isRowSelected(idx);
      var base = this.dark ? 'bg' : 'table';
      var variant = this.selectedVariant;
      return _defineProperty({
        'b-table-row-selected': this.selectable && rowSelected
      }, "".concat(base, "-").concat(variant), this.selectable && rowSelected && variant);
    },
    selectableRowAttrs: function selectableRowAttrs(idx) {
      return {
        'aria-selected': !this.selectable ? null : this.isRowSelected(idx) ? 'true' : 'false'
      };
    },
    clearSelected: function clearSelected() {
      var hasSelection = this.selectedRows.reduce(function (prev, v) {
        return prev || v;
      }, false);

      if (hasSelection) {
        this.selectedLastClicked = -1;
        this.selectedRows = [];
      }
    },
    setSelectionHandlers: function setSelectionHandlers(on) {
      var method = on ? '$on' : '$off'; // Handle row-clicked event

      this[method]('row-clicked', this.selectionHandler); // Clear selection on filter, pagination, and sort changes

      this[method]('filtered', this.clearSelected);
      this[method]('context-changed', this.clearSelected);
    },
    selectionHandler: function selectionHandler(item, index, evt) {
      /* istanbul ignore if: should never happen */
      if (!this.selectable) {
        // Don't do anything if table is not in selectable mode

        /* istanbul ignore next: should never happen */
        this.clearSelected();
        /* istanbul ignore next: should never happen */

        return;
      }

      var selectedRows = this.selectedRows.slice();
      var selected = !selectedRows[index];
      var mode = this.selectMode; // Note 'multi' mode needs no special handling

      if (mode === 'single') {
        selectedRows = [];
      } else if (mode === 'range') {
        if (this.selectedLastRow > -1 && evt.shiftKey) {
          // range
          for (var idx = Math.min(this.selectedLastRow, index); idx <= Math.max(this.selectedLastRow, index); idx++) {
            selectedRows[idx] = true;
          }

          selected = true;
        } else {
          if (!(evt.ctrlKey || evt.metaKey)) {
            // clear range selection if any
            selectedRows = [];
            selected = true;
          }

          this.selectedLastRow = selected ? index : -1;
        }
      }

      selectedRows[index] = selected;
      this.selectedRows = selectedRows;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-sorting.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _stableSort = __webpack_require__("./node_modules/bootstrap-vue/es/utils/stable-sort.js");

var _startcase = __webpack_require__("./node_modules/bootstrap-vue/es/utils/startcase.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _defaultSortCompare = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/default-sort-compare.js");

var _default = {
  props: {
    sortBy: {
      type: String,
      default: null
    },
    sortDesc: {
      // To Do: Make this tri-state: true, false, null
      type: Boolean,
      default: false
    },
    sortDirection: {
      // This prop is named incorrectly.
      // It should be initialSortDirection
      // As it is a bit misleading (not to mention screws up
      // the Aria Label on the headers)
      type: String,
      default: 'asc',
      validator: function validator(direction) {
        return (0, _array.arrayIncludes)(['asc', 'desc', 'last'], direction);
      }
    },
    sortCompare: {
      type: Function,
      default: null
    },
    noSortReset: {
      // Another prop that should have had a better name.
      // It should be noSortClear (on non-sortable headers).
      // We will need to make sure the documentation is clear on what
      // this prop does (as well as in the code for future reference)
      type: Boolean,
      default: false
    },
    labelSortAsc: {
      type: String,
      default: 'Click to sort Ascending'
    },
    labelSortDesc: {
      type: String,
      default: 'Click to sort Descending'
    },
    labelSortClear: {
      type: String,
      default: 'Click to clear sorting'
    },
    noLocalSorting: {
      type: Boolean,
      default: false
    },
    noFooterSorting: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localSortBy: this.sortBy || '',
      localSortDesc: this.sortDesc || false
    };
  },
  computed: {
    localSorting: function localSorting() {
      return this.hasProvider ? !!this.noProviderSorting : !this.noLocalSorting;
    },
    isSortable: function isSortable() {
      return this.computedFields.some(function (f) {
        return f.sortable;
      });
    },
    sortedItems: function sortedItems() {
      // Sorts the filtered items and returns a new array of the sorted items
      // or the original items array if not sorted.
      var items = (this.filteredItems || []).slice();
      var sortBy = this.localSortBy;
      var sortDesc = this.localSortDesc;
      var sortCompare = this.sortCompare;
      var localSorting = this.localSorting;

      if (sortBy && localSorting) {
        // stableSort returns a new array, and leaves the original array intact
        return (0, _stableSort.default)(items, function (a, b) {
          var result = null;

          if (typeof sortCompare === 'function') {
            // Call user provided sortCompare routine
            result = sortCompare(a, b, sortBy, sortDesc);
          }

          if (result === null || result === undefined || result === false) {
            // Fallback to built-in defaultSortCompare if sortCompare
            // is not defined or returns null/false
            result = (0, _defaultSortCompare.default)(a, b, sortBy);
          } // Negate result if sorting in descending order


          return (result || 0) * (sortDesc ? -1 : 1);
        });
      }

      return items;
    }
  },
  watch: {
    isSortable: function isSortable(newVal, oldVal)
    /* istanbul ignore next: pain in the butt to test */
    {
      if (newVal) {
        if (this.isSortable) {
          this.$on('head-clicked', this.handleSort);
        }
      } else {
        this.$off('head-clicked', this.handleSort);
      }
    },
    sortDesc: function sortDesc(newVal, oldVal) {
      if (newVal === this.localSortDesc) {
        /* istanbul ignore next */
        return;
      }

      this.localSortDesc = newVal || false;
    },
    sortBy: function sortBy(newVal, oldVal) {
      if (newVal === this.localSortBy) {
        /* istanbul ignore next */
        return;
      }

      this.localSortBy = newVal || null;
    },
    // Update .sync props
    localSortDesc: function localSortDesc(newVal, oldVal) {
      // Emit update to sort-desc.sync
      if (newVal !== oldVal) {
        this.$emit('update:sortDesc', newVal);
      }
    },
    localSortBy: function localSortBy(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit('update:sortBy', newVal);
      }
    }
  },
  created: function created() {
    if (this.isSortable) {
      this.$on('head-clicked', this.handleSort);
    }
  },
  methods: {
    // Handlers
    // Need to move from thead-mixin
    handleSort: function handleSort(key, field, evt, isFoot) {
      var _this = this;

      if (!this.isSortable) {
        /* istanbul ignore next */
        return;
      }

      if (isFoot && this.noFooterSorting) {
        return;
      } // TODO: make this tri-state sorting
      // cycle desc => asc => none => desc => ...


      var sortChanged = false;

      var toggleLocalSortDesc = function toggleLocalSortDesc() {
        var sortDirection = field.sortDirection || _this.sortDirection;

        if (sortDirection === 'asc') {
          _this.localSortDesc = false;
        } else if (sortDirection === 'desc') {
          _this.localSortDesc = true;
        } else {// sortDirection === 'last'
          // Leave at last sort direction from previous column
        }
      };

      if (field.sortable) {
        if (key === this.localSortBy) {
          // Change sorting direction on current column
          this.localSortDesc = !this.localSortDesc;
        } else {
          // Start sorting this column ascending
          this.localSortBy = key; // this.localSortDesc = false

          toggleLocalSortDesc();
        }

        sortChanged = true;
      } else if (this.localSortBy && !this.noSortReset) {
        this.localSortBy = null;
        toggleLocalSortDesc();
        sortChanged = true;
      }

      if (sortChanged) {
        // Sorting parameters changed
        this.$emit('sort-changed', this.context);
      }
    },
    // methods to compute classes and attrs for thead>th cells
    sortTheadThClasses: function sortTheadThClasses(key, field, isFoot) {
      return {// No Classes for sorting currently...
        // All styles targeted using aria-* attrs
      };
    },
    sortTheadThAttrs: function sortTheadThAttrs(key, field, isFoot) {
      if (!this.isSortable || isFoot && this.noFooterSorting) {
        // No atributes if not a sortable table
        return {};
      }

      var sortable = field.sortable;
      var ariaLabel = '';

      if ((!field.label || !field.label.trim()) && !field.headerTitle) {
        // In case field's label and title are empty/blank, we need to
        // add a hint about what the column is about for non-sighted users.
        // This is dulicated code from tbody-row mixin, but we need it
        // here as well, since we overwrite the original aria-label.

        /* istanbul ignore next */
        ariaLabel = (0, _startcase.default)(key);
      } // The correctness of these labels is very important for screen-reader users.


      var ariaLabelSorting = '';

      if (sortable) {
        if (this.localSortBy === key) {
          // currently sorted sortable column.
          ariaLabelSorting = this.localSortDesc ? this.labelSortAsc : this.labelSortDesc;
        } else {
          // Not currently sorted sortable column.
          // Not using nested ternary's here for clarity/readability
          // Default for ariaLabel
          ariaLabelSorting = this.localSortDesc ? this.labelSortDesc : this.labelSortAsc; // Handle sortDirection setting

          var sortDirection = this.sortDirection || field.sortDirection;

          if (sortDirection === 'asc') {
            ariaLabelSorting = this.labelSortAsc;
          } else if (sortDirection === 'desc') {
            ariaLabelSorting = this.labelSortDesc;
          }
        }
      } else if (!this.noSortReset) {
        // Non sortable column
        ariaLabelSorting = this.localSortBy ? this.labelSortClear : '';
      } // Assemble the aria-label attribute value


      ariaLabel = [ariaLabel.trim(), ariaLabelSorting.trim()].filter(Boolean).join(': '); // Assemble the aria-sort attribute value

      var ariaSort = sortable && this.localSortBy === key ? this.localSortDesc ? 'descending' : 'ascending' : sortable ? 'none' : null; // Return the attributes
      // (All the above just to get these two values)

      return {
        'aria-label': ariaLabel || null,
        'aria-sort': ariaSort
      };
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tbody-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _toString = __webpack_require__("./node_modules/bootstrap-vue/es/utils/to-string.js");

var _get = __webpack_require__("./node_modules/bootstrap-vue/es/utils/get.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _filterEvent = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/filter-event.js");

var _textSelectionActive = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/text-selection-active.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: {
    tbodyTrClass: {
      type: [String, Array, Function],
      default: null
    }
  },
  methods: {
    // Methods for computing classes, attributes and styles for table cells
    tdClasses: function tdClasses(field, item) {
      var cellVariant = '';

      if (item._cellVariants && item._cellVariants[field.key]) {
        cellVariant = "".concat(this.dark ? 'bg' : 'table', "-").concat(item._cellVariants[field.key]);
      }

      return [field.variant && !cellVariant ? "".concat(this.dark ? 'bg' : 'table', "-").concat(field.variant) : '', cellVariant, field.class ? field.class : '', this.getTdValues(item, field.key, field.tdClass, '')];
    },
    tdAttrs: function tdAttrs(field, item, colIndex) {
      var attrs = {
        role: 'cell',
        'aria-colindex': String(colIndex + 1)
      };

      if (field.isRowHeader) {
        attrs.scope = 'row';
        attrs.role = 'rowheader';
      }

      if (this.isStacked) {
        // Generate the "header cell" label content in stacked mode
        attrs['data-label'] = field.label;
      }

      return _objectSpread({}, attrs, this.getTdValues(item, field.key, field.tdAttr, {}));
    },
    rowClasses: function rowClasses(item) {
      return [item._rowVariant ? "".concat(this.dark ? 'bg' : 'table', "-").concat(item._rowVariant) : '', typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(item, 'row') : this.tbodyTrClass];
    },
    getTdValues: function getTdValues(item, key, tdValue, defValue) {
      var parent = this.$parent;

      if (tdValue) {
        var value = (0, _get.default)(item, key, '');

        if (typeof tdValue === 'function') {
          return tdValue(value, key, item);
        } else if (typeof tdValue === 'string' && typeof parent[tdValue] === 'function') {
          return parent[tdValue](value, key, item);
        }

        return tdValue;
      }

      return defValue;
    },
    // Method to get the value for a field
    getFormattedValue: function getFormattedValue(item, field) {
      var key = field.key;
      var formatter = field.formatter;
      var parent = this.$parent;
      var value = (0, _get.default)(item, key, null);

      if (formatter) {
        if (typeof formatter === 'function') {
          value = formatter(value, key, item);
        } else if (typeof formatter === 'string' && typeof parent[formatter] === 'function') {
          value = parent[formatter](value, key, item);
        }
      }

      return value === null || typeof value === 'undefined' ? '' : value;
    },
    tbodyRowKeydown: function tbodyRowKeydown(evt, item, rowIndex) {
      var keyCode = evt.keyCode;
      var target = evt.target;
      var trs = this.$refs.itemRows;

      if (this.stopIfBusy(evt)) {
        // If table is busy (via provider) then don't propagate
        return;
      } else if (!(target && target.tagName === 'TR' && target === document.activeElement)) {
        // Ignore if not the active tr element
        return;
      } else if (target.tabIndex !== 0) {
        // Ignore if not focusable

        /* istanbul ignore next */
        return;
      } else if (trs && trs.length === 0) {
        /* istanbul ignore next */
        return;
      }

      var index = trs.indexOf(target);

      if (keyCode === _keyCodes.default.ENTER || keyCode === _keyCodes.default.SPACE) {
        evt.stopPropagation();
        evt.preventDefault(); // We also allow enter/space to trigger a click (when row is focused)
        // We translate to a row-clicked event

        this.rowClicked(evt, item, rowIndex);
      } else if ((0, _array.arrayIncludes)([_keyCodes.default.UP, _keyCodes.default.DOWN, _keyCodes.default.HOME, _keyCodes.default.END], keyCode)) {
        evt.stopPropagation();
        evt.preventDefault();
        var shift = evt.shiftKey;

        if (keyCode === _keyCodes.default.HOME || shift && keyCode === _keyCodes.default.UP) {
          // Focus first row
          trs[0].focus();
        } else if (keyCode === _keyCodes.default.END || shift && keyCode === _keyCodes.default.DOWN) {
          // Focus last row
          trs[trs.length - 1].focus();
        } else if (keyCode === _keyCodes.default.UP && index > 0) {
          // Focus previous row
          trs[index - 1].focus();
        } else if (keyCode === _keyCodes.default.DOWN && index < trs.length - 1) {
          // Focus next row
          trs[index + 1].focus();
        }
      }
    },
    // Row event handlers
    rowClicked: function rowClicked(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      } else if ((0, _filterEvent.default)(e)) {
        // clicked on a non-disabled control so ignore
        return;
      } else if ((0, _textSelectionActive.default)(this.$el)) {
        // User is selecting text, so ignore

        /* istanbul ignore next: JSDOM doesn't support getSelection() */
        return;
      }

      this.$emit('row-clicked', item, index, e);
    },
    middleMouseRowClicked: function middleMouseRowClicked(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      }

      this.$emit('row-middle-clicked', item, index, e);
    },
    rowDblClicked: function rowDblClicked(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      } else if ((0, _filterEvent.default)(e)) {
        // clicked on a non-disabled control so ignore

        /* istanbul ignore next: event filtering already tested via click handler */
        return;
      }

      this.$emit('row-dblclicked', item, index, e);
    },
    rowHovered: function rowHovered(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      }

      this.$emit('row-hovered', item, index, e);
    },
    rowUnhovered: function rowUnhovered(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      }

      this.$emit('row-unhovered', item, index, e);
    },
    rowContextmenu: function rowContextmenu(e, item, index) {
      if (this.stopIfBusy(e)) {
        // If table is busy (via provider) then don't propagate
        return;
      }

      this.$emit('row-contextmenu', item, index, e);
    },
    // Render helpers
    renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {
      var _this = this;

      var h = this.$createElement; // Renders a TD or TH for a row's field

      var $scoped = this.$scopedSlots;
      var detailsSlot = $scoped['row-details'];
      var rowSelected = this.selectedRows[rowIndex];
      var formatted = this.getFormattedValue(item, field);
      var data = {
        // For the Vue key, we concatinate the column index and field key (as field keys can be duplicated)
        key: "row-".concat(rowIndex, "-cell-").concat(colIndex, "-").concat(field.key),
        class: this.tdClasses(field, item),
        attrs: this.tdAttrs(field, item, colIndex)
      };

      var toggleDetailsFn = function toggleDetailsFn() {
        if (detailsSlot) {
          _this.$set(item, '_showDetails', !item._showDetails);
        }
      };

      var slotScope = {
        item: item,
        index: rowIndex,
        field: field,
        unformatted: (0, _get.default)(item, field.key, ''),
        value: formatted,
        toggleDetails: toggleDetailsFn,
        detailsShowing: Boolean(item._showDetails),
        rowSelected: Boolean(rowSelected)
      };
      var $childNodes = $scoped[field.key] ? $scoped[field.key](slotScope) : (0, _toString.default)(formatted);

      if (this.isStacked) {
        // We wrap in a DIV to ensure rendered as a single cell when visually stacked!
        $childNodes = [h('div', {}, [$childNodes])];
      } // Render either a td or th cell


      return h(field.isRowHeader ? 'th' : 'td', data, [$childNodes]);
    },
    renderTbodyRow: function renderTbodyRow(item, rowIndex) {
      var _this2 = this;

      // Renders an item's row (or rows if details supported)
      var h = this.$createElement;
      var $scoped = this.$scopedSlots;
      var fields = this.computedFields;
      var tableStriped = this.striped;
      var hasRowClickHandler = this.$listeners['row-clicked'] || this.selectable;
      var $detailsSlot = $scoped['row-details'];
      var rowShowDetails = Boolean(item._showDetails && $detailsSlot); // We can return more than one TR if rowDetails enabled

      var $rows = []; // Details ID needed for aria-describedby when details showing

      var detailsId = rowShowDetails ? this.safeId("_details_".concat(rowIndex, "_")) : null;

      var toggleDetailsFn = function toggleDetailsFn() {
        if ($detailsSlot) {
          _this2.$set(item, '_showDetails', !item._showDetails);
        }
      }; // For each item data field in row


      var $tds = fields.map(function (field, colIndex) {
        return _this2.renderTbodyRowCell(field, colIndex, item, rowIndex);
      }); // Calculate the row number in the dataset (indexed from 1)

      var ariaRowIndex = null;

      if (this.currentPage && this.perPage && this.perPage > 0) {
        ariaRowIndex = String((this.currentPage - 1) * this.perPage + rowIndex + 1);
      } // Create a unique :key to help ensure that sub components are re-rendered rather than
      // re-used, which can cause issues. If a primary key is not provided we use the rendered
      // rows index within the tbody.
      // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410


      var primaryKey = this.primaryKey;
      var rowKey = primaryKey && item[primaryKey] !== undefined && item[primaryKey] !== null ? (0, _toString.default)(item[primaryKey]) : String(rowIndex); // If primary key is provided, use it to generate a unique ID on each tbody > tr
      // In the format of '{tableId}__row_{primaryKeyValue}'

      var rowId = primaryKey && item[primaryKey] !== undefined && item[primaryKey] !== null ? this.safeId("_row_".concat(item[primaryKey])) : null;
      var handlers = {};

      if (hasRowClickHandler) {
        handlers['click'] = function (evt) {
          _this2.rowClicked(evt, item, rowIndex);
        };

        handlers['keydown'] = function (evt) {
          _this2.tbodyRowKeydown(evt, item, rowIndex);
        };
      } // Add the item row


      $rows.push(h('tr', {
        key: "__b-table-row-".concat(rowKey, "__"),
        ref: 'itemRows',
        refInFor: true,
        class: [this.rowClasses(item), this.selectableRowClasses(rowIndex), {
          'b-table-has-details': rowShowDetails
        }],
        attrs: _objectSpread({
          id: rowId,
          tabindex: hasRowClickHandler ? '0' : null,
          'data-pk': rowId ? String(item[primaryKey]) : null,
          'aria-describedby': detailsId,
          'aria-owns': detailsId,
          'aria-rowindex': ariaRowIndex,
          role: 'row'
        }, this.selectableRowAttrs(rowIndex)),
        on: _objectSpread({}, handlers, {
          // TODO: instatiate the following handlers only if we have registered
          //       listeners i.e. this.$listeners['row-middle-clicked'], etc.
          auxclick: function auxclick(evt) {
            if (evt.which === 2) {
              _this2.middleMouseRowClicked(evt, item, rowIndex);
            }
          },
          contextmenu: function contextmenu(evt) {
            _this2.rowContextmenu(evt, item, rowIndex);
          },
          // Note: these events are not accessibility friendly!
          dblclick: function dblclick(evt) {
            _this2.rowDblClicked(evt, item, rowIndex);
          },
          mouseenter: function mouseenter(evt) {
            _this2.rowHovered(evt, item, rowIndex);
          },
          mouseleave: function mouseleave(evt) {
            _this2.rowUnhovered(evt, item, rowIndex);
          }
        })
      }, $tds)); // Row Details slot

      if (rowShowDetails) {
        var tdAttrs = {
          colspan: String(fields.length),
          role: 'cell'
        };
        var trAttrs = {
          id: detailsId,
          role: 'row' // Render the details slot

        };
        var $details = h('td', {
          attrs: tdAttrs
        }, [$detailsSlot({
          item: item,
          index: rowIndex,
          fields: fields,
          toggleDetails: toggleDetailsFn
        })]); // Add a hidden row to keep table row striping consistent when details showing

        if (tableStriped) {
          $rows.push(h('tr', {
            key: "__b-table-details-".concat(rowIndex, "-stripe__"),
            staticClass: 'd-none',
            attrs: {
              'aria-hidden': 'true',
              role: 'presentation'
            }
          }));
        } // Add the actual details row


        $rows.push(h('tr', {
          key: "__b-table-details-".concat(rowIndex, "__"),
          staticClass: 'b-table-details',
          class: [typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(item, 'row-details') : this.tbodyTrClass],
          attrs: trAttrs
        }, [$details]));
      } else if ($detailsSlot) {
        // Only add the placeholder if a the table has a row-details slot defined (but not shown)
        $rows.push(h(false));

        if (tableStriped) {
          // add extra placeholder if table is striped
          $rows.push(h(false));
        }
      } // Return the row(s)


      return $rows;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tbody.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _mixinTbodyRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tbody-row.js");

var _mixinEmpty = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-empty.js");

var _mixinTopRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-top-row.js");

var _mixinBottomRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-bottom-row.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// busy mixin is imported in main table.js as it is used by multiple mixins
var _default = {
  mixins: [_mixinTbodyRow.default, _mixinEmpty.default, _mixinTopRow.default, _mixinBottomRow.default],
  props: {
    tbodyClass: {
      type: [String, Array],
      default: null
    },
    tbodyTransitionProps: {
      type: Object // default: undefined

    },
    tbodyTransitionHandlers: {
      type: Object // default: undefined

    }
  },
  methods: {
    renderTbody: function renderTbody() {
      var _this = this;

      // Render the tbody element and children
      var h = this.$createElement;
      var items = this.computedItems; // Prepare the tbody rows

      var $rows = []; // Add the item data rows or the busy slot

      var $busy = this.renderBusy();

      if ($busy) {
        // If table is busy and a busy slot, then return only the busy "row" indicator
        $rows.push($busy);
      } else {
        // Table isn't bsuy, or we don't have a busy slot
        // Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)
        $rows.push(this.renderTopRow()); // render the rows

        items.forEach(function (item, rowIndex) {
          // Render the individual item row (rows if details slot)
          $rows.push(_this.renderTbodyRow(item, rowIndex));
        }); // Empty Items / Empty Filtered Row slot (only shows if items.length < -

        $rows.push(this.renderEmpty()); // Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)

        $rows.push(this.renderBottomRow());
      } // If tbody transition enabled


      var isTransGroup = this.tbodyTransitionProps || this.tbodyTransitionHandlers;
      var tbodyProps = {};
      var tbodyOn = {};

      if (isTransGroup) {
        tbodyOn = this.tbodyTransitionHandlers || {};
        tbodyProps = _objectSpread({}, this.tbodyTransitionProps || {}, {
          tag: 'tbody'
        });
      } // Assemble rows into the tbody


      var $tbody = h(isTransGroup ? 'transition-group' : 'tbody', {
        props: tbodyProps,
        on: tbodyOn,
        class: [this.tbodyClass],
        attrs: {
          role: 'rowgroup'
        }
      }, $rows); // Return the assembled tbody

      return $tbody;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tfoot.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  props: {
    footClone: {
      type: Boolean,
      default: false
    },
    footVariant: {
      type: String,
      default: ''
    },
    tfootClass: {
      type: [String, Array, Object],
      default: null
    },
    tfootTrClass: {
      type: [String, Array, Object],
      default: null
    }
  },
  computed: {
    footClasses: function footClasses() {
      var variant = this.footVariant || this.headVariant || null;
      return [variant ? 'thead-' + variant : '', this.tfootClass];
    }
  },
  methods: {
    renderTfoot: function renderTfoot() {
      var h = this.$createElement; // Passing true to renderThead will make it render a tfoot

      return this.footClone ? this.renderThead(true) : h(false);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-thead.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _startcase = __webpack_require__("./node_modules/bootstrap-vue/es/utils/startcase.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

var _filterEvent = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/filter-event.js");

var _textSelectionActive = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/text-selection-active.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: {
    headVariant: {
      type: String,
      default: ''
    },
    theadClass: {
      type: [String, Array, Object],
      default: null
    },
    theadTrClass: {
      type: [String, Array, Object],
      default: null
    }
  },
  computed: {
    headClasses: function headClasses() {
      return [this.headVariant ? 'thead-' + this.headVariant : '', this.theadClass];
    }
  },
  methods: {
    fieldClasses: function fieldClasses(field) {
      // header field (th) classes
      return [field.variant ? 'table-' + field.variant : '', field.class ? field.class : '', field.thClass ? field.thClass : ''];
    },
    headClicked: function headClicked(evt, field, isFoot) {
      if (this.stopIfBusy(evt)) {
        // If table is busy (via provider) then don't propagate
        return;
      } else if ((0, _filterEvent.default)(evt)) {
        // clicked on a non-disabled control so ignore
        return;
      } else if ((0, _textSelectionActive.default)(this.$el)) {
        // User is selecting text, so ignore

        /* istanbul ignore next: JSDOM doesn't support getSelection() */
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      this.$emit('head-clicked', field.key, field, evt, isFoot);
    },
    renderThead: function renderThead() {
      var _this = this;

      var isFoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var h = this.$createElement;

      if (this.isStacked === true) {
        // In always stacked mode, we don't bother rendering the head/foot
        return h(false);
      }

      var fields = this.computedFields || []; // Helper function to generate a field TH cell

      var makeCell = function makeCell(field, colIndex) {
        var ariaLabel = null;

        if (!field.label.trim() && !field.headerTitle) {
          // In case field's label and title are empty/blank
          // We need to add a hint about what the column is about for non-sighted users

          /* istanbul ignore next */
          ariaLabel = (0, _startcase.default)(field.key);
        }

        var hasHeadClickListener = _this.$listeners['head-clicked'] || _this.isSortable;
        var handlers = {};

        if (hasHeadClickListener) {
          handlers.click = function (evt) {
            _this.headClicked(evt, field, isFoot);
          };

          handlers.keydown = function (evt) {
            var keyCode = evt.keyCode;

            if (keyCode === _keyCodes.default.ENTER || keyCode === _keyCodes.default.SPACE) {
              _this.headClicked(evt, field, isFoot);
            }
          };
        }

        var data = {
          key: field.key,
          class: [_this.fieldClasses(field), _this.sortTheadThClasses(field.key, field, isFoot)],
          style: field.thStyle || {},
          attrs: _objectSpread({
            // We only add a tabindex of 0 if there is a head-clicked listener
            tabindex: hasHeadClickListener ? '0' : null,
            abbr: field.headerAbbr || null,
            title: field.headerTitle || null,
            role: 'columnheader',
            scope: 'col',
            'aria-colindex': String(colIndex + 1),
            'aria-label': ariaLabel
          }, _this.sortTheadThAttrs(field.key, field, isFoot)),
          on: handlers
        };
        var fieldScope = {
          label: field.label,
          column: field.key,
          field: field
        };
        var slot = isFoot && _this.hasNormalizedSlot("FOOT_".concat(field.key)) ? _this.normalizeSlot("FOOT_".concat(field.key), fieldScope) : _this.normalizeSlot("HEAD_".concat(field.key), fieldScope);

        if (slot) {
          slot = [slot];
        } else {
          data.domProps = (0, _html.htmlOrText)(field.labelHtml);
        }

        return h('th', data, slot || field.label);
      }; // Generate the array of TH cells


      var $cells = fields.map(makeCell).filter(function (th) {
        return th;
      }); // Genrate the row(s)

      var $trs = [];

      if (isFoot) {
        $trs.push(h('tr', {
          class: this.tfootTrClass,
          attrs: {
            role: 'row'
          }
        }, $cells));
      } else {
        var scope = {
          columns: fields.length,
          fields: fields
        };
        $trs.push(this.normalizeSlot('thead-top', scope) || h(false));
        $trs.push(h('tr', {
          class: this.theadTrClass,
          attrs: {
            role: 'row'
          }
        }, $cells));
      }

      return h(isFoot ? 'tfoot' : 'thead', {
        key: isFoot ? 'tfoot' : 'thead',
        class: isFoot ? this.footClasses : this.headClasses,
        attrs: {
          role: 'rowgroup'
        }
      }, $trs);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/mixin-top-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var _default = {
  methods: {
    renderTopRow: function renderTopRow() {
      var h = this.$createElement; // Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)
      // If in always stacked mode, we don't bother rendering the row

      if (!this.hasNormalizedSlot('top-row') || this.isStacked === true) {
        return h(false);
      }

      var fields = this.computedFields;
      return h('tr', {
        key: 'top-row',
        staticClass: 'b-table-top-row',
        class: [typeof this.tbodyTrClass === 'function' ? this.tbodyTrClass(null, 'row-top') : this.tbodyTrClass],
        attrs: {
          role: 'row'
        }
      }, [this.normalizeSlot('top-row', {
        columns: fields.length,
        fields: fields
      })]);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/normalize-fields.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = normalizeFields;

var _startcase = __webpack_require__("./node_modules/bootstrap-vue/es/utils/startcase.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _constants = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/constants.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// private function to massage field entry into common object format
function processField(key, value) {
  var field = null;

  if (typeof value === 'string') {
    // Label shortcut
    field = {
      key: key,
      label: value
    };
  } else if (typeof value === 'function') {
    // Formatter shortcut
    field = {
      key: key,
      formatter: value
    };
  } else if (_typeof(value) === 'object') {
    field = _objectSpread({}, value);
    field.key = field.key || key;
  } else if (value !== false) {
    // Fallback to just key

    /* istanbul ignore next */
    field = {
      key: key
    };
  }

  return field;
} // We normalize fields into an array of objects
// [ { key:..., label:..., ...}, {...}, ..., {..}]


function normalizeFields(origFields, items) {
  var fields = [];

  if ((0, _array.isArray)(origFields)) {
    // Normalize array Form
    origFields.filter(function (f) {
      return f;
    }).forEach(function (f) {
      if (typeof f === 'string') {
        fields.push({
          key: f,
          label: (0, _startcase.default)(f)
        });
      } else if (_typeof(f) === 'object' && f.key && typeof f.key === 'string') {
        // Full object definition. We use assign so that we don't mutate the original
        fields.push(_objectSpread({}, f));
      } else if (_typeof(f) === 'object' && (0, _object.keys)(f).length === 1) {
        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }
        var key = (0, _object.keys)(f)[0];
        var field = processField(key, f[key]);

        if (field) {
          fields.push(field);
        }
      }
    });
  } else if (origFields && _typeof(origFields) === 'object' && (0, _object.keys)(origFields).length > 0) {
    // Normalize object Form (deprecated)
    (0, _object.keys)(origFields).forEach(function (key) {
      var field = processField(key, origFields[key]);

      if (field) {
        fields.push(field);
      }
    });
  } // If no field provided, take a sample from first record (if exits)


  if (fields.length === 0 && (0, _array.isArray)(items) && items.length > 0) {
    var sample = items[0];
    (0, _object.keys)(sample).forEach(function (k) {
      if (!_constants.IGNORED_FIELD_KEYS[k]) {
        fields.push({
          key: k,
          label: (0, _startcase.default)(k)
        });
      }
    });
  } // Ensure we have a unique array of fields and that they have String labels


  var memo = {};
  return fields.filter(function (f) {
    if (!memo[f.key]) {
      memo[f.key] = true;
      f.label = typeof f.label === 'string' ? f.label : (0, _startcase.default)(f.key);
      return true;
    }

    return false;
  });
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/sanitize-row.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = sanitizeRow;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _constants = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/constants.js");

// Return a copy of a row after all reserved fields have been filtered out
// TODO: add option to specify which fields to include
function sanitizeRow(row) {
  return (0, _object.keys)(row).reduce(function (obj, key) {
    // Ignore special fields that start with _
    if (!_constants.IGNORED_FIELD_KEYS[key]) {
      obj[key] = row[key];
    }

    return obj;
  }, {});
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/stringify-object-values.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = stringifyObjectValues;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

// Recursively stringifies the values of an object, space separated, in an
// SSR safe deterministic way (keys are storted before stringification)
//
//   ex:
//     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }
//   becomes
//     'one 3 2 zzz 10 12 11'
//
// Primatives (numbers/strings) are returned as-is
// Null and undefined values are filtered out
// Dates are converted to their native string format
//
function stringifyObjectValues(val) {
  if (typeof val === 'undefined' || val === null) {
    /* istanbul ignore next */
    return '';
  }

  if (val instanceof Object && !(val instanceof Date)) {
    // Arrays are also object, and keys just returns the array indexes
    // Date objects we convert to strings
    return (0, _object.keys)(val).sort()
    /* sort to prevent SSR issues on pre-rendered sorted tables */
    .filter(function (v) {
      return v !== undefined && v !== null;
    })
    /* ignore undefined/null values */
    .map(function (k) {
      return stringifyObjectValues(val[k]);
    }).join(' ');
  }

  return String(val);
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/stringify-record-values.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = stringifyRecordValues;

var _sanitizeRow = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/sanitize-row.js");

var _stringifyObjectValues = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/stringify-object-values.js");

// Stringifies the values of a record, ignoring any special top level field keys
// TODO: add option to strigify formatted/scopedSlot items, and only specific fields
function stringifyRecordValues(row) {
  /* istanbul ignore else */
  if (row instanceof Object) {
    return (0, _stringifyObjectValues.default)((0, _sanitizeRow.default)(row));
  } else {
    /* istanbul ignore next */
    return '';
  }
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/helpers/text-selection-active.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = textSelectionActive;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

// Helper to determine if a there is an active text selection on the document page.
// Used to filter out click events caused by the mouse up at end of selection
//
// Accepts an element as only argument to test to see if selection overlaps or is
// contained within the element
function textSelectionActive() {
  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  var win = window;
  /* istanbul ignore if: JSDOM doesn't support getSelection */

  if (win && win.getSelection && win.getSelection().toString() !== '' && (0, _dom.isElement)(el)) {
    /* istanbul ignore next: JSDOM doesn't support getSelection */
    var sel = win.getSelection();
    /* istanbul ignore next: JSDOM doesn't support getSelection */

    return sel.containsNode ? sel.containsNode(el, true) : false;
  } else {
    return false;
  }
}

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _table = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/table.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BTable: _table.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/table/table.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _normalizeSlot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/normalize-slot.js");

var _mixinItems = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-items.js");

var _mixinFiltering = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-filtering.js");

var _mixinSorting = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-sorting.js");

var _mixinPagination = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-pagination.js");

var _mixinCaption = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-caption.js");

var _mixinColgroup = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-colgroup.js");

var _mixinThead = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-thead.js");

var _mixinTfoot = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tfoot.js");

var _mixinTbody = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-tbody.js");

var _mixinBusy = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-busy.js");

var _mixinSelectable = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-selectable.js");

var _mixinProvider = __webpack_require__("./node_modules/bootstrap-vue/es/components/table/helpers/mixin-provider.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// b-table component definition
// @vue/component
var _default2 = {
  name: 'BTable',
  // Order of mixins is important.
  // They are merged from left to fight, followed by this component.
  mixins: [_id.default, _normalizeSlot.default, _mixinItems.default, _mixinFiltering.default, _mixinSorting.default, _mixinPagination.default, _mixinBusy.default, _mixinCaption.default, _mixinColgroup.default, _mixinThead.default, _mixinTfoot.default, _mixinTbody.default, _mixinSelectable.default, _mixinProvider.default],
  // Don't place ATTRS on root element automatically, as table could be wrapped in responsive div
  inheritAttrs: false,
  props: {
    striped: {
      type: Boolean,
      default: false
    },
    bordered: {
      type: Boolean,
      default: false
    },
    borderless: {
      type: Boolean,
      default: false
    },
    outlined: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    hover: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    fixed: {
      type: Boolean,
      default: false
    },
    responsive: {
      type: [Boolean, String],
      default: false
    },
    stacked: {
      type: [Boolean, String],
      default: false
    },
    value: {
      // v-model for retrieving the current displayed rows
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  data: function data() {
    // Mixins add to data
    return {};
  },
  computed: {
    // Layout related computed props
    isStacked: function isStacked() {
      return this.stacked === '' ? true : this.stacked;
    },
    isResponsive: function isResponsive() {
      var responsive = this.responsive === '' ? true : this.responsive;
      return this.isStacked ? false : responsive;
    },
    responsiveClass: function responsiveClass() {
      return this.isResponsive === true ? 'table-responsive' : this.isResponsive ? "table-responsive-".concat(this.responsive) : '';
    },
    tableClasses: function tableClasses() {
      return [_defineProperty({
        'table-striped': this.striped,
        'table-hover': this.hover,
        'table-dark': this.dark,
        'table-bordered': this.bordered,
        'table-borderless': this.borderless,
        'table-sm': this.small,
        border: this.outlined,
        // The following are b-table custom styles
        'b-table-fixed': this.fixed,
        'b-table-stacked': this.stacked === true || this.stacked === ''
      }, "b-table-stacked-".concat(this.stacked), this.stacked !== true && this.stacked), // Selectable classes
      this.selectableTableClasses];
    },
    tableAttrs: function tableAttrs() {
      // Preserve user supplied aria-describedby, if provided in $attrs
      var adb = [(this.$attrs || {})['aria-describedby'], this.captionId].filter(Boolean).join(' ') || null;
      var items = this.computedItems;
      var fields = this.computedFields;
      return _objectSpread({
        // We set aria-rowcount before merging in $attrs, in case user has supplied their own
        'aria-rowcount': this.filteredItems.length > items.length ? String(this.filteredItems.length) : null
      }, this.$attrs, {
        // Now we can override any $attrs here
        id: this.safeId(),
        role: this.isStacked ? 'table' : null,
        'aria-busy': this.computedBusy ? 'true' : 'false',
        'aria-colcount': String(fields.length),
        'aria-describedby': adb
      }, this.selectableTableAttrs);
    },
    context: function context() {
      // Current state of sorting, filtering and pagination props/values
      return {
        filter: this.localFilter,
        sortBy: this.localSortBy,
        sortDesc: this.localSortDesc,
        perPage: parseInt(this.perPage, 10) || 0,
        currentPage: parseInt(this.currentPage, 10) || 1,
        apiUrl: this.apiUrl
      };
    },
    computedItems: function computedItems() {
      return this.paginatedItems || [];
    }
  },
  watch: {
    // Watch for changes on computedItems and update the v-model
    computedItems: function computedItems(newVal, oldVal) {
      this.$emit('input', newVal);
    },
    context: function context(newVal, oldVal) {
      // Emit context info for external paging/filtering/sorting handling
      if (!(0, _looseEqual.default)(newVal, oldVal)) {
        this.$emit('context-changed', newVal);
      }
    }
  },
  mounted: function mounted() {
    // Initially update the v-model of displayed items
    this.$emit('input', this.computedItems);
  },
  render: function render(h) {
    // Build the caption (from caption mixin)
    var $caption = this.renderCaption(); // Build the colgroup

    var $colgroup = this.renderColgroup(); // Build the thead

    var $thead = this.renderThead(); // Build the tfoot

    var $tfoot = this.renderTfoot(); // Build the tbody

    var $tbody = this.renderTbody(); // Assemble table

    var $table = h('table', {
      key: 'b-table',
      staticClass: 'table b-table',
      class: this.tableClasses,
      attrs: this.tableAttrs
    }, [$caption, $colgroup, $thead, $tfoot, $tbody]); // Add responsive wrapper if needed and return table

    return this.isResponsive ? h('div', {
      key: 'b-table-responsive',
      class: this.responsiveClass
    }, [$table]) : $table;
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/tabs/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _tabs = __webpack_require__("./node_modules/bootstrap-vue/es/components/tabs/tabs.js");

var _tab = __webpack_require__("./node_modules/bootstrap-vue/es/components/tabs/tab.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BTabs: _tabs.default,
  BTab: _tab.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/tabs/tab.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

// @vue/component
var _default2 = {
  name: 'BTab',
  mixins: [_id.default],
  inject: {
    bvTabs: {
      default: function _default() {
        return {
          // Don't set a tab index if not rendered inside `<b-tabs>`
          noKeyNav: true
        };
      }
    }
  },
  props: {
    active: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'div'
    },
    buttonId: {
      type: String,
      default: ''
    },
    title: {
      type: String,
      default: ''
    },
    titleItemClass: {
      // Sniffed by tabs.js and added to nav 'li.nav-item'
      type: [String, Array, Object],
      default: null
    },
    titleLinkClass: {
      // Sniffed by tabs.js and added to nav 'a.nav-link'
      type: [String, Array, Object],
      default: null
    },
    headHtml: {
      // Is this actually ever used?
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    noBody: {
      type: Boolean,
      default: false
    },
    href: {
      // This should be deprecated, as tabs are not navigation (URL) based
      // <b-nav> + <b-card> + <router-view>/<nuxt-child> should be used instead
      // And we dont support router-links here
      type: String,
      default: '#'
    },
    lazy: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localActive: this.active && !this.disabled,
      show: false
    };
  },
  computed: {
    tabClasses: function tabClasses() {
      return [this.bvTabs.card && !this.noBody ? 'card-body' : '', this.show ? 'show' : '', this.computedFade ? 'fade' : '', this.disabled ? 'disabled' : '', this.localActive ? 'active' : ''];
    },
    controlledBy: function controlledBy() {
      return this.buttonId || this.safeId('__BV_tab_button__');
    },
    computedFade: function computedFade() {
      return this.bvTabs.fade || false;
    },
    computedLazy: function computedLazy() {
      return this.bvTabs.lazy || this.lazy;
    },
    _isTab: function _isTab() {
      // For parent sniffing of child
      return true;
    }
  },
  watch: {
    localActive: function localActive(newVal, oldVal) {
      // Make 'active' prop work with `.sync` modifier
      this.$emit('update:active', newVal);
    },
    active: function active(newVal, oldVal) {
      if (newVal !== oldVal) {
        if (newVal) {
          // If activated post mount
          this.activate();
        } else {
          if (!this.deactivate()) {
            // Tab couldn't be deactivated, so we reset the synced active prop
            // Deactivation will fail if no other tabs to activate.
            this.$emit('update:active', this.localActive);
          }
        }
      }
    },
    disabled: function disabled(newVal, oldVal) {
      if (newVal !== oldVal) {
        if (newVal && this.localActive && this.bvTabs.firstTab) {
          this.localActive = false;
          this.bvTabs.firstTab();
        }
      }
    }
  },
  mounted: function mounted() {
    // Initially show on mount if active and not disabled
    this.show = this.localActive;
  },
  updated: function updated() {
    // Force the tab button content to update (since slots are not reactive)
    // Only done if we have a title slot, as the title prop is reactive
    if (this.$slots.title && this.bvTabs.updateButton) {
      this.bvTabs.updateButton(this);
    }
  },
  methods: {
    // Transition handlers
    beforeEnter: function beforeEnter() {
      var _this = this;

      // change opacity (add 'show' class) 1 frame after display
      // otherwise css transition won't happen
      (0, _dom.requestAF)(function () {
        _this.show = true;
      });
    },
    beforeLeave: function beforeLeave() {
      // Remove the 'show' class
      this.show = false;
    },
    // Public methods
    activate: function activate() {
      if (this.bvTabs.activateTab && !this.disabled) {
        return this.bvTabs.activateTab(this);
      } else {
        // Not inside a b-tabs component or tab is disabled
        return false;
      }
    },
    deactivate: function deactivate() {
      if (this.bvTabs.deactivateTab && this.localActive) {
        return this.bvTabs.deactivateTab(this);
      } else {
        // Not inside a b-tabs component or not active to begin with
        return false;
      }
    }
  },
  render: function render(h) {
    var content = h(this.tag, {
      ref: 'panel',
      staticClass: 'tab-pane',
      class: this.tabClasses,
      directives: [// TODO: convert to style object in render
      {
        name: 'show',
        rawName: 'v-show',
        value: this.localActive,
        expression: 'localActive'
      }],
      attrs: {
        role: 'tabpanel',
        id: this.safeId(),
        tabindex: this.localActive && !this.bvTabs.noKeyNav ? '0' : null,
        'aria-hidden': this.localActive ? 'false' : 'true',
        'aria-expanded': this.localActive ? 'true' : 'false',
        'aria-labelledby': this.controlledBy || null
      }
    }, // Render content lazily if requested
    [this.localActive || !this.computedLazy ? this.$slots.default : h(false)]);
    return h('transition', {
      props: {
        mode: 'out-in',
        // Disable use of built-in transition classes
        'enter-class': '',
        'enter-active-class': '',
        'enter-to-class': '',
        'leave-class': '',
        'leave-active-class': '',
        'leave-to-class': ''
      },
      on: {
        beforeEnter: this.beforeEnter,
        beforeLeave: this.beforeLeave
      }
    }, [content]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/tabs/tabs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _observeDom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/observe-dom.js");

var _id = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/id.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Private Helper component
// @vue/component
var BTabButtonHelper = {
  name: 'BTabButtonHelper',
  inject: {
    bvTabs: {
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: {
    // Reference to the child b-tab instance
    tab: {
      default: null
    },
    tabs: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    id: {
      type: String,
      default: null
    },
    controls: {
      type: String,
      default: null
    },
    tabIndex: {
      type: Number,
      default: null
    },
    posInSet: {
      type: Number,
      default: null
    },
    setSize: {
      type: Number,
      default: null
    },
    noKeyNav: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    focus: function focus() {
      if (this.$refs && this.$refs.link && this.$refs.link.focus) {
        this.$refs.link.focus();
      }
    },
    handleEvt: function handleEvt(evt) {
      function stop() {
        evt.preventDefault();
        evt.stopPropagation();
      }

      if (this.tab.disabled) {
        /* istanbul ignore next */
        return;
      }

      var type = evt.type;
      var key = evt.keyCode;
      var shift = evt.shiftKey;

      if (type === 'click') {
        stop();
        this.$emit('click', evt);
      } else if (type === 'keydown' && !this.noKeyNav && key === _keyCodes.default.SPACE) {
        // In keynav mode, SPACE press will also trigger a click/select
        stop();
        this.$emit('click', evt);
      } else if (type === 'keydown' && !this.noKeyNav) {
        // For keyboard navigation
        if (key === _keyCodes.default.UP || key === _keyCodes.default.LEFT || key === _keyCodes.default.HOME) {
          stop();

          if (shift || key === _keyCodes.default.HOME) {
            this.$emit('first', evt);
          } else {
            this.$emit('prev', evt);
          }
        } else if (key === _keyCodes.default.DOWN || key === _keyCodes.default.RIGHT || key === _keyCodes.default.END) {
          stop();

          if (shift || key === _keyCodes.default.END) {
            this.$emit('last', evt);
          } else {
            this.$emit('next', evt);
          }
        }
      }
    }
  },
  render: function render(h) {
    var link = h(_link.default, {
      ref: 'link',
      staticClass: 'nav-link',
      class: [{
        active: this.tab.localActive && !this.tab.disabled,
        disabled: this.tab.disabled
      }, this.tab.titleLinkClass],
      props: {
        href: this.tab.href,
        // To be deprecated to always be '#'
        disabled: this.tab.disabled
      },
      attrs: {
        role: 'tab',
        id: this.id,
        // Roving tab index when keynav enabled
        tabindex: this.tabIndex,
        'aria-selected': this.tab.localActive && !this.tab.disabled ? 'true' : 'false',
        'aria-setsize': this.setSize,
        'aria-posinset': this.posInSet,
        'aria-controls': this.controls
      },
      on: {
        click: this.handleEvt,
        keydown: this.handleEvt
      }
    }, [this.tab.$slots.title || this.tab.title]);
    return h('li', {
      staticClass: 'nav-item',
      class: [this.tab.titleItemClass],
      attrs: {
        role: 'presentation'
      }
    }, [link]);
  }
}; // Filter function to filter out disabled tabs

function notDisabled(tab) {
  return !tab.disabled;
} // @vue/component


var _default2 = {
  name: 'BTabs',
  mixins: [_id.default],
  provide: function provide() {
    return {
      bvTabs: this
    };
  },
  model: {
    prop: 'value',
    event: 'input'
  },
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    card: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    pills: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    bottom: {
      type: Boolean,
      default: false
    },
    end: {
      // Synonym for 'bottom'
      type: Boolean,
      default: false
    },
    noFade: {
      type: Boolean,
      default: false
    },
    noNavStyle: {
      type: Boolean,
      default: false
    },
    noKeyNav: {
      type: Boolean,
      default: false
    },
    lazy: {
      // This prop is sniffed by the tab child
      type: Boolean,
      default: false
    },
    contentClass: {
      type: [String, Array, Object],
      default: null
    },
    navClass: {
      type: [String, Array, Object],
      default: null
    },
    navWrapperClass: {
      type: [String, Array, Object],
      default: null
    },
    value: {
      // v-model
      type: Number,
      default: null
    }
  },
  data: function data() {
    var tabIdx = parseInt(this.value, 10);
    tabIdx = isNaN(tabIdx) ? -1 : tabIdx;
    return {
      // Index of current tab
      currentTab: tabIdx,
      // Array of direct child b-tab instances
      tabs: []
    };
  },
  computed: {
    fade: function fade() {
      // This computed prop is sniffed by the tab child
      return !this.noFade;
    },
    navStyle: function navStyle() {
      return this.pills ? 'pills' : 'tabs';
    }
  },
  watch: {
    currentTab: function currentTab(val, old) {
      var index = -1; // Ensure only one tab is active at most

      this.tabs.forEach(function (tab, idx) {
        if (val === idx && !tab.disabled) {
          tab.localActive = true;
          index = idx;
        } else {
          tab.localActive = false;
        }
      }); // Update the v-model

      this.$emit('input', index);
    },
    value: function value(val, old) {
      if (val !== old) {
        val = parseInt(val, 10);
        val = isNaN(val) ? -1 : val;
        old = parseInt(old, 10) || 0;
        var tabs = this.tabs;

        if (tabs[val] && !tabs[val].disabled) {
          this.currentTab = val;
        } else {
          // Try next or prev tabs
          if (val < old) {
            this.previousTab();
          } else {
            this.nextTab();
          }
        }
      }
    }
  },
  created: function created() {
    var _this = this;

    var tabIdx = parseInt(this.value, 10);
    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx; // Create private non-reactive prop

    this._bvObserver = null; // For SSR and to make sure only a single tab is shown on mount
    // We wrap this in a `$nextTick()` to ensure the child tabs have been created

    this.$nextTick(function () {
      _this.updateTabs();
    });
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      // Call updateTabs jsut in case....
      _this2.updateTabs(); // Observe Child changes so we can update list of tabs


      _this2.setObserver(true);
    });
  },
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    this.setObserver(false);
  },
  activated: function activated()
  /* istanbul ignore next */
  {
    var _this3 = this;

    var tabIdx = parseInt(this.value, 10);
    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx;
    this.$nextTick(function () {
      _this3.updateTabs();

      _this3.setObserver(true);
    });
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    this.setObserver(false);
  },
  methods: {
    setObserver: function setObserver(on) {
      if (on) {
        // Make sure no existing observer running
        this.setObserver(false); // Watch for changes to b-tab sub components

        this._bvObserver = (0, _observeDom.default)(this.$refs.tabsContainer, this.updateTabs.bind(this), {
          childList: true,
          subtree: false,
          attributes: true,
          attributeFilter: ['style', 'class']
        });
      } else {
        if (this._bvObserver && this._bvObserver.disconnect) {
          this._bvObserver.disconnect();
        }

        this._bvObserver = null;
      }
    },
    getTabs: function getTabs() {
      return (this.$slots.default || []).map(function (vnode) {
        return vnode.componentInstance;
      }).filter(function (tab) {
        return tab && tab._isTab;
      });
    },
    // Update list of b-tab children
    updateTabs: function updateTabs() {
      // Probe tabs
      var tabs = this.getTabs(); // Find *last* active non-disabled tab in current tabs
      // We trust tab state over currentTab, in case tabs were added/removed/re-ordered

      var tabIndex = tabs.indexOf(tabs.slice().reverse().find(function (tab) {
        return tab.localActive && !tab.disabled;
      })); // Else try setting to currentTab

      if (tabIndex < 0) {
        var currentTab = this.currentTab;

        if (currentTab >= tabs.length) {
          // Handle last tab being removed, so find the last non-disabled tab
          tabIndex = tabs.indexOf(tabs.slice().reverse().find(notDisabled));
        } else if (tabs[currentTab] && !tabs[currentTab].disabled) {
          // Current tab is not disabled
          tabIndex = currentTab;
        }
      } // Else find *first* non-disabled tab in current tabs


      if (tabIndex < 0) {
        tabIndex = tabs.indexOf(tabs.find(notDisabled));
      } // Set the current tab state to active


      tabs.forEach(function (tab, idx) {
        // tab.localActive = idx === tabIndex && !tab.disabled
        tab.localActive = false;
      });

      if (tabs[tabIndex]) {
        tabs[tabIndex].localActive = true;
      } // Update the array of tab children


      this.tabs = tabs; // Set the currentTab index (can be -1 if no non-disabled tabs)

      this.currentTab = tabIndex;
    },
    // Find a button that controls a tab, given the tab reference
    // Returns the button vm instance
    getButtonForTab: function getButtonForTab(tab) {
      return (this.$refs.buttons || []).find(function (btn) {
        return btn.tab === tab;
      });
    },
    // Force a button to re-render it's content, given a b-tab instance
    // Called by b-tab on update()
    updateButton: function updateButton(tab) {
      var button = this.getButtonForTab(tab);

      if (button && button.$forceUpdate) {
        button.$forceUpdate();
      }
    },
    // Activate a tab given a b-tab instance
    // Also accessed by b-tab
    activateTab: function activateTab(tab) {
      var result = false;

      if (tab) {
        var index = this.tabs.indexOf(tab);

        if (!tab.disabled && index > -1) {
          result = true;
          this.currentTab = index;
        }
      }

      if (!result) {
        // Couldn't set tab, so ensure v-model is set to this.currentTab

        /* istanbul ignore next: should rarely happen */
        this.$emit('input', this.currentTab);
      }

      return result;
    },
    // Deactivate a tab given a b-tab instance
    // Accessed by b-tab
    deactivateTab: function deactivateTab(tab) {
      if (tab) {
        // Find first non-disabled tab that isn't the one being deactivated
        // If no available tabs, then don't deactivate current tab
        return this.activateTab(this.tabs.filter(function (t) {
          return t !== tab;
        }).find(notDisabled));
      } else {
        // No tab specified

        /* istanbull ignore next: should never happen */
        return false;
      }
    },
    // Focus a tab button given it's b-tab instance
    focusButton: function focusButton(tab) {
      var _this4 = this;

      // Wrap in nextTick to ensure DOM has completed rendering/updating before focusing
      this.$nextTick(function () {
        var button = _this4.getButtonForTab(tab);

        if (button && button.focus) {
          button.focus();
        }
      });
    },
    // Emit a click event on a specified b-tab component instance
    emitTabClick: function emitTabClick(tab, evt) {
      if (evt && evt instanceof Event && tab && tab.$emit && !tab.disabled) {
        tab.$emit('click', evt);
      }
    },
    // Click Handler
    clickTab: function clickTab(tab, evt) {
      this.activateTab(tab);
      this.emitTabClick(tab, evt);
    },
    // Move to first non-disabled tab
    firstTab: function firstTab(focus) {
      var tab = this.tabs.find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to previous non-disabled tab
    previousTab: function previousTab(focus) {
      var currentIndex = Math.max(this.currentTab, 0);
      var tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to next non-disabled tab
    nextTab: function nextTab(focus) {
      var currentIndex = Math.max(this.currentTab, -1);
      var tab = this.tabs.slice(currentIndex + 1).find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to last non-disabled tab
    lastTab: function lastTab(focus) {
      var tab = this.tabs.slice().reverse().find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    }
  },
  render: function render(h) {
    var _this5 = this,
        _ref;

    var tabs = this.tabs; // Currently active tab

    var activeTab = tabs.find(function (tab) {
      return tab.localActive && !tab.disabled;
    }); // Tab button to allow focusing when no active tab found (keynav only)

    var fallbackTab = tabs.find(function (tab) {
      return !tab.disabled;
    }); // For each <b-tab> found create the tab buttons

    var buttons = tabs.map(function (tab, index) {
      var tabIndex = null; // Ensure at least one tab button is focusable when keynav enabled (if possible)

      if (!_this5.noKeyNav) {
        // Buttons are not in tab index unless active, or a fallback tab
        tabIndex = -1;

        if (activeTab === tab || !activeTab && fallbackTab === tab) {
          // Place tab button in tab sequence
          tabIndex = null;
        }
      }

      return h(BTabButtonHelper, {
        key: tab._uid || index,
        ref: 'buttons',
        // Needed to make this.$refs.buttons an array
        refInFor: true,
        props: {
          tab: tab,
          tabs: tabs,
          id: tab.controlledBy || (_this5.tab && _this5.tab.safeId ? _this5.tab.safeId("_BV_tab_button_") : null),
          controls: _this5.tab && _this5.tab.safeId ? _this5.tab.safeId() : null,
          tabIndex: tabIndex,
          setSize: tabs.length,
          posInSet: index + 1,
          noKeyNav: _this5.noKeyNav
        },
        on: {
          click: function click(evt) {
            _this5.clickTab(tab, evt);
          },
          first: _this5.firstTab,
          prev: _this5.previousTab,
          next: _this5.nextTab,
          last: _this5.lastTab
        }
      });
    }); // Nav 'button' wrapper

    var navs = h('ul', {
      ref: 'navs',
      class: ['nav', (_ref = {}, _defineProperty(_ref, "nav-".concat(this.navStyle), !this.noNavStyle), _defineProperty(_ref, "card-header-".concat(this.navStyle), this.card && !this.vertical), _defineProperty(_ref, 'card-header', this.card && this.vertical), _defineProperty(_ref, 'h-100', this.card && this.vertical), _defineProperty(_ref, 'flex-column', this.vertical), _defineProperty(_ref, 'border-bottom-0', this.vertical), _defineProperty(_ref, 'rounded-0', this.vertical), _defineProperty(_ref, "small", this.small), _ref), this.navClass],
      attrs: {
        role: 'tablist',
        id: this.safeId('_BV_tab_controls_')
      }
    }, [buttons, this.$slots.tabs]);
    navs = h('div', {
      key: 'bv-tabs-navs',
      class: [{
        'card-header': this.card && !this.vertical && !(this.end || this.bottom),
        'card-footer': this.card && !this.vertical && (this.end || this.bottom),
        'col-auto': this.vertical
      }, this.navWrapperClass]
    }, [navs]);
    var empty = h(false);

    if (!tabs || tabs.length === 0) {
      empty = h('div', {
        key: 'empty-tab',
        class: ['tab-pane', 'active', {
          'card-body': this.card
        }]
      }, this.$slots.empty);
    } // Main content section
    // TODO: This container should be a helper component


    var content = h('div', {
      ref: 'tabsContainer',
      key: 'bv-tabs-container',
      staticClass: 'tab-content',
      class: [{
        col: this.vertical
      }, this.contentClass],
      attrs: {
        id: this.safeId('_BV_tab_container_')
      }
    }, [this.$slots.default, empty]); // Render final output

    return h(this.tag, {
      staticClass: 'tabs',
      class: {
        row: this.vertical,
        'no-gutters': this.vertical && this.card
      },
      attrs: {
        id: this.safeId()
      }
    }, [this.end || this.bottom ? content : h(false), [navs], this.end || this.bottom ? h(false) : content]);
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/tooltip/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/components/tooltip/tooltip.js");

var _tooltip2 = __webpack_require__("./node_modules/bootstrap-vue/es/directives/tooltip/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var components = {
  BTooltip: _tooltip.default
};
var plugins = {
  BTooltipDirectivePlugin: _tooltip2.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    components: components,
    plugins: plugins
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/components/tooltip/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/utils/tooltip.class.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _toolpop = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/toolpop.js");

// @vue/component
var _default = {
  name: 'BTooltip',
  mixins: [_toolpop.default],
  props: {
    title: {
      type: String,
      default: ''
    },
    triggers: {
      type: [String, Array],
      default: 'hover focus'
    },
    placement: {
      type: String,
      default: 'top'
    }
  },
  data: function data() {
    return {};
  },
  methods: {
    createToolpop: function createToolpop() {
      // getTarget is in toolpop mixin
      var target = this.getTarget();

      if (target) {
        this._toolpop = new _tooltip.default(target, this.getConfig(), this.$root);
      } else {
        this._toolpop = null;
        (0, _warn.default)("b-tooltip: 'target' element not found!");
      }

      return this._toolpop;
    }
  },
  render: function render(h) {
    return h('div', {
      class: ['d-none'],
      style: {
        display: 'none'
      },
      attrs: {
        'aria-hidden': true
      }
    }, [h('div', {
      ref: 'title'
    }, this.$slots.default)]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _toggle = __webpack_require__("./node_modules/bootstrap-vue/es/directives/toggle/index.js");

exports.Toggle = _toggle.default;

var _modal = __webpack_require__("./node_modules/bootstrap-vue/es/directives/modal/index.js");

exports.Modal = _modal.default;

var _scrollspy = __webpack_require__("./node_modules/bootstrap-vue/es/directives/scrollspy/index.js");

exports.Scrollspy = _scrollspy.default;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/directives/tooltip/index.js");

exports.Tooltip = _tooltip.default;

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/directives/popover/index.js");

exports.Popover = _popover.default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/modal/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _modal = __webpack_require__("./node_modules/bootstrap-vue/es/directives/modal/modal.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var directives = {
  BModal: _modal.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    directives: directives
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/modal/modal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _target = __webpack_require__("./node_modules/bootstrap-vue/es/utils/target.js");

// Target listen types
var listenTypes = {
  click: true // Emitted show event for modal

};
var EVENT_SHOW = 'bv::show::modal';

var setRole = function setRole(el, binding, vnode) {
  if (el.tagName !== 'BUTTON') {
    (0, _dom.setAttr)(el, 'role', 'button');
  }
};
/*
 * Export our directive
 */


var _default = {
  // eslint-disable-next-line no-shadow-restricted-names
  bind: function bind(el, binding, vnode) {
    (0, _target.bindTargets)(vnode, binding, listenTypes, function (_ref) {
      var targets = _ref.targets,
          vnode = _ref.vnode;
      targets.forEach(function (target) {
        vnode.context.$root.$emit(EVENT_SHOW, target, vnode.elm);
      });
    }); // If element is not a button, we add `role="button"` for accessibility

    setRole(el, binding, vnode);
  },
  updated: setRole,
  componentUpdated: setRole,
  unbind: function unbind(el, binding, vnode) {
    (0, _target.unbindTargets)(vnode, binding, listenTypes); // If element is not a button, we add `role="button"` for accessibility

    if (el.tagName !== 'BUTTON') {
      (0, _dom.removeAttr)(el, 'role', 'button');
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/popover/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/directives/popover/popover.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var directives = {
  BPopover: _popover.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    directives: directives
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/popover/popover.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popper = __webpack_require__("./node_modules/popper.js/dist/esm/popper.js");

var _popover = __webpack_require__("./node_modules/bootstrap-vue/es/utils/popover.class.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Key which we use to store tooltip object on element
var BV_POPOVER = '__BV_PopOver__'; // Valid event triggers

var validTriggers = {
  focus: true,
  hover: true,
  click: true,
  blur: true // Build a PopOver config based on bindings (if any)
  // Arguments and modifiers take precedence over passed value config object

  /* istanbul ignore next: not easy to test */

};

var parseBindings = function parseBindings(bindings)
/* istanbul ignore next: not easy to test */
{
  // We start out with a blank config
  var config = {}; // Process bindings.value

  if (typeof bindings.value === 'string') {
    // Value is popover content (html optionally supported)
    config.content = bindings.value;
  } else if (typeof bindings.value === 'function') {
    // Content generator function
    config.content = bindings.value;
  } else if (_typeof(bindings.value) === 'object') {
    // Value is config object, so merge
    config = _objectSpread({}, config, bindings.value);
  } // If argument, assume element ID of container element


  if (bindings.arg) {
    // Element ID specified as arg
    // We must prepend '#' to become a CSS selector
    config.container = "#".concat(bindings.arg);
  } // Process modifiers


  (0, _object.keys)(bindings.modifiers).forEach(function (mod) {
    if (/^html$/.test(mod)) {
      // Title allows HTML
      config.html = true;
    } else if (/^nofade$/.test(mod)) {
      // no animation
      config.animation = false;
    } else if (/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/.test(mod)) {
      // placement of popover
      config.placement = mod;
    } else if (/^(window|viewport)$/.test(mod)) {
      // Boundary of popover
      config.boundary = mod;
    } else if (/^d\d+$/.test(mod)) {
      // Delay value
      var delay = parseInt(mod.slice(1), 10) || 0;

      if (delay) {
        config.delay = delay;
      }
    } else if (/^o-?\d+$/.test(mod)) {
      // Offset value (negative allowed)
      var offset = parseInt(mod.slice(1), 10) || 0;

      if (offset) {
        config.offset = offset;
      }
    }
  }); // Special handling of event trigger modifiers trigger is
  // a space separated list

  var selectedTriggers = {}; // Parse current config object trigger

  var triggers = typeof config.trigger === 'string' ? config.trigger.trim().split(/\s+/) : [];
  triggers.forEach(function (trigger) {
    if (validTriggers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Parse modifiers for triggers

  (0, _object.keys)(validTriggers).forEach(function (trigger) {
    if (bindings.modifiers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Sanitize triggers

  config.trigger = (0, _object.keys)(selectedTriggers).join(' ');

  if (config.trigger === 'blur') {
    // Blur by itself is useless, so convert it to focus
    config.trigger = 'focus';
  }

  if (!config.trigger) {
    // Remove trigger config
    delete config.trigger;
  }

  return config;
}; // Add or update PopOver on our element


var applyPopover = function applyPopover(el, bindings, vnode) {
  if (!_env.inBrowser) {
    /* istanbul ignore next */
    return;
  } // Popper is required for PopOvers to work


  if (!_popper.default) {
    /* istanbul ignore next */
    (0, _warn.default)('v-b-popover: Popper.js is required for PopOvers to work');
    /* istanbul ignore next */

    return;
  }

  var config = parseBindings(bindings);

  if (el[BV_POPOVER]) {
    el[BV_POPOVER].updateConfig(config);
  } else {
    el[BV_POPOVER] = new _popover.default(el, config, vnode.context.$root);
  }
}; // Remove PopOver on our element


var removePopover = function removePopover(el) {
  if (el[BV_POPOVER]) {
    el[BV_POPOVER].destroy();
    el[BV_POPOVER] = null;
    delete el[BV_POPOVER];
  }
};
/*
 * Export our directive
 */


var _default = {
  bind: function bind(el, bindings, vnode) {
    applyPopover(el, bindings, vnode);
  },
  inserted: function inserted(el, bindings, vnode) {
    applyPopover(el, bindings, vnode);
  },
  update: function update(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyPopover(el, bindings, vnode);
    }
  },
  componentUpdated: function componentUpdated(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyPopover(el, bindings, vnode);
    }
  },
  unbind: function unbind(el) {
    removePopover(el);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/scrollspy/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _scrollspy = __webpack_require__("./node_modules/bootstrap-vue/es/directives/scrollspy/scrollspy.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var directives = {
  BScrollspy: _scrollspy.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    directives: directives
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/scrollspy/scrollspy.class.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _observeDom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/observe-dom.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * Constants / Defaults
 */
var NAME = 'v-b-scrollspy';
var ACTIVATE_EVENT = 'bv::scrollspy::activate';
var Default = {
  element: 'body',
  offset: 10,
  method: 'auto',
  throttle: 75
};
var DefaultType = {
  element: '(string|element|component)',
  offset: 'number',
  method: 'string',
  throttle: 'number'
};
var ClassName = {
  DROPDOWN_ITEM: 'dropdown-item',
  ACTIVE: 'active'
};
var Selector = {
  ACTIVE: '.active',
  NAV_LIST_GROUP: '.nav, .list-group',
  NAV_LINKS: '.nav-link',
  NAV_ITEMS: '.nav-item',
  LIST_ITEMS: '.list-group-item',
  DROPDOWN: '.dropdown, .dropup',
  DROPDOWN_ITEMS: '.dropdown-item',
  DROPDOWN_TOGGLE: '.dropdown-toggle'
};
var OffsetMethod = {
  OFFSET: 'offset',
  POSITION: 'position' // HREFs must start with # but can be === '#', or start with '#/' or '#!' (which can be router links)

};
var HREF_REGEX = /^#[^/!]+/; // Transition Events

var TransitionEndEvents = ['webkitTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd']; // Options for events

var EventOptions = {
  passive: true,
  capture: false
  /*
   * Utility Methods
   */
  // Better var type detection

};

function toType(obj)
/* istanbul ignore next: not easy to test */
{
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
} // Check config properties for expected types


function typeCheckConfig(componentName, config, configTypes)
/* istanbul ignore next: not easy to test */
{
  for (var property in configTypes) {
    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && (0, _dom.isElement)(value) ? 'element' : toType(value); // handle Vue instances

      valueType = value && value._isVue ? 'component' : valueType;

      if (!new RegExp(expectedTypes).test(valueType)) {
        (0, _warn.default)("".concat(componentName, ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\""));
      }
    }
  }
}
/*
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

/* istanbul ignore next: not easy to test */


var ScrollSpy
/* istanbul ignore next: not easy to test */
=
/*#__PURE__*/
function () {
  function ScrollSpy(element, config, $root) {
    _classCallCheck(this, ScrollSpy);

    // The element we activate links in
    this.$el = element;
    this.$scroller = null;
    this.$selector = [Selector.NAV_LINKS, Selector.LIST_ITEMS, Selector.DROPDOWN_ITEMS].join(',');
    this.$offsets = [];
    this.$targets = [];
    this.$activeTarget = null;
    this.$scrollHeight = 0;
    this.$resizeTimeout = null;
    this.$obs_scroller = null;
    this.$obs_targets = null;
    this.$root = $root || null;
    this.$config = null;
    this.updateConfig(config);
  }

  _createClass(ScrollSpy, [{
    key: "updateConfig",
    value: function updateConfig(config, $root) {
      if (this.$scroller) {
        // Just in case out scroll element has changed
        this.unlisten();
        this.$scroller = null;
      }

      var cfg = _objectSpread({}, this.constructor.Default, config);

      if ($root) {
        this.$root = $root;
      }

      typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);
      this.$config = cfg;

      if (this.$root) {
        var self = this;
        this.$root.$nextTick(function () {
          self.listen();
        });
      } else {
        this.listen();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.unlisten();
      clearTimeout(this.$resizeTimeout);
      this.$resizeTimeout = null;
      this.$el = null;
      this.$config = null;
      this.$scroller = null;
      this.$selector = null;
      this.$offsets = null;
      this.$targets = null;
      this.$activeTarget = null;
      this.$scrollHeight = null;
    }
  }, {
    key: "listen",
    value: function listen() {
      var _this = this;

      var scroller = this.getScroller();

      if (scroller && scroller.tagName !== 'BODY') {
        (0, _dom.eventOn)(scroller, 'scroll', this, EventOptions);
      }

      (0, _dom.eventOn)(window, 'scroll', this, EventOptions);
      (0, _dom.eventOn)(window, 'resize', this, EventOptions);
      (0, _dom.eventOn)(window, 'orientationchange', this, EventOptions);
      TransitionEndEvents.forEach(function (evtName) {
        (0, _dom.eventOn)(window, evtName, _this, EventOptions);
      });
      this.setObservers(true); // Scedule a refresh

      this.handleEvent('refresh');
    }
  }, {
    key: "unlisten",
    value: function unlisten() {
      var _this2 = this;

      var scroller = this.getScroller();
      this.setObservers(false);

      if (scroller && scroller.tagName !== 'BODY') {
        (0, _dom.eventOff)(scroller, 'scroll', this, EventOptions);
      }

      (0, _dom.eventOff)(window, 'scroll', this, EventOptions);
      (0, _dom.eventOff)(window, 'resize', this, EventOptions);
      (0, _dom.eventOff)(window, 'orientationchange', this, EventOptions);
      TransitionEndEvents.forEach(function (evtName) {
        (0, _dom.eventOff)(window, evtName, _this2, EventOptions);
      });
    }
  }, {
    key: "setObservers",
    value: function setObservers(on) {
      var _this3 = this;

      // We observe both the scroller for content changes, and the target links
      if (this.$obs_scroller) {
        this.$obs_scroller.disconnect();
        this.$obs_scroller = null;
      }

      if (this.$obs_targets) {
        this.$obs_targets.disconnect();
        this.$obs_targets = null;
      }

      if (on) {
        this.$obs_targets = (0, _observeDom.default)(this.$el, function () {
          _this3.handleEvent('mutation');
        }, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ['href']
        });
        this.$obs_scroller = (0, _observeDom.default)(this.getScroller(), function () {
          _this3.handleEvent('mutation');
        }, {
          subtree: true,
          childList: true,
          characterData: true,
          attributes: true,
          attributeFilter: ['id', 'style', 'class']
        });
      }
    } // general event handler

  }, {
    key: "handleEvent",
    value: function handleEvent(evt) {
      var type = typeof evt === 'string' ? evt : evt.type;
      var self = this;

      function resizeThrottle() {
        if (!self.$resizeTimeout) {
          self.$resizeTimeout = setTimeout(function () {
            self.refresh();
            self.process();
            self.$resizeTimeout = null;
          }, self.$config.throttle);
        }
      }

      if (type === 'scroll') {
        if (!this.$obs_scroller) {
          // Just in case we are added to the DOM before the scroll target is
          // We re-instantiate our listeners, just in case
          this.listen();
        }

        this.process();
      } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {
        // Postpone these events by throttle time
        resizeThrottle();
      }
    } // Refresh the list of target links on the element we are applied to

  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;

      var scroller = this.getScroller();

      if (!scroller) {
        return;
      }

      var autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;
      var method = this.$config.method === 'auto' ? autoMethod : this.$config.method;
      var methodFn = method === OffsetMethod.POSITION ? _dom.position : _dom.offset;
      var offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0;
      this.$offsets = [];
      this.$targets = [];
      this.$scrollHeight = this.getScrollHeight(); // Find all the unique link href's

      (0, _dom.selectAll)(this.$selector, this.$el).map(function (link) {
        return (0, _dom.getAttr)(link, 'href');
      }).filter(function (href) {
        return HREF_REGEX.test(href || '');
      }).map(function (href) {
        var el = (0, _dom.select)(href, scroller);

        if ((0, _dom.isVisible)(el)) {
          return {
            offset: parseInt(methodFn(el).top, 10) + offsetBase,
            target: href
          };
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a.offset - b.offset;
      }).reduce(function (memo, item) {
        // record only unique targets/offfsets
        if (!memo[item.target]) {
          _this4.$offsets.push(item.offset);

          _this4.$targets.push(item.target);

          memo[item.target] = true;
        }

        return memo;
      }, {});
      return this;
    } // Handle activating/clearing

  }, {
    key: "process",
    value: function process() {
      var scrollTop = this.getScrollTop() + this.$config.offset;
      var scrollHeight = this.getScrollHeight();
      var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();

      if (this.$scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this.$targets[this.$targets.length - 1];

        if (this.$activeTarget !== target) {
          this.activate(target);
        }

        return;
      }

      if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {
        this.$activeTarget = null;
        this.clear();
        return;
      }

      for (var i = this.$offsets.length; i--;) {
        var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (typeof this.$offsets[i + 1] === 'undefined' || scrollTop < this.$offsets[i + 1]);

        if (isActiveTarget) {
          this.activate(this.$targets[i]);
        }
      }
    }
  }, {
    key: "getScroller",
    value: function getScroller() {
      if (this.$scroller) {
        return this.$scroller;
      }

      var scroller = this.$config.element;

      if (!scroller) {
        return null;
      } else if ((0, _dom.isElement)(scroller.$el)) {
        scroller = scroller.$el;
      } else if (typeof scroller === 'string') {
        scroller = (0, _dom.select)(scroller);
      }

      if (!scroller) {
        return null;
      }

      this.$scroller = scroller.tagName === 'BODY' ? window : scroller;
      return this.$scroller;
    }
  }, {
    key: "getScrollTop",
    value: function getScrollTop() {
      var scroller = this.getScroller();
      return scroller === window ? scroller.pageYOffset : scroller.scrollTop;
    }
  }, {
    key: "getScrollHeight",
    value: function getScrollHeight() {
      return this.getScroller().scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
  }, {
    key: "getOffsetHeight",
    value: function getOffsetHeight() {
      var scroller = this.getScroller();
      return scroller === window ? window.innerHeight : (0, _dom.getBCR)(scroller).height;
    }
  }, {
    key: "activate",
    value: function activate(target) {
      var _this5 = this;

      this.$activeTarget = target;
      this.clear(); // Grab the list of target links (<a href="{$target}">)

      var links = (0, _dom.selectAll)(this.$selector.split(',').map(function (selector) {
        return "".concat(selector, "[href=\"").concat(target, "\"]");
      }).join(','), this.$el);
      links.forEach(function (link) {
        if ((0, _dom.hasClass)(link, ClassName.DROPDOWN_ITEM)) {
          // This is a dropdown item, so find the .dropdown-toggle and set it's state
          var dropdown = (0, _dom.closest)(Selector.DROPDOWN, link);

          if (dropdown) {
            _this5.setActiveState((0, _dom.select)(Selector.DROPDOWN_TOGGLE, dropdown), true);
          } // Also set this link's state


          _this5.setActiveState(link, true);
        } else {
          // Set triggered link as active
          _this5.setActiveState(link, true);

          if ((0, _dom.matches)(link.parentElement, Selector.NAV_ITEMS)) {
            // Handle nav-link inside nav-item, and set nav-item active
            _this5.setActiveState(link.parentElement, true);
          } // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor


          var el = link;

          while (el) {
            el = (0, _dom.closest)(Selector.NAV_LIST_GROUP, el);
            var sibling = el ? el.previousElementSibling : null;

            if ((0, _dom.matches)(sibling, "".concat(Selector.NAV_LINKS, ", ").concat(Selector.LIST_ITEMS))) {
              _this5.setActiveState(sibling, true);
            } // Handle special case where nav-link is inside a nav-item


            if ((0, _dom.matches)(sibling, Selector.NAV_ITEMS)) {
              _this5.setActiveState((0, _dom.select)(Selector.NAV_LINKS, sibling), true); // Add active state to nav-item as well


              _this5.setActiveState(sibling, true);
            }
          }
        }
      }); // Signal event to via $root, passing ID of activaed target and reference to array of links

      if (links && links.length > 0 && this.$root) {
        this.$root.$emit(ACTIVATE_EVENT, target, links);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this6 = this;

      (0, _dom.selectAll)("".concat(this.$selector, ", ").concat(Selector.NAV_ITEMS), this.$el).filter(function (el) {
        return (0, _dom.hasClass)(el, ClassName.ACTIVE);
      }).forEach(function (el) {
        return _this6.setActiveState(el, false);
      });
    }
  }, {
    key: "setActiveState",
    value: function setActiveState(el, active) {
      if (!el) {
        return;
      }

      if (active) {
        (0, _dom.addClass)(el, ClassName.ACTIVE);
      } else {
        (0, _dom.removeClass)(el, ClassName.ACTIVE);
      }
    }
  }], [{
    key: "Name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }]);

  return ScrollSpy;
}();

var _default = ScrollSpy;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/scrollspy/scrollspy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _scrollspy = __webpack_require__("./node_modules/bootstrap-vue/es/directives/scrollspy/scrollspy.class.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Key we use to store our instance
var BV_SCROLLSPY = '__BV_ScrollSpy__'; // Build a ScrollSpy config based on bindings (if any)
// Arguments and modifiers take precedence over passed value config object

/* istanbul ignore next: not easy to test */

var parseBindings = function parseBindings(bindings)
/* istanbul ignore next: not easy to test */
{
  var config = {}; // If argument, assume element ID

  if (bindings.arg) {
    // Element ID specified as arg
    // We must prepend '#' to become a CSS selector
    config.element = "#".concat(bindings.arg);
  } // Process modifiers


  (0, _object.keys)(bindings.modifiers).forEach(function (mod) {
    if (/^\d+$/.test(mod)) {
      // Offset value
      config.offset = parseInt(mod, 10);
    } else if (/^(auto|position|offset)$/.test(mod)) {
      // Offset method
      config.method = mod;
    }
  }); // Process value

  if (typeof bindings.value === 'string') {
    // Value is a CSS ID or selector
    config.element = bindings.value;
  } else if (typeof bindings.value === 'number') {
    // Value is offset
    config.offset = Math.round(bindings.value);
  } else if (_typeof(bindings.value) === 'object') {
    // Value is config object
    // Filter the object based on our supported config options
    (0, _object.keys)(bindings.value).filter(function (k) {
      return Boolean(_scrollspy.default.DefaultType[k]);
    }).forEach(function (k) {
      config[k] = bindings.value[k];
    });
  }

  return config;
}; // Add or update ScrollSpy on our element


var applyScrollspy = function applyScrollspy(el, bindings, vnode)
/* istanbul ignore next: not easy to test */
{
  if (!_env.inBrowser) {
    /* istanbul ignore next */
    return;
  }

  var config = parseBindings(bindings);

  if (el[BV_SCROLLSPY]) {
    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);
  } else {
    el[BV_SCROLLSPY] = new _scrollspy.default(el, config, vnode.context.$root);
  }
}; // Remove ScrollSpy on our element

/* istanbul ignore next: not easy to test */


var removeScrollspy = function removeScrollspy(el)
/* istanbul ignore next: not easy to test */
{
  if (el[BV_SCROLLSPY]) {
    el[BV_SCROLLSPY].dispose();
    el[BV_SCROLLSPY] = null;
    delete el[BV_SCROLLSPY];
  }
};
/*
 * Export our directive
 */


var _default = {
  bind: function bind(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    applyScrollspy(el, bindings, vnode);
  },
  inserted: function inserted(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    applyScrollspy(el, bindings, vnode);
  },
  update: function update(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyScrollspy(el, bindings, vnode);
    }
  },
  componentUpdated: function componentUpdated(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyScrollspy(el, bindings, vnode);
    }
  },
  unbind: function unbind(el)
  /* istanbul ignore next: not easy to test */
  {
    removeScrollspy(el);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/toggle/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _toggle = __webpack_require__("./node_modules/bootstrap-vue/es/directives/toggle/toggle.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var directives = {
  BToggle: _toggle.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    directives: directives
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/toggle/toggle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _target = __webpack_require__("./node_modules/bootstrap-vue/es/utils/target.js");

// Target listen types
var listenTypes = {
  click: true // Property key for handler storage

};
var BV_TOGGLE = '__BV_toggle__';
var BV_TOGGLE_STATE = '__BV_toggle_STATE__';
var BV_TOGGLE_CONTROLS = '__BV_toggle_CONTROLS__'; // Emitted control event for collapse (emitted to collapse)

var EVENT_TOGGLE = 'bv::toggle::collapse'; // Listen to event for toggle state update (emitted by collapse)

var EVENT_STATE = 'bv::collapse::state'; // Reset and remove a property from the provided element

var resetProp = function resetProp(el, prop) {
  el[prop] = null;
  delete el[prop];
}; // Handle directive updates

/* istanbul ignore next: not easy to test */


var handleUpdate = function handleUpdate(el, binding, vnode) {
  if (!_env.inBrowser) {
    return;
  } // Ensure the collapse class and aria-* attributes persist
  // after element is updated (either by parent re-rendering
  // or changes to this element or it's contents


  if (el[BV_TOGGLE_STATE] === true) {
    (0, _dom.addClass)(el, 'collapsed');
    (0, _dom.setAttr)(el, 'aria-expanded', 'true');
  } else if (el[BV_TOGGLE_STATE] === false) {
    (0, _dom.removeClass)(el, 'collapsed');
    (0, _dom.setAttr)(el, 'aria-expanded', 'false');
  }

  (0, _dom.setAttr)(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);
};
/*
 * Export our directive
 */


var _default = {
  bind: function bind(el, binding, vnode) {
    var targets = (0, _target.bindTargets)(vnode, binding, listenTypes, function (_ref) {
      var targets = _ref.targets,
          vnode = _ref.vnode;
      targets.forEach(function (target) {
        vnode.context.$root.$emit(EVENT_TOGGLE, target);
      });
    });

    if (_env.inBrowser && vnode.context && targets.length > 0) {
      // Add aria attributes to element
      el[BV_TOGGLE_CONTROLS] = targets.join(' '); // State is initially collapsed until we receive a state event

      el[BV_TOGGLE_STATE] = false;
      (0, _dom.setAttr)(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);
      (0, _dom.setAttr)(el, 'aria-expanded', 'false'); // If element is not a button, we add `role="button"` for accessibility

      if (el.tagName !== 'BUTTON') {
        (0, _dom.setAttr)(el, 'role', 'button');
      } // Toggle state handler, stored on element


      el[BV_TOGGLE] = function toggleDirectiveHandler(id, state) {
        if (targets.indexOf(id) !== -1) {
          // Set aria-expanded state
          (0, _dom.setAttr)(el, 'aria-expanded', state ? 'true' : 'false'); // Set/Clear 'collapsed' class state

          el[BV_TOGGLE_STATE] = state;

          if (state) {
            (0, _dom.removeClass)(el, 'collapsed');
          } else {
            (0, _dom.addClass)(el, 'collapsed');
          }
        }
      }; // Listen for toggle state changes


      vnode.context.$root.$on(EVENT_STATE, el[BV_TOGGLE]);
    }
  },
  componentUpdated: handleUpdate,
  updated: handleUpdate,
  unbind: function unbind(el, binding, vnode)
  /* istanbul ignore next */
  {
    (0, _target.unbindTargets)(vnode, binding, listenTypes); // Remove our $root listener

    if (el[BV_TOGGLE]) {
      vnode.context.$root.$off(EVENT_STATE, el[BV_TOGGLE]);
    } // Reset custom  props


    resetProp(el, BV_TOGGLE);
    resetProp(el, BV_TOGGLE_STATE);
    resetProp(el, BV_TOGGLE_CONTROLS); // Reset classes/attrs

    (0, _dom.removeClass)(el, 'collapsed');
    (0, _dom.removeAttr)(el, 'aria-expanded');
    (0, _dom.removeAttr)(el, 'aria-controls');
    (0, _dom.removeAttr)(el, 'role');
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/tooltip/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/directives/tooltip/tooltip.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var directives = {
  BTooltip: _tooltip.default
};
var _default = {
  install: (0, _plugins.installFactory)({
    directives: directives
  })
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/directives/tooltip/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popper = __webpack_require__("./node_modules/popper.js/dist/esm/popper.js");

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/utils/tooltip.class.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Key which we use to store tooltip object on element
var BV_TOOLTIP = '__BV_ToolTip__'; // Valid event triggers

var validTriggers = {
  focus: true,
  hover: true,
  click: true,
  blur: true // Build a ToolTip config based on bindings (if any)
  // Arguments and modifiers take precedence over passed value config object

  /* istanbul ignore next: not easy to test */

};

var parseBindings = function parseBindings(bindings)
/* istanbul ignore next: not easy to test */
{
  // We start out with a blank config
  var config = {}; // Process bindings.value

  if (typeof bindings.value === 'string') {
    // Value is tooltip content (html optionally supported)
    config.title = bindings.value;
  } else if (typeof bindings.value === 'function') {
    // Title generator function
    config.title = bindings.value;
  } else if (_typeof(bindings.value) === 'object') {
    // Value is config object, so merge
    config = _objectSpread({}, config, bindings.value);
  } // If argument, assume element ID of container element


  if (bindings.arg) {
    // Element ID specified as arg
    // We must prepend '#' to become a CSS selector
    config.container = "#".concat(bindings.arg);
  } // Process modifiers


  (0, _object.keys)(bindings.modifiers).forEach(function (mod) {
    if (/^html$/.test(mod)) {
      // Title allows HTML
      config.html = true;
    } else if (/^nofade$/.test(mod)) {
      // No animation
      config.animation = false;
    } else if (/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/.test(mod)) {
      // Placement of tooltip
      config.placement = mod;
    } else if (/^(window|viewport)$/.test(mod)) {
      // Boundary of tooltip
      config.boundary = mod;
    } else if (/^d\d+$/.test(mod)) {
      // Delay value
      var delay = parseInt(mod.slice(1), 10) || 0;

      if (delay) {
        config.delay = delay;
      }
    } else if (/^o-?\d+$/.test(mod)) {
      // Offset value, negative allowed
      var offset = parseInt(mod.slice(1), 10) || 0;

      if (offset) {
        config.offset = offset;
      }
    }
  }); // Special handling of event trigger modifiers trigger is
  // a space separated list

  var selectedTriggers = {}; // Parse current config object trigger

  var triggers = typeof config.trigger === 'string' ? config.trigger.trim().split(/\s+/) : [];
  triggers.forEach(function (trigger) {
    if (validTriggers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Parse modifiers for triggers

  (0, _object.keys)(validTriggers).forEach(function (trigger) {
    if (bindings.modifiers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Sanitize triggers

  config.trigger = (0, _object.keys)(selectedTriggers).join(' ');

  if (config.trigger === 'blur') {
    // Blur by itself is useless, so convert it to 'focus'
    config.trigger = 'focus';
  }

  if (!config.trigger) {
    // Remove trigger config
    delete config.trigger;
  }

  return config;
}; // Add or update ToolTip on our element


var applyTooltip = function applyTooltip(el, bindings, vnode) {
  if (!_env.inBrowser) {
    /* istanbul ignore next */
    return;
  }

  if (!_popper.default) {
    // Popper is required for ToolTips to work

    /* istanbul ignore next */
    (0, _warn.default)('v-b-tooltip: Popper.js is required for ToolTips to work');
    /* istanbul ignore next */

    return;
  }

  var config = parseBindings(bindings);

  if (el[BV_TOOLTIP]) {
    el[BV_TOOLTIP].updateConfig(config);
  } else {
    el[BV_TOOLTIP] = new _tooltip.default(el, config, vnode.context.$root);
  }
}; // Remove ToolTip on our element


var removeTooltip = function removeTooltip(el) {
  if (el[BV_TOOLTIP]) {
    el[BV_TOOLTIP].destroy();
    el[BV_TOOLTIP] = null;
    delete el[BV_TOOLTIP];
  }
};
/*
 * Export our directive
 */


var _default = {
  bind: function bind(el, bindings, vnode) {
    applyTooltip(el, bindings, vnode);
  },
  inserted: function inserted(el, bindings, vnode) {
    applyTooltip(el, bindings, vnode);
  },
  update: function update(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyTooltip(el, bindings, vnode);
    }
  },
  componentUpdated: function componentUpdated(el, bindings, vnode)
  /* istanbul ignore next: not easy to test */
  {
    if (bindings.value !== bindings.oldValue) {
      applyTooltip(el, bindings, vnode);
    }
  },
  unbind: function unbind(el) {
    removeTooltip(el);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var componentPlugins = __webpack_require__("./node_modules/bootstrap-vue/es/components/index.js");

var directivePlugins = __webpack_require__("./node_modules/bootstrap-vue/es/directives/index.js");

var _plugins = __webpack_require__("./node_modules/bootstrap-vue/es/utils/plugins.js");

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

var BootstrapVue = {
  install: function install(Vue) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // Configure BootstrapVue
    (0, _config.setConfig)(config); // Register component plugins

    (0, _plugins.registerPlugins)(Vue, componentPlugins); // Register directive plugins

    (0, _plugins.registerPlugins)(Vue, directivePlugins);
  },
  setConfig: function setConfig()
  /* istanbul ignore next */
  {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _config.setConfig)(config);
  }
}; // Auto installation only occurs if window.Vue exists

(0, _plugins.vueUse)(BootstrapVue);
var _default = BootstrapVue;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/card-mixin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    bgVariant: {
      type: String,
      default: null
    },
    borderVariant: {
      type: String,
      default: null
    },
    textVariant: {
      type: String,
      default: null
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/click-out.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

// @vue/component
var _default = {
  data: function data() {
    return {
      listenForClickOut: false
    };
  },
  watch: {
    listenForClickOut: function listenForClickOut(newValue, oldValue) {
      if (newValue !== oldValue) {
        (0, _dom.eventOff)(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, false);

        if (newValue) {
          (0, _dom.eventOn)(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, false);
        }
      }
    }
  },
  beforeCreate: function beforeCreate() {
    // Declare non-reactive properties
    this.clickOutElement = null;
    this.clickOutEventName = null;
  },
  mounted: function mounted() {
    if (!this.clickOutElement) {
      this.clickOutElement = document;
    }

    if (!this.clickOutEventName) {
      this.clickOutEventName = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
    }

    if (this.listenForClickOut) {
      (0, _dom.eventOn)(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, false);
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    (0, _dom.eventOff)(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, false);
  },
  methods: {
    isClickOut: function isClickOut(evt) {
      return !(0, _dom.contains)(this.$el, evt.target);
    },
    _clickOutHandler: function _clickOutHandler(evt) {
      if (this.clickOutHandler && this.isClickOut(evt)) {
        this.clickOutHandler(evt);
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/dropdown.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popper = __webpack_require__("./node_modules/popper.js/dist/esm/popper.js");

var _clickOut = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/click-out.js");

var _focusIn = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/focus-in.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _bvEvent = __webpack_require__("./node_modules/bootstrap-vue/es/utils/bv-event.class.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Return an Array of visible items
function filterVisible(els) {
  return (els || []).filter(_dom.isVisible);
} // Dropdown item CSS selectors
// TODO: .dropdown-form handling


var Selector = {
  FORM_CHILD: '.dropdown form',
  NAVBAR_NAV: '.navbar-nav',
  ITEM_SELECTOR: '.dropdown-item:not(.disabled):not([disabled])' // Popper attachment positions

};
var AttachmentMap = {
  // Dropup left align
  TOP: 'top-start',
  // Dropup right align
  TOPEND: 'top-end',
  // Dropdown left align
  BOTTOM: 'bottom-start',
  // Dropdown right align
  BOTTOMEND: 'bottom-end',
  // Dropright left align
  RIGHT: 'right-start',
  // Dropright right align
  RIGHTEND: 'right-end',
  // Dropleft left align
  LEFT: 'left-start',
  // Dropleft right align
  LEFTEND: 'left-end' // @vue/component

};
var _default2 = {
  mixins: [_clickOut.default, _focusIn.default],
  provide: function provide() {
    return {
      bvDropdown: this
    };
  },
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    text: {
      // Button label
      type: String,
      default: ''
    },
    html: {
      // Button label
      type: String
    },
    dropup: {
      // place on top if possible
      type: Boolean,
      default: false
    },
    dropright: {
      // place right if possible
      type: Boolean,
      default: false
    },
    dropleft: {
      // place left if possible
      type: Boolean,
      default: false
    },
    right: {
      // Right align menu (default is left align)
      type: Boolean,
      default: false
    },
    offset: {
      // Number of pixels to offset menu, or a CSS unit value (i.e. 1px, 1rem, etc)
      type: [Number, String],
      default: 0
    },
    noFlip: {
      // Disable auto-flipping of menu from bottom<=>top
      type: Boolean,
      default: false
    },
    popperOpts: {
      // type: Object,
      default: function _default() {}
    }
  },
  data: function data() {
    return {
      visible: false,
      inNavbar: null,
      visibleChangePrevented: false
    };
  },
  computed: {
    toggler: function toggler() {
      var toggle = this.$refs.toggle;
      return toggle ? toggle.$el || toggle : null;
    }
  },
  watch: {
    visible: function visible(newValue, oldValue) {
      if (this.visibleChangePrevented) {
        this.visibleChangePrevented = false;
        return;
      }

      if (newValue !== oldValue) {
        var evtName = newValue ? 'show' : 'hide';
        var bvEvt = new _bvEvent.default(evtName, {
          cancelable: true,
          vueTarget: this,
          target: this.$refs.menu,
          relatedTarget: null
        });
        this.emitEvent(bvEvt);

        if (bvEvt.defaultPrevented) {
          // Reset value and exit if canceled
          this.visibleChangePrevented = true;
          this.visible = oldValue; // Just in case a child element triggereded this.hide(true)

          this.$off('hidden', this.focusToggler);
          return;
        }

        if (evtName === 'show') {
          this.showMenu();
        } else {
          this.hideMenu();
        }
      }
    },
    disabled: function disabled(newValue, oldValue) {
      if (newValue !== oldValue && newValue && this.visible) {
        // Hide dropdown if disabled changes to true
        this.visible = false;
      }
    }
  },
  created: function created() {
    // Create non-reactive property
    this._popper = null;
  },
  deactivated: function deactivated()
  /* istanbul ignore next: not easy to test */
  {
    // In case we are inside a `<keep-alive>`
    this.visible = false;
    this.whileOpenListen(false);
    this.removePopper();
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next: not easy to test */
  {
    this.visible = false;
    this.whileOpenListen(false);
    this.removePopper();
  },
  methods: {
    // Event emitter
    emitEvent: function emitEvent(bvEvt) {
      var type = bvEvt.type;
      this.$emit(type, bvEvt);
      this.$root.$emit("bv::dropdown::".concat(type), bvEvt);
    },
    showMenu: function showMenu() {
      var _this = this;

      if (this.disabled) {
        return;
      } // Ensure other menus are closed


      this.$root.$emit('bv::dropdown::shown', this); // Are we in a navbar ?

      if (this.inNavbar === null && this.isNav) {
        this.inNavbar = Boolean((0, _dom.closest)('.navbar', this.$el));
      } // Disable totally Popper.js for Dropdown in Navbar

      /* istanbul ignore next: cant test popper in JSDOM */


      if (!this.inNavbar) {
        if (typeof _popper.default === 'undefined') {
          (0, _warn.default)('b-dropdown: Popper.js not found. Falling back to CSS positioning.');
        } else {
          // for dropup with alignment we use the parent element as popper container
          var element = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!

          element = element.$el || element; // Instantiate popper.js

          this.createPopper(element);
        }
      }

      this.whileOpenListen(true); // Wrap in nextTick to ensure menu is fully rendered/shown

      this.$nextTick(function () {
        // Focus on the menu container on show
        _this.focusMenu(); // Emit the shown event


        _this.$emit('shown');
      });
    },
    hideMenu: function hideMenu() {
      this.whileOpenListen(false);
      this.$root.$emit('bv::dropdown::hidden', this);
      this.$emit('hidden');
      this.removePopper();
    },
    createPopper: function createPopper(element)
    /* istanbul ignore next: cant test popper in JSDOM */
    {
      this.removePopper();
      this._popper = new _popper.default(element, this.$refs.menu, this.getPopperConfig());
    },
    removePopper: function removePopper()
    /* istanbul ignore next: cant test popper in JSDOM */
    {
      if (this._popper) {
        // Ensure popper event listeners are removed cleanly
        this._popper.destroy();
      }

      this._popper = null;
    },
    getPopperConfig: function getPopperConfig()
    /* istanbul ignore next: can't test popper in JSDOM */
    {
      var placement = AttachmentMap.BOTTOM;

      if (this.dropup) {
        placement = this.right ? AttachmentMap.TOPEND : AttachmentMap.TOP;
      } else if (this.dropright) {
        placement = AttachmentMap.RIGHT;
      } else if (this.dropleft) {
        placement = AttachmentMap.LEFT;
      } else if (this.right) {
        placement = AttachmentMap.BOTTOMEND;
      }

      var popperConfig = {
        placement: placement,
        modifiers: {
          offset: {
            offset: this.offset || 0
          },
          flip: {
            enabled: !this.noFlip
          }
        }
      };

      if (this.boundary) {
        popperConfig.modifiers.preventOverflow = {
          boundariesElement: this.boundary
        };
      }

      return _objectSpread({}, popperConfig, this.popperOpts || {});
    },
    whileOpenListen: function whileOpenListen(open) {
      // turn listeners on/off while open
      if (open) {
        // If another dropdown is opened
        this.$root.$on('bv::dropdown::shown', this.rootCloseListener); // Hide the dropdown when clicked outside

        this.listenForClickOut = true; // Hide the dropdown when it loses focus

        this.listenForFocusIn = true;
      } else {
        this.$root.$off('bv::dropdown::shown', this.rootCloseListener);
        this.listenForClickOut = false;
        this.listenForFocusIn = false;
      }
    },
    rootCloseListener: function rootCloseListener(vm) {
      if (vm !== this) {
        this.visible = false;
      }
    },
    show: function show() {
      // Public method to show dropdown
      if (this.disabled) {
        return;
      }

      this.visible = true;
    },
    hide: function hide() {
      var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      // Public method to hide dropdown
      if (this.disabled) {
        return;
      }

      this.visible = false;

      if (refocus) {
        // Child element is closing the dropdown on click
        this.$once('hidden', this.focusToggler);
      }
    },
    toggle: function toggle(evt) {
      // Called only by a button that toggles the menu
      evt = evt || {};
      var type = evt.type;
      var key = evt.keyCode;

      if (type !== 'click' && !(type === 'keydown' && (key === _keyCodes.default.ENTER || key === _keyCodes.default.SPACE || key === _keyCodes.default.DOWN))) {
        // We only toggle on Click, Enter, Space, and Arrow Down
        return;
      }

      if (this.disabled) {
        this.visible = false;
        return;
      }

      this.$emit('toggle', evt);

      if (evt.defaultPrevented) {
        // Exit if canceled
        return;
      }

      evt.preventDefault();
      evt.stopPropagation(); // Toggle visibility

      this.visible = !this.visible;
    },
    click: function click(evt) {
      // Called only in split button mode, for the split button
      if (this.disabled) {
        this.visible = false;
        return;
      }

      this.$emit('click', evt);
    },
    onKeydown: function onKeydown(evt)
    /* istanbul ignore next: not easy to test */
    {
      // Called from dropdown menu context
      var key = evt.keyCode;

      if (key === _keyCodes.default.ESC) {
        // Close on ESC
        this.onEsc(evt);
      } else if (key === _keyCodes.default.TAB) {
        // Close on tab out
        this.onTab(evt);
      } else if (key === _keyCodes.default.DOWN) {
        // Down Arrow
        this.focusNext(evt, false);
      } else if (key === _keyCodes.default.UP) {
        // Up Arrow
        this.focusNext(evt, true);
      }
    },
    onEsc: function onEsc(evt)
    /* istanbul ignore next: not easy to test */
    {
      if (this.visible) {
        this.visible = false;
        evt.preventDefault();
        evt.stopPropagation(); // Return focus to original trigger button

        this.$once('hidden', this.focusToggler);
      }
    },
    onTab: function onTab(evt)
    /* istanbul ignore next: not easy to test */
    {// TODO: Need special handler for dealing with form inputs
      // Tab, if in a text-like input, we should just focus next item in the dropdown
      // Note: Inputs are in a special .dropdown-form container
    },
    onMouseOver: function onMouseOver(evt)
    /* istanbul ignore next: not easy to test */
    {// Removed mouseover focus handler
    },
    // Document click out listener
    clickOutHandler: function clickOutHandler() {
      if (this.visible) {
        this.visible = false;
      }
    },
    // Document focusin listener
    focusInHandler: function focusInHandler(evt) {
      // If focus leaves dropdown, hide it
      if (this.visible && !(0, _dom.contains)(this.$refs.menu, evt.target) && !(0, _dom.contains)(this.$refs.toggle, evt.target)) {
        this.visible = false;
      }
    },
    // Keyboard nav
    focusNext: function focusNext(evt, up) {
      var _this2 = this;

      if (!this.visible) {
        return;
      }

      evt.preventDefault();
      evt.stopPropagation();
      this.$nextTick(function () {
        var items = _this2.getItems();

        if (items.length < 1) {
          return;
        }

        var index = items.indexOf(evt.target);

        if (up && index > 0) {
          index--;
        } else if (!up && index < items.length - 1) {
          index++;
        }

        if (index < 0) {
          index = 0;
        }

        _this2.focusItem(index, items);
      });
    },
    focusItem: function focusItem(idx, items) {
      var el = items.find(function (el, i) {
        return i === idx;
      });

      if (el && (0, _dom.getAttr)(el, 'tabindex') !== '-1') {
        el.focus();
      }
    },
    getItems: function getItems() {
      // Get all items
      return filterVisible((0, _dom.selectAll)(Selector.ITEM_SELECTOR, this.$refs.menu));
    },
    focusMenu: function focusMenu() {
      this.$refs.menu.focus && this.$refs.menu.focus();
    },
    focusToggler: function focusToggler() {
      var toggler = this.toggler;

      if (toggler && toggler.focus) {
        toggler.focus();
      }
    }
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/focus-in.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

// @vue/component
var _default = {
  data: function data() {
    return {
      listenForFocusIn: false
    };
  },
  watch: {
    listenForFocusIn: function listenForFocusIn(newValue, oldValue) {
      if (newValue !== oldValue) {
        (0, _dom.eventOff)(this.focusInElement, 'focusin', this._focusInHandler, false);

        if (newValue) {
          (0, _dom.eventOn)(this.focusInElement, 'focusin', this._focusInHandler, false);
        }
      }
    }
  },
  beforeCreate: function beforeCreate() {
    // Declare non-reactive properties
    this.focusInElement = null;
  },
  mounted: function mounted() {
    if (!this.focusInElement) {
      this.focusInElement = document;
    }

    if (this.listenForFocusIn) {
      (0, _dom.eventOn)(this.focusInElement, 'focusin', this._focusInHandler, false);
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    (0, _dom.eventOff)(this.focusInElement, 'focusin', this._focusInHandler, false);
  },
  methods: {
    _focusInHandler: function _focusInHandler(evt) {
      if (this.focusInHandler) {
        this.focusInHandler(evt);
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-custom.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  props: {
    plain: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    custom: function custom() {
      return !this.plain;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-options.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

function isObject(obj) {
  return obj && {}.toString.call(obj) === '[object Object]';
} // @vue/component


var _default2 = {
  props: {
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    valueField: {
      type: String,
      default: 'value'
    },
    textField: {
      type: String,
      default: 'text'
    },
    htmlField: {
      type: String,
      default: 'html'
    },
    disabledField: {
      type: String,
      default: 'disabled'
    }
  },
  computed: {
    formOptions: function formOptions() {
      var options = this.options;
      var valueField = this.valueField;
      var textField = this.textField;
      var htmlField = this.htmlField;
      var disabledField = this.disabledField;

      if ((0, _array.isArray)(options)) {
        // Normalize flat-ish arrays to Array of Objects
        return options.map(function (option) {
          if (isObject(option)) {
            var value = option[valueField];
            var text = String(option[textField]);
            return {
              value: typeof value === 'undefined' ? text : value,
              text: (0, _html.stripTags)(text),
              html: option[htmlField],
              disabled: Boolean(option[disabledField])
            };
          }

          return {
            value: option,
            text: (0, _html.stripTags)(String(option)),
            disabled: false
          };
        });
      } else {
        // options is Object
        // Normalize Objects to Array of Objects
        return (0, _object.keys)(options).map(function (key) {
          var option = options[key] || {};

          if (isObject(option)) {
            var value = option[valueField];
            var text = option[textField];
            return {
              value: typeof value === 'undefined' ? key : value,
              text: typeof text === 'undefined' ? (0, _html.stripTags)(String(key)) : (0, _html.stripTags)(String(text)),
              html: option[htmlField],
              disabled: Boolean(option[disabledField])
            };
          }

          return {
            value: key,
            text: (0, _html.stripTags)(String(option)),
            disabled: false
          };
        });
      }
    }
  }
};
exports.default = _default2;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-radio-check-group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _html = __webpack_require__("./node_modules/bootstrap-vue/es/utils/html.js");

// @vue/component
var _default = {
  model: {
    prop: 'checked',
    event: 'input'
  },
  props: {
    validated: {
      type: Boolean,
      default: false
    },
    ariaInvalid: {
      type: [Boolean, String],
      default: false
    },
    stacked: {
      type: Boolean,
      default: false
    },
    plain: {
      type: Boolean,
      default: false
    },
    buttons: {
      // Render as button style
      type: Boolean,
      default: false
    },
    buttonVariant: {
      // Only applicable when rendered with button style
      type: String,
      default: 'secondary'
    }
  },
  computed: {
    inline: function inline() {
      return !this.stacked;
    },
    groupName: function groupName() {
      // Checks/Radios tied to the same model must have the same name,
      // especially for ARIA accessibility.
      return this.name || this.safeId();
    },
    groupClasses: function groupClasses() {
      if (this.buttons) {
        return ['btn-group-toggle', this.inline ? 'btn-group' : 'btn-group-vertical', this.size ? "btn-group-".concat(this.size) : '', this.validated ? "was-validated" : ''];
      }

      return [this.validated ? "was-validated" : ''];
    },
    computedAriaInvalid: function computedAriaInvalid() {
      var ariaInvalid = this.ariaInvalid;

      if (ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === '') {
        return 'true';
      }

      return this.computedState === false ? 'true' : null;
    }
  },
  watch: {
    checked: function checked(newVal, oldVal) {
      this.localChecked = newVal;
    },
    localChecked: function localChecked(newVal, oldVal) {
      this.$emit('input', newVal);
    }
  },
  render: function render(h) {
    var _this = this;

    var $slots = this.$slots;
    var inputs = this.formOptions.map(function (option, idx) {
      var uid = "_BV_option_".concat(idx, "_");
      return h(_this.is_RadioGroup ? 'b-form-radio' : 'b-form-checkbox', {
        key: uid,
        props: {
          id: _this.safeId(uid),
          value: option.value,
          // Individual radios or checks can be disabled in a group
          disabled: option.disabled || false // We don't need to include these, since the input's will know they are inside here
          // name: this.groupName,
          // form: this.form || null,
          // required: Boolean(this.name && this.required)

        }
      }, [h('span', {
        domProps: (0, _html.htmlOrText)(option.html, option.text)
      })]);
    });
    return h('div', {
      class: this.groupClasses,
      attrs: {
        id: this.safeId(),
        role: this.is_RadioGroup ? 'radiogroup' : 'group',
        // Tabindex to allow group to be focused if needed
        tabindex: '-1',
        'aria-required': this.required ? 'true' : null,
        'aria-invalid': this.computedAriaInvalid
      }
    }, [$slots.first, inputs, $slots.default]);
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-radio-check.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @vue/component
var _default = {
  model: {
    prop: 'checked',
    event: 'input'
  },
  props: {
    value: {// Value when checked
      // type: Object,
      // default: undefined
    },
    checked: {// This is the v-model
      // type: Object,
      // default: undefined
    },
    inline: {
      type: Boolean,
      default: false
    },
    plain: {
      type: Boolean,
      default: false
    },
    button: {
      // Only applicable in standalone mode (non group)
      type: Boolean,
      default: false
    },
    buttonVariant: {
      // Only applicable when rendered with button style
      type: String,
      default: null
    },
    ariaLabel: {
      // Placed on the input if present.
      type: String,
      default: null
    }
  },
  data: function data() {
    return {
      localChecked: this.is_Group ? this.bvGroup.checked : this.checked,
      hasFocus: false
    };
  },
  computed: {
    computedLocalChecked: {
      get: function get() {
        return this.is_Group ? this.bvGroup.localChecked : this.localChecked;
      },
      set: function set(val) {
        if (this.is_Group) {
          this.bvGroup.localChecked = val;
        } else {
          this.localChecked = val;
        }
      }
    },
    is_Group: function is_Group() {
      // Is this check/radio a child of check-group or radio-group?
      return Boolean(this.bvGroup);
    },
    is_BtnMode: function is_BtnMode() {
      // Support button style in single input mode
      return this.is_Group ? this.bvGroup.buttons : this.button;
    },
    is_Plain: function is_Plain() {
      return this.is_BtnMode ? false : this.is_Group ? this.bvGroup.plain : this.plain;
    },
    is_Custom: function is_Custom() {
      return this.is_BtnMode ? false : !this.is_Plain;
    },
    is_Switch: function is_Switch() {
      // Custom switch styling (checkboxes only)
      return this.is_BtnMode || this.is_Radio || this.is_Plain ? false : this.is_Group ? this.bvGroup.switches : this.switch;
    },
    is_Inline: function is_Inline() {
      return this.is_Group ? this.bvGroup.inline : this.inline;
    },
    is_Disabled: function is_Disabled() {
      // Child can be disabled while parent isn't, but is always disabled if group is
      return this.is_Group ? this.bvGroup.disabled || this.disabled : this.disabled;
    },
    is_Required: function is_Required() {
      // Required only works when a name is provided for the input(s)
      // Child can only be required when parent is
      // Groups will always have a name (either user supplied or auto generated)
      return Boolean(this.get_Name && (this.is_Group ? this.bvGroup.required : this.required));
    },
    get_Name: function get_Name() {
      // Group name preferred over local name
      return (this.is_Group ? this.bvGroup.groupName : this.name) || null;
    },
    get_Form: function get_Form() {
      return (this.is_Group ? this.bvGroup.form : this.form) || null;
    },
    get_Size: function get_Size() {
      return (this.is_Group ? this.bvGroup.size : this.size) || '';
    },
    get_State: function get_State() {
      return this.is_Group ? this.bvGroup.computedState : this.computedState;
    },
    get_ButtonVariant: function get_ButtonVariant() {
      // Local variant preferred over group variant
      if (this.buttonVariant) {
        return this.buttonVariant;
      } else if (this.is_Group && this.bvGroup.buttonVariant) {
        return this.bvGroup.buttonVariant;
      } // default variant


      return 'secondary';
    },
    buttonClasses: function buttonClasses() {
      // Same for radio & check
      return ['btn', "btn-".concat(this.get_ButtonVariant), this.get_Size ? "btn-".concat(this.get_Size) : '', // 'disabled' class makes "button" look disabled
      this.is_Disabled ? 'disabled' : '', // 'active' class makes "button" look pressed
      this.is_Checked ? 'active' : '', // Focus class makes button look focused
      this.hasFocus ? 'focus' : ''];
    }
  },
  watch: {
    checked: function checked(newVal, oldVal) {
      this.computedLocalChecked = newVal;
    }
  },
  methods: {
    handleFocus: function handleFocus(evt) {
      // When in buttons mode, we need to add 'focus' class to label when input focused
      // As it is the hidden input which has actual focus
      if (evt.target) {
        if (evt.type === 'focus') {
          this.hasFocus = true;
        } else if (evt.type === 'blur') {
          this.hasFocus = false;
        }
      }
    },
    // Convenience methods for focusing the input
    focus: function focus() {
      if (!this.is_Disabled && this.$refs.input && this.$refs.input.focus) {
        this.$refs.input.focus();
      }
    },
    blur: function blur() {
      if (!this.is_Disabled && this.$refs.input && this.$refs.input.blur) {
        this.$refs.input.blur();
      }
    }
  },
  render: function render(h) {
    var defaultSlot = this.$slots.default; // Generate the input element

    var on = {
      change: this.handleChange
    };

    if (this.is_BtnMode) {
      // Handlers for focus styling when in button mode
      on.focus = on.blur = this.handleFocus;
    }

    var input = h('input', {
      ref: 'input',
      key: 'input',
      on: on,
      class: {
        'form-check-input': this.is_Plain,
        'custom-control-input': this.is_Custom,
        'is-valid': this.get_State === true && !this.is_BtnMode,
        'is-invalid': this.get_State === false && !this.is_BtnMode,
        // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911
        'position-static': this.is_Plain && !defaultSlot
      },
      directives: [{
        name: 'model',
        rawName: 'v-model',
        value: this.computedLocalChecked,
        expression: 'computedLocalChecked'
      }],
      attrs: {
        id: this.safeId(),
        type: this.is_Radio ? 'radio' : 'checkbox',
        name: this.get_Name,
        form: this.get_Form,
        disabled: this.is_Disabled,
        required: this.is_Required,
        autocomplete: 'off',
        'aria-required': this.is_Required || null,
        'aria-label': this.ariaLabel || null
      },
      domProps: {
        value: this.value,
        checked: this.is_Checked
      }
    });

    if (this.is_BtnMode) {
      // Button mode
      var button = h('label', {
        class: this.buttonClasses
      }, [input, defaultSlot]);

      if (!this.is_Group) {
        // Standalone button mode, so wrap in 'btn-group-toggle'
        // and flag it as inline-block to mimic regular buttons
        button = h('div', {
          class: ['btn-group-toggle', 'd-inline-block']
        }, [button]);
      }

      return button;
    } else {
      // Not button mode
      var label = h(false); // If no label content in plain mode we dont render the label
      // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911

      if (!(this.is_Plain && !defaultSlot)) {
        label = h('label', {
          class: {
            'form-check-label': this.is_Plain,
            'custom-control-label': this.is_Custom
          },
          attrs: {
            for: this.safeId()
          }
        }, defaultSlot);
      } // Wrap it in a div


      return h('div', {
        class: _defineProperty({
          'form-check': this.is_Plain,
          'form-check-inline': this.is_Plain && this.is_Inline,
          'custom-control': this.is_Custom,
          'custom-control-inline': this.is_Custom && this.is_Inline,
          'custom-checkbox': this.is_Custom && this.is_Check && !this.is_Switch,
          'custom-switch': this.is_Switch,
          'custom-radio': this.is_Custom && this.is_Radio
        }, "form-control-".concat(this.get_Size), Boolean(this.get_Size && !this.is_BtnMode))
      }, [input, label]);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-selection.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  computed: {
    selectionStart: {
      // Expose selectionStart for formatters, etc
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.selectionStart;
      },
      set: function set(val)
      /* istanbul ignore next */
      {
        this.$refs.input.selectionStart = val;
      }
    },
    selectionEnd: {
      // Expose selectionEnd for formatters, etc
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.selectionEnd;
      },
      set: function set(val)
      /* istanbul ignore next */
      {
        this.$refs.input.selectionEnd = val;
      }
    },
    selectionDirection: {
      // Expose selectionDirection for formatters, etc
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.selectionDirection;
      },
      set: function set(val)
      /* istanbul ignore next */
      {
        this.$refs.input.selectionDirection = val;
      }
    }
  },
  methods: {
    select: function select()
    /* istanbul ignore next */
    {
      var _this$$refs$input;

      // For external handler that may want a select() method
      (_this$$refs$input = this.$refs.input).select.apply(_this$$refs$input, arguments);
    },
    setSelectionRange: function setSelectionRange()
    /* istanbul ignore next */
    {
      var _this$$refs$input2;

      // For external handler that may want a setSelectionRange(a,b,c) method
      (_this$$refs$input2 = this.$refs.input).setSelectionRange.apply(_this$$refs$input2, arguments);
    },
    setRangeText: function setRangeText()
    /* istanbul ignore next */
    {
      var _this$$refs$input3;

      // For external handler that may want a setRangeText(a,b,c) method
      (_this$$refs$input3 = this.$refs.input).setRangeText.apply(_this$$refs$input3, arguments);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-size.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  props: {
    size: {
      type: String,
      default: null
    }
  },
  computed: {
    sizeFormClass: function sizeFormClass() {
      return [this.size ? "form-control-".concat(this.size) : null];
    },
    sizeBtnClass: function sizeBtnClass()
    /* istanbul ignore next: don't think this is used */
    {
      return [this.size ? "btn-".concat(this.size) : null];
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-state.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/* Form control contextual state class computation
 *
 * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop
 * state can be one of five values:
 *  - true or 'valid' for is-valid
 *  - false or 'invalid' for is-invalid
 *  - null (or empty string) for no contextual state
 */
// @vue/component
var _default = {
  props: {
    state: {
      // true/'valid', false/'invalid', '',null
      // The order must be String first, then Boolean!
      type: [String, Boolean],
      default: null
    }
  },
  computed: {
    computedState: function computedState() {
      var state = this.state;

      if (state === '') {
        return null;
      } else if (state === true || state === 'valid') {
        return true;
      } else if (state === false || state === 'invalid') {
        return false;
      }

      return null;
    },
    stateClass: function stateClass() {
      var state = this.computedState;

      if (state === true) {
        return 'is-valid';
      } else if (state === false) {
        return 'is-invalid';
      }

      return null;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-text.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  model: {
    prop: 'value',
    event: 'update'
  },
  props: {
    value: {
      type: [String, Number],
      default: ''
    },
    ariaInvalid: {
      type: [Boolean, String],
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    plaintext: {
      type: Boolean,
      default: false
    },
    autocomplete: {
      type: String,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    formatter: {
      type: Function,
      default: null
    },
    trim: {
      type: Boolean,
      default: false
    },
    number: {
      type: Boolean,
      default: false
    },
    lazyFormatter: {
      type: Boolean,
      value: false
    }
  },
  data: function data() {
    return {
      localValue: this.stringifyValue(this.value)
    };
  },
  computed: {
    computedClass: function computedClass() {
      return [{
        // Range input needs class custom-range
        'custom-range': this.type === 'range',
        // plaintext not supported by type=range or type=color
        'form-control-plaintext': this.plaintext && this.type !== 'range' && this.type !== 'color',
        // form-control not used by type=range or plaintext. Always used by type=color
        'form-control': !this.plaintext && this.type !== 'range' || this.type === 'color'
      }, this.sizeFormClass, this.stateClass];
    },
    computedAriaInvalid: function computedAriaInvalid() {
      if (!this.ariaInvalid || this.ariaInvalid === 'false') {
        // this.ariaInvalid is null or false or 'false'
        return this.computedState === false ? 'true' : null;
      }

      if (this.ariaInvalid === true) {
        // User wants explicit aria-invalid=true
        return 'true';
      } // Most likely a string value (which could be the string 'true')


      return this.ariaInvalid;
    }
  },
  watch: {
    value: function value(newVal, oldVal) {
      if (newVal !== oldVal && newVal !== this.localValue) {
        this.localValue = this.stringifyValue(newVal);
      }
    }
  },
  mounted: function mounted() {
    var value = this.stringifyValue(this.value);

    if (value !== this.localValue) {
      /* istanbul ignore next */
      this.localValue = value;
    }
  },
  methods: {
    stringifyValue: function stringifyValue(value) {
      return value === null || typeof value === 'undefined' ? '' : String(value);
    },
    getFormatted: function getFormatted(value, event) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      value = this.stringifyValue(value);

      if ((!this.lazyFormatter || force) && typeof this.formatter === 'function') {
        value = this.formatter(value, event);
      }

      return value;
    },
    updateValue: function updateValue(value) {
      value = this.stringifyValue(value);

      if (this.localValue !== value) {
        // keep the input set to the value before modifiers
        this.localValue = value;

        if (this.number) {
          // Emulate .number modifier behaviour
          var num = parseFloat(value);
          value = isNaN(num) ? value : num;
        } else if (this.trim) {
          // Emulate .trim modifier behaviour
          value = value.trim();
        } // Update the v-model


        this.$emit('update', value);
      }
    },
    onInput: function onInput(evt) {
      // evt.target.composing is set by Vue
      // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js

      /* istanbul ignore if: hard to test composition events */
      if (evt.target.composing) {
        return;
      }

      var formatted = this.getFormatted(evt.target.value, evt);

      if (formatted === false || evt.defaultPrevented) {
        evt.preventDefault();
        return;
      }

      this.updateValue(formatted);
      this.$emit('input', formatted);
    },
    onChange: function onChange(evt) {
      // evt.target.composing is set by Vue
      // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js

      /* istanbul ignore if: hard to test composition events */
      if (evt.target.composing) {
        return;
      }

      var formatted = this.getFormatted(evt.target.value, evt);

      if (formatted === false) {
        return;
      }

      this.updateValue(formatted);
      this.$emit('change', formatted);
    },
    onBlur: function onBlur(evt) {
      // lazy formatter
      if (this.lazyFormatter) {
        var formatted = this.getFormatted(evt.target.value, evt, true);

        if (formatted === false) {
          return;
        }

        this.updateValue(formatted);
      } // Emit native blur event


      this.$emit('blur', evt);
    },
    focus: function focus() {
      // For external handler that may want a focus method
      if (!this.disabled) {
        this.$el.focus();
      }
    },
    blur: function blur() {
      // For external handler that may want a blur method
      if (!this.disabled) {
        this.$el.blur();
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form-validity.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  computed: {
    validity: {
      // Expose validity property
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.validity;
      }
    },
    validationMessage: {
      // Expose validationMessage property
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.validationMessage;
      }
    },
    willValidate: {
      // Expose willValidate property
      cache: false,
      get: function get()
      /* istanbul ignore next */
      {
        return this.$refs.input.willValidate;
      }
    }
  },
  methods: {
    setCustomValidity: function setCustomValidity()
    /* istanbul ignore next */
    {
      var _this$$refs$input;

      // For external handler that may want a setCustomValidity(...) method
      return (_this$$refs$input = this.$refs.input).setCustomValidity.apply(_this$$refs$input, arguments);
    },
    checkValidity: function checkValidity()
    /* istanbul ignore next */
    {
      var _this$$refs$input2;

      // For external handler that may want a checkValidity(...) method
      return (_this$$refs$input2 = this.$refs.input).checkValidity.apply(_this$$refs$input2, arguments);
    },
    reportValidity: function reportValidity()
    /* istanbul ignore next */
    {
      var _this$$refs$input3;

      // For external handler that may want a reportValidity(...) method
      return (_this$$refs$input3 = this.$refs.input).reportValidity.apply(_this$$refs$input3, arguments);
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/form.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
// @vue/component
var _default = {
  props: {
    name: {
      type: String // default: undefined

    },
    id: {
      type: String // default: undefined

    },
    disabled: {
      type: Boolean
    },
    required: {
      type: Boolean,
      default: false
    },
    form: {
      type: String,
      default: null
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/id.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/*
 * SSR Safe Client Side ID attribute generation
 * id's can only be generated client side, after mount.
 * this._uid is not synched between server and client.
 */
// @vue/component
var _default = {
  props: {
    id: {
      type: String,
      default: null
    }
  },
  data: function data() {
    return {
      localId_: null
    };
  },
  computed: {
    safeId: function safeId() {
      // Computed property that returns a dynamic function for creating the ID.
      // Reacts to changes in both .id and .localId_ And regens a new function
      var id = this.id || this.localId_; // We return a function that accepts an optional suffix string
      // So this computed prop looks and works like a method!!!
      // But benefits from Vue's Computed prop caching

      var fn = function fn(suffix) {
        if (!id) {
          return null;
        }

        suffix = String(suffix || '').replace(/\s+/g, '_');
        return suffix ? id + '_' + suffix : id;
      };

      return fn;
    }
  },
  mounted: function mounted() {
    var _this = this;

    // mounted only occurs client side
    this.$nextTick(function () {
      // Update dom with auto ID after dom loaded to prevent
      // SSR hydration errors.
      _this.localId_ = "__BVID__".concat(_this._uid);
    });
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/listen-on-root.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Issue #569: collapse::toggle::state triggered too many times
 * @link https://github.com/bootstrap-vue/bootstrap-vue/issues/569
 */
// @vue/component
var _default = {
  methods: {
    /**
     * Safely register event listeners on the root Vue node.
     * While Vue automatically removes listeners for individual components,
     * when a component registers a listener on root and is destroyed,
     * this orphans a callback because the node is gone,
     * but the root does not clear the callback.
     *
     * When registering a $root listener, it also registers a listener on
     * the component's `beforeDestroy` hook to automatically remove the
     * event listener from the $root instance.
     *
     * @param {string} event
     * @param {function} callback
     * @chainable
     */
    listenOnRoot: function listenOnRoot(event, callback) {
      var _this = this;

      this.$root.$on(event, callback);
      this.$on('hook:beforeDestroy', function () {
        _this.$root.$off(event, callback);
      }); // Return this for easy chaining

      return this;
    },

    /**
     * Convenience method for calling vm.$emit on vm.$root.
     * @param {string} event
     * @param {*} args
     * @chainable
     */
    emitOnRoot: function emitOnRoot(event) {
      var _this$$root;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_this$$root = this.$root).$emit.apply(_this$$root, [event].concat(args)); // Return this for easy chaining


      return this;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/normalize-slot.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _normalizeSlot2 = __webpack_require__("./node_modules/bootstrap-vue/es/utils/normalize-slot.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _default = {
  methods: {
    hasNormalizedSlot: function hasNormalizedSlot(name) {
      // Returns true if the either a $scopedSlot or $slot exists with the specified name
      return Boolean(this.$scopedSlots[name] || this.$slots[name]);
    },
    normalizeSlot: function normalizeSlot(name) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Returns an array of rendered vNodes if slot found.
      // Returns undefined if not found.
      var vNodes = (0, _normalizeSlot2.default)(name, scope, this.$scopedSlots, this.$slots);
      return vNodes ? (0, _array.concat)(vNodes) : vNodes;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/pagination.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _range = __webpack_require__("./node_modules/bootstrap-vue/es/utils/range.js");

var _keyCodes = __webpack_require__("./node_modules/bootstrap-vue/es/utils/key-codes.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _toString = __webpack_require__("./node_modules/bootstrap-vue/es/utils/to-string.js");

var _normalizeSlot = __webpack_require__("./node_modules/bootstrap-vue/es/mixins/normalize-slot.js");

var _link = __webpack_require__("./node_modules/bootstrap-vue/es/components/link/link.js");

/*
 * Comon props, computed, data, render function, and methods for b-pagination and b-pagination-nav
 */
// Threshold of limit size when we start/stop showing ellipsis
var ELLIPSIS_THRESHOLD = 3; // Default # of buttons limit

var DEFAULT_LIMIT = 5; // Make an array of N to N+X

function makePageArray(startNum, numPages) {
  return (0, _range.default)(numPages).map(function (value, index) {
    return {
      number: index + startNum,
      classes: null
    };
  });
} // Sanitize the provided Limit value (converting to a number)


function sanitizeLimit(value) {
  var limit = parseInt(value, 10) || 1;
  return limit < 1 ? DEFAULT_LIMIT : limit;
} // Sanitize the provided current page number (converting to a number)


function sanitizeCurPage(value, numPages) {
  var page = parseInt(value, 10) || 1;
  return page > numPages ? numPages : page < 1 ? 1 : page;
} // Links don't normally respond to SPACE, so we add that functionality via this handler


function onSpaceKey(evt) {
  if (evt.keyCode === _keyCodes.default.SPACE) {
    evt.preventDefault(); // Stop page from scrolling

    evt.stopImmediatePropagation();
    evt.stopPropagation(); // Trigger the click event on the link

    evt.currentTarget.click();
    return false;
  }
} // Props object


var props = {
  disabled: {
    type: Boolean,
    default: false
  },
  value: {
    type: [Number, String],
    default: null,
    validator: function validator(value) {
      var num = parseInt(value, 10);
      /* istanbul ignore if */

      if (value !== null && (isNaN(num) || num < 1)) {
        (0, _warn.default)('pagination: v-model value must be a number greater than 0');
        return false;
      }

      return true;
    }
  },
  limit: {
    type: [Number, String],
    default: DEFAULT_LIMIT,
    validator: function validator(value) {
      var num = parseInt(value, 10);
      /* istanbul ignore if */

      if (isNaN(num) || num < 1) {
        (0, _warn.default)('pagination: prop "limit" must be a number greater than 0');
        return false;
      }

      return true;
    }
  },
  size: {
    type: String,
    default: 'md'
  },
  align: {
    type: String,
    default: 'left'
  },
  hideGotoEndButtons: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: 'Pagination'
  },
  labelFirstPage: {
    type: String,
    default: 'Go to first page'
  },
  firstText: {
    type: String,
    default: ''
  },
  labelPrevPage: {
    type: String,
    default: 'Go to previous page'
  },
  prevText: {
    type: String,
    default: ''
  },
  labelNextPage: {
    type: String,
    default: 'Go to next page'
  },
  nextText: {
    type: String,
    default: ''
  },
  labelLastPage: {
    type: String,
    default: 'Go to last page'
  },
  lastText: {
    type: String,
    default: ''
  },
  labelPage: {
    type: [String, Function],
    default: 'Go to page'
  },
  hideEllipsis: {
    type: Boolean,
    default: false
  },
  ellipsisText: {
    type: String,
    default: ''
  } // @vue/component

};
var _default = {
  components: {
    BLink: _link.default
  },
  mixins: [_normalizeSlot.default],
  model: {
    prop: 'value',
    event: 'input'
  },
  props: props,
  data: function data() {
    var curr = parseInt(this.value, 10);
    return {
      // -1 signifies no page initially selected
      currentPage: curr > 0 ? curr : -1,
      localNumPages: 1,
      localLimit: DEFAULT_LIMIT
    };
  },
  computed: {
    btnSize: function btnSize() {
      return this.size ? "pagination-".concat(this.size) : '';
    },
    alignment: function alignment() {
      var align = this.align;

      if (align === 'center') {
        return 'justify-content-center';
      } else if (align === 'end' || align === 'right') {
        return 'justify-content-end';
      } else if (align === 'fill') {
        // The page-items will also have 'flex-fill' added.
        // We ad text centering to make the button appearance better in fill mode.
        return 'text-center';
      }

      return '';
    },
    computedCurrentPage: function computedCurrentPage() {
      return sanitizeCurPage(this.currentPage, this.localNumPages);
    },
    paginationParams: function paginationParams() {
      // Determine if we should show the the ellipsis
      var limit = this.limit;
      var numPages = this.localNumPages;
      var curPage = this.computedCurrentPage;
      var hideEllipsis = this.hideEllipsis;
      var showFirstDots = false;
      var showLastDots = false;
      var numLinks = limit;
      var startNum = 1;

      if (numPages <= limit) {
        // Special Case: Less pages available than the limit of displayed pages
        numLinks = numPages;
      } else if (curPage < limit - 1 && limit > ELLIPSIS_THRESHOLD) {
        // We are near the beginning of the page list
        if (!hideEllipsis) {
          showLastDots = true;
          numLinks = limit - 1;
        }
      } else if (numPages - curPage + 2 < limit && limit > ELLIPSIS_THRESHOLD) {
        // We are near the end of the list
        if (!hideEllipsis) {
          numLinks = limit - 1;
          showFirstDots = true;
        }

        startNum = numPages - numLinks + 1;
      } else {
        // We are somewhere in the middle of the page list
        if (limit > ELLIPSIS_THRESHOLD && !hideEllipsis) {
          numLinks = limit - 2;
          showFirstDots = showLastDots = true;
        }

        startNum = curPage - Math.floor(numLinks / 2);
      } // Sanity checks


      if (startNum < 1) {
        /* istanbul ignore next */
        startNum = 1;
      } else if (startNum > numPages - numLinks) {
        startNum = numPages - numLinks + 1;
      }

      return {
        showFirstDots: showFirstDots,
        showLastDots: showLastDots,
        numLinks: numLinks,
        startNum: startNum
      };
    },
    pageList: function pageList() {
      // Generates the pageList array
      var _this$paginationParam = this.paginationParams,
          numLinks = _this$paginationParam.numLinks,
          startNum = _this$paginationParam.startNum;
      var currPage = this.computedCurrentPage; // Generate list of page numbers

      var pages = makePageArray(startNum, numLinks); // We limit to a total of 3 page buttons on XS screens
      // So add classes to page links to hide them for XS breakpoint
      // Note: Ellipsis will also be hidden on XS screens
      // TODO: Make this visual limit configurable based on breakpoint(s)

      if (pages.length > 3) {
        var idx = currPage - startNum; // THe following is a bootstrap-vue custom utility class

        var classes = 'bv-d-xs-down-none';

        if (idx === 0) {
          // Keep leftmost 3 buttons visible when current page is first page
          for (var i = 3; i < pages.length; i++) {
            pages[i].classes = classes;
          }
        } else if (idx === pages.length - 1) {
          // Keep rightmost 3 buttons visible when current page is last page
          for (var _i = 0; _i < pages.length - 3; _i++) {
            pages[_i].classes = classes;
          }
        } else {
          // Hide all except current page, current page - 1 and current page + 1
          for (var _i2 = 0; _i2 < idx - 1; _i2++) {
            // hide some left button(s)
            pages[_i2].classes = classes;
          }

          for (var _i3 = pages.length - 1; _i3 > idx + 1; _i3--) {
            // hide some right button(s)
            pages[_i3].classes = classes;
          }
        }
      }

      return pages;
    }
  },
  watch: {
    value: function value(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.currentPage = sanitizeCurPage(newValue, this.localNumPages);
      }
    },
    currentPage: function currentPage(newValue, oldValue) {
      if (newValue !== oldValue) {
        // Emit null if no page selected
        this.$emit('input', newValue > 0 ? newValue : null);
      }
    },
    limit: function limit(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.localLimit = sanitizeLimit(newValue);
      }
    }
  },
  created: function created() {
    var _this = this;

    // Set our default values in data
    this.localLimit = sanitizeLimit(this.limit);
    this.$nextTick(function () {
      // Sanity check
      _this.currentPage = _this.currentPage > _this.localNumPages ? _this.localNumPages : _this.currentPage;
    });
  },
  methods: {
    getButtons: function getButtons() {
      // Return only buttons that are visible
      return (0, _dom.selectAll)('a.page-link', this.$el).filter(function (btn) {
        return (0, _dom.isVisible)(btn);
      });
    },
    setBtnFocus: function setBtnFocus(btn) {
      btn.focus();
    },
    focusCurrent: function focusCurrent() {
      var _this2 = this;

      // We do this in next tick to ensure buttons have finished rendering
      this.$nextTick(function () {
        var btn = _this2.getButtons().find(function (el) {
          return parseInt((0, _dom.getAttr)(el, 'aria-posinset'), 10) === _this2.computedCurrentPage;
        });

        if (btn && btn.focus) {
          _this2.setBtnFocus(btn);
        } else {
          // Fallback if current page is not in button list
          _this2.focusFirst();
        }
      });
    },
    focusFirst: function focusFirst() {
      var _this3 = this;

      // We do this in next tick to ensure buttons have finished rendering
      this.$nextTick(function () {
        var btn = _this3.getButtons().find(function (el) {
          return !(0, _dom.isDisabled)(el);
        });

        if (btn && btn.focus && btn !== document.activeElement) {
          _this3.setBtnFocus(btn);
        }
      });
    },
    focusLast: function focusLast() {
      var _this4 = this;

      // We do this in next tick to ensure buttons have finished rendering
      this.$nextTick(function () {
        var btn = _this4.getButtons().reverse().find(function (el) {
          return !(0, _dom.isDisabled)(el);
        });

        if (btn && btn.focus && btn !== document.activeElement) {
          _this4.setBtnFocus(btn);
        }
      });
    },
    focusPrev: function focusPrev() {
      var _this5 = this;

      // We do this in next tick to ensure buttons have finished rendering
      this.$nextTick(function () {
        var buttons = _this5.getButtons();

        var idx = buttons.indexOf(document.activeElement);

        if (idx > 0 && !(0, _dom.isDisabled)(buttons[idx - 1]) && buttons[idx - 1].focus) {
          _this5.setBtnFocus(buttons[idx - 1]);
        }
      });
    },
    focusNext: function focusNext() {
      var _this6 = this;

      // We do this in next tick to ensure buttons have finished rendering
      this.$nextTick(function () {
        var buttons = _this6.getButtons();

        var idx = buttons.indexOf(document.activeElement);
        var cnt = buttons.length - 1;

        if (idx < cnt && !(0, _dom.isDisabled)(buttons[idx + 1]) && buttons[idx + 1].focus) {
          _this6.setBtnFocus(buttons[idx + 1]);
        }
      });
    }
  },
  render: function render(h) {
    var _this7 = this;

    var buttons = [];
    var numberOfPages = this.localNumPages;
    var disabled = this.disabled;
    var _this$paginationParam2 = this.paginationParams,
        showFirstDots = _this$paginationParam2.showFirstDots,
        showLastDots = _this$paginationParam2.showLastDots;
    var currPage = this.computedCurrentPage;
    var fill = this.align === 'fill'; // Helper function and flag

    var isActivePage = function isActivePage(pageNum) {
      return pageNum === currPage;
    };

    var noCurrPage = this.currentPage < 1; // Factory function for prev/next/first/last buttons

    var makeEndBtn = function makeEndBtn(linkTo, ariaLabel, btnSlot, btnText, pageTest, key) {
      var isDisabled = disabled || isActivePage(pageTest) || noCurrPage || linkTo < 1 || linkTo > numberOfPages;
      var pageNum = linkTo < 1 ? 1 : linkTo > numberOfPages ? numberOfPages : linkTo;
      var scope = {
        disabled: isDisabled,
        page: pageNum,
        index: pageNum - 1
      };
      var btnContent = _this7.normalizeSlot(btnSlot, scope) || (0, _toString.default)(btnText) || h(false);
      var inner = h(isDisabled ? 'span' : 'b-link', {
        staticClass: 'page-link',
        props: isDisabled ? {} : _this7.linkProps(linkTo),
        attrs: {
          role: 'menuitem',
          tabindex: isDisabled ? null : '-1',
          'aria-label': ariaLabel,
          'aria-controls': _this7.ariaControls || null,
          'aria-disabled': isDisabled ? 'true' : null
        },
        on: isDisabled ? {} : {
          click: function click(evt) {
            _this7.onClick(linkTo, evt);
          },
          keydown: onSpaceKey
        }
      }, [btnContent]);
      return h('li', {
        key: key,
        staticClass: 'page-item',
        class: {
          disabled: isDisabled,
          'flex-fill': fill
        },
        attrs: {
          role: 'none presentation',
          'aria-hidden': isDisabled ? 'true' : null
        }
      }, [inner]);
    }; // Ellipsis factory


    var makeEllipsis = function makeEllipsis(isLast) {
      return h('li', {
        key: "elipsis-".concat(isLast ? 'last' : 'first'),
        staticClass: 'page-item',
        class: ['disabled', 'bv-d-xs-down-none', fill ? 'flex-fill' : ''],
        attrs: {
          role: 'separator'
        }
      }, [h('span', {
        staticClass: 'page-link'
      }, [_this7.normalizeSlot('ellipsis-text', {}) || (0, _toString.default)(_this7.ellipsisText) || h(false)])]);
    }; // Goto First Page button bookend


    buttons.push(this.hideGotoEndButtons ? h(false) : makeEndBtn(1, this.labelFirstPage, 'first-text', this.firstText, 1, 'bookend-goto-first')); // Goto Previous page button bookend

    buttons.push(makeEndBtn(currPage - 1, this.labelPrevPage, 'prev-text', this.prevText, 1, 'bookend-goto-prev')); // First Ellipsis Bookend

    buttons.push(showFirstDots ? makeEllipsis(false) : h(false)); // Individual Page links

    this.pageList.forEach(function (page, idx) {
      var active = isActivePage(page.number) && !noCurrPage; // Active page will have tabindex of 0, or if no current page and first page button

      var tabIndex = disabled ? null : active || noCurrPage && idx === 0 ? '0' : '-1';
      var attrs = {
        role: 'menuitemradio',
        'aria-disabled': disabled ? 'true' : null,
        'aria-controls': _this7.ariaControls || null,
        'aria-label': typeof _this7.labelPage === 'function' ? _this7.labelPage(page.number) : "".concat(_this7.labelPage, " ").concat(page.number),
        'aria-checked': active ? 'true' : 'false',
        'aria-posinset': page.number,
        'aria-setsize': numberOfPages,
        // ARIA "roving tabindex" method
        tabindex: tabIndex
      };
      var btnContent = (0, _toString.default)(_this7.makePage(page.number));
      var scope = {
        page: page.number,
        index: page.number - 1,
        content: btnContent,
        active: active,
        disabled: disabled
      };
      var inner = h(disabled ? 'span' : 'b-link', {
        props: disabled ? {} : _this7.linkProps(page.number),
        staticClass: 'page-link',
        attrs: attrs,
        on: disabled ? {} : {
          click: function click(evt) {
            _this7.onClick(page.number, evt);
          },
          keydown: onSpaceKey
        }
      }, [_this7.normalizeSlot('page', scope) || btnContent]);
      buttons.push(h('li', {
        key: "page-".concat(page.number),
        staticClass: 'page-item',
        class: [{
          disabled: disabled,
          active: active,
          'flex-fill': fill
        }, page.classes],
        attrs: {
          role: 'none presentation'
        }
      }, [inner]));
    }); // Last Ellipsis Bookend

    buttons.push(showLastDots ? makeEllipsis(true) : h(false)); // Goto Next page button bookend

    buttons.push(makeEndBtn(currPage + 1, this.labelNextPage, 'next-text', this.nextText, numberOfPages, 'bookend-goto-next')); // Goto Last Page button bookend

    buttons.push(this.hideGotoEndButtons ? h(false) : makeEndBtn(numberOfPages, this.labelLastPage, 'last-text', this.lastText, numberOfPages, 'bookend-goto-last')); // Assemble the paginatiom buttons

    var pagination = h('ul', {
      ref: 'ul',
      staticClass: 'pagination',
      class: ['b-pagination', this.btnSize, this.alignment],
      attrs: {
        role: 'menubar',
        'aria-disabled': disabled ? 'true' : 'false',
        'aria-label': this.ariaLabel || null
      },
      on: {
        keydown: function keydown(evt) {
          var keyCode = evt.keyCode;
          var shift = evt.shiftKey;

          if (keyCode === _keyCodes.default.LEFT) {
            evt.preventDefault();
            shift ? _this7.focusFirst() : _this7.focusPrev();
          } else if (keyCode === _keyCodes.default.RIGHT) {
            evt.preventDefault();
            shift ? _this7.focusLast() : _this7.focusNext();
          }
        }
      }
    }, buttons); // if we are pagination-nav, wrap in '<nav>' wrapper

    if (this.isNav) {
      return h('nav', {
        attrs: {
          'aria-disabled': disabled ? 'true' : null,
          'aria-hidden': disabled ? 'true' : 'false'
        }
      }, [pagination]);
    } else {
      return pagination;
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/mixins/toolpop.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _ssr = __webpack_require__("./node_modules/bootstrap-vue/es/utils/ssr.js");

var _observeDom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/observe-dom.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var PLACEMENTS = {
  top: 'top',
  topleft: 'topleft',
  topright: 'topright',
  right: 'right',
  righttop: 'righttop',
  rightbottom: 'rightbottom',
  bottom: 'bottom',
  bottomleft: 'bottomleft',
  bottomright: 'bottomright',
  left: 'left',
  lefttop: 'lefttop',
  leftbottom: 'leftbottom',
  auto: 'auto'
};
var OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true,
  attributes: true,
  attributeFilter: ['class', 'style'] // @vue/component

};
var _default = {
  props: {
    target: {
      // String ID of element, or element/component reference
      type: [String, Object, _ssr.HTMLElement, Function] // default: undefined

    },
    delay: {
      type: [Number, Object, String],
      default: 0
    },
    offset: {
      type: [Number, String],
      default: 0
    },
    noFade: {
      type: Boolean,
      default: false
    },
    container: {
      // String ID of container, if null body is used (default)
      type: String,
      default: null
    },
    boundary: {
      // String: scrollParent, window, or viewport
      // Element: element reference
      type: [String, _ssr.HTMLElement],
      default: 'scrollParent'
    },
    boundaryPadding: {
      type: Number,
      default: 5
    },
    show: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    baseConfig: function baseConfig() {
      var cont = this.container;
      var delay = _typeof(this.delay) === 'object' ? this.delay : parseInt(this.delay, 10) || 0;
      return {
        // Title prop
        title: (this.title || '').trim() || '',
        // Contnt prop (if popover)
        content: (this.content || '').trim() || '',
        // Tooltip/Popover placement
        placement: PLACEMENTS[this.placement] || 'auto',
        // Container curently needs to be an ID with '#' prepended, if null then body is used
        container: cont ? /^#/.test(cont) ? cont : "#".concat(cont) : false,
        // boundariesElement passed to popper
        boundary: this.boundary,
        // boundariesElement padding passed to popper
        boundaryPadding: this.boundaryPadding,
        // Show/Hide delay
        delay: delay || 0,
        // Offset can be css distance. if no units, pixels are assumed
        offset: this.offset || 0,
        // Disable fade Animation?
        animation: !this.noFade,
        // Open/Close Trigger(s)
        trigger: (0, _array.isArray)(this.triggers) ? this.triggers.join(' ') : this.triggers,
        // Callbacks so we can trigger events on component
        callbacks: {
          show: this.onShow,
          shown: this.onShown,
          hide: this.onHide,
          hidden: this.onHidden,
          enabled: this.onEnabled,
          disabled: this.onDisabled
        }
      };
    }
  },
  watch: {
    show: function show(_show, old) {
      /* istanbul ignore if */
      if (_show === old) {
        /* istanbul ignore next */
        return;
      }

      _show ? this.onOpen() : this.onClose();
    },
    disabled: function disabled(_disabled, old) {
      /* istanbul ignore if */
      if (_disabled === old) {
        /* istanbul ignore next */
        return;
      }

      _disabled ? this.onDisable() : this.onEnable();
    }
  },
  created: function created() {
    // Create non-reactive property
    this._toolpop = null;
    this._obs_title = null;
    this._obs_content = null;
  },
  mounted: function mounted() {
    var _this = this;

    // We do this in a next tick to ensure DOM has rendered first
    this.$nextTick(function () {
      // Instantiate ToolTip/PopOver on target
      // The createToolpop method must exist in main component
      if (_this.createToolpop()) {
        if (_this.disabled) {
          // Initially disabled
          _this.onDisable();
        } // Listen to open signals from others


        _this.$on('open', _this.onOpen); // Listen to close signals from others


        _this.$on('close', _this.onClose); // Listen to disable signals from others


        _this.$on('disable', _this.onDisable); // Listen to disable signals from others


        _this.$on('enable', _this.onEnable); // Observe content Child changes so we can notify popper of possible size change


        _this.setObservers(true); // Set intially open state


        if (_this.show) {
          _this.onOpen();
        }
      }
    });
  },
  updated: function updated() {
    // If content/props changes, etc

    /* istanbul ignore next: can't test in JSDOM */
    if (this._toolpop) {
      this._toolpop.updateConfig(this.getConfig());
    }
  },
  activated: function activated() {
    // Called when component is inside a <keep-alive> and component brought offline

    /* istanbul ignore next: can't test in JSDOM */
    this.setObservers(true);
  },
  deactivated: function deactivated() {
    // Called when component is inside a <keep-alive> and component taken offline

    /* istanbul ignore next: can't test in JSDOM */
    if (this._toolpop) {
      this.setObservers(false);

      this._toolpop.hide();
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next: not easy to test */
  {
    // Shutdown our local event listeners
    this.$off('open', this.onOpen);
    this.$off('close', this.onClose);
    this.$off('disable', this.onDisable);
    this.$off('enable', this.onEnable);
    this.setObservers(false); // bring our content back if needed

    this.bringItBack();

    if (this._toolpop) {
      this._toolpop.destroy();

      this._toolpop = null;
    }
  },
  methods: {
    getConfig: function getConfig() {
      var cfg = _objectSpread({}, this.baseConfig);

      if (this.$refs.title && this.$refs.title.innerHTML.trim()) {
        // If slot has content, it overrides 'title' prop
        // We use the DOM node as content to allow components!
        cfg.title = this.$refs.title;
        cfg.html = true;
      }

      if (this.$refs.content && this.$refs.content.innerHTML.trim()) {
        // If slot has content, it overrides 'content' prop
        // We use the DOM node as content to allow components!
        cfg.content = this.$refs.content;
        cfg.html = true;
      }

      return cfg;
    },
    onOpen: function onOpen() {
      if (this._toolpop) {
        this._toolpop.show();
      }
    },
    onClose: function onClose(callback) {
      if (this._toolpop) {
        this._toolpop.hide(callback);
      } else if (typeof callback === 'function') {
        callback();
      }
    },
    onDisable: function onDisable() {
      /* istanbul ignore next: can't test in JSDOM */
      if (this._toolpop) {
        this._toolpop.disable();
      }
    },
    onEnable: function onEnable() {
      /* istanbul ignore next: can't test in JSDOM */
      if (this._toolpop) {
        this._toolpop.enable();
      }
    },
    updatePosition: function updatePosition() {
      /* istanbul ignore next: can't test in JSDOM */
      if (this._toolpop) {
        // Instruct popper to reposition popover if necessary
        this._toolpop.update();
      }
    },
    getTarget: function getTarget() {
      var target = this.target;

      if (typeof target === 'function') {
        target = target();
      }

      if (typeof target === 'string') {
        // Assume ID of element
        return (0, _dom.getById)(target);
      } else if (_typeof(target) === 'object' && (0, _dom.isElement)(target.$el)) {
        // Component reference
        return target.$el;
      } else if (_typeof(target) === 'object' && (0, _dom.isElement)(target)) {
        // Element reference
        return target;
      }

      return null;
    },
    onShow: function onShow(evt) {
      this.$emit('show', evt);
    },
    onShown: function onShown(evt) {
      this.setObservers(true);
      this.$emit('update:show', true);
      this.$emit('shown', evt);
    },
    onHide: function onHide(evt) {
      this.$emit('hide', evt);
    },
    onHidden: function onHidden(evt) {
      this.setObservers(false); // bring our content back if needed to keep Vue happy
      // Tooltip class will move it back to tip when shown again

      this.bringItBack();
      this.$emit('update:show', false);
      this.$emit('hidden', evt);
    },
    onEnabled: function onEnabled(evt) {
      if (!evt || evt.type !== 'enabled') {
        // Prevent possible endless loop if user mistakienly fires enabled instead of enable
        return;
      }

      this.$emit('update:disabled', false);
      this.$emit('disabled');
    },
    onDisabled: function onDisabled(evt) {
      if (!evt || evt.type !== 'disabled') {
        // Prevent possible endless loop if user mistakienly fires disabled instead of disable
        return;
      }

      this.$emit('update:disabled', true);
      this.$emit('enabled');
    },
    bringItBack: function bringItBack() {
      // bring our content back if needed to keep Vue happy
      if (this.$el && this.$refs.title) {
        this.$el.appendChild(this.$refs.title);
      }

      if (this.$el && this.$refs.content) {
        this.$el.appendChild(this.$refs.content);
      }
    },
    setObservers: function setObservers(on)
    /* istanbul ignore next: can't test in JSDOM */
    {
      if (on) {
        if (this.$refs.title) {
          this._obs_title = (0, _observeDom.default)(this.$refs.title, this.updatePosition.bind(this), OBSERVER_CONFIG);
        }

        if (this.$refs.content) {
          this._obs_content = (0, _observeDom.default)(this.$refs.content, this.updatePosition.bind(this), OBSERVER_CONFIG);
        }
      } else {
        if (this._obs_title) {
          this._obs_title.disconnect();

          this._obs_title = null;
        }

        if (this._obs_content) {
          this._obs_content.disconnect();

          this._obs_content = null;
        }
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/array.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.concat = exports.arrayIncludes = exports.isArray = exports.from = void 0;

// Production steps of ECMA-262, Edition 6, 22.1.2.1
// es6-ified by @alexsasharegan

/* istanbul ignore if */
if (!Array.from) {
  Array.from = function () {
    var toStr = Object.prototype.toString;

    var isCallable = function isCallable(fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };

    var toInteger = function toInteger(value) {
      var number = Number(value);

      if (isNaN(number)) {
        return 0;
      }

      if (number === 0 || !isFinite(number)) {
        return number;
      }

      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };

    var maxSafeInteger = Math.pow(2, 53) - 1;

    var toLength = function toLength(value) {
      return Math.min(Math.max(toInteger(value), 0), maxSafeInteger);
    }; // The length property of the from method is 1.


    return function from(arrayLike
    /*, mapFn, thisArg */
    ) {
      // 1. Let C be the this value.
      var C = this; // 2. Let items be ToObject(arrayLike).

      var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).

      if (arrayLike == null) {
        throw new TypeError('Array.from requires an array-like object - not null or undefined');
      } // 4. If mapfn is undefined, then let mapping be false.


      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;

      if (typeof mapFn !== 'undefined') {
        // 5. else
        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        } // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.


        if (arguments.length > 2) {
          T = arguments[2];
        }
      } // 10. Let lenValue be Get(items, "length").
      // 11. Let len be ToLength(lenValue).


      var len = toLength(items.length); // 13. If IsConstructor(C) is true, then
      // 13. a. Let A be the result of calling the [[Construct]] internal method
      // of C with an argument list containing the single item len.
      // 14. a. Else, Let A be ArrayCreate(len).

      var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Let k be 0.

      var k = 0; // 17. Repeat, while k < len (also steps a - h)

      var kValue;

      while (k < len) {
        kValue = items[k];

        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }

        k += 1;
      } // 18. Let putStatus be Put(A, "length", len, true).


      A.length = len; // 20. Return A.

      return A;
    };
  }();
} // https://tc39.github.io/ecma262/#sec-array.prototype.find
// Needed for IE support

/* istanbul ignore if */


if (!Array.prototype.find) {
  // eslint-disable-next-line no-extend-native
  Object.defineProperty(Array.prototype, 'find', {
    value: function value(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

      var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.

      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


      var thisArg = arguments[1]; // 5. Let k be 0.

      var k = 0; // 6. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return kValue.
        var kValue = o[k];

        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        } // e. Increase k by 1.


        k++;
      } // 7. Return undefined.


      return undefined;
    }
  });
}
/* istanbul ignore if */


if (!Array.isArray) {
  Array.isArray = function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
} // Static


var from = Array.from;
exports.from = from;
var isArray = Array.isArray; // Instance

exports.isArray = isArray;

var arrayIncludes = function arrayIncludes(array, value) {
  return array.indexOf(value) !== -1;
};

exports.arrayIncludes = arrayIncludes;

var concat = function concat() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return Array.prototype.concat.apply([], args);
};

exports.concat = concat;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/bv-event.class.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BvEvent =
/*#__PURE__*/
function () {
  function BvEvent(type) {
    var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, BvEvent);

    // Start by emulating native Event constructor.
    if (!type) {
      /* istanbul ignore next */
      throw new TypeError("Failed to construct '".concat(this.constructor.name, "'. 1 argument required, ").concat(arguments.length, " given."));
    } // Assign defaults first, the eventInit,
    // and the type last so it can't be overwritten.


    (0, _object.assign)(this, BvEvent.defaults(), eventInit, {
      type: type
    }); // Freeze some props as readonly, but leave them enumerable.

    (0, _object.defineProperties)(this, {
      type: (0, _object.readonlyDescriptor)(),
      cancelable: (0, _object.readonlyDescriptor)(),
      nativeEvent: (0, _object.readonlyDescriptor)(),
      target: (0, _object.readonlyDescriptor)(),
      relatedTarget: (0, _object.readonlyDescriptor)(),
      vueTarget: (0, _object.readonlyDescriptor)()
    }); // Create a private variable using closure scoping.

    var defaultPrevented = false; // Recreate preventDefault method. One way setter.

    this.preventDefault = function preventDefault() {
      if (this.cancelable) {
        defaultPrevented = true;
      }
    }; // Create 'defaultPrevented' publicly accessible prop
    // that can only be altered by the preventDefault method.


    (0, _object.defineProperty)(this, 'defaultPrevented', {
      enumerable: true,
      get: function get() {
        return defaultPrevented;
      }
    });
  }

  _createClass(BvEvent, null, [{
    key: "defaults",
    value: function defaults() {
      return {
        type: '',
        cancelable: true,
        nativeEvent: null,
        target: null,
        relatedTarget: null,
        vueTarget: null
      };
    }
  }]);

  return BvEvent;
}();

var _default = BvEvent;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/clone-deep.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.cloneDeep = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var cloneDeep = function cloneDeep(obj) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;

  if ((0, _array.isArray)(obj)) {
    return obj.reduce(function (result, val) {
      return [].concat(_toConsumableArray(result), [cloneDeep(val, val)]);
    }, []);
  }

  if ((0, _object.isPlainObject)(obj)) {
    return (0, _object.keys)(obj).reduce(function (result, key) {
      return _objectSpread({}, result, _defineProperty({}, key, cloneDeep(obj[key], obj[key])));
    }, {});
  }

  return defaultValue;
};

exports.cloneDeep = cloneDeep;
var _default = cloneDeep;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/config.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getBreakpointsDown = exports.getBreakpointsUp = exports.getBreakpoints = exports.getComponentConfig = exports.getConfigValue = exports.getDefaults = exports.getConfig = exports.resetConfig = exports.setConfig = void 0;

var _cloneDeep = __webpack_require__("./node_modules/bootstrap-vue/es/utils/clone-deep.js");

var _get = __webpack_require__("./node_modules/bootstrap-vue/es/utils/get.js");

var _warn = __webpack_require__("./node_modules/bootstrap-vue/es/utils/warn.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

// General Bootstrap Vue configuration
//
// BREAKPOINT DEFINITIONS
//
// Some components (BCol and BFormGroup) generate props based on breakpoints, and this
// occurs when the component is first loaded (evaluated), which may happen before the
// config is created/modified
//
// To get around this we make these components async (lazy evaluation)
// The component definition is only called/executed when the first access to the
// component is used (and cached on subsequent uses)
//
// See: https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components
//
// PROP DEFAULTS
//
// For default values on props, we use the default value factory function approach so
// so that the default values are pulled in at each component instantiation
//
//  props: {
//    variant: {
//      type: String,
//      default: () => getConfigComponent('BAlert', 'variant')
//    }
//  }
// prettier-ignore
var DEFAULTS = {
  // Breakpoints
  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],
  // Component Specific defaults are keyed by the component
  // name (PascalCase) and prop name (camelCase)
  BAlert: {
    dismissLabel: 'Close',
    variant: 'info'
  },
  BBadge: {
    variant: 'secondary'
  },
  BButton: {
    variant: 'secondary'
  },
  BButtonClose: {
    // `textVariant` is `null` to inherit the current text color
    textVariant: null,
    ariaLabel: 'Close'
  },
  BCardSubTitle: {
    // BCard and BCardBody also inherit this prop
    subTitleTextVariant: 'muted'
  },
  BDropdown: {
    toggleText: 'Toggle Dropdown',
    variant: 'secondary'
  },
  BFormFile: {
    browseText: 'Browse',
    // Chrome default file prompt
    placeholder: 'No file chosen',
    dropPlaceholder: 'Drop files here'
  },
  BFormText: {
    textVariant: 'muted'
  },
  BImg: {
    blankColor: 'transparent'
  },
  BImgLazy: {
    blankColor: 'transparent'
  },
  BModal: {
    cancelTitle: 'Cancel',
    cancelVariant: 'secondary',
    okTitle: 'OK',
    okVariant: 'primary',
    headerCloseLabel: 'Close'
  } // This contains user defined configuration

};
var CONFIG = {}; // Method to get a deep clone (immutable) copy of the defaults

var getDefaults = function getDefaults() {
  return (0, _cloneDeep.default)(DEFAULTS);
}; // Method to set the config
// Merges in only known top-level and sub-level keys
//   Vue.use(BootstrapVue, config)
// or
//   BootstrapVue.setConfig(config)
//   Vue.use(BootstrapVue)


exports.getDefaults = getDefaults;

var setConfig = function setConfig() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!(0, _object.isObject)(config)) {
    /* istanbul ignore next */
    return;
  }

  (0, _object.keys)(config).filter(function (cmpName) {
    return config.hasOwnProperty(cmpName);
  }).forEach(function (cmpName) {
    if (!DEFAULTS.hasOwnProperty(cmpName)) {
      /* istanbul ignore next */
      (0, _warn.default)("config: unknown config property \"".concat(cmpName, "\""));
      /* istanbul ignore next */

      return;
    }

    var cmpConfig = config[cmpName];

    if (cmpName === 'breakpoints') {
      // Special case for breakpoints
      var breakpoints = config.breakpoints;

      if (!(0, _array.isArray)(breakpoints) || breakpoints.length < 2 || breakpoints.some(function (b) {
        return typeof b !== 'string' || b.length === 0;
      })) {
        /* istanbul ignore next */
        (0, _warn.default)('config: "breakpoints" must be an array of at least 2 breakpoint names');
      } else {
        CONFIG.breakpoints = (0, _cloneDeep.default)(breakpoints);
      }
    } else if ((0, _object.isObject)(cmpConfig)) {
      (0, _object.keys)(cmpConfig).filter(function (key) {
        return cmpConfig.hasOwnProperty(key);
      }).forEach(function (key) {
        if (!DEFAULTS[cmpName].hasOwnProperty(key)) {
          /* istanbul ignore next */
          (0, _warn.default)("config: unknown config property \"".concat(cmpName, ".{$key}\""));
        } else {
          // If we pre-populate the config with defaults, we can skip this line
          CONFIG[cmpName] = CONFIG[cmpName] || {};

          if (cmpConfig[key] !== undefined) {
            CONFIG[cmpName][key] = (0, _cloneDeep.default)(cmpConfig[key]);
          }
        }
      });
    }
  });
}; // Reset the user config to default
// For testing purposes only


exports.setConfig = setConfig;

var resetConfig = function resetConfig() {
  CONFIG = {};
}; // Get the current user config
// For testing purposes only


exports.resetConfig = resetConfig;

var getConfig = function getConfig() {
  return (0, _cloneDeep.default)(CONFIG);
}; // Method to grab a config value based on a dotted/array notation key
// Returns a deep clone (immutable) copy


exports.getConfig = getConfig;

var getConfigValue = function getConfigValue(key) {
  // First we try the user config, and if key not found we fall back to default value
  // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get
  return (0, _cloneDeep.default)((0, _get.default)(CONFIG, key, (0, _get.default)(getDefaults(), key)));
}; // Method to grab a config value for a particular component.
// Returns a deep clone (immutable) copy


exports.getConfigValue = getConfigValue;

var getComponentConfig = function getComponentConfig(cmpName) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  // Return the particular config value for key for if specified,
  // otherwise we return the full config
  return key ? getConfigValue("".concat(cmpName, ".").concat(key)) : getConfigValue(cmpName) || {};
}; // Convenience method for getting all breakpoint names


exports.getComponentConfig = getComponentConfig;

var getBreakpoints = function getBreakpoints() {
  return getConfigValue('breakpoints');
}; // Convenience method for getting breakpoints with
// the smallest breakpoint set as ''
// Useful for components that create breakpoint specific props


exports.getBreakpoints = getBreakpoints;

var getBreakpointsUp = function getBreakpointsUp() {
  var breakpoints = getBreakpoints();
  breakpoints[0] = '';
  return breakpoints;
}; // Convenience method for getting breakpoints with
// the largest breakpoint set as ''
// Useful for components that create breakpoint specific props


exports.getBreakpointsUp = getBreakpointsUp;

var getBreakpointsDown = function getBreakpointsDown() {
  var breakpoints = getBreakpoints();
  breakpoints[breakpoints.length - 1] = '';
  return breakpoints;
}; // Named Exports


exports.getBreakpointsDown = getBreakpointsDown;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/copy-props.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _identity = __webpack_require__("./node_modules/bootstrap-vue/es/utils/identity.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copies props from one array/object to a new array/object. Prop values
 * are also cloned as new references to prevent possible mutation of original
 * prop object values. Optionally accepts a function to transform the prop name.
 *
 * @param {[]|{}} props
 * @param {Function} transformFn
 */
var copyProps = function copyProps(props) {
  var transformFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _identity.default;

  if ((0, _array.isArray)(props)) {
    return props.map(transformFn);
  } // Props as an object.


  var copied = {};

  for (var prop in props) {
    /* istanbul ignore else */
    if (props.hasOwnProperty(prop)) {
      // If the prop value is an object, do a shallow clone to prevent
      // potential mutations to the original object.
      copied[transformFn(prop)] = (0, _object.isObject)(props[prop]) ? _objectSpread({}, props[prop]) : props[prop];
    }
  }

  return copied;
};

var _default = copyProps;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/dom.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.requestAF = exports.position = exports.offset = exports.getCS = exports.getBCR = exports.hasAttr = exports.getAttr = exports.removeAttr = exports.setAttr = exports.hasClass = exports.removeClass = exports.addClass = exports.getById = exports.contains = exports.closest = exports.matches = exports.select = exports.selectAll = exports.reflow = exports.isDisabled = exports.isVisible = exports.isElement = exports.eventOff = exports.eventOn = exports.parseEventOptions = exports.isPassiveSupported = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

// Determine if the browser supports the option passive for events
var passiveEventSupported = false;
/* istanbul ignore if */

if (_env.inBrowser) {
  try {
    var options = {
      get passive() {
        // This function will be called when the browser
        // attempts to access the passive property.
        passiveEventSupported = true;
      }

    };
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (err) {
    passiveEventSupported = false;
  }
} // Exported only for testing purposes


var isPassiveSupported = function isPassiveSupported() {
  return passiveEventSupported;
}; // Normalize event options based on support of passive option
// Exported only for testing purposes


exports.isPassiveSupported = isPassiveSupported;

var parseEventOptions = function parseEventOptions(options) {
  if (!passiveEventSupported) {
    // Need to translate to actual Boolean value
    return Boolean((0, _object.isObject)(options) ? options.useCapture : options);
  }
  /* istanbul ignore next: JSDOM doesn't support above detection of passive */


  return options || {
    useCapture: false // So we can't reach this anymore for unit testing due to the above if statement

  };
}; // Attach an event listener to an element


exports.parseEventOptions = parseEventOptions;

var eventOn = function eventOn(el, evtName, handler, options) {
  if (el && el.addEventListener) {
    el.addEventListener(evtName, handler, parseEventOptions(options));
  }
}; // Remove an event listener from an element


exports.eventOn = eventOn;

var eventOff = function eventOff(el, evtName, handler, options) {
  if (el && el.removeEventListener) {
    el.removeEventListener(evtName, handler, parseEventOptions(options));
  }
}; // Determine if an element is an HTML Element


exports.eventOff = eventOff;

var isElement = function isElement(el) {
  return Boolean(el && el.nodeType === Node.ELEMENT_NODE);
}; // Determine if an HTML element is visible - Faster than CSS check


exports.isElement = isElement;

var isVisible = function isVisible(el)
/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */
{
  if (!isElement(el) || !contains(document.body, el)) {
    return false;
  } // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(
  // So any tests that need isVisible will fail in JSDOM


  var bcr = getBCR(el);
  return Boolean(bcr && bcr.height > 0 && bcr.width > 0);
}; // Determine if an element is disabled


exports.isVisible = isVisible;

var isDisabled = function isDisabled(el) {
  return !isElement(el) || el.disabled || hasClass(el, 'disabled') || Boolean(getAttr(el, 'disabled'));
}; // Cause/wait-for an element to reflow it's content (adjusting it's height/width)


exports.isDisabled = isDisabled;

var reflow = function reflow(el) {
  // Requesting an elements offsetHight will trigger a reflow of the element content

  /* istanbul ignore next: reflow doesn't happen in JSDOM */
  return isElement(el) && el.offsetHeight;
}; // Select all elements matching selector. Returns `[]` if none found


exports.reflow = reflow;

var selectAll = function selectAll(selector, root) {
  if (!isElement(root)) {
    root = document;
  }

  return (0, _array.from)(root.querySelectorAll(selector));
}; // Select a single element, returns `null` if not found


exports.selectAll = selectAll;

var select = function select(selector, root) {
  if (!isElement(root)) {
    root = document;
  }

  return root.querySelector(selector) || null;
}; // Determine if an element matches a selector


exports.select = select;

var matches = function matches(el, selector) {
  if (!isElement(el)) {
    return false;
  } // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
  // Prefer native implementations over polyfill function


  var proto = Element.prototype;
  /* istanbul ignore next */

  var Matches = proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function (sel)
  /* istanbul ignore next */
  {
    var element = this;
    var m = selectAll(sel, element.document || element.ownerDocument);
    var i = m.length; // eslint-disable-next-line no-empty

    while (--i >= 0 && m.item(i) !== element) {}

    return i > -1;
  };

  return Matches.call(el, selector);
}; // Finds closest element matching selector. Returns `null` if not found


exports.matches = matches;

var closest = function closest(selector, root) {
  if (!isElement(root)) {
    return null;
  } // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
  // Since we dont support IE < 10, we can use the "Matches" version of the polyfill for speed
  // Prefer native implementation over polyfill function


  var Closest = Element.prototype.closest || function (sel)
  /* istanbul ignore next */
  {
    var element = this;

    if (!contains(document.documentElement, element)) {
      return null;
    }

    do {
      // Use our "patched" matches function
      if (matches(element, sel)) {
        return element;
      }

      element = element.parentElement || element.parentNode;
    } while (element !== null && element.nodeType === Node.ELEMENT_NODE);

    return null;
  };

  var el = Closest.call(root, selector); // Emulate jQuery closest and return `null` if match is the passed in element (root)

  return el === root ? null : el;
}; // Returns true if the parent element contains the child element


exports.closest = closest;

var contains = function contains(parent, child) {
  if (!parent || typeof parent.contains !== 'function') {
    return false;
  }

  return parent.contains(child);
}; // Get an element given an ID


exports.contains = contains;

var getById = function getById(id) {
  return document.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;
}; // Add a class to an element


exports.getById = getById;

var addClass = function addClass(el, className) {
  // We are checking for `el.classList` existence here since IE 11
  // returns `undefined` for some elements (e.g. SVG elements)
  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
  if (className && isElement(el) && el.classList) {
    el.classList.add(className);
  }
}; // Remove a class from an element


exports.addClass = addClass;

var removeClass = function removeClass(el, className) {
  // We are checking for `el.classList` existence here since IE 11
  // returns `undefined` for some elements (e.g. SVG elements)
  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
  if (className && isElement(el) && el.classList) {
    el.classList.remove(className);
  }
}; // Test if an element has a class


exports.removeClass = removeClass;

var hasClass = function hasClass(el, className) {
  // We are checking for `el.classList` existence here since IE 11
  // returns `undefined` for some elements (e.g. SVG elements)
  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
  if (className && isElement(el) && el.classList) {
    return el.classList.contains(className);
  }

  return false;
}; // Set an attribute on an element


exports.hasClass = hasClass;

var setAttr = function setAttr(el, attr, value) {
  if (attr && isElement(el)) {
    el.setAttribute(attr, value);
  }
}; // Remove an attribute from an element


exports.setAttr = setAttr;

var removeAttr = function removeAttr(el, attr) {
  if (attr && isElement(el)) {
    el.removeAttribute(attr);
  }
}; // Get an attribute value from an element (returns `null` if not found)


exports.removeAttr = removeAttr;

var getAttr = function getAttr(el, attr) {
  if (attr && isElement(el)) {
    return el.getAttribute(attr);
  }

  return null;
}; // Determine if an attribute exists on an element (returns `true`
// or `false`, or `null` if element not found)


exports.getAttr = getAttr;

var hasAttr = function hasAttr(el, attr) {
  if (attr && isElement(el)) {
    return el.hasAttribute(attr);
  }

  return null;
}; // Return the Bounding Client Rect of an element. Returns `null` if not an element


exports.hasAttr = hasAttr;

var getBCR = function getBCR(el) {
  /* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */
  return isElement(el) ? el.getBoundingClientRect() : null;
}; // Get computed style object for an element


exports.getBCR = getBCR;

var getCS = function getCS(el) {
  /* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */
  return isElement(el) ? window.getComputedStyle(el) : {};
}; // Return an element's offset with respect to document element
// https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset


exports.getCS = getCS;

var offset = function offset(el)
/* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */
{
  var _offset = {
    top: 0,
    left: 0
  };

  if (!isElement(el) || el.getClientRects().length === 0) {
    return _offset;
  }

  var bcr = getBCR(el);

  if (bcr) {
    var win = el.ownerDocument.defaultView;
    _offset.top = bcr.top + win.pageYOffset;
    _offset.left = bcr.left + win.pageXOffset;
  }

  return _offset;
}; // Return an element's offset with respect to to it's offsetParent
// https://j11y.io/jquery/#v=git&fn=jQuery.fn.position


exports.offset = offset;

var position = function position(el)
/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */
{
  var _offset = {
    top: 0,
    left: 0
  };

  if (!isElement(el)) {
    return _offset;
  }

  var parentOffset = {
    top: 0,
    left: 0
  };
  var elStyles = getCS(el);

  if (elStyles.position === 'fixed') {
    _offset = getBCR(el) || _offset;
  } else {
    _offset = offset(el);
    var doc = el.ownerDocument;
    var offsetParent = el.offsetParent || doc.documentElement;

    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && getCS(offsetParent).position === 'static') {
      offsetParent = offsetParent.parentNode;
    }

    if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {
      parentOffset = offset(offsetParent);
      var offsetParentStyles = getCS(offsetParent);
      parentOffset.top += parseFloat(offsetParentStyles.borderTopWidth);
      parentOffset.left += parseFloat(offsetParentStyles.borderLeftWidth);
    }
  }

  return {
    top: _offset.top - parentOffset.top - parseFloat(elStyles.marginTop),
    left: _offset.left - parentOffset.left - parseFloat(elStyles.marginLeft)
  };
}; // requestAnimationFrame convenience method
// We don't have a version for cancelAnimationFrame, but we don't call it anywhere


exports.position = position;

var requestAF = function requestAF(cb) {
  var w = _env.inBrowser ? window : {};

  var rAF = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.mozRequestAnimationFrame || w.msRequestAnimationFrame || w.oRequestAnimationFrame || function (cb) {
    // Fallback, but not a true polyfill.
    // But all browsers we support (other than Opera Mini) support rAF
    // without a polyfill.

    /* istanbul ignore next */
    return setTimeout(cb, 16);
  };

  return rAF(cb);
};

exports.requestAF = requestAF;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/env.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
exports.getNoWarn = exports.hasPointerEvent = exports.hasTouchSupport = exports.isServer = exports.inBrowser = void 0;
// Info about the current environment
// Constants
var inBrowser = typeof document !== 'undefined' && typeof window !== 'undefined';
exports.inBrowser = inBrowser;
var isServer = !inBrowser;
exports.isServer = isServer;
var hasTouchSupport = inBrowser && ('ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0);
exports.hasTouchSupport = hasTouchSupport;
var hasPointerEvent = inBrowser && Boolean(window.PointerEvent || window.MSPointerEvent); // Getters

exports.hasPointerEvent = hasPointerEvent;

var getNoWarn = function getNoWarn() {
  return process && Object({"MIX_PUSHER_APP_KEY":"0a1c3553c294c60fc728","MIX_PUSHER_APP_CLUSTER":"mt1","NODE_ENV":"development"}) && Object({"MIX_PUSHER_APP_KEY":"0a1c3553c294c60fc728","MIX_PUSHER_APP_CLUSTER":"mt1","NODE_ENV":"development"}).BOOTSTRAP_VUE_NO_WARN;
};

exports.getNoWarn = getNoWarn;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/get.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

/**
 * Get property defined by dot/array notation in string.
 *
 * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901
 *
 * @param {Object} obj
 * @param {string|Array} path
 * @param {*} defaultValue (optional)
 * @return {*}
 */
var get = function get(obj, path) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  // Handle array of path values
  path = (0, _array.isArray)(path) ? path.join('.') : path; // If no path or no object passed

  if (!path || !(0, _object.isObject)(obj)) {
    return defaultValue;
  } // Handle edge case where user has dot(s) in top-level item field key
  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762


  if (obj.hasOwnProperty(path)) {
    return obj[path];
  } // Handle string array notation (numeric indices only)


  path = String(path).replace(/\[(\d+)]/g, '.$1');
  var steps = path.split('.').filter(Boolean); // Handle case where someone passes a string of only dots

  if (steps.length === 0) {
    return defaultValue;
  } // Traverse path in object to find result


  return steps.every(function (step) {
    return (0, _object.isObject)(obj) && obj.hasOwnProperty(step) && (obj = obj[step]);
  }) ? obj : defaultValue;
};

var _default = get;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/html.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.htmlOrText = exports.stripTags = void 0;
var stripTagsRegex = /(<([^>]+)>)/gi; // Removes any thing that looks like an HTML tag from the supplied string

var stripTags = function stripTags() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return String(text).replace(stripTagsRegex, '');
}; // Generate a domProps object for either innerHTML, textContent or nothing


exports.stripTags = stripTags;

var htmlOrText = function htmlOrText(innerHTML, textContent) {
  return innerHTML ? {
    innerHTML: innerHTML
  } : textContent ? {
    textContent: textContent
  } : {};
};

exports.htmlOrText = htmlOrText;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/identity.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var identity = function identity(x) {
  return x;
};

var _default = identity;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/key-codes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/*
 * Key Codes (events)
 */
var KEY_CODES = {
  SPACE: 32,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PAGEUP: 33,
  PAGEDOWN: 34,
  HOME: 36,
  END: 35,
  TAB: 9,
  SHIFT: 16,
  CTRL: 17,
  BACKSPACE: 8,
  ALT: 18,
  PAUSE: 19,
  BREAK: 19,
  INSERT: 45,
  INS: 45,
  DELETE: 46
};
var _default = KEY_CODES;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/loose-equal.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var isDate = function isDate(obj) {
  return obj instanceof Date;
}; // Assumes both a and b are arrays!
// Handles when arrays are "sparse" (array.every(...) doesn't handle sparse)


var compareArrays = function compareArrays(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  var equal = true;

  for (var i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 * Returns boolean true or false
 */


var looseEqual = function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var aValidType = isDate(a);
  var bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = (0, _array.isArray)(a);
  bValidType = (0, _array.isArray)(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? compareArrays(a, b) : false;
  }

  aValidType = (0, _object.isObject)(a);
  bValidType = (0, _object.isObject)(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    var aKeysCount = (0, _object.keys)(a).length;
    var bKeysCount = (0, _object.keys)(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (var key in a) {
      var aHasKey = a.hasOwnProperty(key);
      var bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
};

var _default = looseEqual;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/loose-index-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _looseEqual = __webpack_require__("./node_modules/bootstrap-vue/es/utils/loose-equal.js");

var looseIndexOf = function looseIndexOf(arr, val) {
  // Assumes that the first argument is an array
  for (var i = 0; i < arr.length; i++) {
    if ((0, _looseEqual.default)(arr[i], val)) {
      return i;
    }
  }

  return -1;
};

var _default = looseIndexOf;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/lower-first.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * @param {string} str
 */
var lowerFirst = function lowerFirst(str) {
  str = String(str);
  return str.charAt(0).toLowerCase() + str.slice(1);
};

var _default = lowerFirst;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/memoize.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var memoize = function memoize(fn) {
  var cache = (0, _object.create)(null);
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var argsKey = JSON.stringify(args);
    return cache[argsKey] = cache[argsKey] || fn.apply(null, args);
  };
};

var _default = memoize;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/noop.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var noop = function noop() {};

var _default = noop;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/normalize-slot.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Returns vNodes for named slot either scoped or unscoped
 *
 * @param {String} name
 * @param {String} scope
 * @param {Object} scopedSlots
 * @param {Object} slots
 * @returns {Array|undefined} vNodes
 */
var normalizeSlot = function normalizeSlot(name) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var $scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var $slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Note: in Vue 2.6.x, all names slots are also scoped slots
  var slot = $scopedSlots[name] || $slots[name];
  return typeof slot === 'function' ? slot(scope) : slot;
};

var _default = normalizeSlot;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/object.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.readonlyDescriptor = exports.omit = exports.isPlainObject = exports.isObject = exports.is = exports.isFrozen = exports.create = exports.getPrototypeOf = exports.getOwnPropertySymbols = exports.getOwnPropertyDescriptor = exports.freeze = exports.defineProperty = exports.defineProperties = exports.keys = exports.getOwnPropertyNames = exports.assign = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Aliasing Object[method] allows the minifier to shorten methods to a single character variable,
 * as well as giving BV a chance to inject polyfills.
 * As long as we avoid
 * - import * as Object from "utils/object"
 * all unused exports should be removed by tree-shaking.
 */
// @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

/* istanbul ignore if */
if (typeof Object.assign !== 'function') {
  Object.assign = function (target, varArgs) {
    // .length of function is 2
    if (target == null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];

      if (nextSource != null) {
        // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
} // @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Polyfill

/* istanbul ignore if */


if (!Object.is) {
  Object.is = function (x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      // eslint-disable-next-line no-self-compare
      return x !== x && y !== y;
    }
  };
}

var assign = Object.assign;
exports.assign = assign;
var getOwnPropertyNames = Object.getOwnPropertyNames;
exports.getOwnPropertyNames = getOwnPropertyNames;
var keys = Object.keys;
exports.keys = keys;
var defineProperties = Object.defineProperties;
exports.defineProperties = defineProperties;
var defineProperty = Object.defineProperty;
exports.defineProperty = defineProperty;
var freeze = Object.freeze;
exports.freeze = freeze;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
exports.getOwnPropertyDescriptor = getOwnPropertyDescriptor;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
exports.getOwnPropertySymbols = getOwnPropertySymbols;
var getPrototypeOf = Object.getPrototypeOf;
exports.getPrototypeOf = getPrototypeOf;
var create = Object.create;
exports.create = create;
var isFrozen = Object.isFrozen;
exports.isFrozen = isFrozen;
var is = Object.is;
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 * Note object could be a complex type like array, date, etc.
 */

exports.is = is;

var isObject = function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
};
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


exports.isObject = isObject;

var isPlainObject = function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}; // @link https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc


exports.isPlainObject = isPlainObject;

var omit = function omit(obj, props) {
  return Object.keys(obj).filter(function (key) {
    return props.indexOf(key) === -1;
  }).reduce(function (result, key) {
    return _objectSpread({}, result, _defineProperty({}, key, obj[key]));
  }, {});
};

exports.omit = omit;

var readonlyDescriptor = function readonlyDescriptor() {
  return {
    enumerable: true,
    configurable: false,
    writable: false
  };
};

exports.readonlyDescriptor = readonlyDescriptor;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/observe-dom.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var eventListenerSupported = _env.inBrowser && window.addEventListener;
var MutationObserver = _env.inBrowser && (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver); // Fallback observation for legacy browsers
// Emulate observer disconnect() method so that we can detach the events later

var fakeObserverFactory = function fakeObserverFactory(el, callback)
/* istanbul ignore next: hard to test in JSDOM */
{
  (0, _dom.eventOn)(el, 'DOMNodeInserted', callback, false);
  (0, _dom.eventOn)(el, 'DOMNodeRemoved', callback, false);
  return {
    disconnect: function disconnect() {
      (0, _dom.eventOff)(el, 'DOMNodeInserted', callback, false);
      (0, _dom.eventOff)(el, 'DOMNodeRemoved', callback, false);
    }
  };
};
/**
 * Observe a DOM element changes, falls back to eventListener mode
 * @param {Element} el The DOM element to observe
 * @param {Function} callback callback to be called on change
 * @param {object} [opts={childList: true, subtree: true}] observe options
 * @see http://stackoverflow.com/questions/3219758
 */


var observeDom = function observeDom(el, callback, opts)
/* istanbul ignore next: difficult to test in JSDOM */
{
  // Handle case where we might be passed a vue instance
  el = el ? el.$el || el : null;
  /* istanbul ignore next: difficult to test in JSDOM */

  if (!(0, _dom.isElement)(el)) {
    // We can't observe something that isn't an element
    return null;
  }

  var obs = null;

  if (MutationObserver) {
    // Define a new observer
    obs = new MutationObserver(function (mutations) {
      var changed = false; // A Mutation can contain several change records, so we loop through them to see what has changed.
      // We break out of the loop early if any "significant" change has been detected

      for (var i = 0; i < mutations.length && !changed; i++) {
        // The mutation record
        var mutation = mutations[i]; // Mutation Type

        var type = mutation.type; // DOM Node (could be any DOM Node type - HTMLElement, Text, comment, etc)

        var target = mutation.target;

        if (type === 'characterData' && target.nodeType === Node.TEXT_NODE) {
          // We ignore nodes that are not TEXT (i.e. comments, etc) as they don't change layout
          changed = true;
        } else if (type === 'attributes') {
          changed = true;
        } else if (type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
          // This includes HTMLElement and Text Nodes being added/removed/re-arranged
          changed = true;
        }
      }

      if (changed) {
        // We only call the callback if a change that could affect layout/size truely happened.
        callback();
      }
    }); // Have the observer observe foo for changes in children, etc

    obs.observe(el, _objectSpread({
      childList: true,
      subtree: true
    }, opts));
  } else if (eventListenerSupported) {
    // Legacy interface. most likely not used in modern browsers
    obs = fakeObserverFactory(el, callback);
  } // We return a reference to the observer so that obs.disconnect() can be called if necessary
  // To reduce overhead when the root element is hidden


  return obs;
};

var _default = observeDom;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/pluck-props.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _identity = __webpack_require__("./node_modules/bootstrap-vue/es/utils/identity.js");

/**
 * Given an array of properties or an object of property keys,
 * plucks all the values off the target object, returning a new object
 * that has props that reference the original prop values
 *
 * @param {{}|string[]} keysToPluck
 * @param {{}} objToPluck
 * @param {Function} transformFn
 * @return {{}}
 */
var pluckProps = function pluckProps(keysToPluck, objToPluck) {
  var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _identity.default;
  return ((0, _array.isArray)(keysToPluck) ? keysToPluck.slice() : (0, _object.keys)(keysToPluck)).reduce(function (memo, prop) {
    memo[transformFn(prop)] = objToPluck[prop];
    return memo;
  }, {});
};

var _default = pluckProps;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/plugins.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.vueUse = exports.registerDirectives = exports.registerDirective = exports.registerComponents = exports.registerComponent = exports.registerPlugins = exports.installFactory = void 0;

var _config = __webpack_require__("./node_modules/bootstrap-vue/es/utils/config.js");

/**
 * Plugin install factory function.
 * @param {object} { components, directives }
 * @returns {function} plugin install function
 */
var installFactory = function installFactory(_ref) {
  var components = _ref.components,
      directives = _ref.directives,
      plugins = _ref.plugins;
  return function (Vue) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _config.setConfig)(config);
    registerComponents(Vue, components);
    registerDirectives(Vue, directives);
    registerPlugins(Vue, plugins);
  };
};
/**
 * Load a group of plugins.
 * @param {object} Vue
 * @param {object} Plugin definitions
 */


exports.installFactory = installFactory;

var registerPlugins = function registerPlugins(Vue) {
  var plugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var plugin in plugins) {
    if (plugin && plugins[plugin]) {
      Vue.use(plugins[plugin]);
    }
  }
};
/**
 * Load a component.
 * @param {object} Vue
 * @param {string} Component name
 * @param {object} Component definition
 */


exports.registerPlugins = registerPlugins;

var registerComponent = function registerComponent(Vue, name, def) {
  if (Vue && name && def) {
    Vue.component(name, def);
  }
};
/**
 * Load a group of components.
 * @param {object} Vue
 * @param {object} Object of component definitions
 */


exports.registerComponent = registerComponent;

var registerComponents = function registerComponents(Vue) {
  var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var component in components) {
    registerComponent(Vue, component, components[component]);
  }
};
/**
 * Load a directive.
 * @param {object} Vue
 * @param {string} Directive name
 * @param {object} Directive definition
 */


exports.registerComponents = registerComponents;

var registerDirective = function registerDirective(Vue, name, def) {
  if (Vue && name && def) {
    Vue.directive(name, def);
  }
};
/**
 * Load a group of directives.
 * @param {object} Vue
 * @param {object} Object of directive definitions
 */


exports.registerDirective = registerDirective;

var registerDirectives = function registerDirectives(Vue) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var directive in directives) {
    registerDirective(Vue, directive, directives[directive]);
  }
};
/**
 * Install plugin if window.Vue available
 * @param {object} Plugin definition
 */


exports.registerDirectives = registerDirectives;

var vueUse = function vueUse(VuePlugin) {
  /* istanbul ignore next */
  if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(VuePlugin);
  }
};

exports.vueUse = vueUse;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/popover.class.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _tooltip = __webpack_require__("./node_modules/bootstrap-vue/es/utils/tooltip.class.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NAME = 'popover';
var CLASS_PREFIX = 'bs-popover';
var BS_CLASS_PREFIX_REGEX = new RegExp("\\b".concat(CLASS_PREFIX, "\\S+"), 'g');

var Defaults = _objectSpread({}, _tooltip.default.Default, {
  placement: 'right',
  trigger: 'click',
  content: '',
  template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
});

var ClassName = {
  FADE: 'fade',
  SHOW: 'show'
};
var Selector = {
  TITLE: '.popover-header',
  CONTENT: '.popover-body'
  /* istanbul ignore next: dificult to test in Jest/JSDOM environment */

};

var PopOver =
/*#__PURE__*/
function (_ToolTip) {
  _inherits(PopOver, _ToolTip);

  function PopOver() {
    _classCallCheck(this, PopOver);

    return _possibleConstructorReturn(this, _getPrototypeOf(PopOver).apply(this, arguments));
  }

  _createClass(PopOver, [{
    key: "isWithContent",
    // Method overrides
    value: function isWithContent(tip)
    /* istanbul ignore next */
    {
      tip = tip || this.$tip;

      if (!tip) {
        return false;
      }

      var hasTitle = Boolean(((0, _dom.select)(Selector.TITLE, tip) || {}).innerHTML);
      var hasContent = Boolean(((0, _dom.select)(Selector.CONTENT, tip) || {}).innerHTML);
      return hasTitle || hasContent;
    }
  }, {
    key: "addAttachmentClass",
    value: function addAttachmentClass(attachment)
    /* istanbul ignore next */
    {
      (0, _dom.addClass)(this.getTipElement(), "".concat(CLASS_PREFIX, "-").concat(attachment));
    }
  }, {
    key: "setContent",
    value: function setContent(tip)
    /* istanbul ignore next */
    {
      // we use append for html objects to maintain js events/components
      this.setElementContent((0, _dom.select)(Selector.TITLE, tip), this.getTitle());
      this.setElementContent((0, _dom.select)(Selector.CONTENT, tip), this.getContent());
      (0, _dom.removeClass)(tip, ClassName.FADE);
      (0, _dom.removeClass)(tip, ClassName.SHOW);
    } // This method may look identical to ToolTip version, but it uses a different RegEx defined above

  }, {
    key: "cleanTipClass",
    value: function cleanTipClass()
    /* istanbul ignore next */
    {
      var tip = this.getTipElement();
      var tabClass = tip.className.match(BS_CLASS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        tabClass.forEach(function (cls) {
          (0, _dom.removeClass)(tip, cls);
        });
      }
    }
  }, {
    key: "getTitle",
    value: function getTitle()
    /* istanbul ignore next */
    {
      var title = this.$config.title || '';

      if (typeof title === 'function') {
        title = title(this.$element);
      }

      if (_typeof(title) === 'object' && title.nodeType && !title.innerHTML.trim()) {
        // We have a dom node, but without inner content, so just return an empty string
        title = '';
      }

      if (typeof title === 'string') {
        title = title.trim();
      }

      if (!title) {
        // Try and grab element's title attribute
        title = (0, _dom.getAttr)(this.$element, 'title') || (0, _dom.getAttr)(this.$element, 'data-original-title') || '';
        title = title.trim();
      }

      return title;
    } // New methods

  }, {
    key: "getContent",
    value: function getContent()
    /* istanbul ignore next */
    {
      var content = this.$config.content || '';

      if (typeof content === 'function') {
        content = content(this.$element);
      }

      if (_typeof(content) === 'object' && content.nodeType && !content.innerHTML.trim()) {
        // We have a dom node, but without inner content, so just return an empty string
        content = '';
      }

      if (typeof content === 'string') {
        content = content.trim();
      }

      return content;
    }
  }], [{
    key: "Default",
    // Getter overrides
    get: function get()
    /* istanbul ignore next */
    {
      return Defaults;
    }
  }, {
    key: "NAME",
    get: function get()
    /* istanbul ignore next */
    {
      return NAME;
    }
  }]);

  return PopOver;
}(_tooltip.default);

var _default = PopOver;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/prefix-prop-name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _upperFirst = __webpack_require__("./node_modules/bootstrap-vue/es/utils/upper-first.js");

/**
 * @param {string} prefix
 * @param {string} value
 */
var prefixPropName = function prefixPropName(prefix, value) {
  return prefix + (0, _upperFirst.default)(value);
};

var _default = prefixPropName;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/range.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * @param {number} length
 * @return {Array}
 */
var range = function range(length) {
  return Array.apply(null, {
    length: length
  });
};

var _default = range;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/router.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.computeHref = exports.computeRel = exports.computeTag = exports.isRouterLink = exports.parseQuery = exports.stringifyQueryObj = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _toString = __webpack_require__("./node_modules/bootstrap-vue/es/utils/to-string.js");

var ANCHOR_TAG = 'a'; // Precompile RegExp

var commaRE = /%2C/g;
var encodeReserveRE = /[!'()*]/g; // Method to replace reserved chars

var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
}; // Fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas


var encode = function encode(str) {
  return encodeURIComponent((0, _toString.default)(str)).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent; // Stringifies an object of query parameters
// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js

var stringifyQueryObj = function stringifyQueryObj(obj) {
  if (!(0, _object.isPlainObject)(obj)) {
    return '';
  }

  var query = (0, _object.keys)(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    } else if (val === null) {
      return encode(key);
    } else if ((0, _array.isArray)(val)) {
      return val.reduce(function (results, val2) {
        if (val2 === null) {
          results.push(encode(key));
        } else if (val2 !== undefined) {
          // Faster than string interpolation
          results.push(encode(key) + '=' + encode(val2));
        }

        return results;
      }, []).join('&');
    } // Faster than string interpolation


    return encode(key) + '=' + encode(val);
  })
  /* must check for length, as we only want to filter empty strings, not things that look falsey! */
  .filter(function (x) {
    return x.length > 0;
  }).join('&');
  return query ? "?".concat(query) : '';
};

exports.stringifyQueryObj = stringifyQueryObj;

var parseQuery = function parseQuery(query) {
  var parsed = {};
  query = (0, _toString.default)(query).trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return parsed;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (parsed[key] === undefined) {
      parsed[key] = val;
    } else if ((0, _array.isArray)(parsed[key])) {
      parsed[key].push(val);
    } else {
      parsed[key] = [parsed[key], val];
    }
  });
  return parsed;
};

exports.parseQuery = parseQuery;

var isRouterLink = function isRouterLink(tag) {
  return tag !== ANCHOR_TAG;
};

exports.isRouterLink = isRouterLink;

var computeTag = function computeTag() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      to = _ref.to,
      disabled = _ref.disabled;

  var thisOrParent = arguments.length > 1 ? arguments[1] : undefined;
  return thisOrParent.$router && to && !disabled ? thisOrParent.$nuxt ? 'nuxt-link' : 'router-link' : ANCHOR_TAG;
};

exports.computeTag = computeTag;

var computeRel = function computeRel() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      target = _ref2.target,
      rel = _ref2.rel;

  if (target === '_blank' && rel === null) {
    return 'noopener';
  }

  return rel || null;
};

exports.computeRel = computeRel;

var computeHref = function computeHref() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      href = _ref3.href,
      to = _ref3.to;

  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;
  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';
  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';

  // We've already checked the $router in computeTag(), so isRouterLink() indicates a live router.
  // When deferring to Vue Router's router-link, don't use the href attribute at all.
  // We return null, and then remove href from the attributes passed to router-link
  if (isRouterLink(tag)) {
    return null;
  } // Return `href` when explicitly provided


  if (href) {
    return href;
  } // Reconstruct `href` when `to` used, but no router


  if (to) {
    // Fallback to `to` prop (if `to` is a string)
    if (typeof to === 'string') {
      return to || toFallback;
    } // Fallback to `to.path + to.query + to.hash` prop (if `to` is an object)


    if ((0, _object.isPlainObject)(to) && (to.path || to.query || to.hash)) {
      var path = (0, _toString.default)(to.path);
      var query = stringifyQueryObj(to.query);
      var hash = (0, _toString.default)(to.hash);
      hash = !hash || hash.charAt(0) === '#' ? hash : "#".concat(hash);
      return "".concat(path).concat(query).concat(hash) || toFallback;
    }
  } // If nothing is provided return the fallback


  return fallback;
};

exports.computeHref = computeHref;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/ssr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.HTMLElement = void 0;
// Polyfills for SSR
var isSSR = typeof window === 'undefined';
var HTMLElement = isSSR ? Object : window.HTMLElement;
exports.HTMLElement = HTMLElement;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/stable-sort.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/*
 * Consistent and stable sort function across JavaScript platforms
 *
 * Inconsistent sorts can cause SSR problems between client and server
 * such as in <b-table> if sortBy is applied to the data on server side render.
 * Chrome and V8 native sorts are inconsistent/unstable
 *
 * This function uses native sort with fallback to index compare when the a and b
 * compare returns 0
 *
 * Algorithm based on:
 * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645
 *
 * @param {array} array to sort
 * @param {function} sort compare function
 * @return {array}
 */
var stableSort = function stableSort(array, compareFn) {
  // Using `.bind(compareFn)` on the wrapped anonymous function improves
  // performance by avoiding the function call setup. We don't use an arrow
  // function here as it binds `this` to the `stableSort` context rather than
  // the `compareFn` context, which wouldn't give us the performance increase.
  return array.map(function (a, index) {
    return [index, a];
  }).sort(function (a, b) {
    return this(a[1], b[1]) || a[0] - b[0];
  }.bind(compareFn)).map(function (e) {
    return e[1];
  });
};

var _default = stableSort;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/startcase.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Converts a string, including strings in camelCase or snake_case, into Start Case (a variant
 * of Title Case where all words start with a capital letter), it keeps original single quote
 * and hyphen in the word.
 *
 * Copyright (c) 2017 Compass (MIT)
 * https://github.com/UrbanCompass/to-start-case
 * @author Zhuoyuan Zhang <https://github.com/drawyan>
 * @author Wei Wang <https://github.com/onlywei>
 *
 *
 *   'management_companies' to 'Management Companies'
 *   'managementCompanies' to 'Management Companies'
 *   `hell's kitchen` to `Hell's Kitchen`
 *   `co-op` to `Co-op`
 *
 * @param {String} str
 * @returns {String}
 */
var startCase = function startCase(str) {
  return str.replace(/_/g, ' ').replace(/([a-z])([A-Z])/g, function (str, $1, $2) {
    return $1 + ' ' + $2;
  }).replace(/(\s|^)(\w)/g, function (str, $1, $2) {
    return $1 + $2.toUpperCase();
  });
};

var _default = startCase;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/suffix-prop-name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _upperFirst = __webpack_require__("./node_modules/bootstrap-vue/es/utils/upper-first.js");

/**
 * Suffix can be a falsey value so nothing is appended to string.
 * (helps when looping over props & some shouldn't change)
 * Use data last parameters to allow for currying.
 * @param {string} suffix
 * @param {string} str
 */
var suffixPropName = function suffixPropName(suffix, str) {
  return str + (suffix ? (0, _upperFirst.default)(suffix) : '');
};

var _default = suffixPropName;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/target.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = exports.unbindTargets = exports.bindTargets = void 0;

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

var allListenTypes = {
  hover: true,
  click: true,
  focus: true
};
var BVBoundListeners = '__BV_boundEventListeners__';

var bindTargets = function bindTargets(vnode, binding, listenTypes, fn) {
  var targets = (0, _object.keys)(binding.modifiers || {}).filter(function (t) {
    return !allListenTypes[t];
  });

  if (binding.value) {
    targets.push(binding.value);
  }

  var listener = function listener() {
    fn({
      targets: targets,
      vnode: vnode
    });
  };

  (0, _object.keys)(allListenTypes).forEach(function (type) {
    if (listenTypes[type] || binding.modifiers[type]) {
      (0, _dom.eventOn)(vnode.elm, type, listener);
      var boundListeners = vnode.elm[BVBoundListeners] || {};
      boundListeners[type] = boundListeners[type] || [];
      boundListeners[type].push(listener);
      vnode.elm[BVBoundListeners] = boundListeners;
    }
  }); // Return the list of targets

  return targets;
};

exports.bindTargets = bindTargets;

var unbindTargets = function unbindTargets(vnode, binding, listenTypes) {
  (0, _object.keys)(allListenTypes).forEach(function (type) {
    if (listenTypes[type] || binding.modifiers[type]) {
      var boundListeners = vnode.elm[BVBoundListeners] && vnode.elm[BVBoundListeners][type];

      if (boundListeners) {
        boundListeners.forEach(function (listener) {
          return (0, _dom.eventOff)(vnode.elm, type, listener);
        });
        delete vnode.elm[BVBoundListeners][type];
      }
    }
  });
};

exports.unbindTargets = unbindTargets;
var _default = bindTargets;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/to-string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _object = __webpack_require__("./node_modules/bootstrap-vue/es/utils/object.js");

/**
 * Convert a value to a string that can be rendered.
 */
var toString = function toString(val) {
  var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return val === null || val === undefined ? '' : (0, _array.isArray)(val) || (0, _object.isPlainObject)(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
};

var _default = toString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/tooltip.class.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _popper = __webpack_require__("./node_modules/popper.js/dist/esm/popper.js");

var _bvEvent = __webpack_require__("./node_modules/bootstrap-vue/es/utils/bv-event.class.js");

var _noop = __webpack_require__("./node_modules/bootstrap-vue/es/utils/noop.js");

var _array = __webpack_require__("./node_modules/bootstrap-vue/es/utils/array.js");

var _dom = __webpack_require__("./node_modules/bootstrap-vue/es/utils/dom.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var NAME = 'tooltip';
var CLASS_PREFIX = 'bs-tooltip';
var BS_CLASS_PREFIX_REGEX = new RegExp("\\b".concat(CLASS_PREFIX, "\\S+"), 'g');
var TRANSITION_DURATION = 150; // Modal $root hidden event

var MODAL_CLOSE_EVENT = 'bv::modal::hidden'; // Modal container for appending tooltip/popover

var MODAL_CLASS = '.modal-content';
var AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left',
  TOPLEFT: 'top',
  TOPRIGHT: 'top',
  RIGHTTOP: 'right',
  RIGHTBOTTOM: 'right',
  BOTTOMLEFT: 'bottom',
  BOTTOMRIGHT: 'bottom',
  LEFTTOP: 'left',
  LEFTBOTTOM: 'left'
};
var OffsetMap = {
  AUTO: 0,
  TOPLEFT: -1,
  TOP: 0,
  TOPRIGHT: +1,
  RIGHTTOP: -1,
  RIGHT: 0,
  RIGHTBOTTOM: +1,
  BOTTOMLEFT: -1,
  BOTTOM: 0,
  BOTTOMRIGHT: +1,
  LEFTTOP: -1,
  LEFT: 0,
  LEFTBOTTOM: +1
};
var HoverState = {
  SHOW: 'show',
  OUT: 'out'
};
var ClassName = {
  FADE: 'fade',
  SHOW: 'show'
};
var Selector = {
  TOOLTIP: '.tooltip',
  TOOLTIP_INNER: '.tooltip-inner',
  ARROW: '.arrow'
};
var Defaults = {
  animation: true,
  template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  placement: 'top',
  offset: 0,
  arrowPadding: 6,
  container: false,
  fallbackPlacement: 'flip',
  callbacks: {},
  boundary: 'scrollParent' // Transition event names

};
var TransitionEndEvents = {
  WebkitTransition: ['webkitTransitionEnd'],
  MozTransition: ['transitionend'],
  OTransition: ['otransitionend', 'oTransitionEnd'],
  transition: ['transitionend'] // Client-side tip ID counter for aria-describedby attribute
  // Each tooltip requires a unique client side ID

};
var NEXTID = 1;
/* istanbul ignore next */

var generateId = function generateId(name) {
  return "__BV_".concat(name, "_").concat(NEXTID++, "__");
};
/*
 * ToolTip class definition
 */

/* istanbul ignore next: difficult to test in Jest/JSDOM environment */


var ToolTip =
/*#__PURE__*/
function () {
  // Main constructor
  function ToolTip(element, config, $root) {
    _classCallCheck(this, ToolTip);

    // New tooltip object
    this.$isEnabled = true;
    this.$fadeTimeout = null;
    this.$hoverTimeout = null;
    this.$visibleInterval = null;
    this.$hoverState = '';
    this.$activeTrigger = {};
    this.$popper = null;
    this.$element = element;
    this.$tip = null;
    this.$id = generateId(this.constructor.NAME);
    this.$root = $root || null;
    this.$routeWatcher = null; // We use a bound version of the following handlers for root/modal
    // listeners to maintain the 'this' context

    this.$forceHide = this.forceHide.bind(this);
    this.$doHide = this.doHide.bind(this);
    this.$doShow = this.doShow.bind(this);
    this.$doDisable = this.doDisable.bind(this);
    this.$doEnable = this.doEnable.bind(this);
    this._noop = _noop.default.bind(this); // Set the configuration

    this.updateConfig(config);
  } // NOTE: Overridden by PopOver class


  _createClass(ToolTip, [{
    key: "updateConfig",
    // Update config
    value: function updateConfig(config) {
      // Merge config into defaults. We use "this" here because PopOver overrides Default
      var updatedConfig = _objectSpread({}, this.constructor.Default, config); // Sanitize delay


      if (config.delay && typeof config.delay === 'number') {
        updatedConfig.delay = {
          show: config.delay,
          hide: config.delay
        };
      } // Title for tooltip and popover


      if (config.title && typeof config.title === 'number') {
        updatedConfig.title = config.title.toString();
      } // Content only for popover


      if (config.content && typeof config.content === 'number') {
        updatedConfig.content = config.content.toString();
      } // Hide element original title if needed


      this.fixTitle(); // Update the config

      this.$config = updatedConfig; // Stop/Restart listening

      this.unListen();
      this.listen();
    } // Destroy this instance

  }, {
    key: "destroy",
    value: function destroy() {
      // Stop listening to trigger events
      this.unListen(); // Disable while open listeners/watchers

      this.setWhileOpenListeners(false); // Clear any timeouts

      clearTimeout(this.$hoverTimeout);
      this.$hoverTimeout = null;
      clearTimeout(this.$fadeTimeout);
      this.$fadeTimeout = null; // Remove popper

      if (this.$popper) {
        this.$popper.destroy();
      }

      this.$popper = null; // Remove tip from document

      if (this.$tip && this.$tip.parentElement) {
        this.$tip.parentElement.removeChild(this.$tip);
      }

      this.$tip = null; // Null out other properties

      this.$id = null;
      this.$isEnabled = null;
      this.$root = null;
      this.$element = null;
      this.$config = null;
      this.$hoverState = null;
      this.$activeTrigger = null;
      this.$forceHide = null;
      this.$doHide = null;
      this.$doShow = null;
      this.$doDisable = null;
      this.$doEnable = null;
    }
  }, {
    key: "enable",
    value: function enable() {
      // Create a non-cancelable BvEvent
      var enabledEvt = new _bvEvent.default('enabled', {
        cancelable: false,
        target: this.$element,
        relatedTarget: null
      });
      this.$isEnabled = true;
      this.emitEvent(enabledEvt);
    }
  }, {
    key: "disable",
    value: function disable() {
      // Create a non-cancelable BvEvent
      var disabledEvt = new _bvEvent.default('disabled', {
        cancelable: false,
        target: this.$element,
        relatedTarget: null
      });
      this.$isEnabled = false;
      this.emitEvent(disabledEvt);
    } // Click toggler

  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this.$isEnabled) {
        return;
      }

      if (event) {
        this.$activeTrigger.click = !this.$activeTrigger.click;

        if (this.isWithActiveTrigger()) {
          this.enter(null);
        } else {
          this.leave(null);
        }
      } else {
        if ((0, _dom.hasClass)(this.getTipElement(), ClassName.SHOW)) {
          this.leave(null);
        } else {
          this.enter(null);
        }
      }
    } // Show tooltip

  }, {
    key: "show",
    value: function show() {
      var _this = this;

      if (!document.body.contains(this.$element) || !(0, _dom.isVisible)(this.$element)) {
        // If trigger element isn't in the DOM or is not visible
        return;
      } // Build tooltip element (also sets this.$tip)


      var tip = this.getTipElement();
      this.fixTitle();
      this.setContent(tip);

      if (!this.isWithContent(tip)) {
        // If no content, don't bother showing
        this.$tip = null;
        return;
      } // Set ID on tip and aria-describedby on element


      (0, _dom.setAttr)(tip, 'id', this.$id);
      this.addAriaDescribedby(); // Set animation on or off

      if (this.$config.animation) {
        (0, _dom.addClass)(tip, ClassName.FADE);
      } else {
        (0, _dom.removeClass)(tip, ClassName.FADE);
      }

      var placement = this.getPlacement();
      var attachment = this.constructor.getAttachment(placement);
      this.addAttachmentClass(attachment); // Create a cancelable BvEvent

      var showEvt = new _bvEvent.default('show', {
        cancelable: true,
        target: this.$element,
        relatedTarget: tip
      });
      this.emitEvent(showEvt);

      if (showEvt.defaultPrevented) {
        // Don't show if event cancelled
        this.$tip = null;
        return;
      } // Insert tooltip if needed


      var container = this.getContainer();

      if (!document.body.contains(tip)) {
        container.appendChild(tip);
      } // Refresh popper


      this.removePopper();
      this.$popper = new _popper.default(this.$element, tip, this.getPopperConfig(placement, tip)); // Transitionend callback

      var complete = function complete() {
        if (_this.$config.animation) {
          _this.fixTransition(tip);
        }

        var prevHoverState = _this.$hoverState;
        _this.$hoverState = null;

        if (prevHoverState === HoverState.OUT) {
          _this.leave(null);
        } // Create a non-cancelable BvEvent


        var shownEvt = new _bvEvent.default('shown', {
          cancelable: false,
          target: _this.$element,
          relatedTarget: tip
        });

        _this.emitEvent(shownEvt);
      }; // Enable while open listeners/watchers


      this.setWhileOpenListeners(true); // Show tip

      (0, _dom.addClass)(tip, ClassName.SHOW); // Start the transition/animation

      this.transitionOnce(tip, complete);
    } // Handler for periodic visibility check

  }, {
    key: "visibleCheck",
    value: function visibleCheck(on) {
      var _this2 = this;

      clearInterval(this.$visibleInterval);
      this.$visibleInterval = null;

      if (on) {
        this.$visibleInterval = setInterval(function () {
          var tip = _this2.getTipElement();

          if (tip && !(0, _dom.isVisible)(_this2.$element) && (0, _dom.hasClass)(tip, ClassName.SHOW)) {
            // Element is no longer visible, so force-hide the tooltip
            _this2.forceHide();
          }
        }, 100);
      }
    }
  }, {
    key: "setWhileOpenListeners",
    value: function setWhileOpenListeners(on) {
      // Modal close events
      this.setModalListener(on); // Periodic $element visibility check
      // For handling when tip is in <keepalive>, tabs, carousel, etc

      this.visibleCheck(on); // Route change events

      this.setRouteWatcher(on); // On-touch start listeners

      this.setOnTouchStartListener(on);

      if (on && /(focus|blur)/.test(this.$config.trigger)) {
        // If focus moves between trigger element and tip container, don't close
        (0, _dom.eventOn)(this.$tip, 'focusout', this);
      } else {
        (0, _dom.eventOff)(this.$tip, 'focusout', this);
      }
    } // Force hide of tip (internal method)

  }, {
    key: "forceHide",
    value: function forceHide() {
      if (!this.$tip || !(0, _dom.hasClass)(this.$tip, ClassName.SHOW)) {
        return;
      } // Disable while open listeners/watchers


      this.setWhileOpenListeners(false); // Clear any hover enter/leave event

      clearTimeout(this.$hoverTimeout);
      this.$hoverTimeout = null;
      this.$hoverState = ''; // Hide the tip

      this.hide(null, true);
    } // Hide tooltip

  }, {
    key: "hide",
    value: function hide(callback, force) {
      var _this3 = this;

      var tip = this.$tip;

      if (!tip) {
        return;
      } // Create a cancelable BvEvent


      var hideEvt = new _bvEvent.default('hide', {
        // We disable cancelling if force is true
        cancelable: !force,
        target: this.$element,
        relatedTarget: tip
      });
      this.emitEvent(hideEvt);

      if (hideEvt.defaultPrevented) {
        // Don't hide if event cancelled
        return;
      } // Transitionend callback

      /* istanbul ignore next */


      var complete = function complete() {
        if (_this3.$hoverState !== HoverState.SHOW && tip.parentNode) {
          // Remove tip from DOM, and force recompile on next show
          tip.parentNode.removeChild(tip);

          _this3.removeAriaDescribedby();

          _this3.removePopper();

          _this3.$tip = null;
        }

        if (callback) {
          callback();
        } // Create a non-cancelable BvEvent


        var hiddenEvt = new _bvEvent.default('hidden', {
          cancelable: false,
          target: _this3.$element,
          relatedTarget: null
        });

        _this3.emitEvent(hiddenEvt);
      }; // Disable while open listeners/watchers


      this.setWhileOpenListeners(false); // If forced close, disable animation

      if (force) {
        (0, _dom.removeClass)(tip, ClassName.FADE);
      } // Hide tip


      (0, _dom.removeClass)(tip, ClassName.SHOW);
      this.$activeTrigger.click = false;
      this.$activeTrigger.focus = false;
      this.$activeTrigger.hover = false; // Start the hide transition

      this.transitionOnce(tip, complete);
      this.$hoverState = '';
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(evt) {
      var evtName = evt.type;

      if (this.$root && this.$root.$emit) {
        // Emit an event on $root
        this.$root.$emit("bv::".concat(this.constructor.NAME, "::").concat(evtName), evt);
      }

      var callbacks = this.$config.callbacks || {};

      if (typeof callbacks[evtName] === 'function') {
        callbacks[evtName](evt);
      }
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      var container = this.$config.container;
      var body = document.body; // If we are in a modal, we append to the modal instead of body,
      // unless a container is specified

      return container === false ? (0, _dom.closest)(MODAL_CLASS, this.$element) || body : (0, _dom.select)(container, body) || body;
    } // Will be overridden by PopOver if needed

  }, {
    key: "addAriaDescribedby",
    value: function addAriaDescribedby() {
      // Add aria-describedby on trigger element, without removing any other IDs
      var desc = (0, _dom.getAttr)(this.$element, 'aria-describedby') || '';
      desc = desc.split(/\s+/).concat(this.$id).join(' ').trim();
      (0, _dom.setAttr)(this.$element, 'aria-describedby', desc);
    } // Will be overridden by PopOver if needed

  }, {
    key: "removeAriaDescribedby",
    value: function removeAriaDescribedby() {
      var _this4 = this;

      var desc = (0, _dom.getAttr)(this.$element, 'aria-describedby') || '';
      desc = desc.split(/\s+/).filter(function (d) {
        return d !== _this4.$id;
      }).join(' ').trim();

      if (desc) {
        (0, _dom.setAttr)(this.$element, 'aria-describedby', desc);
      } else {
        (0, _dom.removeAttr)(this.$element, 'aria-describedby');
      }
    }
  }, {
    key: "removePopper",
    value: function removePopper() {
      if (this.$popper) {
        this.$popper.destroy();
      }

      this.$popper = null;
    }
    /* istanbul ignore next */

  }, {
    key: "transitionOnce",
    value: function transitionOnce(tip, complete) {
      var _this5 = this;

      var transEvents = this.getTransitionEndEvents();
      var called = false;
      clearTimeout(this.$fadeTimeout);
      this.$fadeTimeout = null;

      var fnOnce = function fnOnce() {
        if (called) {
          return;
        }

        called = true;
        clearTimeout(_this5.$fadeTimeout);
        _this5.$fadeTimeout = null;
        transEvents.forEach(function (evtName) {
          (0, _dom.eventOff)(tip, evtName, fnOnce);
        }); // Call complete callback

        complete();
      };

      if ((0, _dom.hasClass)(tip, ClassName.FADE)) {
        transEvents.forEach(function (evtName) {
          (0, _dom.eventOn)(tip, evtName, fnOnce);
        }); // Fallback to setTimeout()

        this.$fadeTimeout = setTimeout(fnOnce, TRANSITION_DURATION);
      } else {
        fnOnce();
      }
    } // What transitionend event(s) to use? (returns array of event names)

  }, {
    key: "getTransitionEndEvents",
    value: function getTransitionEndEvents() {
      for (var name in TransitionEndEvents) {
        if (this.$element.style[name] !== undefined) {
          return TransitionEndEvents[name];
        }
      } // Fallback


      return [];
    }
  }, {
    key: "update",
    value: function update() {
      if (this.$popper !== null) {
        this.$popper.scheduleUpdate();
      }
    } // NOTE: Overridden by PopOver class

  }, {
    key: "isWithContent",
    value: function isWithContent(tip) {
      tip = tip || this.$tip;

      if (!tip) {
        return false;
      }

      return Boolean(((0, _dom.select)(Selector.TOOLTIP_INNER, tip) || {}).innerHTML);
    } // NOTE: Overridden by PopOver class

  }, {
    key: "addAttachmentClass",
    value: function addAttachmentClass(attachment) {
      (0, _dom.addClass)(this.getTipElement(), "".concat(CLASS_PREFIX, "-").concat(attachment));
    }
  }, {
    key: "getTipElement",
    value: function getTipElement() {
      if (!this.$tip) {
        // Try and compile user supplied template, or fallback to default template
        this.$tip = this.compileTemplate(this.$config.template) || this.compileTemplate(this.constructor.Default.template);
      } // Add tab index so tip can be focused, and to allow it to be
      // set as relatedTarget in focusin/out events


      this.$tip.tabIndex = -1;
      return this.$tip;
    }
  }, {
    key: "compileTemplate",
    value: function compileTemplate(html) {
      if (!html || typeof html !== 'string') {
        return null;
      }

      var div = document.createElement('div');
      div.innerHTML = html.trim();
      var node = div.firstElementChild ? div.removeChild(div.firstElementChild) : null;
      div = null;
      return node;
    } // NOTE: Overridden by PopOver class

  }, {
    key: "setContent",
    value: function setContent(tip) {
      this.setElementContent((0, _dom.select)(Selector.TOOLTIP_INNER, tip), this.getTitle());
      (0, _dom.removeClass)(tip, ClassName.FADE);
      (0, _dom.removeClass)(tip, ClassName.SHOW);
    }
  }, {
    key: "setElementContent",
    value: function setElementContent(container, content) {
      if (!container) {
        // If container element doesn't exist, just return
        return;
      }

      var allowHtml = this.$config.html;

      if (_typeof(content) === 'object' && content.nodeType) {
        // Content is a DOM node
        if (allowHtml) {
          if (content.parentElement !== container) {
            container.innerHTML = '';
            container.appendChild(content);
          }
        } else {
          container.innerText = content.innerText;
        }
      } else {
        // We have a plain HTML string or Text
        container[allowHtml ? 'innerHTML' : 'innerText'] = content;
      }
    } // NOTE: Overridden by PopOver class

  }, {
    key: "getTitle",
    value: function getTitle() {
      var title = this.$config.title || '';

      if (typeof title === 'function') {
        // Call the function to get the title value
        title = title(this.$element);
      }

      if (_typeof(title) === 'object' && title.nodeType && !title.innerHTML.trim()) {
        // We have a DOM node, but without inner content,
        // so just return empty string
        title = '';
      }

      if (typeof title === 'string') {
        title = title.trim();
      }

      if (!title) {
        // If an explicit title is not given, try element's title attributes
        title = (0, _dom.getAttr)(this.$element, 'title') || (0, _dom.getAttr)(this.$element, 'data-original-title') || '';
        title = title.trim();
      }

      return title;
    }
  }, {
    key: "listen",
    value: function listen() {
      var _this6 = this;

      var triggers = this.$config.trigger.trim().split(/\s+/);
      var el = this.$element; // Listen for global show/hide events

      this.setRootListener(true); // Using 'this' as the handler will get automatically directed to
      // this.handleEvent and maintain our binding to 'this'

      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          (0, _dom.eventOn)(el, 'click', _this6);
        } else if (trigger === 'focus') {
          (0, _dom.eventOn)(el, 'focusin', _this6);
          (0, _dom.eventOn)(el, 'focusout', _this6);
        } else if (trigger === 'blur') {
          // Used to close $tip when element looses focus
          (0, _dom.eventOn)(el, 'focusout', _this6);
        } else if (trigger === 'hover') {
          (0, _dom.eventOn)(el, 'mouseenter', _this6);
          (0, _dom.eventOn)(el, 'mouseleave', _this6);
        }
      }, this);
    }
  }, {
    key: "unListen",
    value: function unListen() {
      var _this7 = this;

      var events = ['click', 'focusin', 'focusout', 'mouseenter', 'mouseleave']; // Using "this" as the handler will get automatically directed to this.handleEvent

      events.forEach(function (evt) {
        (0, _dom.eventOff)(_this7.$element, evt, _this7);
      }, this); // Stop listening for global show/hide/enable/disable events

      this.setRootListener(false);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(e) {
      // This special method allows us to use "this" as the event handlers
      if ((0, _dom.isDisabled)(this.$element)) {
        // If disabled, don't do anything. Note: If tip is shown before element gets
        // disabled, then tip not close until no longer disabled or forcefully closed.
        return;
      }

      if (!this.$isEnabled) {
        // If not enable
        return;
      }

      var type = e.type;
      var target = e.target;
      var relatedTarget = e.relatedTarget;
      var $element = this.$element;
      var $tip = this.$tip;

      if (type === 'click') {
        this.toggle(e);
      } else if (type === 'focusin' || type === 'mouseenter') {
        this.enter(e);
      } else if (type === 'focusout') {
        // target is the element which is loosing focus
        // and relatedTarget is the element gaining focus
        if ($tip && $element && $element.contains(target) && $tip.contains(relatedTarget)) {
          // If focus moves from $element to $tip, don't trigger a leave
          return;
        }

        if ($tip && $element && $tip.contains(target) && $element.contains(relatedTarget)) {
          // If focus moves from $tip to $element, don't trigger a leave
          return;
        }

        if ($tip && $tip.contains(target) && $tip.contains(relatedTarget)) {
          // If focus moves within $tip, don't trigger a leave
          return;
        }

        if ($element && $element.contains(target) && $element.contains(relatedTarget)) {
          // If focus moves within $element, don't trigger a leave
          return;
        } // Otherwise trigger a leave


        this.leave(e);
      } else if (type === 'mouseleave') {
        this.leave(e);
      }
    }
    /* istanbul ignore next */

  }, {
    key: "setRouteWatcher",
    value: function setRouteWatcher(on) {
      var _this8 = this;

      if (on) {
        this.setRouteWatcher(false);

        if (this.$root && Boolean(this.$root.$route)) {
          this.$routeWatcher = this.$root.$watch('$route', function (newVal, oldVal) {
            if (newVal === oldVal) {
              return;
            } // If route has changed, we force hide the tooltip/popover


            _this8.forceHide();
          });
        }
      } else {
        if (this.$routeWatcher) {
          // Cancel the route watcher by calling the stored reference
          this.$routeWatcher();
          this.$routeWatcher = null;
        }
      }
    }
    /* istanbul ignore next */

  }, {
    key: "setModalListener",
    value: function setModalListener(on) {
      var modal = (0, _dom.closest)(MODAL_CLASS, this.$element);

      if (!modal) {
        // If we are not in a modal, don't worry. be happy
        return;
      } // We can listen for modal hidden events on $root


      if (this.$root) {
        this.$root[on ? '$on' : '$off'](MODAL_CLOSE_EVENT, this.$forceHide);
      }
    }
    /* istanbul ignore next */

  }, {
    key: "setRootListener",
    value: function setRootListener(on) {
      // Listen for global 'bv::{hide|show}::{tooltip|popover}' hide request event
      if (this.$root) {
        this.$root[on ? '$on' : '$off']("bv::hide::".concat(this.constructor.NAME), this.$doHide);
        this.$root[on ? '$on' : '$off']("bv::show::".concat(this.constructor.NAME), this.$doShow);
        this.$root[on ? '$on' : '$off']("bv::disable::".concat(this.constructor.NAME), this.$doDisable);
        this.$root[on ? '$on' : '$off']("bv::enable::".concat(this.constructor.NAME), this.$doEnable);
      }
    }
  }, {
    key: "doHide",
    value: function doHide(id) {
      // Programmatically hide tooltip or popover
      if (!id) {
        // Close all tooltips or popovers
        this.forceHide();
      } else if (this.$element && this.$element.id && this.$element.id === id) {
        // Close this specific tooltip or popover
        this.hide();
      }
    }
  }, {
    key: "doShow",
    value: function doShow(id) {
      // Programmatically show tooltip or popover
      if (!id) {
        // Open all tooltips or popovers
        this.show();
      } else if (id && this.$element && this.$element.id && this.$element.id === id) {
        // Show this specific tooltip or popover
        this.show();
      }
    }
  }, {
    key: "doDisable",
    value: function doDisable(id) {
      // Programmatically disable tooltip or popover
      if (!id) {
        // Disable all tooltips or popovers
        this.disable();
      } else if (this.$element && this.$element.id && this.$element.id === id) {
        // Disable this specific tooltip or popover
        this.disable();
      }
    }
  }, {
    key: "doEnable",
    value: function doEnable(id) {
      // Programmatically enable tooltip or popover
      if (!id) {
        // Enable all tooltips or popovers
        this.enable();
      } else if (this.$element && this.$element.id && this.$element.id === id) {
        // Enable this specific tooltip or popover
        this.enable();
      }
    }
    /* istanbul ignore next */

  }, {
    key: "setOnTouchStartListener",
    value: function setOnTouchStartListener(on) {
      var _this9 = this;

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children
      // Only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement) {
        (0, _array.from)(document.body.children).forEach(function (el) {
          if (on) {
            (0, _dom.eventOn)(el, 'mouseover', _this9._noop);
          } else {
            (0, _dom.eventOff)(el, 'mouseover', _this9._noop);
          }
        });
      }
    }
  }, {
    key: "fixTitle",
    value: function fixTitle() {
      var el = this.$element;

      var titleType = _typeof((0, _dom.getAttr)(el, 'data-original-title'));

      if ((0, _dom.getAttr)(el, 'title') || titleType !== 'string') {
        (0, _dom.setAttr)(el, 'data-original-title', (0, _dom.getAttr)(el, 'title') || '');
        (0, _dom.setAttr)(el, 'title', '');
      }
    } // Enter handler

    /* istanbul ignore next */

  }, {
    key: "enter",
    value: function enter(e) {
      var _this10 = this;

      if (e) {
        this.$activeTrigger[e.type === 'focusin' ? 'focus' : 'hover'] = true;
      }

      if ((0, _dom.hasClass)(this.getTipElement(), ClassName.SHOW) || this.$hoverState === HoverState.SHOW) {
        this.$hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(this.$hoverTimeout);
      this.$hoverState = HoverState.SHOW;

      if (!this.$config.delay || !this.$config.delay.show) {
        this.show();
        return;
      }

      this.$hoverTimeout = setTimeout(function () {
        if (_this10.$hoverState === HoverState.SHOW) {
          _this10.show();
        }
      }, this.$config.delay.show);
    } // Leave handler

    /* istanbul ignore next */

  }, {
    key: "leave",
    value: function leave(e) {
      var _this11 = this;

      if (e) {
        this.$activeTrigger[e.type === 'focusout' ? 'focus' : 'hover'] = false;

        if (e.type === 'focusout' && /blur/.test(this.$config.trigger)) {
          // Special case for `blur`: we clear out the other triggers
          this.$activeTrigger.click = false;
          this.$activeTrigger.hover = false;
        }
      }

      if (this.isWithActiveTrigger()) {
        return;
      }

      clearTimeout(this.$hoverTimeout);
      this.$hoverState = HoverState.OUT;

      if (!this.$config.delay || !this.$config.delay.hide) {
        this.hide();
        return;
      }

      this.$hoverTimeout = setTimeout(function () {
        if (_this11.$hoverState === HoverState.OUT) {
          _this11.hide();
        }
      }, this.$config.delay.hide);
    }
  }, {
    key: "getPopperConfig",
    value: function getPopperConfig(placement, tip) {
      var _this12 = this;

      return {
        placement: this.constructor.getAttachment(placement),
        modifiers: {
          offset: {
            offset: this.getOffset(placement, tip)
          },
          flip: {
            behavior: this.$config.fallbackPlacement
          },
          arrow: {
            element: '.arrow'
          },
          preventOverflow: {
            padding: this.$config.boundaryPadding,
            boundariesElement: this.$config.boundary
          }
        },
        onCreate: function onCreate(data) {
          // Handle flipping arrow classes
          if (data.originalPlacement !== data.placement) {
            _this12.handlePopperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          // Handle flipping arrow classes
          _this12.handlePopperPlacementChange(data);
        }
      };
    }
  }, {
    key: "getOffset",
    value: function getOffset(placement, tip) {
      if (!this.$config.offset) {
        var arrow = (0, _dom.select)(Selector.ARROW, tip);
        var arrowOffset = parseFloat((0, _dom.getCS)(arrow).width) + parseFloat(this.$config.arrowPadding);

        switch (OffsetMap[placement.toUpperCase()]) {
          case +1:
            return "+50%p - ".concat(arrowOffset, "px");

          case -1:
            return "-50%p + ".concat(arrowOffset, "px");

          default:
            return 0;
        }
      }

      return this.$config.offset;
    }
  }, {
    key: "getPlacement",
    value: function getPlacement() {
      var placement = this.$config.placement;

      if (typeof placement === 'function') {
        return placement.call(this, this.$tip, this.$element);
      }

      return placement;
    }
  }, {
    key: "isWithActiveTrigger",
    value: function isWithActiveTrigger() {
      for (var trigger in this.$activeTrigger) {
        if (this.$activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    } // NOTE: Overridden by PopOver class

  }, {
    key: "cleanTipClass",
    value: function cleanTipClass() {
      var tip = this.getTipElement();
      var tabClass = tip.className.match(BS_CLASS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        tabClass.forEach(function (cls) {
          (0, _dom.removeClass)(tip, cls);
        });
      }
    }
  }, {
    key: "handlePopperPlacementChange",
    value: function handlePopperPlacementChange(data) {
      this.cleanTipClass();
      this.addAttachmentClass(this.constructor.getAttachment(data.placement));
    }
  }, {
    key: "fixTransition",
    value: function fixTransition(tip) {
      var initConfigAnimation = this.$config.animation || false;

      if ((0, _dom.getAttr)(tip, 'x-placement') !== null) {
        return;
      }

      (0, _dom.removeClass)(tip, ClassName.FADE);
      this.$config.animation = false;
      this.hide();
      this.show();
      this.$config.animation = initConfigAnimation;
    }
  }], [{
    key: "getAttachment",
    value: function getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    }
  }, {
    key: "Default",
    get: function get() {
      return Defaults;
    } // NOTE: Overridden by PopOver class

  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }]);

  return ToolTip;
}();

var _default = ToolTip;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/unprefix-prop-name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _lowerFirst = __webpack_require__("./node_modules/bootstrap-vue/es/utils/lower-first.js");

/**
 * @param {string} prefix
 * @param {string} value
 */
var unprefixPropName = function unprefixPropName(prefix, value) {
  return (0, _lowerFirst.default)(value.replace(prefix, ''));
};

var _default = unprefixPropName;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/upper-first.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * @param {string} str
 */
var upperFirst = function upperFirst(str) {
  if (typeof str !== 'string') {
    str = String(str);
  }

  str = str.trim();
  return str.charAt(0).toUpperCase() + str.slice(1);
};

var _default = upperFirst;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap-vue/es/utils/warn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _env = __webpack_require__("./node_modules/bootstrap-vue/es/utils/env.js");

/**
 * Log a warning message to the console with bootstrap-vue formatting sugar.
 * @param {string} message
 */

/* istanbul ignore next */
var warn = function warn(message) {
  if (!(0, _env.getNoWarn)()) {
    console.warn("[BootstrapVue warn]: ".concat(message));
  }
};

var _default = warn;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.js":
/***/ (function(module, exports, __webpack_require__) {

/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
(function (global, factory) {
   true ? factory(exports, __webpack_require__("./node_modules/jquery/dist/jquery.js"), __webpack_require__("./node_modules/popper.js/dist/esm/popper.js")) :
  typeof define === 'function' && define.amd ? define(['exports', 'jquery', 'popper.js'], factory) :
  (global = global || self, factory(global.bootstrap = {}, global.jQuery, global.Popper));
}(this, function (exports, $, Popper) { 'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */
  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */

  var TRANSITION_END = 'transitionend';
  var MAX_UID = 1000000;
  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: TRANSITION_END,
      delegateType: TRANSITION_END,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    $.fn.emulateTransitionEnd = transitionEndEmulator;
    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        var hrefAttr = element.getAttribute('href');
        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
      }

      try {
        return document.querySelector(selector) ? selector : null;
      } catch (err) {
        return null;
      }
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
      if (!element) {
        return 0;
      } // Get transition-duration of the element


      var transitionDuration = $(element).css('transition-duration');
      var transitionDelay = $(element).css('transition-delay');
      var floatTransitionDuration = parseFloat(transitionDuration);
      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      } // If multiple durations are defined, take the first


      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];
      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(TRANSITION_END);
    },
    // TODO: Remove in v5
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(TRANSITION_END);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    },
    findShadowRoot: function findShadowRoot(element) {
      if (!document.documentElement.attachShadow) {
        return null;
      } // Can find the shadow root otherwise it'll return the document


      if (typeof element.getRootNode === 'function') {
        var root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
      }

      if (element instanceof ShadowRoot) {
        return element;
      } // when we don't find a shadow root


      if (!element.parentNode) {
        return null;
      }

      return Util.findShadowRoot(element.parentNode);
    }
  };
  setTransitionEndSupport();

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME = 'alert';
  var VERSION = '4.3.1';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var Selector = {
    DISMISS: '[data-dismiss="alert"]'
  };
  var Event = {
    CLOSE: "close" + EVENT_KEY,
    CLOSED: "closed" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    SHOW: 'show'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Alert =
  /*#__PURE__*/
  function () {
    function Alert(element) {
      this._element = element;
    } // Getters


    var _proto = Alert.prototype;

    // Public
    _proto.close = function close(element) {
      var rootElement = this._element;

      if (element) {
        rootElement = this._getRootElement(element);
      }

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private
    ;

    _proto._getRootElement = function _getRootElement(element) {
      var selector = Util.getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = document.querySelector(selector);
      }

      if (!parent) {
        parent = $(element).closest("." + ClassName.ALERT)[0];
      }

      return parent;
    };

    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
      var closeEvent = $.Event(Event.CLOSE);
      $(element).trigger(closeEvent);
      return closeEvent;
    };

    _proto._removeElement = function _removeElement(element) {
      var _this = this;

      $(element).removeClass(ClassName.SHOW);

      if (!$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);

        return;
      }

      var transitionDuration = Util.getTransitionDurationFromElement(element);
      $(element).one(Util.TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(transitionDuration);
    };

    _proto._destroyElement = function _destroyElement(element) {
      $(element).detach().trigger(Event.CLOSED).remove();
    } // Static
    ;

    Alert._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    };

    Alert._handleDismiss = function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    };

    _createClass(Alert, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);

    return Alert;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Alert._jQueryInterface;
  $.fn[NAME].Constructor = Alert;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Alert._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$1 = 'button';
  var VERSION$1 = '4.3.1';
  var DATA_KEY$1 = 'bs.button';
  var EVENT_KEY$1 = "." + DATA_KEY$1;
  var DATA_API_KEY$1 = '.data-api';
  var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
  var ClassName$1 = {
    ACTIVE: 'active',
    BUTTON: 'btn',
    FOCUS: 'focus'
  };
  var Selector$1 = {
    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
    DATA_TOGGLE: '[data-toggle="buttons"]',
    INPUT: 'input:not([type="hidden"])',
    ACTIVE: '.active',
    BUTTON: '.btn'
  };
  var Event$1 = {
    CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1)
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Button =
  /*#__PURE__*/
  function () {
    function Button(element) {
      this._element = element;
    } // Getters


    var _proto = Button.prototype;

    // Public
    _proto.toggle = function toggle() {
      var triggerChangeEvent = true;
      var addAriaPressed = true;
      var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLE)[0];

      if (rootElement) {
        var input = this._element.querySelector(Selector$1.INPUT);

        if (input) {
          if (input.type === 'radio') {
            if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            } else {
              var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

              if (activeElement) {
                $(activeElement).removeClass(ClassName$1.ACTIVE);
              }
            }
          }

          if (triggerChangeEvent) {
            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
              return;
            }

            input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
            $(input).trigger('change');
          }

          input.focus();
          addAriaPressed = false;
        }
      }

      if (addAriaPressed) {
        this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
      }

      if (triggerChangeEvent) {
        $(this._element).toggleClass(ClassName$1.ACTIVE);
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$1);
      this._element = null;
    } // Static
    ;

    Button._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$1);

        if (!data) {
          data = new Button(this);
          $(this).data(DATA_KEY$1, data);
        }

        if (config === 'toggle') {
          data[config]();
        }
      });
    };

    _createClass(Button, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$1;
      }
    }]);

    return Button;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    event.preventDefault();
    var button = event.target;

    if (!$(button).hasClass(ClassName$1.BUTTON)) {
      button = $(button).closest(Selector$1.BUTTON);
    }

    Button._jQueryInterface.call($(button), 'toggle');
  }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = $(event.target).closest(Selector$1.BUTTON)[0];
    $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$1] = Button._jQueryInterface;
  $.fn[NAME$1].Constructor = Button;

  $.fn[NAME$1].noConflict = function () {
    $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
    return Button._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$2 = 'carousel';
  var VERSION$2 = '4.3.1';
  var DATA_KEY$2 = 'bs.carousel';
  var EVENT_KEY$2 = "." + DATA_KEY$2;
  var DATA_API_KEY$2 = '.data-api';
  var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var SWIPE_THRESHOLD = 40;
  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  };
  var Direction = {
    NEXT: 'next',
    PREV: 'prev',
    LEFT: 'left',
    RIGHT: 'right'
  };
  var Event$2 = {
    SLIDE: "slide" + EVENT_KEY$2,
    SLID: "slid" + EVENT_KEY$2,
    KEYDOWN: "keydown" + EVENT_KEY$2,
    MOUSEENTER: "mouseenter" + EVENT_KEY$2,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
    TOUCHSTART: "touchstart" + EVENT_KEY$2,
    TOUCHMOVE: "touchmove" + EVENT_KEY$2,
    TOUCHEND: "touchend" + EVENT_KEY$2,
    POINTERDOWN: "pointerdown" + EVENT_KEY$2,
    POINTERUP: "pointerup" + EVENT_KEY$2,
    DRAG_START: "dragstart" + EVENT_KEY$2,
    LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
    CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
  };
  var ClassName$2 = {
    CAROUSEL: 'carousel',
    ACTIVE: 'active',
    SLIDE: 'slide',
    RIGHT: 'carousel-item-right',
    LEFT: 'carousel-item-left',
    NEXT: 'carousel-item-next',
    PREV: 'carousel-item-prev',
    ITEM: 'carousel-item',
    POINTER_EVENT: 'pointer-event'
  };
  var Selector$2 = {
    ACTIVE: '.active',
    ACTIVE_ITEM: '.active.carousel-item',
    ITEM: '.carousel-item',
    ITEM_IMG: '.carousel-item img',
    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
    INDICATORS: '.carousel-indicators',
    DATA_SLIDE: '[data-slide], [data-slide-to]',
    DATA_RIDE: '[data-ride="carousel"]'
  };
  var PointerType = {
    TOUCH: 'touch',
    PEN: 'pen'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Carousel =
  /*#__PURE__*/
  function () {
    function Carousel(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._element = element;
      this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

      this._addEventListeners();
    } // Getters


    var _proto = Carousel.prototype;

    // Public
    _proto.next = function next() {
      if (!this._isSliding) {
        this._slide(Direction.NEXT);
      }
    };

    _proto.nextWhenVisible = function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
        this.next();
      }
    };

    _proto.prev = function prev() {
      if (!this._isSliding) {
        this._slide(Direction.PREV);
      }
    };

    _proto.pause = function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (this._element.querySelector(Selector$2.NEXT_PREV)) {
        Util.triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    };

    _proto.cycle = function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    };

    _proto.to = function to(index) {
      var _this = this;

      this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        $(this._element).one(Event$2.SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

      this._slide(direction, this._items[index]);
    };

    _proto.dispose = function dispose() {
      $(this._element).off(EVENT_KEY$2);
      $.removeData(this._element, DATA_KEY$2);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default, config);
      Util.typeCheckConfig(NAME$2, config, DefaultType);
      return config;
    };

    _proto._handleSwipe = function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax / this.touchDeltaX; // swipe left

      if (direction > 0) {
        this.prev();
      } // swipe right


      if (direction < 0) {
        this.next();
      }
    };

    _proto._addEventListeners = function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        $(this._element).on(Event$2.KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        $(this._element).on(Event$2.MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(Event$2.MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });
      }

      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    };

    _proto._addTouchEventListeners = function _addTouchEventListeners() {
      var _this3 = this;

      if (!this._touchSupported) {
        return;
      }

      var start = function start(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchStartX = event.originalEvent.clientX;
        } else if (!_this3._pointerEvent) {
          _this3.touchStartX = event.originalEvent.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
          _this3.touchDeltaX = 0;
        } else {
          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
        }
      };

      var end = function end(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
        }

        _this3._handleSwipe();

        if (_this3._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this3.pause();

          if (_this3.touchTimeout) {
            clearTimeout(_this3.touchTimeout);
          }

          _this3.touchTimeout = setTimeout(function (event) {
            return _this3.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
        }
      };

      $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
        return e.preventDefault();
      });

      if (this._pointerEvent) {
        $(this._element).on(Event$2.POINTERDOWN, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(ClassName$2.POINTER_EVENT);
      } else {
        $(this._element).on(Event$2.TOUCHSTART, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.TOUCHMOVE, function (event) {
          return move(event);
        });
        $(this._element).on(Event$2.TOUCHEND, function (event) {
          return end(event);
        });
      }
    };

    _proto._keydown = function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;

        default:
      }
    };

    _proto._getItemIndex = function _getItemIndex(element) {
      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
      return this._items.indexOf(element);
    };

    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === Direction.NEXT;
      var isPrevDirection = direction === Direction.PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === Direction.PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    };

    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

      var slideEvent = $.Event(Event$2.SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      $(this._element).trigger(slideEvent);
      return slideEvent;
    };

    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
        $(indicators).removeClass(ClassName$2.ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          $(nextIndicator).addClass(ClassName$2.ACTIVE);
        }
      }
    };

    _proto._slide = function _slide(direction, element) {
      var _this4 = this;

      var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === Direction.NEXT) {
        directionalClassName = ClassName$2.LEFT;
        orderClassName = ClassName$2.NEXT;
        eventDirectionName = Direction.LEFT;
      } else {
        directionalClassName = ClassName$2.RIGHT;
        orderClassName = ClassName$2.PREV;
        eventDirectionName = Direction.RIGHT;
      }

      if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      var slidEvent = $.Event(Event$2.SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if ($(this._element).hasClass(ClassName$2.SLIDE)) {
        $(nextElement).addClass(orderClassName);
        Util.reflow(nextElement);
        $(activeElement).addClass(directionalClassName);
        $(nextElement).addClass(directionalClassName);
        var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

        if (nextElementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = nextElementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
        $(activeElement).one(Util.TRANSITION_END, function () {
          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
          $(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
          _this4._isSliding = false;
          setTimeout(function () {
            return $(_this4._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        $(activeElement).removeClass(ClassName$2.ACTIVE);
        $(nextElement).addClass(ClassName$2.ACTIVE);
        this._isSliding = false;
        $(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    } // Static
    ;

    Carousel._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$2);

        var _config = _objectSpread({}, Default, $(this).data());

        if (typeof config === 'object') {
          _config = _objectSpread({}, _config, config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          $(this).data(DATA_KEY$2, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"" + action + "\"");
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      });
    };

    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
      var selector = Util.getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = $(selector)[0];

      if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
        return;
      }

      var config = _objectSpread({}, $(target).data(), $(this).data());

      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call($(target), config);

      if (slideIndex) {
        $(target).data(DATA_KEY$2).to(slideIndex);
      }

      event.preventDefault();
    };

    _createClass(Carousel, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$2;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Carousel;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
  $(window).on(Event$2.LOAD_DATA_API, function () {
    var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

    for (var i = 0, len = carousels.length; i < len; i++) {
      var $carousel = $(carousels[i]);

      Carousel._jQueryInterface.call($carousel, $carousel.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$2] = Carousel._jQueryInterface;
  $.fn[NAME$2].Constructor = Carousel;

  $.fn[NAME$2].noConflict = function () {
    $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
    return Carousel._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$3 = 'collapse';
  var VERSION$3 = '4.3.1';
  var DATA_KEY$3 = 'bs.collapse';
  var EVENT_KEY$3 = "." + DATA_KEY$3;
  var DATA_API_KEY$3 = '.data-api';
  var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
  var Default$1 = {
    toggle: true,
    parent: ''
  };
  var DefaultType$1 = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event$3 = {
    SHOW: "show" + EVENT_KEY$3,
    SHOWN: "shown" + EVENT_KEY$3,
    HIDE: "hide" + EVENT_KEY$3,
    HIDDEN: "hidden" + EVENT_KEY$3,
    CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
  };
  var ClassName$3 = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector$3 = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

      for (var i = 0, len = toggleList.length; i < len; i++) {
        var elem = toggleList[i];
        var selector = Util.getSelectorFromElement(elem);
        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
          return foundElem === element;
        });

        if (selector !== null && filterElement.length > 0) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    var _proto = Collapse.prototype;

    // Public
    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName$3.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(ClassName$3.COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).not(this._selector).data(DATA_KEY$3);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event$3.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY$3, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event$3.SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event$3.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(ClassName$3.SHOW)) {
              $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$3);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$1, config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      Util.typeCheckConfig(NAME$3, config, DefaultType$1);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      var children = [].slice.call(parent.querySelectorAll(selector));
      $(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = $(element).hasClass(ClassName$3.SHOW);

      if (triggerArray.length) {
        $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static
    ;

    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$3);

        var _config = _objectSpread({}, Default$1, $this.data(), typeof config === 'object' && config ? config : {});

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY$3, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$3;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$1;
      }
    }]);

    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    var selectors = [].slice.call(document.querySelectorAll(selector));
    $(selectors).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY$3);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$3] = Collapse._jQueryInterface;
  $.fn[NAME$3].Constructor = Collapse;

  $.fn[NAME$3].noConflict = function () {
    $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
    return Collapse._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$4 = 'dropdown';
  var VERSION$4 = '4.3.1';
  var DATA_KEY$4 = 'bs.dropdown';
  var EVENT_KEY$4 = "." + DATA_KEY$4;
  var DATA_API_KEY$4 = '.data-api';
  var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
  var Event$4 = {
    HIDE: "hide" + EVENT_KEY$4,
    HIDDEN: "hidden" + EVENT_KEY$4,
    SHOW: "show" + EVENT_KEY$4,
    SHOWN: "shown" + EVENT_KEY$4,
    CLICK: "click" + EVENT_KEY$4,
    CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
  };
  var ClassName$4 = {
    DISABLED: 'disabled',
    SHOW: 'show',
    DROPUP: 'dropup',
    DROPRIGHT: 'dropright',
    DROPLEFT: 'dropleft',
    MENURIGHT: 'dropdown-menu-right',
    MENULEFT: 'dropdown-menu-left',
    POSITION_STATIC: 'position-static'
  };
  var Selector$4 = {
    DATA_TOGGLE: '[data-toggle="dropdown"]',
    FORM_CHILD: '.dropdown form',
    MENU: '.dropdown-menu',
    NAVBAR_NAV: '.navbar-nav',
    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
  };
  var AttachmentMap = {
    TOP: 'top-start',
    TOPEND: 'top-end',
    BOTTOM: 'bottom-start',
    BOTTOMEND: 'bottom-end',
    RIGHT: 'right-start',
    RIGHTEND: 'right-end',
    LEFT: 'left-start',
    LEFTEND: 'left-end'
  };
  var Default$2 = {
    offset: 0,
    flip: true,
    boundary: 'scrollParent',
    reference: 'toggle',
    display: 'dynamic'
  };
  var DefaultType$2 = {
    offset: '(number|string|function)',
    flip: 'boolean',
    boundary: '(string|element)',
    reference: '(string|element)',
    display: 'string'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Dropdown =
  /*#__PURE__*/
  function () {
    function Dropdown(element, config) {
      this._element = element;
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();

      this._addEventListeners();
    } // Getters


    var _proto = Dropdown.prototype;

    // Public
    _proto.toggle = function toggle() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this._element);

      var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);
      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      } // Disable totally Popper.js for Dropdown in Navbar


      if (!this._inNavbar) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (Util.isElement(this._config.reference)) {
          referenceElement = this._config.reference; // Check if it's jQuery element

          if (typeof this._config.reference.jquery !== 'undefined') {
            referenceElement = this._config.reference[0];
          }
        } // If boundary is not `scrollParent`, then set position to `static`
        // to allow the menu to "escape" the scroll parent's boundaries
        // https://github.com/twbs/bootstrap/issues/24251


        if (this._config.boundary !== 'scrollParent') {
          $(parent).addClass(ClassName$4.POSITION_STATIC);
        }

        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
        $(document.body).children().on('mouseover', null, $.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.show = function show() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.hide = function hide() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$4);
      $(this._element).off(EVENT_KEY$4);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();

        this._popper = null;
      }
    };

    _proto.update = function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Private
    ;

    _proto._addEventListeners = function _addEventListeners() {
      var _this = this;

      $(this._element).on(Event$4.CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    };

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);
      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getMenuElement = function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        if (parent) {
          this._menu = parent.querySelector(Selector$4.MENU);
        }
      }

      return this._menu;
    };

    _proto._getPlacement = function _getPlacement() {
      var $parentDropdown = $(this._element.parentNode);
      var placement = AttachmentMap.BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
        placement = AttachmentMap.TOP;

        if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
          placement = AttachmentMap.TOPEND;
        }
      } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
        placement = AttachmentMap.RIGHT;
      } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
        placement = AttachmentMap.LEFT;
      } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
        placement = AttachmentMap.BOTTOMEND;
      }

      return placement;
    };

    _proto._detectNavbar = function _detectNavbar() {
      return $(this._element).closest('.navbar').length > 0;
    };

    _proto._getOffset = function _getOffset() {
      var _this2 = this;

      var offset = {};

      if (typeof this._config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});
          return data;
        };
      } else {
        offset.offset = this._config.offset;
      }

      return offset;
    };

    _proto._getPopperConfig = function _getPopperConfig() {
      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        } // Disable Popper.js if we have a static display

      };

      if (this._config.display === 'static') {
        popperConfig.modifiers.applyStyle = {
          enabled: false
        };
      }

      return popperConfig;
    } // Static
    ;

    Dropdown._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$4);

        var _config = typeof config === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          $(this).data(DATA_KEY$4, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    Dropdown._clearMenus = function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

      for (var i = 0, len = toggles.length; i < len; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = $(toggles[i]).data(DATA_KEY$4);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (event && event.type === 'click') {
          relatedTarget.clickEvent = event;
        }

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!$(parent).hasClass(ClassName$4.SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().off('mouseover', null, $.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');
        $(dropdownMenu).removeClass(ClassName$4.SHOW);
        $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement(element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = document.querySelector(selector);
      }

      return parent || element.parentNode;
    } // eslint-disable-next-line complexity
    ;

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = $(parent).hasClass(ClassName$4.SHOW);

      if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
        if (event.which === ESCAPE_KEYCODE) {
          var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return;
      }

      var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS));

      if (items.length === 0) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // Up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // Down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    _createClass(Dropdown, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$4;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$2;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$2;
      }
    }]);

    return Dropdown;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
    event.preventDefault();
    event.stopPropagation();

    Dropdown._jQueryInterface.call($(this), 'toggle');
  }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
    e.stopPropagation();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$4] = Dropdown._jQueryInterface;
  $.fn[NAME$4].Constructor = Dropdown;

  $.fn[NAME$4].noConflict = function () {
    $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
    return Dropdown._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$5 = 'modal';
  var VERSION$5 = '4.3.1';
  var DATA_KEY$5 = 'bs.modal';
  var EVENT_KEY$5 = "." + DATA_KEY$5;
  var DATA_API_KEY$5 = '.data-api';
  var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default$3 = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType$3 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event$5 = {
    HIDE: "hide" + EVENT_KEY$5,
    HIDDEN: "hidden" + EVENT_KEY$5,
    SHOW: "show" + EVENT_KEY$5,
    SHOWN: "shown" + EVENT_KEY$5,
    FOCUSIN: "focusin" + EVENT_KEY$5,
    RESIZE: "resize" + EVENT_KEY$5,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
    CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
  };
  var ClassName$5 = {
    SCROLLABLE: 'modal-dialog-scrollable',
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$5 = {
    DIALOG: '.modal-dialog',
    MODAL_BODY: '.modal-body',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = element.querySelector(Selector$5.DIALOG);
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollbarWidth = 0;
    } // Getters


    var _proto = Modal.prototype;

    // Public
    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      if ($(this._element).hasClass(ClassName$5.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event$5.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = $.Event(Event$5.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event$5.FOCUSIN);
      $(this._element).removeClass(ClassName$5.SHOW);
      $(this._element).off(Event$5.CLICK_DISMISS);
      $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return $(htmlElement).off(EVENT_KEY$5);
      });
      /**
       * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `Event.CLICK_DATA_API` event that should remain
       */

      $(document).off(Event$5.FOCUSIN);
      $.removeData(this._element, DATA_KEY$5);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$3, config);
      Util.typeCheckConfig(NAME$5, config, DefaultType$3);
      return config;
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this3 = this;

      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE)) {
        this._dialog.querySelector(Selector$5.MODAL_BODY).scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName$5.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event$5.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this3._config.focus) {
          _this3._element.focus();
        }

        _this3._isTransitioning = false;
        $(_this3._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this4 = this;

      $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
      .on(Event$5.FOCUSIN, function (event) {
        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
          _this4._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this5 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE$1) {
            event.preventDefault();

            _this5.hide();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event$5.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this6 = this;

      if (this._isShown) {
        $(window).on(Event$5.RESIZE, function (event) {
          return _this6.handleUpdate(event);
        });
      } else {
        $(window).off(Event$5.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this7 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName$5.OPEN);

        _this7._resetAdjustments();

        _this7._resetScrollbar();

        $(_this7._element).trigger(Event$5.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this8 = this;

      var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName$5.BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
          if (_this8._ignoreBackdropClick) {
            _this8._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this8._config.backdrop === 'static') {
            _this8._element.focus();
          } else {
            _this8.hide();
          }
        });

        if (animate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName$5.SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName$5.SHOW);

        var callbackRemove = function callbackRemove() {
          _this8._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if ($(this._element).hasClass(ClassName$5.FADE)) {
          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------
    ;

    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this9 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

        $(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $(document.body).css('padding-right');
        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }

      $(document.body).addClass(ClassName$5.OPEN);
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
      $(fixedContent).each(function (index, element) {
        var padding = $(element).data('padding-right');
        $(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
      $(elements).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $(document.body).data('padding-right');
      $(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static
    ;

    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$5);

        var _config = _objectSpread({}, Default$3, $(this).data(), typeof config === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY$5, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    _createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$5;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$3;
      }
    }]);

    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
    var _this10 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = document.querySelector(selector);
    }

    var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event$5.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // Only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event$5.HIDDEN, function () {
        if ($(_this10).is(':visible')) {
          _this10.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$5] = Modal._jQueryInterface;
  $.fn[NAME$5].Constructor = Modal;

  $.fn[NAME$5].noConflict = function () {
    $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
    return Modal._jQueryInterface;
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): tools/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */
  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultWhitelist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
    /**
     * A pattern that recognizes a commonly useful subset of URLs that are safe.
     *
     * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
     */

  };
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function allowedAttribute(attr, allowedAttributeList) {
    var attrName = attr.nodeName.toLowerCase();

    if (allowedAttributeList.indexOf(attrName) !== -1) {
      if (uriAttrs.indexOf(attrName) !== -1) {
        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
      }

      return true;
    }

    var regExp = allowedAttributeList.filter(function (attrRegex) {
      return attrRegex instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, l = regExp.length; i < l; i++) {
      if (attrName.match(regExp[i])) {
        return true;
      }
    }

    return false;
  }

  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
    if (unsafeHtml.length === 0) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    var whitelistKeys = Object.keys(whiteList);
    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

    var _loop = function _loop(i, len) {
      var el = elements[i];
      var elName = el.nodeName.toLowerCase();

      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
        el.parentNode.removeChild(el);
        return "continue";
      }

      var attributeList = [].slice.call(el.attributes);
      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
      attributeList.forEach(function (attr) {
        if (!allowedAttribute(attr, whitelistedAttributes)) {
          el.removeAttribute(attr.nodeName);
        }
      });
    };

    for (var i = 0, len = elements.length; i < len; i++) {
      var _ret = _loop(i, len);

      if (_ret === "continue") continue;
    }

    return createdDocument.body.innerHTML;
  }

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$6 = 'tooltip';
  var VERSION$6 = '4.3.1';
  var DATA_KEY$6 = 'bs.tooltip';
  var EVENT_KEY$6 = "." + DATA_KEY$6;
  var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
  var DefaultType$4 = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)',
    boundary: '(string|element)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    whiteList: 'object'
  };
  var AttachmentMap$1 = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default$4 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent',
    sanitize: true,
    sanitizeFn: null,
    whiteList: DefaultWhitelist
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event$6 = {
    HIDE: "hide" + EVENT_KEY$6,
    HIDDEN: "hidden" + EVENT_KEY$6,
    SHOW: "show" + EVENT_KEY$6,
    SHOWN: "shown" + EVENT_KEY$6,
    INSERTED: "inserted" + EVENT_KEY$6,
    CLICK: "click" + EVENT_KEY$6,
    FOCUSIN: "focusin" + EVENT_KEY$6,
    FOCUSOUT: "focusout" + EVENT_KEY$6,
    MOUSEENTER: "mouseenter" + EVENT_KEY$6,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$6
  };
  var ClassName$6 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$6 = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      /**
       * Check for Popper dependency
       * Popper - https://popper.js.org
       */
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
      } // private


      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // Protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // Getters


    var _proto = Tooltip.prototype;

    // Public
    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal');

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper !== null) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var shadowRoot = Util.findShadowRoot(this.element);
        var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName$6.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, {
          placement: attachment,
          modifiers: {
            offset: this._getOffset(),
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Selector$6.ARROW
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(data) {
            if (data.originalPlacement !== data.placement) {
              _this._handlePopperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate(data) {
            return _this._handlePopperPlacementChange(data);
          }
        });
        $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if ($(this.tip).hasClass(ClassName$6.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $(document.body).children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if ($(this.tip).hasClass(ClassName$6.FADE)) {
        var transitionDuration = Util.getTransitionDurationFromElement(tip);
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected
    ;

    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var tip = this.getTipElement();
      this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
      $(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private
    ;

    _proto._getOffset = function _getOffset() {
      var _this3 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread({}, data.offsets, _this3.config.offset(data.offsets, _this3.element) || {});
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    };

    _proto._getContainer = function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (Util.isElement(this.config.container)) {
        return $(this.config.container);
      }

      return $(document).find(this.config.container);
    };

    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap$1[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this4 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this4.element).on(_this4.constructor.Event.CLICK, _this4.config.selector, function (event) {
            return _this4.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSEENTER : _this4.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSELEAVE : _this4.constructor.Event.FOCUSOUT;
          $(_this4.element).on(eventIn, _this4.config.selector, function (event) {
            return _this4._enter(event);
          }).on(eventOut, _this4.config.selector, function (event) {
            return _this4._leave(event);
          });
        }
      });
      $(this.element).closest('.modal').on('hide.bs.modal', function () {
        if (_this4.element) {
          _this4.hide();
        }
      });

      if (this.config.selector) {
        this.config = _objectSpread({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = typeof this.element.getAttribute('data-original-title');

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      var dataAttributes = $(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread({}, this.constructor.Default, dataAttributes, typeof config === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
      var popperInstance = popperData.instance;
      this.tip = popperInstance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName$6.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static
    ;

    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$6);

        var _config = typeof config === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY$6, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$6;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$4;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$6;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$6;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$6;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$6;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$4;
      }
    }]);

    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$6] = Tooltip._jQueryInterface;
  $.fn[NAME$6].Constructor = Tooltip;

  $.fn[NAME$6].noConflict = function () {
    $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
    return Tooltip._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$7 = 'popover';
  var VERSION$7 = '4.3.1';
  var DATA_KEY$7 = 'bs.popover';
  var EVENT_KEY$7 = "." + DATA_KEY$7;
  var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
  var CLASS_PREFIX$1 = 'bs-popover';
  var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

  var Default$5 = _objectSpread({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });

  var DefaultType$5 = _objectSpread({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });

  var ClassName$7 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$7 = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event$7 = {
    HIDE: "hide" + EVENT_KEY$7,
    HIDDEN: "hidden" + EVENT_KEY$7,
    SHOW: "show" + EVENT_KEY$7,
    SHOWN: "shown" + EVENT_KEY$7,
    INSERTED: "inserted" + EVENT_KEY$7,
    CLICK: "click" + EVENT_KEY$7,
    FOCUSIN: "focusin" + EVENT_KEY$7,
    FOCUSOUT: "focusout" + EVENT_KEY$7,
    MOUSEENTER: "mouseenter" + EVENT_KEY$7,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$7
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    _inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype;

    // Overrides
    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(Selector$7.CONTENT), content);
      $tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
    } // Private
    ;

    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    } // Static
    ;

    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$7);

        var _config = typeof config === 'object' ? config : null;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY$7, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Popover, null, [{
      key: "VERSION",
      // Getters
      get: function get() {
        return VERSION$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$5;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$7;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$7;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$7;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$7;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$5;
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$7] = Popover._jQueryInterface;
  $.fn[NAME$7].Constructor = Popover;

  $.fn[NAME$7].noConflict = function () {
    $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
    return Popover._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$8 = 'scrollspy';
  var VERSION$8 = '4.3.1';
  var DATA_KEY$8 = 'bs.scrollspy';
  var EVENT_KEY$8 = "." + DATA_KEY$8;
  var DATA_API_KEY$6 = '.data-api';
  var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
  var Default$6 = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType$6 = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var Event$8 = {
    ACTIVATE: "activate" + EVENT_KEY$8,
    SCROLL: "scroll" + EVENT_KEY$8,
    LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
  };
  var ClassName$8 = {
    DROPDOWN_ITEM: 'dropdown-item',
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active'
  };
  var Selector$8 = {
    DATA_SPY: '[data-spy="scroll"]',
    ACTIVE: '.active',
    NAV_LIST_GROUP: '.nav, .list-group',
    NAV_LINKS: '.nav-link',
    NAV_ITEMS: '.nav-item',
    LIST_ITEMS: '.list-group-item',
    DROPDOWN: '.dropdown',
    DROPDOWN_ITEMS: '.dropdown-item',
    DROPDOWN_TOGGLE: '.dropdown-toggle'
  };
  var OffsetMethod = {
    OFFSET: 'offset',
    POSITION: 'position'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var ScrollSpy =
  /*#__PURE__*/
  function () {
    function ScrollSpy(element, config) {
      var _this = this;

      this._element = element;
      this._scrollElement = element.tagName === 'BODY' ? window : element;
      this._config = this._getConfig(config);
      this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      $(this._scrollElement).on(Event$8.SCROLL, function (event) {
        return _this._process(event);
      });
      this.refresh();

      this._process();
    } // Getters


    var _proto = ScrollSpy.prototype;

    // Public
    _proto.refresh = function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = [].slice.call(document.querySelectorAll(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = Util.getSelectorFromElement(element);

        if (targetSelector) {
          target = document.querySelector(targetSelector);
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // TODO (fat): remove sketch reliance on jQuery position/offset
            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$8);
      $(this._scrollElement).off(EVENT_KEY$8);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$6, typeof config === 'object' && config ? config : {});

      if (typeof config.target !== 'string') {
        var id = $(config.target).attr('id');

        if (!id) {
          id = Util.getUID(NAME$8);
          $(config.target).attr('id', id);
        }

        config.target = "#" + id;
      }

      Util.typeCheckConfig(NAME$8, config, DefaultType$6);
      return config;
    };

    _proto._getScrollTop = function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    };

    _proto._getScrollHeight = function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    };

    _proto._getOffsetHeight = function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    };

    _proto._process = function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      var offsetLength = this._offsets.length;

      for (var i = offsetLength; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    };

    _proto._activate = function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(',').map(function (selector) {
        return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
      });

      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

      if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
        $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
        $link.addClass(ClassName$8.ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
      }

      $(this._scrollElement).trigger(Event$8.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
        return node.classList.contains(ClassName$8.ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(ClassName$8.ACTIVE);
      });
    } // Static
    ;

    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$8);

        var _config = typeof config === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $(this).data(DATA_KEY$8, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(ScrollSpy, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$8;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$6;
      }
    }]);

    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(window).on(Event$8.LOAD_DATA_API, function () {
    var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
    var scrollSpysLength = scrollSpys.length;

    for (var i = scrollSpysLength; i--;) {
      var $spy = $(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$8] = ScrollSpy._jQueryInterface;
  $.fn[NAME$8].Constructor = ScrollSpy;

  $.fn[NAME$8].noConflict = function () {
    $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
    return ScrollSpy._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$9 = 'tab';
  var VERSION$9 = '4.3.1';
  var DATA_KEY$9 = 'bs.tab';
  var EVENT_KEY$9 = "." + DATA_KEY$9;
  var DATA_API_KEY$7 = '.data-api';
  var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
  var Event$9 = {
    HIDE: "hide" + EVENT_KEY$9,
    HIDDEN: "hidden" + EVENT_KEY$9,
    SHOW: "show" + EVENT_KEY$9,
    SHOWN: "shown" + EVENT_KEY$9,
    CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
  };
  var ClassName$9 = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$9 = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event$9.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event$9.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event$9.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event$9.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$9);
      this._element = null;
    } // Private
    ;

    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = Util.getTransitionDurationFromElement(active);
        $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $(active).removeClass(ClassName$9.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName$9.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName$9.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);

      if (element.classList.contains(ClassName$9.FADE)) {
        element.classList.add(ClassName$9.SHOW);
      }

      if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
          $(dropdownToggleList).addClass(ClassName$9.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static
    ;

    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$9);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY$9, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$9;
      }
    }]);

    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$9] = Tab._jQueryInterface;
  $.fn[NAME$9].Constructor = Tab;

  $.fn[NAME$9].noConflict = function () {
    $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
    return Tab._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME$a = 'toast';
  var VERSION$a = '4.3.1';
  var DATA_KEY$a = 'bs.toast';
  var EVENT_KEY$a = "." + DATA_KEY$a;
  var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
  var Event$a = {
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
    HIDE: "hide" + EVENT_KEY$a,
    HIDDEN: "hidden" + EVENT_KEY$a,
    SHOW: "show" + EVENT_KEY$a,
    SHOWN: "shown" + EVENT_KEY$a
  };
  var ClassName$a = {
    FADE: 'fade',
    HIDE: 'hide',
    SHOW: 'show',
    SHOWING: 'showing'
  };
  var DefaultType$7 = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default$7 = {
    animation: true,
    autohide: true,
    delay: 500
  };
  var Selector$a = {
    DATA_DISMISS: '[data-dismiss="toast"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Toast =
  /*#__PURE__*/
  function () {
    function Toast(element, config) {
      this._element = element;
      this._config = this._getConfig(config);
      this._timeout = null;

      this._setListeners();
    } // Getters


    var _proto = Toast.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      $(this._element).trigger(Event$a.SHOW);

      if (this._config.animation) {
        this._element.classList.add(ClassName$a.FADE);
      }

      var complete = function complete() {
        _this._element.classList.remove(ClassName$a.SHOWING);

        _this._element.classList.add(ClassName$a.SHOW);

        $(_this._element).trigger(Event$a.SHOWN);

        if (_this._config.autohide) {
          _this.hide();
        }
      };

      this._element.classList.remove(ClassName$a.HIDE);

      this._element.classList.add(ClassName$a.SHOWING);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto.hide = function hide(withoutTimeout) {
      var _this2 = this;

      if (!this._element.classList.contains(ClassName$a.SHOW)) {
        return;
      }

      $(this._element).trigger(Event$a.HIDE);

      if (withoutTimeout) {
        this._close();
      } else {
        this._timeout = setTimeout(function () {
          _this2._close();
        }, this._config.delay);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      this._timeout = null;

      if (this._element.classList.contains(ClassName$a.SHOW)) {
        this._element.classList.remove(ClassName$a.SHOW);
      }

      $(this._element).off(Event$a.CLICK_DISMISS);
      $.removeData(this._element, DATA_KEY$a);
      this._element = null;
      this._config = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$7, $(this._element).data(), typeof config === 'object' && config ? config : {});
      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
      return config;
    };

    _proto._setListeners = function _setListeners() {
      var _this3 = this;

      $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
        return _this3.hide(true);
      });
    };

    _proto._close = function _close() {
      var _this4 = this;

      var complete = function complete() {
        _this4._element.classList.add(ClassName$a.HIDE);

        $(_this4._element).trigger(Event$a.HIDDEN);
      };

      this._element.classList.remove(ClassName$a.SHOW);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    } // Static
    ;

    Toast._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY$a);

        var _config = typeof config === 'object' && config;

        if (!data) {
          data = new Toast(this, _config);
          $element.data(DATA_KEY$a, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](this);
        }
      });
    };

    _createClass(Toast, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$a;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$7;
      }
    }]);

    return Toast;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$a] = Toast._jQueryInterface;
  $.fn[NAME$a].Constructor = Toast;

  $.fn[NAME$a].noConflict = function () {
    $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
    return Toast._jQueryInterface;
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  (function () {
    if (typeof $ === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = $.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  })();

  exports.Util = Util;
  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=bootstrap.js.map


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/vue-css-donut-chart/dist/vcdonut.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".cdc-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.cdc{height:auto;position:relative;-ms-flex-negative:0;flex-shrink:0}.cdc,.cdc-overlay{border-radius:50%;overflow:hidden}.cdc-overlay{opacity:1;position:absolute;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.cdc-text{text-align:center}.cdc-legend{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-top:1em;-ms-flex-wrap:wrap;flex-wrap:wrap}.cdc-legend-item{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:.5em}.cdc-legend-item-color{height:1.25em;width:1.25em;border-radius:2px;margin-right:.5em}.cdc-sections{position:absolute;height:auto;width:100%;padding-bottom:100%;border-radius:50%}.cdc-section{width:50%;overflow:hidden;background-color:transparent;-webkit-transform-origin:0 50%;transform-origin:0 50%;pointer-events:none}.cdc-filler,.cdc-section{position:absolute;height:100%}.cdc-filler{width:100%;pointer-events:all}.cdc-section.cdc-section-right{left:50%}.cdc-section.cdc-section-right .cdc-filler{-webkit-transform-origin:0 50%;transform-origin:0 50%}.cdc-section.cdc-section-left{left:0}.cdc-section.cdc-section-left,.cdc-section.cdc-section-left .cdc-filler{-webkit-transform-origin:100% 50%;transform-origin:100% 50%}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n[v-cloak][data-v-15965e3b] {\n  display: none;\n}\n.vuetable th.sortable[data-v-15965e3b]:hover {\n  color: #2185d0;\n  cursor: pointer;\n}\n.vuetable-body-wrapper[data-v-15965e3b] {\n  position:relative;\n  overflow-y:auto;\n}\n.vuetable-head-wrapper[data-v-15965e3b] {\n  overflow-x: hidden;\n}\n.vuetable-actions[data-v-15965e3b] {\n  width: 15%;\n  padding: 12px 0px;\n  text-align: center;\n}\n.vuetable-pagination[data-v-15965e3b] {\n  background: #f9fafb !important;\n}\n.vuetable-pagination-info[data-v-15965e3b] {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n.vuetable-empty-result[data-v-15965e3b] {\n  text-align: center;\n}\n.vuetable-clip-text[data-v-15965e3b] {\n  white-space: pre-wrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  display: block;\n}\n.vuetable-semantic-no-top[data-v-15965e3b] {\n  border-top:none !important;\n  margin-top:0 !important;\n}\n.vuetable-fixed-layout[data-v-15965e3b] {\n  table-layout: fixed;\n}\n.vuetable-gutter-col[data-v-15965e3b] {\n  padding: 0 !important;\n  border-left: none  !important;\n  border-right: none  !important;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.15.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/vue-apexcharts/dist/vue-apexcharts.js":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory(__webpack_require__("./node_modules/apexcharts/dist/apexcharts.esm.js")) :
  typeof define === 'function' && define.amd ? define(['apexcharts'], factory) :
  (global.VueApexCharts = factory(global.ApexCharts));
}(this, (function (ApexCharts) { 'use strict';

  ApexCharts = ApexCharts && ApexCharts.hasOwnProperty('default') ? ApexCharts['default'] : ApexCharts;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var ApexChartsComponent = {
    props: {
      options: {
        type: Object
      },
      type: {
        type: String,
        default: 'line'
      },
      series: {
        type: Array,
        required: true,
        default: function _default() {
          return [];
        }
      },
      width: {
        default: '100%'
      },
      height: {
        default: 'auto'
      }
    },
    data: function data() {
      return {
        chart: null
      };
    },
    beforeMount: function beforeMount() {
      window.ApexCharts = ApexCharts;
    },
    mounted: function mounted() {
      this.init();
    },
    created: function created() {
      var _this = this;

      this.$watch('options', function (options) {
        if (!_this.chart && options) {
          _this.init();
        } else {
          _this.chart.updateOptions(_this.options);
        }
      });
      this.$watch('series', function (series) {
        if (!_this.chart && series) {
          _this.init();
        } else {
          _this.chart.updateSeries(_this.series);
        }
      }, {
        deep: true
      });
      var watched = ['type', 'width', 'height'];
      watched.forEach(function (prop) {
        _this.$watch(prop, function () {
          _this.refresh();
        });
      });
    },
    beforeDestroy: function beforeDestroy() {
      if (!this.chart) {
        return;
      }

      this.destroy();
    },
    render: function render(createElement) {
      return createElement('div');
    },
    methods: {
      init: function init() {
        var _this2 = this;

        var newOptions = {
          chart: {
            type: this.type,
            height: this.height,
            width: this.width,
            events: {}
          },
          series: this.series
        };
        Object.keys(this.$listeners).forEach(function (evt) {
          newOptions.chart.events[evt] = _this2.$listeners[evt];
        });
        var config = this.extend(this.options, newOptions);
        this.chart = new ApexCharts(this.$el, config);
        this.chart.render();
      },
      isObject: function isObject(item) {
        return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;
      },
      extend: function extend(target, source) {
        var _this3 = this;

        if (typeof Object.assign !== 'function') {
          (function () {
            Object.assign = function (target) {
              // We must check against these specific cases.
              if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
              }

              var output = Object(target);

              for (var index = 1; index < arguments.length; index++) {
                var _source = arguments[index];

                if (_source !== undefined && _source !== null) {
                  for (var nextKey in _source) {
                    if (_source.hasOwnProperty(nextKey)) {
                      output[nextKey] = _source[nextKey];
                    }
                  }
                }
              }

              return output;
            };
          })();
        }

        var output = Object.assign({}, target);

        if (this.isObject(target) && this.isObject(source)) {
          Object.keys(source).forEach(function (key) {
            if (_this3.isObject(source[key])) {
              if (!(key in target)) {
                Object.assign(output, _defineProperty({}, key, source[key]));
              } else {
                output[key] = _this3.extend(target[key], source[key]);
              }
            } else {
              Object.assign(output, _defineProperty({}, key, source[key]));
            }
          });
        }

        return output;
      },
      refresh: function refresh() {
        this.destroy();
        this.init();
      },
      destroy: function destroy() {
        this.chart.destroy();
      },
      updateSeries: function updateSeries(newSeries, animate) {
        this.chart.updateSeries(newSeries, animate);
      },
      updateOptions: function updateOptions(newOptions, redrawPaths, animate) {
        this.chart.updateOptions(newOptions, redrawPaths, animate);
      },
      toggleSeries: function toggleSeries(seriesName) {
        this.chart.toggleSeries(seriesName);
      },
      resetSeries: function resetSeries() {
        this.chart.resetSeries();
      },
      toggleDataPointSelection: function toggleDataPointSelection(seriesIndex, dataPointIndex) {
        this.chart.toggleDataPointSelection(seriesIndex, dataPointIndex);
      },
      appendData: function appendData(newData) {
        this.chart.appendData(newData);
      },
      addText: function addText(options) {
        this.chart.addText(options);
      },
      dataURI: function dataURI() {
        return this.chart.dataURI();
      },
      addXaxisAnnotation: function addXaxisAnnotation(options, pushToMemory) {
        this.chart.addXaxisAnnotation(options, pushToMemory);
      },
      addYaxisAnnotation: function addYaxisAnnotation(options, pushToMemory) {
        this.chart.addYaxisAnnotation(options, pushToMemory);
      },
      addPointAnnotation: function addPointAnnotation(options, pushToMemory) {
        this.chart.addPointAnnotation(options, pushToMemory);
      },
      clearAnnotations: function clearAnnotations() {
        this.chart.clearAnnotations();
      }
    }
  };

  var VueApexCharts = ApexChartsComponent;
  window.ApexCharts = ApexCharts;

  VueApexCharts.install = function (Vue) {
    //adding a global method or property
    Vue.ApexCharts = ApexCharts;
    window.ApexCharts = ApexCharts; // add the instance method

    Object.defineProperty(Vue.prototype, '$apexcharts', {
      get: function get() {
        return ApexCharts;
      }
    });
  };

  return VueApexCharts;

})));


/***/ }),

/***/ "./node_modules/vue-css-donut-chart/dist/vcdonut.common.js":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "7e79":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f6fd":
/***/ (function(module, exports) {

// document.currentScript polyfill by Adam Miller

// MIT license

(function(document){
  var currentScript = "currentScript",
      scripts = document.getElementsByTagName('script'); // Live NodeList collection

  // If browser needs currentScript polyfill, add get currentScript() to the document object
  if (!(currentScript in document)) {
    Object.defineProperty(document, currentScript, {
      get: function(){

        // IE 6-10 supports script readyState
        // IE 10+ support stack trace
        try { throw new Error(); }
        catch (err) {

          // Find the second match for the "at" string to get file src url from stack.
          // Specifically works with the format of stack traces in IE.
          var i, res = ((/.*at [^\(]*\((.*):.+:.+\)$/ig).exec(err.stack) || [false])[1];

          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag
          for(i in scripts){
            if(scripts[i].src == res || scripts[i].readyState == "interactive"){
              return scripts[i];
            }
          }

          // If no match, return null
          return null;
        }
      }
    });
  }
})(document);


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  if (true) {
    __webpack_require__("f6fd")
  }

  var setPublicPath_i
  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"40566109-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Donut.vue?vue&type=template&id=651bd70d&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"cdc-container",style:(_vm.placementStyles.container)},[_c('div',{ref:"donut",staticClass:"cdc",style:(_vm.donutStyles)},[_c('DonutSections',{attrs:{"sections":_vm.donutSections,"start-angle":_vm.startAngle},on:{"section-click":_vm.emitSectionClick}}),_c('div',{staticClass:"cdc-overlay",style:(_vm.overlayStyles)},[_c('div',{staticClass:"cdc-text",style:(_vm.donutTextStyles)},[_vm._t("default",[_vm._v(_vm._s(_vm.text))])],2)])],1),_vm._t("legend",[(_vm.hasLegend)?_c('div',{staticClass:"cdc-legend",style:(_vm.placementStyles.legend)},_vm._l((_vm.legend),function(item,idx){return _c('span',{key:idx,staticClass:"cdc-legend-item",attrs:{"title":item.percent}},[_c('span',{staticClass:"cdc-legend-item-color",style:(item.styles)}),_c('span',[_vm._v(_vm._s(item.label))])])}),0):_vm._e()])],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/Donut.vue?vue&type=template&id=651bd70d&

// CONCATENATED MODULE: ./src/utils/colors.js
var colors = ['#FF6384', '#36A2EB', '#FFCE56', '#F58231', '#46F0F0', '#D2F53C', '#911EB4', '#F032E6', '#3CB44B', '#FFE119', '#E6194B', '#FABEBE', '#008080', '#E6BEFF', '#0082C8', '#AA6E28', '#FFFAC8', '#800000', '#AAFFC3', '#808000', '#FFD8B1', '#000080', '#808080', '#000000'];
/* harmony default export */ var utils_colors = (colors);
// CONCATENATED MODULE: ./src/utils/misc.js
var _placementStyles;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var legendGap = '1em';
var defaultColor = 'dodgerblue';
var placement = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left'
};
var misc_placementStyles = (_placementStyles = {}, _defineProperty(_placementStyles, placement.TOP, {
  container: {
    flexDirection: 'column'
  },
  legend: {
    order: -1,
    margin: 0,
    marginBottom: legendGap
  }
}), _defineProperty(_placementStyles, placement.RIGHT, {
  container: {},
  legend: {
    flexDirection: 'column',
    margin: 0,
    marginLeft: legendGap
  }
}), _defineProperty(_placementStyles, placement.BOTTOM, {
  container: {
    flexDirection: 'column'
  },
  legend: {}
}), _defineProperty(_placementStyles, placement.LEFT, {
  container: {},
  legend: {
    flexDirection: 'column',
    order: -1,
    margin: 0,
    marginRight: legendGap
  }
}), _placementStyles);

var isObject = function isObject(obj) {
  return !!obj && obj.constructor === Object;
};

var sectionKeys = [{
  type: 'number',
  key: 'value',
  required: true
}, {
  key: 'label'
}, {
  key: 'color'
}];
function sectionValidator(section) {
  if (!isObject(section)) return false;
  return sectionKeys.reduce(function (acc, curr) {
    if (!acc) return false;
    var valid = true;
    if (curr.required) valid = valid && Object.hasOwnProperty.call(section, curr.key);
    if (curr.type) valid = valid && _typeof(section[curr.key]) === curr.type;
    return acc && valid;
  }, true);
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"40566109-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/DonutSections.vue?vue&type=template&id=aecb9232&
var DonutSectionsvue_type_template_id_aecb9232_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"cdc-sections",style:(_vm.containerStyles)},_vm._l((_vm.dSections),function(section,idx){return _c('div',{key:idx,staticClass:"cdc-section",class:section.className,style:(section.sectionStyles),on:{"click":function($event){return _vm.emitClick(_vm.sections[idx])}}},[_c('div',{staticClass:"cdc-filler",style:(section.fillerStyles),attrs:{"title":section.label}})])}),0)}
var DonutSectionsvue_type_template_id_aecb9232_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/DonutSections.vue?vue&type=template&id=aecb9232&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/DonutSections.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//

var sectionClass = {
  LEFT: 'cdc-section-left',
  RIGHT: 'cdc-section-right'
};
/* harmony default export */ var DonutSectionsvue_type_script_lang_js_ = ({
  props: {
    startAngle: {
      type: Number,
      default: 0
    },
    sections: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    containerStyles: function containerStyles() {
      return {
        transform: "rotate(".concat(this.startAngle, "deg)")
      };
    },
    dSections: function dSections() {
      var maxDegreesPerSection = 180;
      var degreesConsumed = 0;
      var offsetBy = 0;
      var sections = this.sections.map(function (section) {
        var _ref = [sectionClass.RIGHT, -180],
            className = _ref[0],
            offset = _ref[1];

        if (degreesConsumed >= maxDegreesPerSection) {
          var _ref2 = [sectionClass.LEFT, 180];
          className = _ref2[0];
          offset = _ref2[1];
        }

        var degree = offset + section.degree;
        var fillerStyles = {
          backgroundColor: section.color || defaultColor,
          transform: "rotate(".concat(degree, "deg)")
        };
        var sectionStyles = {
          transform: "rotate(".concat(offsetBy, "deg)")
        };
        degreesConsumed += section.degree;
        if (degreesConsumed === 180) offsetBy = 0;else offsetBy += section.degree;
        return {
          label: section.label,
          className: className,
          fillerStyles: fillerStyles,
          sectionStyles: sectionStyles
        };
      });
      return sections;
    }
  },
  methods: {
    emitClick: function emitClick(section) {
      this.$emit('section-click', section);
    }
  }
});
// CONCATENATED MODULE: ./src/components/DonutSections.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_DonutSectionsvue_type_script_lang_js_ = (DonutSectionsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/DonutSections.vue





/* normalize component */

var component = normalizeComponent(
  components_DonutSectionsvue_type_script_lang_js_,
  DonutSectionsvue_type_template_id_aecb9232_render,
  DonutSectionsvue_type_template_id_aecb9232_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DonutSections = (component.exports);
// EXTERNAL MODULE: ./src/styles/main.css
var main = __webpack_require__("7e79");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Donut.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var Donutvue_type_script_lang_js_ = ({
  name: 'vc-donut',
  props: {
    // diameter of the donut
    size: {
      type: Number,
      default: 250,
      validator: function validator(v) {
        return v > 0;
      }
    },
    // unit to use for `size`
    unit: {
      type: String,
      default: 'px'
    },
    // percentage of donut ring's thickness
    thickness: {
      type: Number,
      default: 20,
      validator: function validator(v) {
        return v >= 0 && v <= 100;
      }
    },
    // text in the middle of the donut, this can also be passed using the default slot
    text: {
      type: String,
      default: null
    },
    // color to use for the middle of the donut
    // set this to `transparent` or `thickness` to 100 to make a pie chart instead
    background: {
      type: String,
      default: '#ffffff'
    },
    // color to use for the empty ring areas
    foreground: {
      type: String,
      default: '#eeeeee'
    },
    // sections of the donut, must have a `degree` property
    // other valid properties are `label` and `color` (default is `dodgerblue`)
    sections: {
      type: Array,
      default: function _default() {
        return [];
      },
      validator: function validator(sections) {
        for (var i = 0; i < sections.length; ++i) {
          if (!sectionValidator(sections[i])) return false;
        }

        return true;
      }
    },
    total: {
      type: Number,
      default: 100,
      validator: function validator(v) {
        return v > 0;
      }
    },
    hasLegend: {
      type: Boolean,
      default: false
    },
    legendPlacement: {
      default: placement.BOTTOM,
      validator: function validator(val) {
        return !!placement[val.toUpperCase()];
      }
    },
    // degree angle at which the first section begins
    startAngle: {
      type: Number,
      default: 0
    }
  },
  watch: {
    size: function size() {
      this.recalcFontSize();
    },
    unit: function unit() {
      this.recalcFontSize();
    }
  },
  data: function data() {
    return {
      donutEl: null,
      fontSize: '1em',
      resizeListener: null
    };
  },
  computed: {
    donutSections: function donutSections() {
      var _this = this;

      var valueTotal = this.sections.reduce(function (a, c) {
        return a + c.value;
      }, 0);

      if (valueTotal > this.total) {
        var err = "Sum of all the sections' values (".concat(valueTotal, ") should not exceed `total` (").concat(this.total, ")");
        throw new Error(err);
      }

      var degreesInACircle = 360;
      var degreesInASection = 180;
      var consumedDegrees = 0;
      var currentDefaultColorIdx = 0;
      var sections = [];
      this.sections.forEach(function (section) {
        var valToDeg = degreesInACircle * (section.value / _this.total);
        var degreeArr = [valToDeg];

        if (valToDeg > degreesInASection) {
          degreeArr = [degreesInASection, valToDeg - degreesInASection];
        }

        var color = section.color || utils_colors[currentDefaultColorIdx++];
        degreeArr.forEach(function (degree) {
          var consumedWithCurrent = consumedDegrees + degree;

          if (consumedWithCurrent > degreesInASection) {
            var remainingDegreesInCurrentSection = degreesInASection - consumedDegrees;
            sections.push(Object.assign({}, section, {
              degree: remainingDegreesInCurrentSection,
              color: color
            }), Object.assign({}, section, {
              degree: degree - remainingDegreesInCurrentSection,
              color: color
            }));
          } else {
            sections.push(Object.assign({}, section, {
              degree: degree,
              color: color
            }));
          }

          consumedDegrees += degree;

          if (consumedDegrees >= degreesInASection) {
            consumedDegrees -= degreesInASection;
          }
        });
      });
      return sections;
    },
    legend: function legend() {
      var _this2 = this;

      if (!this.hasLegend) return null;
      var currentDefaultColorIdx = 0;
      return this.sections.map(function (section, idx) {
        return {
          label: section.label || "Section ".concat(idx + 1),
          percent: "".concat(section.value, " (").concat(section.value / _this2.total * 100, "%)"),
          styles: {
            backgroundColor: section.color || utils_colors[currentDefaultColorIdx++]
          }
        };
      });
    },
    placementStyles: function placementStyles() {
      if (!this.hasLegend) return {};
      return misc_placementStyles[this.legendPlacement];
    },
    donutStyles: function donutStyles() {
      var size = "".concat(this.size).concat(this.unit);
      var styles = {
        width: size,
        paddingBottom: size,
        backgroundColor: this.foreground
      };
      return styles;
    },
    overlayStyles: function overlayStyles() {
      var availablePercent = 100;
      var size = availablePercent - this.thickness;
      var sizePercent = "".concat(size, "%");
      var pos = "calc(50% - ".concat(size / 2, "%)");
      return {
        height: sizePercent,
        width: sizePercent,
        top: pos,
        left: pos,
        backgroundColor: this.background
      };
    },
    donutTextStyles: function donutTextStyles() {
      var fontSize = this.fontSize;
      return {
        fontSize: fontSize
      };
    }
  },
  methods: {
    recalcFontSize: function recalcFontSize() {
      var _this3 = this;

      var scaleDownBy = 0.08;
      var widthInPx = this.size;
      this.$nextTick(function () {
        if (_this3.unit !== 'px') {
          if (_this3.donutEl) widthInPx = _this3.donutEl.clientWidth;else widthInPx = null;
        }

        _this3.fontSize = widthInPx ? "".concat((widthInPx * scaleDownBy).toFixed(2), "px") : '1em';
      });
    },
    emitSectionClick: function emitSectionClick(section) {
      this.$emit('section-click', section);
    }
  },
  mounted: function mounted() {
    this.donutEl = this.$refs.donut;
    this.recalcFontSize();
    this.resizeListener = this.recalcFontSize.bind(this);
    window.addEventListener('resize', this.resizeListener);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.resizeListener);
  },
  components: {
    DonutSections: DonutSections
  }
});
// CONCATENATED MODULE: ./src/components/Donut.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Donutvue_type_script_lang_js_ = (Donutvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/Donut.vue





/* normalize component */

var Donut_component = normalizeComponent(
  components_Donutvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Donut = (Donut_component.exports);
// CONCATENATED MODULE: ./src/index.js

var DonutPlugin = {
  install: function install(Vue) {
    Vue.component(Donut.name, Donut);
  }
};
/* harmony default export */ var src = (DonutPlugin);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src);



/***/ })

/******/ });

/***/ }),

/***/ "./node_modules/vue-css-donut-chart/dist/vcdonut.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js!./node_modules/vue-css-donut-chart/dist/vcdonut.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("./node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../css-loader/index.js!./vcdonut.css", function() {
			var newContent = require("!!../../css-loader/index.js!./vcdonut.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-events/dist/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function plugin(Vue) {

  // Exit if the plugin has already been installed.
  if (plugin.installed) return;

  // Create a `vm` to serve as our global event bus.
  var events = new Vue({
    methods: {
      /**
       * Emit the given event.
       *
       * @param {string|object} event
       * @param {...*} args
       */
      emit: function emit(event) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this.$emit.apply(this, [event].concat(args));
      },


      /**
       * Emit the given event.
       *
       * @param {string|object} event
       * @param {...*} args
       */
      fire: function fire(event) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this.emit.apply(this, [event].concat(args));
      },


      /**
       * Listen for the given event.
       *
       * @param {string} event
       * @param {function} callback
       */
      on: function on(event, callback) {
        this.$on(event, callback);
      },


      /**
       * Listen for the given event.
       *
       * @param {string} event
       * @param {function} callback
       */
      listen: function listen(event, callback) {
        this.on(event, callback);
      },


      /**
       * Listen for the given event once.
       *
       * @param {string} event
       * @param {function} callback
       */
      once: function once(event, callback) {
        this.$once(event, callback);
      },


      /**
       * Remove one or more event listeners.
       *
       * @param {string} event
       * @param {function} callback
       */
      off: function off(event, callback) {
        this.$off(event, callback);
      },


      /**
       * Remove one or more event listeners.
       *
       * @param {string} event
       * @param {function} callback
       */
      remove: function remove(event, callback) {
        this.off(event, callback);
      }
    }
  });

  // Extend `Vue.prototype` to include our global event bus.
  Object.defineProperty(Vue.prototype, '$events', {
    get: function get() {
      return events;
    }
  });

  // Register a mixin that adds an `events` option to Vue 2.0 components.
  Vue.mixin({
    // Hook into the Vue 2.0 `beforeCreate` life-cycle event.
    beforeCreate: function beforeCreate() {
      // Exit if there's no `events` option.
      if (_typeof(this.$options.events) !== 'object') return;
      // Cache of events to bound functions for automatic unsubscriptions
      var eventMap = {};
      // Loop through each event.
      for (var key in this.$options.events) {
        // Assign event type and bound function to map
        eventMap[key] = this.$options.events[key].bind(this);
      }
      // Listen for the `hook:beforeMount` Vue 2.0 life-cycle event.
      this.$once('hook:beforeMount', function () {
        // Loop through each event.
        for (var key in eventMap) {
          // Register a listener for the event.
          events.$on(key, eventMap[key]);
        }
      });
      // Listen for the `hook:beforeDestroy` Vue 2.0 life-cycle event.
      this.$once('hook:beforeDestroy', function () {
        // Loop through each event.
        for (var key in eventMap) {
          // Register a listener for the event.
          events.$off(key, eventMap[key]);
        }
        // Release cache
        eventMap = null;
      });
    }
  });
}

// Check for `window.Vue`
if (typeof window !== 'undefined' && window.Vue) {
  // Install plugin automatically.
  window.Vue.use(plugin);
}

exports.default = plugin;

/***/ }),

/***/ "./node_modules/vue-functional-data-merge/dist/lib.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeData", function() { return mergeData; });
var __assign=function(){return(__assign=Object.assign||function(e){for(var a,s=1,t=arguments.length;s<t;s++)for(var r in a=arguments[s])Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r]);return e}).apply(this,arguments)};function mergeData(){for(var e,a,s={},t=arguments.length;t--;)for(var r=0,c=Object.keys(arguments[t]);r<c.length;r++)switch(e=c[r]){case"class":case"style":case"directives":Array.isArray(s[e])||(s[e]=[]),s[e]=s[e].concat(arguments[t][e]);break;case"staticClass":if(!arguments[t][e])break;void 0===s[e]&&(s[e]=""),s[e]&&(s[e]+=" "),s[e]+=arguments[t][e].trim();break;case"on":case"nativeOn":s[e]||(s[e]={});for(var n=0,o=Object.keys(arguments[t][e]||{});n<o.length;n++)a=o[n],s[e][a]?s[e][a]=[].concat(s[e][a],arguments[t][e][a]):s[e][a]=arguments[t][e][a];break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":s[e]||(s[e]={}),s[e]=__assign({},arguments[t][e],s[e]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:s[e]||(s[e]=arguments[t][e])}return s}
//# sourceMappingURL=lib.esm.js.map


/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-15965e3b\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.isFixedHeader
    ? _c("div", [
        _c("div", { staticClass: "vuetable-head-wrapper" }, [
          _c(
            "table",
            {
              class: ["vuetable", _vm.css.tableClass, _vm.css.tableHeaderClass]
            },
            [
              _c("thead", [
                _c(
                  "tr",
                  [
                    _vm._l(_vm.tableFields, function(field, fieldIndex) {
                      return [
                        field.visible
                          ? [
                              _vm.isSpecialField(field.name)
                                ? [
                                    _vm.extractName(field.name) == "__checkbox"
                                      ? _c(
                                          "th",
                                          {
                                            key: fieldIndex,
                                            class: [
                                              "vuetable-th-checkbox-" +
                                                _vm.trackBy,
                                              field.titleClass
                                            ],
                                            style: { width: field.width }
                                          },
                                          [
                                            _c("input", {
                                              attrs: { type: "checkbox" },
                                              domProps: {
                                                checked: _vm.checkCheckboxesState(
                                                  field.name
                                                )
                                              },
                                              on: {
                                                change: function($event) {
                                                  return _vm.toggleAllCheckboxes(
                                                    field.name,
                                                    $event
                                                  )
                                                }
                                              }
                                            })
                                          ]
                                        )
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) == "__component"
                                      ? _c("th", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-th-component-" +
                                              _vm.trackBy,
                                            field.titleClass,
                                            _vm.sortClass(field),
                                            { sortable: _vm.isSortable(field) }
                                          ],
                                          style: { width: field.width },
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderTitle(field)
                                            )
                                          },
                                          on: {
                                            click: function($event) {
                                              return _vm.orderBy(field, $event)
                                            }
                                          }
                                        })
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) == "__slot"
                                      ? _c("th", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-th-slot-" +
                                              _vm.extractArgs(field.name),
                                            field.titleClass,
                                            _vm.sortClass(field),
                                            { sortable: _vm.isSortable(field) }
                                          ],
                                          style: { width: field.width },
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderTitle(field)
                                            )
                                          },
                                          on: {
                                            click: function($event) {
                                              return _vm.orderBy(field, $event)
                                            }
                                          }
                                        })
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) == "__sequence"
                                      ? _c("th", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-th-sequence",
                                            field.titleClass || ""
                                          ],
                                          style: { width: field.width },
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderTitle(field)
                                            )
                                          }
                                        })
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.notIn(_vm.extractName(field.name), [
                                      "__sequence",
                                      "__checkbox",
                                      "__component",
                                      "__slot"
                                    ])
                                      ? _c("th", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-th-" + field.name,
                                            field.titleClass || ""
                                          ],
                                          style: { width: field.width },
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderTitle(field)
                                            )
                                          }
                                        })
                                      : _vm._e()
                                  ]
                                : [
                                    _c("th", {
                                      key: fieldIndex,
                                      class: [
                                        "vuetable-th-" + field.name,
                                        field.titleClass,
                                        _vm.sortClass(field),
                                        { sortable: _vm.isSortable(field) }
                                      ],
                                      style: { width: field.width },
                                      attrs: { id: "_" + field.name },
                                      domProps: {
                                        innerHTML: _vm._s(
                                          _vm.renderTitle(field)
                                        )
                                      },
                                      on: {
                                        click: function($event) {
                                          return _vm.orderBy(field, $event)
                                        }
                                      }
                                    })
                                  ]
                            ]
                          : _vm._e()
                      ]
                    }),
                    _vm._v(" "),
                    _vm.scrollVisible
                      ? _c("th", {
                          staticClass: "vuetable-gutter-col",
                          style: { width: _vm.scrollBarWidth }
                        })
                      : _vm._e()
                  ],
                  2
                )
              ])
            ]
          )
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "vuetable-body-wrapper",
            style: { height: _vm.tableHeight }
          },
          [
            _c(
              "table",
              {
                class: ["vuetable", _vm.css.tableClass, _vm.css.tableBodyClass]
              },
              [
                _c(
                  "colgroup",
                  [
                    _vm._l(_vm.tableFields, function(field, fieldIndex) {
                      return [
                        field.visible
                          ? [
                              _c("col", {
                                key: fieldIndex,
                                class: [
                                  "vuetable-th-" + field.name,
                                  field.titleClass
                                ],
                                style: { width: field.width },
                                attrs: { id: "_col_" + field.name }
                              })
                            ]
                          : _vm._e()
                      ]
                    })
                  ],
                  2
                ),
                _vm._v(" "),
                _c(
                  "tbody",
                  { staticClass: "vuetable-body" },
                  [
                    _vm._l(_vm.tableData, function(item, itemIndex) {
                      return [
                        _c(
                          "tr",
                          {
                            key: itemIndex,
                            class: _vm.onRowClass(item, itemIndex),
                            attrs: {
                              "item-index": itemIndex,
                              render: _vm.onRowChanged(item)
                            },
                            on: {
                              click: function($event) {
                                return _vm.onRowClicked(item, $event)
                              },
                              dblclick: function($event) {
                                return _vm.onRowDoubleClicked(item, $event)
                              }
                            }
                          },
                          [
                            _vm._l(_vm.tableFields, function(
                              field,
                              fieldIndex
                            ) {
                              return [
                                field.visible
                                  ? [
                                      _vm.isSpecialField(field.name)
                                        ? [
                                            _vm.extractName(field.name) ==
                                            "__sequence"
                                              ? _c("td", {
                                                  key: fieldIndex,
                                                  class: [
                                                    "vuetable-sequence",
                                                    field.dataClass
                                                  ],
                                                  domProps: {
                                                    innerHTML: _vm._s(
                                                      _vm.renderSequence(
                                                        itemIndex
                                                      )
                                                    )
                                                  }
                                                })
                                              : _vm._e(),
                                            _vm._v(" "),
                                            _vm.extractName(field.name) ==
                                            "__handle"
                                              ? _c("td", {
                                                  key: fieldIndex,
                                                  class: [
                                                    "vuetable-handle",
                                                    field.dataClass
                                                  ],
                                                  domProps: {
                                                    innerHTML: _vm._s(
                                                      _vm.renderIconTag([
                                                        "handle-icon",
                                                        _vm.css.handleIcon
                                                      ])
                                                    )
                                                  }
                                                })
                                              : _vm._e(),
                                            _vm._v(" "),
                                            _vm.extractName(field.name) ==
                                            "__checkbox"
                                              ? _c(
                                                  "td",
                                                  {
                                                    key: fieldIndex,
                                                    class: [
                                                      "vuetable-checkboxes",
                                                      field.dataClass
                                                    ]
                                                  },
                                                  [
                                                    _c("input", {
                                                      attrs: {
                                                        type: "checkbox"
                                                      },
                                                      domProps: {
                                                        checked: _vm.rowSelected(
                                                          item,
                                                          field.name
                                                        )
                                                      },
                                                      on: {
                                                        change: function(
                                                          $event
                                                        ) {
                                                          return _vm.toggleCheckbox(
                                                            item,
                                                            field.name,
                                                            $event
                                                          )
                                                        }
                                                      }
                                                    })
                                                  ]
                                                )
                                              : _vm._e(),
                                            _vm._v(" "),
                                            _vm.extractName(field.name) ===
                                            "__component"
                                              ? _c(
                                                  "td",
                                                  {
                                                    key: fieldIndex,
                                                    class: [
                                                      "vuetable-component",
                                                      field.dataClass
                                                    ]
                                                  },
                                                  [
                                                    _c(
                                                      _vm.extractArgs(
                                                        field.name
                                                      ),
                                                      {
                                                        tag: "component",
                                                        attrs: {
                                                          "row-data": item,
                                                          "row-index": itemIndex,
                                                          "row-field":
                                                            field.sortField
                                                        }
                                                      }
                                                    )
                                                  ],
                                                  1
                                                )
                                              : _vm._e(),
                                            _vm._v(" "),
                                            _vm.extractName(field.name) ===
                                            "__slot"
                                              ? _c(
                                                  "td",
                                                  {
                                                    key: fieldIndex,
                                                    class: [
                                                      "vuetable-slot",
                                                      field.dataClass
                                                    ]
                                                  },
                                                  [
                                                    _vm._t(
                                                      _vm.extractArgs(
                                                        field.name
                                                      ),
                                                      null,
                                                      {
                                                        rowData: item,
                                                        rowIndex: itemIndex,
                                                        rowField:
                                                          field.sortField
                                                      }
                                                    )
                                                  ],
                                                  2
                                                )
                                              : _vm._e()
                                          ]
                                        : [
                                            _c("td", {
                                              key: fieldIndex,
                                              class: field.dataClass,
                                              domProps: {
                                                innerHTML: _vm._s(
                                                  _vm.renderNormalField(
                                                    field,
                                                    item
                                                  )
                                                )
                                              },
                                              on: {
                                                click: function($event) {
                                                  return _vm.onCellClicked(
                                                    item,
                                                    field,
                                                    $event
                                                  )
                                                },
                                                dblclick: function($event) {
                                                  return _vm.onCellDoubleClicked(
                                                    item,
                                                    field,
                                                    $event
                                                  )
                                                },
                                                contextmenu: function($event) {
                                                  return _vm.onCellRightClicked(
                                                    item,
                                                    field,
                                                    $event
                                                  )
                                                }
                                              }
                                            })
                                          ]
                                    ]
                                  : _vm._e()
                              ]
                            })
                          ],
                          2
                        ),
                        _vm._v(" "),
                        _vm.useDetailRow
                          ? [
                              _c(
                                "transition",
                                {
                                  key: itemIndex,
                                  attrs: { name: _vm.detailRowTransition }
                                },
                                [
                                  _vm.isVisibleDetailRow(item[_vm.trackBy])
                                    ? _c(
                                        "tr",
                                        {
                                          class: [_vm.css.detailRowClass],
                                          on: {
                                            click: function($event) {
                                              return _vm.onDetailRowClick(
                                                item,
                                                $event
                                              )
                                            }
                                          }
                                        },
                                        [
                                          _c(
                                            "td",
                                            {
                                              attrs: {
                                                colspan: _vm.countVisibleFields
                                              }
                                            },
                                            [
                                              _c(_vm.detailRowComponent, {
                                                tag: "component",
                                                attrs: {
                                                  "row-data": item,
                                                  "row-index": itemIndex
                                                }
                                              })
                                            ],
                                            1
                                          )
                                        ]
                                      )
                                    : _vm._e()
                                ]
                              )
                            ]
                          : _vm._e()
                      ]
                    }),
                    _vm._v(" "),
                    _vm.displayEmptyDataRow
                      ? [
                          _c("tr", [
                            _c("td", {
                              staticClass: "vuetable-empty-result",
                              attrs: { colspan: _vm.countVisibleFields },
                              domProps: {
                                innerHTML: _vm._s(_vm.noDataTemplate)
                              }
                            })
                          ])
                        ]
                      : _vm._e(),
                    _vm._v(" "),
                    _vm.lessThanMinRows
                      ? _vm._l(_vm.blankRows, function(i) {
                          return _c(
                            "tr",
                            { key: i, staticClass: "blank-row" },
                            [
                              _vm._l(_vm.tableFields, function(
                                field,
                                fieldIndex
                              ) {
                                return [
                                  field.visible
                                    ? _c("td", { key: fieldIndex }, [
                                        _vm._v("")
                                      ])
                                    : _vm._e()
                                ]
                              })
                            ],
                            2
                          )
                        })
                      : _vm._e()
                  ],
                  2
                )
              ]
            )
          ]
        )
      ])
    : _c("table", { class: ["vuetable", _vm.css.tableClass] }, [
        _c("thead", [
          _c(
            "tr",
            [
              _vm._l(_vm.tableFields, function(field, fieldIndex) {
                return [
                  field.visible
                    ? [
                        _vm.isSpecialField(field.name)
                          ? [
                              _vm.extractName(field.name) == "__checkbox"
                                ? _c(
                                    "th",
                                    {
                                      key: fieldIndex,
                                      class: [
                                        "vuetable-th-checkbox-" + _vm.trackBy,
                                        field.titleClass
                                      ],
                                      style: { width: field.width }
                                    },
                                    [
                                      _c("input", {
                                        attrs: { type: "checkbox" },
                                        domProps: {
                                          checked: _vm.checkCheckboxesState(
                                            field.name
                                          )
                                        },
                                        on: {
                                          change: function($event) {
                                            return _vm.toggleAllCheckboxes(
                                              field.name,
                                              $event
                                            )
                                          }
                                        }
                                      })
                                    ]
                                  )
                                : _vm._e(),
                              _vm._v(" "),
                              _vm.extractName(field.name) == "__component"
                                ? _c("th", {
                                    key: fieldIndex,
                                    class: [
                                      "vuetable-th-component-" + _vm.trackBy,
                                      field.titleClass,
                                      _vm.sortClass(field),
                                      { sortable: _vm.isSortable(field) }
                                    ],
                                    style: { width: field.width },
                                    domProps: {
                                      innerHTML: _vm._s(_vm.renderTitle(field))
                                    },
                                    on: {
                                      click: function($event) {
                                        return _vm.orderBy(field, $event)
                                      }
                                    }
                                  })
                                : _vm._e(),
                              _vm._v(" "),
                              _vm.extractName(field.name) == "__slot"
                                ? _c("th", {
                                    key: fieldIndex,
                                    class: [
                                      "vuetable-th-slot-" +
                                        _vm.extractArgs(field.name),
                                      field.titleClass,
                                      _vm.sortClass(field),
                                      { sortable: _vm.isSortable(field) }
                                    ],
                                    style: { width: field.width },
                                    domProps: {
                                      innerHTML: _vm._s(_vm.renderTitle(field))
                                    },
                                    on: {
                                      click: function($event) {
                                        return _vm.orderBy(field, $event)
                                      }
                                    }
                                  })
                                : _vm._e(),
                              _vm._v(" "),
                              _vm.extractName(field.name) == "__sequence"
                                ? _c("th", {
                                    key: fieldIndex,
                                    class: [
                                      "vuetable-th-sequence",
                                      field.titleClass || "",
                                      _vm.sortClass(field)
                                    ],
                                    style: { width: field.width },
                                    domProps: {
                                      innerHTML: _vm._s(_vm.renderTitle(field))
                                    }
                                  })
                                : _vm._e(),
                              _vm._v(" "),
                              _vm.notIn(_vm.extractName(field.name), [
                                "__sequence",
                                "__checkbox",
                                "__component",
                                "__slot"
                              ])
                                ? _c("th", {
                                    key: fieldIndex,
                                    class: [
                                      "vuetable-th-" + field.name,
                                      field.titleClass || "",
                                      _vm.sortClass(field)
                                    ],
                                    style: { width: field.width },
                                    domProps: {
                                      innerHTML: _vm._s(_vm.renderTitle(field))
                                    }
                                  })
                                : _vm._e()
                            ]
                          : [
                              _c("th", {
                                key: fieldIndex,
                                class: [
                                  "vuetable-th-" + field.name,
                                  field.titleClass,
                                  _vm.sortClass(field),
                                  { sortable: _vm.isSortable(field) }
                                ],
                                style: { width: field.width },
                                attrs: { id: "_" + field.name },
                                domProps: {
                                  innerHTML: _vm._s(_vm.renderTitle(field))
                                },
                                on: {
                                  click: function($event) {
                                    return _vm.orderBy(field, $event)
                                  }
                                }
                              })
                            ]
                      ]
                    : _vm._e()
                ]
              })
            ],
            2
          )
        ]),
        _vm._v(" "),
        _c(
          "tbody",
          { staticClass: "vuetable-body" },
          [
            _vm._l(_vm.tableData, function(item, itemIndex) {
              return [
                _c(
                  "tr",
                  {
                    key: itemIndex,
                    class: _vm.onRowClass(item, itemIndex),
                    attrs: {
                      "item-index": itemIndex,
                      render: _vm.onRowChanged(item)
                    },
                    on: {
                      dblclick: function($event) {
                        return _vm.onRowDoubleClicked(item, $event)
                      },
                      click: function($event) {
                        return _vm.onRowClicked(item, $event)
                      }
                    }
                  },
                  [
                    _vm._l(_vm.tableFields, function(field, fieldIndex) {
                      return [
                        field.visible
                          ? [
                              _vm.isSpecialField(field.name)
                                ? [
                                    _vm.extractName(field.name) == "__sequence"
                                      ? _c("td", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-sequence",
                                            field.dataClass
                                          ],
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderSequence(itemIndex)
                                            )
                                          }
                                        })
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) == "__handle"
                                      ? _c("td", {
                                          key: fieldIndex,
                                          class: [
                                            "vuetable-handle",
                                            field.dataClass
                                          ],
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.renderIconTag([
                                                "handle-icon",
                                                _vm.css.handleIcon
                                              ])
                                            )
                                          }
                                        })
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) == "__checkbox"
                                      ? _c(
                                          "td",
                                          {
                                            key: fieldIndex,
                                            class: [
                                              "vuetable-checkboxes",
                                              field.dataClass
                                            ]
                                          },
                                          [
                                            _c("input", {
                                              attrs: { type: "checkbox" },
                                              domProps: {
                                                checked: _vm.rowSelected(
                                                  item,
                                                  field.name
                                                )
                                              },
                                              on: {
                                                change: function($event) {
                                                  return _vm.toggleCheckbox(
                                                    item,
                                                    field.name,
                                                    $event
                                                  )
                                                }
                                              }
                                            })
                                          ]
                                        )
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) ===
                                    "__component"
                                      ? _c(
                                          "td",
                                          {
                                            key: fieldIndex,
                                            class: [
                                              "vuetable-component",
                                              field.dataClass
                                            ]
                                          },
                                          [
                                            _c(_vm.extractArgs(field.name), {
                                              tag: "component",
                                              attrs: {
                                                "row-data": item,
                                                "row-index": itemIndex,
                                                "row-field": field.sortField
                                              }
                                            })
                                          ],
                                          1
                                        )
                                      : _vm._e(),
                                    _vm._v(" "),
                                    _vm.extractName(field.name) === "__slot"
                                      ? _c(
                                          "td",
                                          {
                                            key: fieldIndex,
                                            class: [
                                              "vuetable-slot",
                                              field.dataClass
                                            ]
                                          },
                                          [
                                            _vm._t(
                                              _vm.extractArgs(field.name),
                                              null,
                                              {
                                                rowData: item,
                                                rowIndex: itemIndex,
                                                rowField: field.sortField
                                              }
                                            )
                                          ],
                                          2
                                        )
                                      : _vm._e()
                                  ]
                                : [
                                    _vm.hasCallback(field)
                                      ? _c("td", {
                                          key: fieldIndex,
                                          class: field.dataClass,
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.callCallback(field, item)
                                            )
                                          },
                                          on: {
                                            click: function($event) {
                                              return _vm.onCellClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            },
                                            dblclick: function($event) {
                                              return _vm.onCellDoubleClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            },
                                            contextmenu: function($event) {
                                              return _vm.onCellRightClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            }
                                          }
                                        })
                                      : _c("td", {
                                          key: fieldIndex,
                                          class: field.dataClass,
                                          domProps: {
                                            innerHTML: _vm._s(
                                              _vm.getObjectValue(
                                                item,
                                                field.name,
                                                ""
                                              )
                                            )
                                          },
                                          on: {
                                            click: function($event) {
                                              return _vm.onCellClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            },
                                            dblclick: function($event) {
                                              return _vm.onCellDoubleClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            },
                                            contextmenu: function($event) {
                                              return _vm.onCellRightClicked(
                                                item,
                                                field,
                                                $event
                                              )
                                            }
                                          }
                                        })
                                  ]
                            ]
                          : _vm._e()
                      ]
                    })
                  ],
                  2
                ),
                _vm._v(" "),
                _vm.useDetailRow
                  ? [
                      _c(
                        "transition",
                        {
                          key: itemIndex,
                          attrs: { name: _vm.detailRowTransition }
                        },
                        [
                          _vm.isVisibleDetailRow(item[_vm.trackBy])
                            ? _c(
                                "tr",
                                {
                                  class: [_vm.css.detailRowClass],
                                  on: {
                                    click: function($event) {
                                      return _vm.onDetailRowClick(item, $event)
                                    }
                                  }
                                },
                                [
                                  _c(
                                    "td",
                                    {
                                      attrs: { colspan: _vm.countVisibleFields }
                                    },
                                    [
                                      _c(_vm.detailRowComponent, {
                                        tag: "component",
                                        attrs: {
                                          "row-data": item,
                                          "row-index": itemIndex
                                        }
                                      })
                                    ],
                                    1
                                  )
                                ]
                              )
                            : _vm._e()
                        ]
                      )
                    ]
                  : _vm._e()
              ]
            }),
            _vm._v(" "),
            _vm.displayEmptyDataRow
              ? [
                  _c("tr", [
                    _c("td", {
                      staticClass: "vuetable-empty-result",
                      attrs: { colspan: _vm.countVisibleFields },
                      domProps: { innerHTML: _vm._s(_vm.noDataTemplate) }
                    })
                  ])
                ]
              : _vm._e(),
            _vm._v(" "),
            _vm.lessThanMinRows
              ? _vm._l(_vm.blankRows, function(i) {
                  return _c(
                    "tr",
                    { key: i, staticClass: "blank-row" },
                    [
                      _vm._l(_vm.tableFields, function(field, fieldIndex) {
                        return [
                          field.visible
                            ? _c("td", { key: fieldIndex }, [_vm._v("")])
                            : _vm._e()
                        ]
                      })
                    ],
                    2
                  )
                })
              : _vm._e()
          ],
          2
        )
      ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-15965e3b", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-17724083\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", {
    class: ["vuetable-pagination-info", _vm.css.infoClass],
    domProps: { innerHTML: _vm._s(_vm.paginationInfo) }
  })
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-17724083", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-27921bbd\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/create.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "create-screen",
    { attrs: { resource: "products", title: _vm.$t("create.title") } },
    [
      _vm.show
        ? _c(
            "b-form",
            {
              staticClass: "mt-3",
              attrs: { slot: "form", id: "product" },
              on: { submit: _vm.onSubmit, reset: _vm.onReset },
              slot: "form"
            },
            [
              _c(
                "b-form-group",
                {
                  attrs: {
                    id: "name",
                    "label-for": "name",
                    "label-class": "control-label-v",
                    horizontal: "",
                    label: _vm.$t("fields.name.text"),
                    description: _vm.$t("fields.name.description")
                  }
                },
                [
                  _c("b-form-input", {
                    staticClass: "col-md-8",
                    class: { "is-invalid": _vm.errors.name },
                    attrs: {
                      id: "name",
                      type: "text",
                      required: "",
                      placeholder: "Product name"
                    },
                    model: {
                      value: _vm.form.name,
                      callback: function($$v) {
                        _vm.$set(_vm.form, "name", $$v)
                      },
                      expression: "form.name"
                    }
                  }),
                  _vm._v(" "),
                  _vm.errors.name
                    ? _c("div", { staticClass: "invalid-feedback" }, [
                        _vm._v(_vm._s(_vm.errors.name[0]))
                      ])
                    : _vm._e()
                ],
                1
              ),
              _vm._v(" "),
              _c(
                "b-form-group",
                {
                  attrs: {
                    id: "manufacturer",
                    "label-for": "manufacturer",
                    "label-class": "control-label-v",
                    horizontal: "",
                    label: _vm.$t("fields.manufacturer.text"),
                    description: _vm.$t("fields.manufacturer.description")
                  }
                },
                [
                  _c("b-form-select", {
                    staticClass: "col-md-6",
                    attrs: {
                      id: "manufacturer",
                      options: _vm.manufacturers,
                      required: ""
                    },
                    model: {
                      value: _vm.form.manufacturer,
                      callback: function($$v) {
                        _vm.$set(_vm.form, "manufacturer", $$v)
                      },
                      expression: "form.manufacturer"
                    }
                  })
                ],
                1
              ),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "form-group mt-5 row justify-content-end" },
                [
                  _c(
                    "div",
                    { staticClass: "col-md-offset-4 col-md-4" },
                    [
                      _c(
                        "b-button",
                        { attrs: { type: "submit", variant: "primary" } },
                        [_vm._v(_vm._s(_vm.$t("actions.submit")))]
                      ),
                      _vm._v(" "),
                      _c(
                        "b-button",
                        { attrs: { type: "reset", variant: "danger" } },
                        [_vm._v(_vm._s(_vm.$t("actions.reset")))]
                      )
                    ],
                    1
                  )
                ]
              )
            ],
            1
          )
        : _vm._e()
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-27921bbd", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-27efafea\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/edit.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "create-screen",
    { attrs: { resource: "products", title: _vm.$t("edit.title") } },
    [
      _vm.show
        ? _c(
            "b-form",
            {
              staticClass: "mt-3",
              attrs: { slot: "form", id: "product" },
              on: { submit: _vm.onSubmit, reset: _vm.onReset },
              slot: "form"
            },
            [
              _c(
                "b-form-group",
                {
                  attrs: {
                    id: "name",
                    "label-for": "name",
                    "label-class": "control-label-v",
                    horizontal: "",
                    label: _vm.$t("fields.name.text"),
                    description: _vm.$t("fields.name.description")
                  }
                },
                [
                  _c("b-form-input", {
                    staticClass: "col-md-8",
                    class: { "is-invalid": _vm.errors.name },
                    attrs: {
                      id: "name",
                      type: "text",
                      required: "",
                      placeholder: "MakerMake Ltd."
                    },
                    model: {
                      value: _vm.form.name,
                      callback: function($$v) {
                        _vm.$set(_vm.form, "name", $$v)
                      },
                      expression: "form.name"
                    }
                  }),
                  _vm._v(" "),
                  _vm.errors.name
                    ? _c("div", { staticClass: "invalid-feedback" }, [
                        _vm._v(_vm._s(_vm.errors.name[0]))
                      ])
                    : _vm._e()
                ],
                1
              ),
              _vm._v(" "),
              _c(
                "b-form-group",
                {
                  attrs: {
                    id: "manufacturer",
                    "label-for": "manufacturer",
                    "label-class": "control-label-v",
                    horizontal: "",
                    label: _vm.$t("fields.manufacturer.text"),
                    description: _vm.$t("fields.manufacturer.description")
                  }
                },
                [
                  _c("b-form-select", {
                    staticClass: "col-md-6",
                    attrs: {
                      id: "manufacturer",
                      options: _vm.manufacturers,
                      required: ""
                    },
                    model: {
                      value: _vm.form.manufacturer,
                      callback: function($$v) {
                        _vm.$set(_vm.form, "manufacturer", $$v)
                      },
                      expression: "form.manufacturer"
                    }
                  })
                ],
                1
              ),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "form-group mt-5 row justify-content-end" },
                [
                  _c(
                    "div",
                    { staticClass: "col-md-offset-4 col-md-4" },
                    [
                      _c(
                        "b-button",
                        { attrs: { type: "submit", variant: "primary" } },
                        [_vm._v(_vm._s(_vm.$t("actions.submit")))]
                      ),
                      _vm._v(" "),
                      _c(
                        "b-button",
                        { attrs: { type: "reset", variant: "danger" } },
                        [_vm._v(_vm._s(_vm.$t("actions.reset")))]
                      )
                    ],
                    1
                  )
                ]
              )
            ],
            1
          )
        : _vm._e()
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-27efafea", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-3efdd596\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/VuetablePagination.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.tablePagination && _vm.tablePagination.last_page > 1,
          expression: "tablePagination && tablePagination.last_page > 1"
        }
      ],
      class: _vm.css.wrapperClass
    },
    [
      _c(
        "a",
        {
          class: [
            "btn-nav",
            _vm.css.linkClass,
            _vm.isOnFirstPage ? _vm.css.disabledClass : ""
          ],
          on: {
            click: function($event) {
              return _vm.loadPage(1)
            }
          }
        },
        [
          _vm.css.icons.first != ""
            ? _c("i", { class: [_vm.css.icons.first] })
            : _c("span", [_vm._v("")])
        ]
      ),
      _vm._v(" "),
      _c(
        "a",
        {
          class: [
            "btn-nav",
            _vm.css.linkClass,
            _vm.isOnFirstPage ? _vm.css.disabledClass : ""
          ],
          on: {
            click: function($event) {
              return _vm.loadPage("prev")
            }
          }
        },
        [
          _vm.css.icons.next != ""
            ? _c("i", { class: [_vm.css.icons.prev] })
            : _c("span", [_vm._v("")])
        ]
      ),
      _vm._v(" "),
      _vm.notEnoughPages
        ? [
            _vm._l(_vm.totalPage, function(n) {
              return [
                _c("a", {
                  class: [
                    _vm.css.pageClass,
                    _vm.isCurrentPage(n) ? _vm.css.activeClass : ""
                  ],
                  domProps: { innerHTML: _vm._s(n) },
                  on: {
                    click: function($event) {
                      return _vm.loadPage(n)
                    }
                  }
                })
              ]
            })
          ]
        : [
            _vm._l(_vm.windowSize, function(n) {
              return [
                _c("a", {
                  class: [
                    _vm.css.pageClass,
                    _vm.isCurrentPage(_vm.windowStart + n - 1)
                      ? _vm.css.activeClass
                      : ""
                  ],
                  domProps: { innerHTML: _vm._s(_vm.windowStart + n - 1) },
                  on: {
                    click: function($event) {
                      return _vm.loadPage(_vm.windowStart + n - 1)
                    }
                  }
                })
              ]
            })
          ],
      _vm._v(" "),
      _c(
        "a",
        {
          class: [
            "btn-nav",
            _vm.css.linkClass,
            _vm.isOnLastPage ? _vm.css.disabledClass : ""
          ],
          on: {
            click: function($event) {
              return _vm.loadPage("next")
            }
          }
        },
        [
          _vm.css.icons.next != ""
            ? _c("i", { class: [_vm.css.icons.next] })
            : _c("span", [_vm._v("")])
        ]
      ),
      _vm._v(" "),
      _c(
        "a",
        {
          class: [
            "btn-nav",
            _vm.css.linkClass,
            _vm.isOnLastPage ? _vm.css.disabledClass : ""
          ],
          on: {
            click: function($event) {
              return _vm.loadPage(_vm.totalPage)
            }
          }
        },
        [
          _vm.css.icons.last != ""
            ? _c("i", { class: [_vm.css.icons.last] })
            : _c("span", [_vm._v("")])
        ]
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3efdd596", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-46d6b2e9\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/CollectionTable.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c("div", { staticClass: "d-flex" }, [
        _c(
          "div",
          { staticClass: "p-2" },
          [
            _c(
              "b-link",
              {
                staticClass: "btn btn-primary btn-sm text-uppercase",
                attrs: { href: _vm.model + "/create", title: "Add a new Spool" }
              },
              [
                _c("svgicon", {
                  staticClass: "button-icon-sm",
                  attrs: { icon: "plus", color: "#fff" }
                }),
                _vm._v("\n                add\n            ")
              ],
              1
            )
          ],
          1
        ),
        _vm._v(" "),
        _c(
          "div",
          { staticClass: "ml-auto p-2" },
          [
            _c(
              "b-form-group",
              { attrs: { horizontal: "" } },
              [
                _c(
                  "b-input-group",
                  [
                    _c("b-form-input", {
                      attrs: { placeholder: "Search..." },
                      model: {
                        value: _vm.filter,
                        callback: function($$v) {
                          _vm.filter = $$v
                        },
                        expression: "filter"
                      }
                    }),
                    _vm._v(" "),
                    _c(
                      "b-input-group-append",
                      [
                        _c(
                          "b-btn",
                          {
                            attrs: { disabled: !_vm.filter },
                            on: {
                              click: function($event) {
                                _vm.filter = ""
                              }
                            }
                          },
                          [_vm._v("Clear")]
                        )
                      ],
                      1
                    )
                  ],
                  1
                )
              ],
              1
            )
          ],
          1
        )
      ]),
      _vm._v(" "),
      _c("b-table", {
        attrs: {
          "sort-by": _vm.sortBy,
          "sort-desc": _vm.sortDesc,
          filter: _vm.filter,
          items: _vm.collection,
          fields: _vm.fields,
          "current-page": _vm.currentPage,
          "per-page": _vm.perPage
        },
        on: {
          "update:sortBy": function($event) {
            _vm.sortBy = $event
          },
          "update:sort-by": function($event) {
            _vm.sortBy = $event
          },
          "update:sortDesc": function($event) {
            _vm.sortDesc = $event
          },
          "update:sort-desc": function($event) {
            _vm.sortDesc = $event
          },
          filtered: _vm.onFiltered
        },
        scopedSlots: _vm._u([
          {
            key: "name",
            fn: function(row) {
              return [
                _c("b-link", { attrs: { href: "/spools/" + row.item.id } }, [
                  _vm._v(_vm._s(row.value))
                ])
              ]
            }
          },
          {
            key: "material",
            fn: function(row) {
              return [
                _c("span", { staticClass: "text-uppercase" }, [
                  _vm._v(_vm._s(row.item.material))
                ])
              ]
            }
          },
          {
            key: "diameter",
            fn: function(row) {
              return [_vm._v(_vm._s(row.item.diameter) + "\n        ")]
            }
          },
          {
            key: "price",
            fn: function(row) {
              return [
                _vm._v(
                  _vm._s(_vm.moneyFormat(row.item.unitPrice.volume)) +
                    "\n        "
                )
              ]
            }
          },
          {
            key: "details",
            fn: function(row) {
              return [
                _c(
                  "b-link",
                  {
                    attrs: { title: "View more details" },
                    on: {
                      click: function($event) {
                        $event.stopPropagation()
                        return row.toggleDetails($event)
                      }
                    }
                  },
                  [
                    _c("svgicon", {
                      staticClass: "action-icon-sm",
                      class: { "svg-right": row.detailsShowing },
                      attrs: { icon: "details" }
                    })
                  ],
                  1
                )
              ]
            }
          },
          {
            key: "actions",
            fn: function(row) {
              return [
                _c(
                  "b-dropdown",
                  { attrs: { variant: "link", size: "sm", "no-caret": "" } },
                  [
                    _c(
                      "template",
                      { slot: "button-content" },
                      [
                        _c("svgicon", {
                          directives: [
                            {
                              name: "b-tooltip",
                              rawName: "v-b-tooltip.hover",
                              modifiers: { hover: true }
                            }
                          ],
                          staticClass: "action-icon-md",
                          attrs: { title: "More actions", icon: "actions" }
                        })
                      ],
                      1
                    ),
                    _vm._v(" "),
                    _c(
                      "b-dropdown-item",
                      {
                        attrs: {
                          href: "/spools/" + row.item.id + "/edit",
                          title: "Edit machine `" + row.item.name + "`"
                        }
                      },
                      [_vm._v("Edit\n                ")]
                    ),
                    _vm._v(" "),
                    _c(
                      "b-dropdown-item",
                      {
                        attrs: {
                          href: "#",
                          title: "Delete machine `" + row.item.name + "`"
                        },
                        on: {
                          click: function($event) {
                            $event.stopPropagation()
                            return _vm.deleteInstance(row.item.id)
                          }
                        }
                      },
                      [_vm._v("Delete\n                ")]
                    )
                  ],
                  2
                )
              ]
            }
          },
          {
            key: "row-details",
            fn: function(row) {
              return [
                _c("b-card", { staticClass: "collection-row-detail" }, [
                  _c("div", { staticClass: "d-flex justify-content-start" }, [
                    _c("div", { staticClass: "p-2" }, [
                      _c("table", { staticClass: "table detail-table" }, [
                        _c("tbody", [
                          _c("tr", [
                            _c("th", { attrs: { scope: "row" } }, [
                              _vm._v("Lifespan")
                            ]),
                            _vm._v(" "),
                            _c("td", [
                              _vm._v(_vm._s(row.item.lifespan) + " years")
                            ])
                          ]),
                          _vm._v(" "),
                          _c("tr", [
                            _c("th", { attrs: { scope: "row" } }, [
                              _vm._v("Operating Hours")
                            ]),
                            _vm._v(" "),
                            _c("td", [_vm._v(_vm._s(row.item.operating_hours))])
                          ]),
                          _vm._v(" "),
                          _c("tr", [
                            _c("th", { attrs: { scope: "row" } }, [
                              _vm._v("Energy Consumption")
                            ]),
                            _vm._v(" "),
                            _c("td", [
                              _vm._v(_vm._s(row.item.energy_consumption) + " W")
                            ])
                          ])
                        ])
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "p-2 pl-4" }, [
                      _c("table", { staticClass: "table detail-table" }, [
                        _c("tr", { staticClass: "money" }, [
                          _c("th", [_vm._v("Acquisition Cost")]),
                          _vm._v(" "),
                          _c("td", [
                            _vm._v(
                              _vm._s(_vm.moneyFormat(row.item.acquisition_cost))
                            )
                          ])
                        ]),
                        _vm._v(" "),
                        _c("tr", { staticClass: "money" }, [
                          _c("th", { attrs: { scope: "row" } }, [
                            _vm._v("Residual Value")
                          ]),
                          _vm._v(" "),
                          _c("td", [
                            _vm._v(
                              _vm._s(_vm.moneyFormat(row.item.residual_value))
                            )
                          ])
                        ]),
                        _vm._v(" "),
                        _c("tr", { staticClass: "money" }, [
                          _c("th", { attrs: { scope: "row" } }, [
                            _vm._v("Maintenance Cost")
                          ]),
                          _vm._v(" "),
                          _c("td", [
                            _vm._v(
                              _vm._s(_vm.moneyFormat(row.item.maintenance_cost))
                            )
                          ])
                        ]),
                        _vm._v(" "),
                        _c("tr", { staticClass: "money" }, [
                          _c("th", { attrs: { scope: "row" } }, [
                            _vm._v("Total Lifetime Cost")
                          ]),
                          _vm._v(" "),
                          _c("th", { staticClass: "footer" }, [
                            _vm._v(
                              "\n                                    " +
                                _vm._s(
                                  _vm.moneyFormat(row.item.lifetime_cost)
                                ) +
                                "\n                                "
                            )
                          ])
                        ])
                      ])
                    ])
                  ])
                ])
              ]
            }
          }
        ])
      }),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "d-flex align-items-center flex-column" },
        [
          _vm.totalRows > _vm.perPage
            ? _c("b-pagination", {
                staticClass: "my-0",
                attrs: { "total-rows": _vm.totalRows, "per-page": _vm.perPage },
                model: {
                  value: _vm.currentPage,
                  callback: function($$v) {
                    _vm.currentPage = $$v
                  },
                  expression: "currentPage"
                }
              })
            : _vm._e()
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-46d6b2e9", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5296d9be\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/index.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "index-screen",
    {
      attrs: {
        title: _vm.$t("index.title"),
        resource: "products",
        fields: _vm.fields,
        "sort-order": _vm.sortOrder
      }
    },
    [
      _c("span", {
        attrs: { slot: "description" },
        domProps: { textContent: _vm._s(_vm.$t("index.description")) },
        slot: "description"
      })
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5296d9be", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-53148bb6\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/parts/FilterBar.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "d-flex" }, [
    _c(
      "div",
      { staticClass: "p-2" },
      [
        _c(
          "b-link",
          {
            staticClass: "btn btn-primary btn-sm text-uppercase",
            attrs: {
              href: _vm.resource + "/create",
              title: _vm.$t("actions.add_resource", {
                resource: _vm.$tc("resources." + _vm.resource, 1)
              })
            }
          },
          [
            _c("svgicon", {
              staticClass: "button-icon-sm",
              attrs: { icon: "plus", color: "#fff" }
            }),
            _vm._v(
              "\n            " + _vm._s(_vm.$t("actions.add")) + "\n        "
            )
          ],
          1
        )
      ],
      1
    ),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "ml-auto p-2" },
      [
        _c(
          "b-form-group",
          { attrs: { horizontal: "" } },
          [
            _c(
              "b-input-group",
              [
                _c("b-form-input", {
                  attrs: { placeholder: _vm.$t("actions.search_ellipsis") },
                  model: {
                    value: _vm.filterText,
                    callback: function($$v) {
                      _vm.filterText = $$v
                    },
                    expression: "filterText"
                  }
                }),
                _vm._v(" "),
                _c(
                  "b-input-group-append",
                  [
                    _c(
                      "b-btn",
                      {
                        attrs: { disabled: !_vm.filterText },
                        on: { click: _vm.resetFilter }
                      },
                      [
                        _vm._v(
                          _vm._s(_vm.$t("actions.clear")) +
                            "\n                    "
                        )
                      ]
                    )
                  ],
                  1
                )
              ],
              1
            )
          ],
          1
        )
      ],
      1
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-53148bb6", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-59e12e3f\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/CreateScreen.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("div", { staticClass: "row" }, [
      _c("div", { staticClass: "col-md-12 d-flex" }, [
        _c("h1", { staticClass: "display-5" }, [_vm._v(_vm._s(_vm.title))]),
        _vm._v(" "),
        _c(
          "div",
          { staticClass: "ml-auto" },
          [
            _c(
              "b-button",
              { attrs: { variant: "secondary", to: "/" + _vm.resource } },
              [
                _c("svgicon", {
                  staticClass: "button-icon",
                  attrs: { icon: "details" }
                }),
                _vm._v(
                  "\n                    " +
                    _vm._s(_vm.$t("actions.back")) +
                    "\n                "
                )
              ],
              1
            )
          ],
          1
        )
      ])
    ]),
    _vm._v(" "),
    _c("div", { staticClass: "card-collection card mt-3" }, [
      _c("div", { staticClass: "card-body" }, [_vm._t("form")], 2)
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-59e12e3f", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5b8e7712\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/IndexScreen.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("div", { staticClass: "row" }, [
      _c("div", { staticClass: "col-md-12 d-flex" }, [
        _c("h1", { staticClass: "display-5" }, [_vm._v(_vm._s(this.title))])
      ]),
      _vm._v(" "),
      _c(
        "p",
        { staticClass: "col-md-12 text-muted text-uppercase small" },
        [_vm._t("description")],
        2
      )
    ]),
    _vm._v(" "),
    _c("div", { staticClass: "card-collection card" }, [
      _c(
        "div",
        { staticClass: "card-body" },
        [
          _c("filter-bar", { attrs: { resource: _vm.resource } }),
          _vm._v(" "),
          _c("vuetable", {
            ref: "vuetable",
            attrs: {
              "api-url": "/api/" + _vm.resource,
              fields: _vm.fields,
              "data-path": "resourcedata",
              "append-params": _vm.moreParams,
              "pagination-path": "pagination",
              "http-options": _vm.http_options,
              "sort-order": _vm.sortOrder
            },
            on: { "vuetable:pagination-data": _vm.onPaginationData },
            scopedSlots: _vm._u(
              [
                {
                  key: "actions",
                  fn: function(props) {
                    return [
                      _c(
                        "b-dropdown",
                        {
                          attrs: { variant: "link", size: "sm", "no-caret": "" }
                        },
                        [
                          _c(
                            "template",
                            { slot: "button-content" },
                            [
                              _c("svgicon", {
                                directives: [
                                  {
                                    name: "b-tooltip",
                                    rawName: "v-b-tooltip.hover",
                                    modifiers: { hover: true }
                                  }
                                ],
                                staticClass: "action-icon-md",
                                attrs: {
                                  title: _vm.$t("actions.more"),
                                  icon: "actions"
                                }
                              })
                            ],
                            1
                          ),
                          _vm._v(" "),
                          _c(
                            "b-dropdown-item",
                            {
                              attrs: {
                                href:
                                  _vm.resource +
                                  "/" +
                                  props.rowData.id +
                                  "/edit",
                                title: _vm.$t("actions.edit_resource", {
                                  resource: _vm.$tc(
                                    "resources." + _vm.resource,
                                    1
                                  ),
                                  name: props.rowData.name
                                })
                              }
                            },
                            [_vm._v("Edit\n                        ")]
                          ),
                          _vm._v(" "),
                          _c(
                            "b-dropdown-item",
                            {
                              attrs: {
                                href: "#",
                                title: _vm.$t("actions.delete_resource", {
                                  resource: _vm.$tc(
                                    "resources." + _vm.resource,
                                    1
                                  ),
                                  name: props.rowData.name
                                })
                              },
                              on: {
                                click: function($event) {
                                  $event.stopPropagation()
                                  return _vm.deleteInstance(
                                    props.rowData.id,
                                    props.rowIndex
                                  )
                                }
                              }
                            },
                            [_vm._v("Delete\n                        ")]
                          )
                        ],
                        2
                      )
                    ]
                  }
                },
                {
                  key: "custom_field_1",
                  fn: function(props) {
                    return [_vm._t("custom_1", null, { data: props.rowData })]
                  }
                }
              ],
              null,
              true
            )
          }),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "d-flex" },
            [
              _c("vuetable-pagination-info", { ref: "paginationInfo" }),
              _vm._v(" "),
              _c("vuetable-pagination", {
                ref: "pagination",
                staticClass: "ml-auto",
                attrs: { css: _vm.css.pagination },
                on: { "vuetable-pagination:change-page": _vm.onChangePage }
              })
            ],
            1
          )
        ],
        1
      )
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5b8e7712", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-multiple-progress/lib/progress.js":
/***/ (function(module, exports, __webpack_require__) {

!function(A,s){ true?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.progress=s():A.progress=s()}(this,function(){return function(A){function s(t){if(e[t])return e[t].exports;var r=e[t]={i:t,l:!1,exports:{}};return A[t].call(r.exports,r,r.exports,s),r.l=!0,r.exports}var e={};return s.m=A,s.c=e,s.i=function(A){return A},s.d=function(A,e,t){s.o(A,e)||Object.defineProperty(A,e,{configurable:!1,enumerable:!0,get:t})},s.n=function(A){var e=A&&A.__esModule?function(){return A.default}:function(){return A};return s.d(e,"a",e),e},s.o=function(A,s){return Object.prototype.hasOwnProperty.call(A,s)},s.p="",s(s.s=4)}([function(A,s){A.exports="data:application/vnd.ms-fontobject;base64,QhgAACgXAAABAAIAAAAAAAIABgMAAAAAAAABAPQBAAAAAExQAQAAAAAAABAAAAAAAAAAAAEAAAAAAAAAcSOqAAAAAAAAAAAAAAAAAAAAAAAAABAAaQBjAG8AbgBmAG8AbgB0AAAADABNAGUAZABpAHUAbQAAAIoAVgBlAHIAcwBpAG8AbgAgADEALgAwADsAIAB0AHQAZgBhAHUAdABvAGgAaQBuAHQAIAAoAHYAMAAuADkANAApACAALQBsACAAOAAgAC0AcgAgADUAMAAgAC0ARwAgADIAMAAwACAALQB4ACAAMQA0ACAALQB3ACAAIgBHACIAIAAtAGYAIAAtAHMAAAAQAGkAYwBvAG4AZgBvAG4AdAAAAAAAAAEAAAAQAQAABAAARkZUTXd+x/YAAAEMAAAAHEdERUYAOQAGAAABKAAAACBPUy8yVxRbvgAAAUgAAABWY21hcNL42GwAAAGgAAABamN2dCAM5f90AAAM1AAAACRmcGdtMPeelQAADPgAAAmWZ2FzcAAAABAAAAzMAAAACGdseWaxLuVGAAADDAAABhBoZWFkDkxpIwAACRwAAAA2aGhlYQdeA8YAAAlUAAAAJGhtdHgQ5QJsAAAJeAAAACJsb2NhCjYIHgAACZwAAAAabWF4cAEuCisAAAm4AAAAIG5hbWUULc4VAAAJ2AAAAitwb3N0viQ/1QAADAQAAADIcHJlcKW5vmYAABaQAAAAlQAAAAEAAAAAzD2izwAAAADVoJKTAAAAANWgkpMAAQAAAA4AAAAYAAAAAAACAAEAAwALAAEABAAAAAIAAAABA/0B9AAFAAgCmQLMAAAAjwKZAswAAAHrADMBCQAAAgAGAwAAAAAAAAAAAAEQAAAAAAAAAAAAAABQZkVkAEAAeOjuA4D/gABcA0AAQAAAAAEAAAAAAAAAAAADAAAAAwAAABwAAQAAAAAAZAADAAEAAAAcAAQASAAAAA4ACAACAAYAAAB46OXo6ujs6O7//wAAAAAAeOjk6Ofo7Oju//8AAP+LFyAXHxceFx0AAQAAAAAAAAAAAAAAAAAAAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUALP/hA7wDGAAWADAAOgBSAF4Bd0uwE1BYQEoCAQANDg0ADmYAAw4BDgNeAAEICAFcEAEJCAoGCV4RAQwGBAYMXgALBAtpDwEIAAYMCAZYAAoHBQIECwoEWRIBDg4NUQANDQoOQhtLsBdQWEBLAgEADQ4NAA5mAAMOAQ4DXgABCAgBXBABCQgKCAkKZhEBDAYEBgxeAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CG0uwGFBYQEwCAQANDg0ADmYAAw4BDgNeAAEICAFcEAEJCAoICQpmEQEMBgQGDARmAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CG0BOAgEADQ4NAA5mAAMOAQ4DAWYAAQgOAQhkEAEJCAoICQpmEQEMBgQGDARmAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CWVlZQChTUzs7MjEXF1NeU15bWDtSO1JLQzc1MToyOhcwFzBRETEYESgVQBMWKwEGKwEiDgIdASE1NCY1NC4CKwEVIQUVFBYUDgIjBiYrASchBysBIiciLgI9ARciBhQWMzI2NCYXBgcOAx4BOwYyNicuAScmJwE1ND4COwEyFh0BARkbGlMSJRwSA5ABChgnHoX+SgKiARUfIw4OHw4gLf5JLB0iFBkZIBMIdwwSEgwNEhKMCAYFCwQCBA8OJUNRUEAkFxYJBQkFBQb+pAUPGhW8HykCHwEMGScaTCkQHAQNIBsSYYg0Fzo6JRcJAQGAgAETGyAOpz8RGhERGhF8GhYTJA4QDQgYGg0jERMUAXfkCxgTDB0m4wAAAgBA/8ADwANAAAcADwAiQB8PDg0MCwkGAQABQAAAAQEATQAAAAFRAAEAAUUTEAIQKwAgABAAIAAQAQcvATcXARcCuf6O/vkBBwFyAQf97C4tdC11AW8uA0D++f6O/vkBBwFy/nkuLnUudQFvLQAAAAIArgB/A00CegADAAcACLUGBAIAAiYrExcHJwEXASfc0i3SAnEt/jMtAX/SLdIBKC7+NC0AAAAAAgBA/8ADwANAAAcAEwAoQCUTEhEQDw4NDAsKCQgMAQABQAAAAQEATQAAAAFRAAEAAUUTEAIQKwAgABAAIAAQAwcnByc3JzcXNxcHArn+jv75AQcBcgEH0i3Bwi3CwS3Bwi3BA0D++f6O/vkBBwFy/oUtwcAtwcItwsEtwQAAAAABANkAWQMnAqcACwAGswcBASYrAScHJwcXBxc3FzcnAyYt+fkt+fkt+fkt+AJ5Lfn5Lfn5Lfj4LfkAAAACAYAAAAKAAwAAAwAOADtAOAkIBwMDAgFAAAABAGgAAQIBaAACAwJoBgUCAwQEA0sGBQIDAwRQAAQDBEQEBAQOBA4RFBIREAcTKwEzFSMTESMHFzcRIxUhNQHgQEBAIX8RT2ABAAMAQP2AAkAiPhb+CkBAAAMAQP/AA8ADQAAHAAsAFgA+QDsSERADBQYBQAcBBQYEBgUEZgAAAAIDAAJXAAMABgUDBlcABAEBBEsABAQBUQABBAFFERQRERETExAIFisAIAAQACAAECUzFSMTITUzNQcnNzMRMwK5/o7++QEHAXIBB/4gQECg/wBgTxF/IWADQP75/o7++QEHAXJHQP5AQPYWPiL+wAAAAwBA/8ADwANAAAcACwAPADFALgAAAAQFAARXBgEFAAMCBQNXAAIBAQJLAAICAVEAAQIBRQwMDA8MDxIRExMQBxMrACAAEAAgABABIzUzJxEzEQK5/o7++QEHAXIBB/5gQEBAQANA/vn+jv75AQcBcv5HQEABgP6AAAAAAAIB4AAAAiADAAADAAcAiUuwC1BYQBsAAQIAAgFeAAAAZwADAgIDSwADAwJPAAIDAkMbS7AUUFhAFgABAgACAV4AAABnAAICA08AAwMKAkIbS7AWUFhAFwABAgACAQBmAAAAZwACAgNPAAMDCgJCG0AcAAECAAIBAGYAAABnAAMCAgNLAAMDAk8AAgMCQ1lZWbUREREQBBIrISM1MyczESMCIEBAQEBAQEACgAABAAAAAQAAAKojcV8PPPUACwQAAAAAANWgkpMAAAAA1aCSkwAs/8ADwANAAAAACAACAAAAAAAAAAEAAANA/8AAXAQAAAAAAAPAAAEAAAAAAAAAAAAAAAAAAAAFBAAAAAAAAAABVQAAA+kALAQAAEAArgBAANkBgABAAEAB4AAAAAAAAAAAAAABPAF0AZAB0AHuAigCdAKyAwgAAAABAAAADABfAAUAAAAAAAIAJgA0AGwAAACKCZYAAAAAAAAADACWAAEAAAAAAAEACAAAAAEAAAAAAAIABgAIAAEAAAAAAAMAJAAOAAEAAAAAAAQACAAyAAEAAAAAAAUARQA6AAEAAAAAAAYACAB/AAMAAQQJAAEAEACHAAMAAQQJAAIADACXAAMAAQQJAAMASACjAAMAAQQJAAQAEADrAAMAAQQJAAUAigD7AAMAAQQJAAYAEAGFaWNvbmZvbnRNZWRpdW1Gb250Rm9yZ2UgMi4wIDogaWNvbmZvbnQgOiAyOC03LTIwMTdpY29uZm9udFZlcnNpb24gMS4wOyB0dGZhdXRvaGludCAodjAuOTQpIC1sIDggLXIgNTAgLUcgMjAwIC14IDE0IC13ICJHIiAtZiAtc2ljb25mb250AGkAYwBvAG4AZgBvAG4AdABNAGUAZABpAHUAbQBGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAGkAYwBvAG4AZgBvAG4AdAAgADoAIAAyADgALQA3AC0AMgAwADEANwBpAGMAbwBuAGYAbwBuAHQAVgBlAHIAcwBpAG8AbgAgADEALgAwADsAIAB0AHQAZgBhAHUAdABvAGgAaQBuAHQAIAAoAHYAMAAuADkANAApACAALQBsACAAOAAgAC0AcgAgADUAMAAgAC0ARwAgADIAMAAwACAALQB4ACAAMQA0ACAALQB3ACAAIgBHACIAIAAtAGYAIAAtAHMAaQBjAG8AbgBmAG8AbgB0AAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAABAAIAWwECAQMBBAEFAQYBBwEIAQkaemhlbmdxdWV3YW5jaGVuZy15dWFua3VhbmcQemhlbmdxdWV3YW5jaGVuZxtjdW93dWd1YW5iaXF1eGlhby15dWFua3VhbmcRY3Vvd3VndWFuYmlxdXhpYW8FeGlueGkPeGlueGkteXVhbmt1YW5nE2dhbnRhbmhhby15dWFua3VhbmcJZ2FudGFuaGFvAAEAAf//AA8AAAAAAAAAAAAAAAAAAAAAADIAMgMY/+EDQP/AAxj/4QNA/8CwACywIGBmLbABLCBkILDAULAEJlqwBEVbWCEjIRuKWCCwUFBYIbBAWRsgsDhQWCGwOFlZILAKRWFksChQWCGwCkUgsDBQWCGwMFkbILDAUFggZiCKimEgsApQWGAbILAgUFghsApgGyCwNlBYIbA2YBtgWVlZG7AAK1lZI7AAUFhlWVktsAIsIEUgsAQlYWQgsAVDUFiwBSNCsAYjQhshIVmwAWAtsAMsIyEjISBksQViQiCwBiNCsgoAAiohILAGQyCKIIqwACuxMAUlilFYYFAbYVJZWCNZISCwQFNYsAArGyGwQFkjsABQWGVZLbAELLAII0KwByNCsAAjQrAAQ7AHQ1FYsAhDK7IAAQBDYEKwFmUcWS2wBSywAEMgRSCwAkVjsAFFYmBELbAGLLAAQyBFILAAKyOxBAQlYCBFiiNhIGQgsCBQWCGwABuwMFBYsCAbsEBZWSOwAFBYZVmwAyUjYURELbAHLLEFBUWwAWFELbAILLABYCAgsApDSrAAUFggsAojQlmwC0NKsABSWCCwCyNCWS2wCSwguAQAYiC4BABjiiNhsAxDYCCKYCCwDCNCIy2wCixLVFixBwFEWSSwDWUjeC2wCyxLUVhLU1ixBwFEWRshWSSwE2UjeC2wDCyxAA1DVVixDQ1DsAFhQrAJK1mwAEOwAiVCsgABAENgQrEKAiVCsQsCJUKwARYjILADJVBYsABDsAQlQoqKIIojYbAIKiEjsAFhIIojYbAIKiEbsABDsAIlQrACJWGwCCohWbAKQ0ewC0NHYLCAYiCwAkVjsAFFYmCxAAATI0SwAUOwAD6yAQEBQ2BCLbANLLEABUVUWACwDSNCIGCwAWG1Dg4BAAwAQkKKYLEMBCuwaysbIlktsA4ssQANKy2wDyyxAQ0rLbAQLLECDSstsBEssQMNKy2wEiyxBA0rLbATLLEFDSstsBQssQYNKy2wFSyxBw0rLbAWLLEIDSstsBcssQkNKy2wGCywByuxAAVFVFgAsA0jQiBgsAFhtQ4OAQAMAEJCimCxDAQrsGsrGyJZLbAZLLEAGCstsBossQEYKy2wGyyxAhgrLbAcLLEDGCstsB0ssQQYKy2wHiyxBRgrLbAfLLEGGCstsCAssQcYKy2wISyxCBgrLbAiLLEJGCstsCMsIGCwDmAgQyOwAWBDsAIlsAIlUVgjIDywAWAjsBJlHBshIVktsCQssCMrsCMqLbAlLCAgRyAgsAJFY7ABRWJgI2E4IyCKVVggRyAgsAJFY7ABRWJgI2E4GyFZLbAmLLEABUVUWACwARawJSqwARUwGyJZLbAnLLAHK7EABUVUWACwARawJSqwARUwGyJZLbAoLCA1sAFgLbApLACwA0VjsAFFYrAAK7ACRWOwAUVisAArsAAWtAAAAAAARD4jOLEoARUqLbAqLCA8IEcgsAJFY7ABRWJgsABDYTgtsCssLhc8LbAsLCA8IEcgsAJFY7ABRWJgsABDYbABQ2M4LbAtLLECABYlIC4gR7AAI0KwAiVJiopHI0cjYSBYYhshWbABI0KyLAEBFRQqLbAuLLAAFrAEJbAEJUcjRyNhsAZFK2WKLiMgIDyKOC2wLyywABawBCWwBCUgLkcjRyNhILAEI0KwBkUrILBgUFggsEBRWLMCIAMgG7MCJgMaWUJCIyCwCUMgiiNHI0cjYSNGYLAEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmEjICCwBCYjRmE4GyOwCUNGsAIlsAlDRyNHI2FgILAEQ7CAYmAjILAAKyOwBENgsAArsAUlYbAFJbCAYrAEJmEgsAQlYGQjsAMlYGRQWCEbIyFZIyAgsAQmI0ZhOFktsDAssAAWICAgsAUmIC5HI0cjYSM8OC2wMSywABYgsAkjQiAgIEYjR7AAKyNhOC2wMiywABawAyWwAiVHI0cjYbAAVFguIDwjIRuwAiWwAiVHI0cjYSCwBSWwBCVHI0cjYbAGJbAFJUmwAiVhsAFFYyMgWGIbIVljsAFFYmAjLiMgIDyKOCMhWS2wMyywABYgsAlDIC5HI0cjYSBgsCBgZrCAYiMgIDyKOC2wNCwjIC5GsAIlRlJYIDxZLrEkARQrLbA1LCMgLkawAiVGUFggPFkusSQBFCstsDYsIyAuRrACJUZSWCA8WSMgLkawAiVGUFggPFkusSQBFCstsDcssC4rIyAuRrACJUZSWCA8WS6xJAEUKy2wOCywLyuKICA8sAQjQoo4IyAuRrACJUZSWCA8WS6xJAEUK7AEQy6wJCstsDkssAAWsAQlsAQmIC5HI0cjYbAGRSsjIDwgLiM4sSQBFCstsDossQkEJUKwABawBCWwBCUgLkcjRyNhILAEI0KwBkUrILBgUFggsEBRWLMCIAMgG7MCJgMaWUJCIyBHsARDsIBiYCCwACsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsIBiYbACJUZhOCMgPCM4GyEgIEYjR7AAKyNhOCFZsSQBFCstsDsssC4rLrEkARQrLbA8LLAvKyEjICA8sAQjQiM4sSQBFCuwBEMusCQrLbA9LLAAFSBHsAAjQrIAAQEVFBMusCoqLbA+LLAAFSBHsAAjQrIAAQEVFBMusCoqLbA/LLEAARQTsCsqLbBALLAtKi2wQSywABZFIyAuIEaKI2E4sSQBFCstsEIssAkjQrBBKy2wQyyyAAA6Ky2wRCyyAAE6Ky2wRSyyAQA6Ky2wRiyyAQE6Ky2wRyyyAAA7Ky2wSCyyAAE7Ky2wSSyyAQA7Ky2wSiyyAQE7Ky2wSyyyAAA3Ky2wTCyyAAE3Ky2wTSyyAQA3Ky2wTiyyAQE3Ky2wTyyyAAA5Ky2wUCyyAAE5Ky2wUSyyAQA5Ky2wUiyyAQE5Ky2wUyyyAAA8Ky2wVCyyAAE8Ky2wVSyyAQA8Ky2wViyyAQE8Ky2wVyyyAAA4Ky2wWCyyAAE4Ky2wWSyyAQA4Ky2wWiyyAQE4Ky2wWyywMCsusSQBFCstsFwssDArsDQrLbBdLLAwK7A1Ky2wXiywABawMCuwNistsF8ssDErLrEkARQrLbBgLLAxK7A0Ky2wYSywMSuwNSstsGIssDErsDYrLbBjLLAyKy6xJAEUKy2wZCywMiuwNCstsGUssDIrsDUrLbBmLLAyK7A2Ky2wZyywMysusSQBFCstsGgssDMrsDQrLbBpLLAzK7A1Ky2waiywMyuwNistsGssK7AIZbADJFB4sAEVMC0AAEu4AMhSWLEBAY5ZuQgACABjILABI0QgsAMjcLAORSAgS7gADlFLsAZTWliwNBuwKFlgZiCKVViwAiVhsAFFYyNisAIjRLMKCQUEK7MKCwUEK7MODwUEK1myBCgJRVJEswoNBgQrsQYBRLEkAYhRWLBAiFixBgNEsSYBiFFYuAQAiFixBgFEWVlZWbgB/4WwBI2xBQBEAAAA"},function(A,s,e){var t=e(5);"string"==typeof t&&(t=[[A.i,t,""]]);var r={};r.transform=void 0;e(8)(t,r);t.locals&&(A.exports=t.locals)},function(A,s,e){var t=e(12)(e(3),e(13),null,null,null);t.options.__file="/Users/gusaifei/Workspace/workspace-personal/progress/src/components/progress.vue",t.esModule&&Object.keys(t.esModule).some(function(A){return"default"!==A&&"__"!==A.substr(0,2)})&&console.error("named exports are not supported in *.vue files."),t.options.functional&&console.error("[vue-loader] progress.vue: functional components are not supported with templates, they should use render functions."),A.exports=t.exports},function(A,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0}),s.default={name:"VmProgress",componentName:"VmProgress",props:{type:{type:String,default:"line",validator:function(A){return["line","circle"].indexOf(A)>-1}},percentage:{type:[Number,String],default:0,required:!0,validator:function(A){return A>=0&&A<=100}},strokeWidth:{type:[Number,String],default:6},strokeLinecap:{type:String,default:"round",validator:function(A){return["butt","square","round"].indexOf(A)>-1}},strokeColor:{type:String},trackColor:{type:String,default:function(){return"line"===this.type?"#e4e8f1":"#e5e9f2"}},textInside:{type:Boolean,default:!1},showText:{type:Boolean,default:!0},status:{type:String,validator:function(A){return["success","exception","warning","info"].indexOf(A)>-1}},width:{type:Number,default:126},reverse:{type:Boolean,default:!1},striped:{type:Boolean,default:!1},linearClassName:String},data:function(){return{st:this.status}},watch:{percentage:function(A){this.$slots.default||(this.st=100===A?"success":this.status)},status:function(A){this.st=A}},computed:{barStyle:function(){var A={};return A.width=this.percentage+"%",this.strokeColor&&(A.backgroundColor=this.strokeColor),A},relativeStrokeWidth:function(){return(this.strokeWidth/this.width*100).toFixed(1)},trackPath:function(){var A=parseInt(50-parseFloat(this.relativeStrokeWidth)/2,10),s=this.reverse?0:1;return"M 50 50 m 0 -"+A+" a "+A+" "+A+" 0 1 "+s+" 0 "+2*A+" a "+A+" "+A+" 0 1 "+s+" 0 -"+2*A},perimeter:function(){var A=50-parseFloat(this.relativeStrokeWidth)/2;return 2*Math.PI*A},circlePathStyle:function(){var A=this.perimeter;return{strokeDasharray:A+"px,"+A+"px",strokeDashoffset:(1-this.percentage/100)*A+"px",transition:"stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease"}},stroke:function(){var A=void 0;switch(this.st){case"success":A="#13ce66";break;case"warning":A="#f7ba2a";break;case"info":A="#50bfff";break;case"exception":A="#ff4949";break;default:A=this.strokeColor?this.strokeColor:"#20a0ff"}return A},iconClass:function(){return"vm-progress-icon"+("line"===this.type?"-circle":"")+"--"+("exception"===this.st?"error":this.st)},progressTextSize:function(){return"line"===this.type?12+.4*this.strokeWidth:.111111*this.width+2}}}},function(A,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var t=e(2),r=e.n(t),n=e(1),i=(e.n(n),function A(s){arguments.length>1&&void 0!==arguments[1]&&arguments[1];A.installed||s.component("VmProgress",r.a)});"undefined"!=typeof window&&window.Vue&&Vue.component("VmProgress",r.a),r.a.install=i,s.default=r.a},function(A,s,e){s=A.exports=e(6)(void 0),s.push([A.i,'@font-face {\n  font-family: "iconfont";\n  src: url('+e(0)+");\n  /* IE9*/\n  src: url("+e(0)+"#iefix) format('embedded-opentype'),  url("+e(11)+") format('woff'),  url("+e(10)+") format('truetype'),  url("+e(7)+'#iconfont) format(\'svg\');\n  /* iOS 4.1- */\n}\n[class^="vm-progress-icon"],\n[class*=" vm-progress-icon"] {\n  font-family: "iconfont" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.vm-progress-icon-circle--success {\n  color: #13ce66;\n}\n.vm-progress-icon-circle--success:before {\n  content: "\\E8E4";\n}\n.vm-progress-icon--success {\n  color: #13ce66;\n}\n.vm-progress-icon--success:before {\n  content: "\\E8E5";\n}\n.vm-progress-icon-circle--error {\n  color: #ff4949;\n}\n.vm-progress-icon-circle--error:before {\n  content: "\\E8E7";\n}\n.vm-progress-icon--error {\n  color: #ff4949;\n}\n.vm-progress-icon--error:before {\n  content: "\\E8E8";\n}\n.vm-progress-icon-circle--info {\n  color: #50bfff;\n}\n.vm-progress-icon-circle--info:before {\n  content: "\\E8EA";\n}\n.vm-progress-icon--info {\n  color: #50bfff;\n}\n.vm-progress-icon--info:before {\n  content: "\\E8E9";\n}\n.vm-progress-icon-circle--warning {\n  color: #f7ba2a;\n}\n.vm-progress-icon-circle--warning:before {\n  content: "\\E8EC";\n}\n.vm-progress-icon--warning {\n  color: #f7ba2a;\n}\n.vm-progress-icon--warning:before {\n  content: "\\E8EE";\n}\n.vm-progress-icon--close:before {\n  content: "\\E8E8";\n}\n.vm-progress {\n  position: relative;\n  line-height: 1;\n}\n.vm-progress__text {\n  display: inline-block;\n  vertical-align: middle;\n  margin-left: 10px;\n  font-size: 14px;\n  color: #48576a;\n  line-height: 1;\n}\n.vm-progress--circle {\n  display: inline-block;\n}\n.vm-progress--circle .vm-progress__text {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  width: 100%;\n  margin: 0;\n  text-align: center;\n  transform: translate(0, -50%);\n}\n.vm-progress--circle .vm-progress__text i {\n  display: inline-block;\n  vertical-align: middle;\n  font-size: 22px;\n  font-weight: bold;\n}\n.vm-progress.is-success .vm-progress-bar__inner {\n  background-color: #13ce66;\n}\n.vm-progress.is-success .vm-progress__text {\n  color: #13ce66;\n}\n.vm-progress.is-exception .vm-progress-bar__inner {\n  background-color: #ff4949;\n}\n.vm-progress.is-exception .vm-progress__text {\n  color: #ff4949;\n}\n.vm-progress.is-warning .vm-progress-bar__inner {\n  background-color: #f7ba2a;\n}\n.vm-progress.is-warning .vm-progress__text {\n  color: #f7ba2a;\n}\n.vm-progress.is-info .vm-progress-bar__inner {\n  background-color: #50bfff;\n}\n.vm-progress.is-info .vm-progress__text {\n  color: #50bfff;\n}\n.vm-progress--without-text .vm-progress__text {\n  display: none;\n}\n.vm-progress--without-text .vm-progress-bar {\n  padding-right: 0;\n  margin-right: 0;\n  display: block;\n}\n.vm-progress--text-inside .vm-progress-bar {\n  padding-right: 0;\n  margin-right: 0;\n}\n.vm-progress-bar {\n  display: inline-block;\n  vertical-align: middle;\n  width: 100%;\n  padding-right: 50px;\n  margin-right: -55px;\n  box-sizing: border-box;\n}\n.vm-progress-bar__outer {\n  position: relative;\n  height: 6px;\n  background-color: #e4e8f1;\n  border-radius: 100px;\n  vertical-align: middle;\n  overflow: hidden;\n}\n.vm-progress-bar__inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  height: 100%;\n  line-height: 1;\n  text-align: right;\n  background-color: #20a0ff;\n  border-radius: 100px;\n}\n.vm-progress-bar__innerText {\n  display: inline-block;\n  vertical-align: middle;\n  color: #fff;\n  font-size: 12px;\n  margin: 0 5px;\n  white-space: nowrap;\n}\n.vm-progress-bar__striped {\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n  background-size: 40px 40px;\n  animation: progress-bar-stripes 2s linear infinite;\n}\n@keyframes progress-bar-stripes {\n  from {\n    background-position: 40px 0;\n  }\n  to {\n    background-position: 0 0;\n  }\n}\n',""])},function(A,s){function e(A,s){var e=A[1]||"",r=A[3];if(!r)return e;if(s&&"function"==typeof btoa){var n=t(r);return[e].concat(r.sources.map(function(A){return"/*# sourceURL="+r.sourceRoot+A+" */"})).concat([n]).join("\n")}return[e].join("\n")}function t(A){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(A))))+" */"}A.exports=function(A){var s=[];return s.toString=function(){return this.map(function(s){var t=e(s,A);return s[2]?"@media "+s[2]+"{"+t+"}":t}).join("")},s.i=function(A,e){"string"==typeof A&&(A=[[null,A,""]]);for(var t={},r=0;r<this.length;r++){var n=this[r][0];"number"==typeof n&&(t[n]=!0)}for(r=0;r<A.length;r++){var i=A[r];"number"==typeof i[0]&&t[i[0]]||(e&&!i[2]?i[2]=e:e&&(i[2]="("+i[2]+") and ("+e+")"),s.push(i))}},s}},function(A,s,e){A.exports=e.p+"iconfont.svg?247a342cb02057a16940fcd318e2b91c"},function(A,s,e){function t(A,s){for(var e=0;e<A.length;e++){var t=A[e],r=a[t.id];if(r){r.refs++;for(var n=0;n<r.parts.length;n++)r.parts[n](t.parts[n]);for(;n<t.parts.length;n++)r.parts.push(C(t.parts[n],s))}else{for(var i=[],n=0;n<t.parts.length;n++)i.push(C(t.parts[n],s));a[t.id]={id:t.id,refs:1,parts:i}}}}function r(A,s){for(var e=[],t={},r=0;r<A.length;r++){var n=A[r],i=s.base?n[0]+s.base:n[0],o=n[1],B=n[2],g=n[3],C={css:o,media:B,sourceMap:g};t[i]?t[i].parts.push(C):e.push(t[i]={id:i,parts:[C]})}return e}function n(A,s){var e=y(A.insertInto);if(!e)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var t=u[u.length-1];if("top"===A.insertAt)t?t.nextSibling?e.insertBefore(s,t.nextSibling):e.appendChild(s):e.insertBefore(s,e.firstChild),u.push(s);else{if("bottom"!==A.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");e.appendChild(s)}}function i(A){if(null===A.parentNode)return!1;A.parentNode.removeChild(A);var s=u.indexOf(A);s>=0&&u.splice(s,1)}function o(A){var s=document.createElement("style");return A.attrs.type="text/css",g(s,A.attrs),n(A,s),s}function B(A){var s=document.createElement("link");return A.attrs.type="text/css",A.attrs.rel="stylesheet",g(s,A.attrs),n(A,s),s}function g(A,s){Object.keys(s).forEach(function(e){A.setAttribute(e,s[e])})}function C(A,s){var e,t,r,n;if(s.transform&&A.css){if(!(n=s.transform(A.css)))return function(){};A.css=n}if(s.singleton){var g=l++;e=I||(I=o(s)),t=Q.bind(null,e,g,!1),r=Q.bind(null,e,g,!0)}else A.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(e=B(s),t=c.bind(null,e,s),r=function(){i(e),e.href&&URL.revokeObjectURL(e.href)}):(e=o(s),t=w.bind(null,e),r=function(){i(e)});return t(A),function(s){if(s){if(s.css===A.css&&s.media===A.media&&s.sourceMap===A.sourceMap)return;t(A=s)}else r()}}function Q(A,s,e,t){var r=e?"":t.css;if(A.styleSheet)A.styleSheet.cssText=L(s,r);else{var n=document.createTextNode(r),i=A.childNodes;i[s]&&A.removeChild(i[s]),i.length?A.insertBefore(n,i[s]):A.appendChild(n)}}function w(A,s){var e=s.css,t=s.media;if(t&&A.setAttribute("media",t),A.styleSheet)A.styleSheet.cssText=e;else{for(;A.firstChild;)A.removeChild(A.firstChild);A.appendChild(document.createTextNode(e))}}function c(A,s,e){var t=e.css,r=e.sourceMap,n=void 0===s.convertToAbsoluteUrls&&r;(s.convertToAbsoluteUrls||n)&&(t=p(t)),r&&(t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var i=new Blob([t],{type:"text/css"}),o=A.href;A.href=URL.createObjectURL(i),o&&URL.revokeObjectURL(o)}var a={},E=function(A){var s;return function(){return void 0===s&&(s=A.apply(this,arguments)),s}}(function(){return window&&document&&document.all&&!window.atob}),y=function(A){var s={};return function(e){return void 0===s[e]&&(s[e]=A.call(this,e)),s[e]}}(function(A){return document.querySelector(A)}),I=null,l=0,u=[],p=e(9);A.exports=function(A,s){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");s=s||{},s.attrs="object"==typeof s.attrs?s.attrs:{},s.singleton||(s.singleton=E()),s.insertInto||(s.insertInto="head"),s.insertAt||(s.insertAt="bottom");var e=r(A,s);return t(e,s),function(A){for(var n=[],i=0;i<e.length;i++){var o=e[i],B=a[o.id];B.refs--,n.push(B)}if(A){t(r(A,s),s)}for(var i=0;i<n.length;i++){var B=n[i];if(0===B.refs){for(var g=0;g<B.parts.length;g++)B.parts[g]();delete a[B.id]}}}};var L=function(){var A=[];return function(s,e){return A[s]=e,A.filter(Boolean).join("\n")}}()},function(A,s){A.exports=function(A){var s="undefined"!=typeof window&&window.location;if(!s)throw new Error("fixUrls requires window.location");if(!A||"string"!=typeof A)return A;var e=s.protocol+"//"+s.host,t=e+s.pathname.replace(/\/[^\/]*$/,"/");return A.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(A,s){var r=s.trim().replace(/^"(.*)"$/,function(A,s){return s}).replace(/^'(.*)'$/,function(A,s){return s});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(r))return A;var n;return n=0===r.indexOf("//")?r:0===r.indexOf("/")?e+r:t+r.replace(/^\.\//,""),"url("+JSON.stringify(n)+")"})}},function(A,s){A.exports="data:application/x-font-ttf;base64,AAEAAAAQAQAABAAARkZUTXd+x/YAAAEMAAAAHEdERUYAOQAGAAABKAAAACBPUy8yVxRbvgAAAUgAAABWY21hcNL42GwAAAGgAAABamN2dCAM5f90AAAM1AAAACRmcGdtMPeelQAADPgAAAmWZ2FzcAAAABAAAAzMAAAACGdseWaxLuVGAAADDAAABhBoZWFkDkxpIwAACRwAAAA2aGhlYQdeA8YAAAlUAAAAJGhtdHgQ5QJsAAAJeAAAACJsb2NhCjYIHgAACZwAAAAabWF4cAEuCisAAAm4AAAAIG5hbWUULc4VAAAJ2AAAAitwb3N0viQ/1QAADAQAAADIcHJlcKW5vmYAABaQAAAAlQAAAAEAAAAAzD2izwAAAADVoJKTAAAAANWgkpMAAQAAAA4AAAAYAAAAAAACAAEAAwALAAEABAAAAAIAAAABA/0B9AAFAAgCmQLMAAAAjwKZAswAAAHrADMBCQAAAgAGAwAAAAAAAAAAAAEQAAAAAAAAAAAAAABQZkVkAEAAeOjuA4D/gABcA0AAQAAAAAEAAAAAAAAAAAADAAAAAwAAABwAAQAAAAAAZAADAAEAAAAcAAQASAAAAA4ACAACAAYAAAB46OXo6ujs6O7//wAAAAAAeOjk6Ofo7Oju//8AAP+LFyAXHxceFx0AAQAAAAAAAAAAAAAAAAAAAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUALP/hA7wDGAAWADAAOgBSAF4Bd0uwE1BYQEoCAQANDg0ADmYAAw4BDgNeAAEICAFcEAEJCAoGCV4RAQwGBAYMXgALBAtpDwEIAAYMCAZYAAoHBQIECwoEWRIBDg4NUQANDQoOQhtLsBdQWEBLAgEADQ4NAA5mAAMOAQ4DXgABCAgBXBABCQgKCAkKZhEBDAYEBgxeAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CG0uwGFBYQEwCAQANDg0ADmYAAw4BDgNeAAEICAFcEAEJCAoICQpmEQEMBgQGDARmAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CG0BOAgEADQ4NAA5mAAMOAQ4DAWYAAQgOAQhkEAEJCAoICQpmEQEMBgQGDARmAAsEC2kPAQgABgwIBlgACgcFAgQLCgRZEgEODg1RAA0NCg5CWVlZQChTUzs7MjEXF1NeU15bWDtSO1JLQzc1MToyOhcwFzBRETEYESgVQBMWKwEGKwEiDgIdASE1NCY1NC4CKwEVIQUVFBYUDgIjBiYrASchBysBIiciLgI9ARciBhQWMzI2NCYXBgcOAx4BOwYyNicuAScmJwE1ND4COwEyFh0BARkbGlMSJRwSA5ABChgnHoX+SgKiARUfIw4OHw4gLf5JLB0iFBkZIBMIdwwSEgwNEhKMCAYFCwQCBA8OJUNRUEAkFxYJBQkFBQb+pAUPGhW8HykCHwEMGScaTCkQHAQNIBsSYYg0Fzo6JRcJAQGAgAETGyAOpz8RGhERGhF8GhYTJA4QDQgYGg0jERMUAXfkCxgTDB0m4wAAAgBA/8ADwANAAAcADwAiQB8PDg0MCwkGAQABQAAAAQEATQAAAAFRAAEAAUUTEAIQKwAgABAAIAAQAQcvATcXARcCuf6O/vkBBwFyAQf97C4tdC11AW8uA0D++f6O/vkBBwFy/nkuLnUudQFvLQAAAAIArgB/A00CegADAAcACLUGBAIAAiYrExcHJwEXASfc0i3SAnEt/jMtAX/SLdIBKC7+NC0AAAAAAgBA/8ADwANAAAcAEwAoQCUTEhEQDw4NDAsKCQgMAQABQAAAAQEATQAAAAFRAAEAAUUTEAIQKwAgABAAIAAQAwcnByc3JzcXNxcHArn+jv75AQcBcgEH0i3Bwi3CwS3Bwi3BA0D++f6O/vkBBwFy/oUtwcAtwcItwsEtwQAAAAABANkAWQMnAqcACwAGswcBASYrAScHJwcXBxc3FzcnAyYt+fkt+fkt+fkt+AJ5Lfn5Lfn5Lfj4LfkAAAACAYAAAAKAAwAAAwAOADtAOAkIBwMDAgFAAAABAGgAAQIBaAACAwJoBgUCAwQEA0sGBQIDAwRQAAQDBEQEBAQOBA4RFBIREAcTKwEzFSMTESMHFzcRIxUhNQHgQEBAIX8RT2ABAAMAQP2AAkAiPhb+CkBAAAMAQP/AA8ADQAAHAAsAFgA+QDsSERADBQYBQAcBBQYEBgUEZgAAAAIDAAJXAAMABgUDBlcABAEBBEsABAQBUQABBAFFERQRERETExAIFisAIAAQACAAECUzFSMTITUzNQcnNzMRMwK5/o7++QEHAXIBB/4gQECg/wBgTxF/IWADQP75/o7++QEHAXJHQP5AQPYWPiL+wAAAAwBA/8ADwANAAAcACwAPADFALgAAAAQFAARXBgEFAAMCBQNXAAIBAQJLAAICAVEAAQIBRQwMDA8MDxIRExMQBxMrACAAEAAgABABIzUzJxEzEQK5/o7++QEHAXIBB/5gQEBAQANA/vn+jv75AQcBcv5HQEABgP6AAAAAAAIB4AAAAiADAAADAAcAiUuwC1BYQBsAAQIAAgFeAAAAZwADAgIDSwADAwJPAAIDAkMbS7AUUFhAFgABAgACAV4AAABnAAICA08AAwMKAkIbS7AWUFhAFwABAgACAQBmAAAAZwACAgNPAAMDCgJCG0AcAAECAAIBAGYAAABnAAMCAgNLAAMDAk8AAgMCQ1lZWbUREREQBBIrISM1MyczESMCIEBAQEBAQEACgAABAAAAAQAAAKojcV8PPPUACwQAAAAAANWgkpMAAAAA1aCSkwAs/8ADwANAAAAACAACAAAAAAAAAAEAAANA/8AAXAQAAAAAAAPAAAEAAAAAAAAAAAAAAAAAAAAFBAAAAAAAAAABVQAAA+kALAQAAEAArgBAANkBgABAAEAB4AAAAAAAAAAAAAABPAF0AZAB0AHuAigCdAKyAwgAAAABAAAADABfAAUAAAAAAAIAJgA0AGwAAACKCZYAAAAAAAAADACWAAEAAAAAAAEACAAAAAEAAAAAAAIABgAIAAEAAAAAAAMAJAAOAAEAAAAAAAQACAAyAAEAAAAAAAUARQA6AAEAAAAAAAYACAB/AAMAAQQJAAEAEACHAAMAAQQJAAIADACXAAMAAQQJAAMASACjAAMAAQQJAAQAEADrAAMAAQQJAAUAigD7AAMAAQQJAAYAEAGFaWNvbmZvbnRNZWRpdW1Gb250Rm9yZ2UgMi4wIDogaWNvbmZvbnQgOiAyOC03LTIwMTdpY29uZm9udFZlcnNpb24gMS4wOyB0dGZhdXRvaGludCAodjAuOTQpIC1sIDggLXIgNTAgLUcgMjAwIC14IDE0IC13ICJHIiAtZiAtc2ljb25mb250AGkAYwBvAG4AZgBvAG4AdABNAGUAZABpAHUAbQBGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAGkAYwBvAG4AZgBvAG4AdAAgADoAIAAyADgALQA3AC0AMgAwADEANwBpAGMAbwBuAGYAbwBuAHQAVgBlAHIAcwBpAG8AbgAgADEALgAwADsAIAB0AHQAZgBhAHUAdABvAGgAaQBuAHQAIAAoAHYAMAAuADkANAApACAALQBsACAAOAAgAC0AcgAgADUAMAAgAC0ARwAgADIAMAAwACAALQB4ACAAMQA0ACAALQB3ACAAIgBHACIAIAAtAGYAIAAtAHMAaQBjAG8AbgBmAG8AbgB0AAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAABAAIAWwECAQMBBAEFAQYBBwEIAQkaemhlbmdxdWV3YW5jaGVuZy15dWFua3VhbmcQemhlbmdxdWV3YW5jaGVuZxtjdW93dWd1YW5iaXF1eGlhby15dWFua3VhbmcRY3Vvd3VndWFuYmlxdXhpYW8FeGlueGkPeGlueGkteXVhbmt1YW5nE2dhbnRhbmhhby15dWFua3VhbmcJZ2FudGFuaGFvAAEAAf//AA8AAAAAAAAAAAAAAAAAAAAAADIAMgMY/+EDQP/AAxj/4QNA/8CwACywIGBmLbABLCBkILDAULAEJlqwBEVbWCEjIRuKWCCwUFBYIbBAWRsgsDhQWCGwOFlZILAKRWFksChQWCGwCkUgsDBQWCGwMFkbILDAUFggZiCKimEgsApQWGAbILAgUFghsApgGyCwNlBYIbA2YBtgWVlZG7AAK1lZI7AAUFhlWVktsAIsIEUgsAQlYWQgsAVDUFiwBSNCsAYjQhshIVmwAWAtsAMsIyEjISBksQViQiCwBiNCsgoAAiohILAGQyCKIIqwACuxMAUlilFYYFAbYVJZWCNZISCwQFNYsAArGyGwQFkjsABQWGVZLbAELLAII0KwByNCsAAjQrAAQ7AHQ1FYsAhDK7IAAQBDYEKwFmUcWS2wBSywAEMgRSCwAkVjsAFFYmBELbAGLLAAQyBFILAAKyOxBAQlYCBFiiNhIGQgsCBQWCGwABuwMFBYsCAbsEBZWSOwAFBYZVmwAyUjYURELbAHLLEFBUWwAWFELbAILLABYCAgsApDSrAAUFggsAojQlmwC0NKsABSWCCwCyNCWS2wCSwguAQAYiC4BABjiiNhsAxDYCCKYCCwDCNCIy2wCixLVFixBwFEWSSwDWUjeC2wCyxLUVhLU1ixBwFEWRshWSSwE2UjeC2wDCyxAA1DVVixDQ1DsAFhQrAJK1mwAEOwAiVCsgABAENgQrEKAiVCsQsCJUKwARYjILADJVBYsABDsAQlQoqKIIojYbAIKiEjsAFhIIojYbAIKiEbsABDsAIlQrACJWGwCCohWbAKQ0ewC0NHYLCAYiCwAkVjsAFFYmCxAAATI0SwAUOwAD6yAQEBQ2BCLbANLLEABUVUWACwDSNCIGCwAWG1Dg4BAAwAQkKKYLEMBCuwaysbIlktsA4ssQANKy2wDyyxAQ0rLbAQLLECDSstsBEssQMNKy2wEiyxBA0rLbATLLEFDSstsBQssQYNKy2wFSyxBw0rLbAWLLEIDSstsBcssQkNKy2wGCywByuxAAVFVFgAsA0jQiBgsAFhtQ4OAQAMAEJCimCxDAQrsGsrGyJZLbAZLLEAGCstsBossQEYKy2wGyyxAhgrLbAcLLEDGCstsB0ssQQYKy2wHiyxBRgrLbAfLLEGGCstsCAssQcYKy2wISyxCBgrLbAiLLEJGCstsCMsIGCwDmAgQyOwAWBDsAIlsAIlUVgjIDywAWAjsBJlHBshIVktsCQssCMrsCMqLbAlLCAgRyAgsAJFY7ABRWJgI2E4IyCKVVggRyAgsAJFY7ABRWJgI2E4GyFZLbAmLLEABUVUWACwARawJSqwARUwGyJZLbAnLLAHK7EABUVUWACwARawJSqwARUwGyJZLbAoLCA1sAFgLbApLACwA0VjsAFFYrAAK7ACRWOwAUVisAArsAAWtAAAAAAARD4jOLEoARUqLbAqLCA8IEcgsAJFY7ABRWJgsABDYTgtsCssLhc8LbAsLCA8IEcgsAJFY7ABRWJgsABDYbABQ2M4LbAtLLECABYlIC4gR7AAI0KwAiVJiopHI0cjYSBYYhshWbABI0KyLAEBFRQqLbAuLLAAFrAEJbAEJUcjRyNhsAZFK2WKLiMgIDyKOC2wLyywABawBCWwBCUgLkcjRyNhILAEI0KwBkUrILBgUFggsEBRWLMCIAMgG7MCJgMaWUJCIyCwCUMgiiNHI0cjYSNGYLAEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmEjICCwBCYjRmE4GyOwCUNGsAIlsAlDRyNHI2FgILAEQ7CAYmAjILAAKyOwBENgsAArsAUlYbAFJbCAYrAEJmEgsAQlYGQjsAMlYGRQWCEbIyFZIyAgsAQmI0ZhOFktsDAssAAWICAgsAUmIC5HI0cjYSM8OC2wMSywABYgsAkjQiAgIEYjR7AAKyNhOC2wMiywABawAyWwAiVHI0cjYbAAVFguIDwjIRuwAiWwAiVHI0cjYSCwBSWwBCVHI0cjYbAGJbAFJUmwAiVhsAFFYyMgWGIbIVljsAFFYmAjLiMgIDyKOCMhWS2wMyywABYgsAlDIC5HI0cjYSBgsCBgZrCAYiMgIDyKOC2wNCwjIC5GsAIlRlJYIDxZLrEkARQrLbA1LCMgLkawAiVGUFggPFkusSQBFCstsDYsIyAuRrACJUZSWCA8WSMgLkawAiVGUFggPFkusSQBFCstsDcssC4rIyAuRrACJUZSWCA8WS6xJAEUKy2wOCywLyuKICA8sAQjQoo4IyAuRrACJUZSWCA8WS6xJAEUK7AEQy6wJCstsDkssAAWsAQlsAQmIC5HI0cjYbAGRSsjIDwgLiM4sSQBFCstsDossQkEJUKwABawBCWwBCUgLkcjRyNhILAEI0KwBkUrILBgUFggsEBRWLMCIAMgG7MCJgMaWUJCIyBHsARDsIBiYCCwACsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsIBiYbACJUZhOCMgPCM4GyEgIEYjR7AAKyNhOCFZsSQBFCstsDsssC4rLrEkARQrLbA8LLAvKyEjICA8sAQjQiM4sSQBFCuwBEMusCQrLbA9LLAAFSBHsAAjQrIAAQEVFBMusCoqLbA+LLAAFSBHsAAjQrIAAQEVFBMusCoqLbA/LLEAARQTsCsqLbBALLAtKi2wQSywABZFIyAuIEaKI2E4sSQBFCstsEIssAkjQrBBKy2wQyyyAAA6Ky2wRCyyAAE6Ky2wRSyyAQA6Ky2wRiyyAQE6Ky2wRyyyAAA7Ky2wSCyyAAE7Ky2wSSyyAQA7Ky2wSiyyAQE7Ky2wSyyyAAA3Ky2wTCyyAAE3Ky2wTSyyAQA3Ky2wTiyyAQE3Ky2wTyyyAAA5Ky2wUCyyAAE5Ky2wUSyyAQA5Ky2wUiyyAQE5Ky2wUyyyAAA8Ky2wVCyyAAE8Ky2wVSyyAQA8Ky2wViyyAQE8Ky2wVyyyAAA4Ky2wWCyyAAE4Ky2wWSyyAQA4Ky2wWiyyAQE4Ky2wWyywMCsusSQBFCstsFwssDArsDQrLbBdLLAwK7A1Ky2wXiywABawMCuwNistsF8ssDErLrEkARQrLbBgLLAxK7A0Ky2wYSywMSuwNSstsGIssDErsDYrLbBjLLAyKy6xJAEUKy2wZCywMiuwNCstsGUssDIrsDUrLbBmLLAyK7A2Ky2wZyywMysusSQBFCstsGgssDMrsDQrLbBpLLAzK7A1Ky2waiywMyuwNistsGssK7AIZbADJFB4sAEVMC0AAEu4AMhSWLEBAY5ZuQgACABjILABI0QgsAMjcLAORSAgS7gADlFLsAZTWliwNBuwKFlgZiCKVViwAiVhsAFFYyNisAIjRLMKCQUEK7MKCwUEK7MODwUEK1myBCgJRVJEswoNBgQrsQYBRLEkAYhRWLBAiFixBgNEsSYBiFFYuAQAiFixBgFEWVlZWbgB/4WwBI2xBQBEAAAA"},function(A,s){A.exports="data:application/font-woff;base64,d09GRgABAAAAAA4sABAAAAAAFzwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABoAAAAcd37H9kdERUYAAAGIAAAAHQAAACAAOQAET1MvMgAAAagAAABHAAAAVlcUW75jbWFwAAAB8AAAAF8AAAFq0vjYbGN2dCAAAAJQAAAAGAAAACQM5f90ZnBnbQAAAmgAAAT8AAAJljD3npVnYXNwAAAHZAAAAAgAAAAIAAAAEGdseWYAAAdsAAADyAAABhCxL+VHaGVhZAAACzQAAAAwAAAANg5gaSNoaGVhAAALZAAAAB0AAAAkB14DxmhtdHgAAAuEAAAAIgAAACIQ5wJsbG9jYQAAC6gAAAAaAAAAGgo2CB5tYXhwAAALxAAAACAAAAAgAS4CDG5hbWUAAAvkAAABQwAAAj0lSsBUcG9zdAAADSgAAABsAAAAyL4kP9VwcmVwAAANlAAAAJUAAACVpbm+ZnicY2BgYGQAgjO2i86D6KsLJk2G0QBQdQewAAB4nGNgZGBg4ANiCQYQYGJgBEJuIGYB8xgABMMAPgAAAHicY2Bk/sv4hYGVgYNpJtMZBgaGfgjN+JrBmJGTgYGJgY2ZAQYYBRgQICDNNYXBgaHixTvmhv8NDDHMDkAeUA1IDgBdog15AHicY2BgYGaAYBkGRgYQSAHyGMF8FgYPIM3HwMHAxMAGZFW8ePri1Ys3L979/w9WWfHiyYvnMP7/bnEFcXlxOXFZqDlIgBGoGybIyAQkmNAVoOugHmCmndEkAQA9fRb+AHicY2BAA0YMRswS/x8yO/w/AKMBRGYIX3icnVVpd9NGFJW8ZE/aksRQRNsxE6c0GpmwBQMuBCmyC+niQGgl6CInMV34A3zsZ/2ap9Ce04/8tN47XhJaek7bHEvvvpk7b9N7E3GMqOx5IK5RR0pe96Sy/lQq8bOkrutenijp9ZK6bKeekhZRK02VzMX9I7lEdS5WskmwScbrXqKeqzzvg9JLMqwoSyLaItrKvCxNU08cP021OL1kkKaBlIyCnUqjjxCqUS+Rqg5lSodevZ6KmwVSNhrxqKOiehAq7hzPOaWNOmCkcpXDXLFZbeR7Sdbz+o/SRKfY236cYMNj9CNXgVSMzMD2NB6HTyTT0V4iM5F/7LhOlIVSG1wAr2qwx6BK8aG48UG2E8jUeM3xdVGpNDIV57rPstksHY+VEOXB39ihlBu6v4Oz06aoVmNx+8AzBjkplCh6SBaADlOZp/YI2jy0QGaN+qPiHPB1CC+yEGUqz5Qs6FAHMmd295Ni2t1J12RxoF8GMm9295Ldx8NFr471Zbu+YApnMXqSFIuLEdyHMuunTLvUCEcZF3PAxTxe4ta0QsjIAoxKI8xRW/ie2ahrnB1jb3Qej9VTZNJF/N1Mfj04qVjhOMt6R9xInLvHruvCVSCLCKca7yeOLOpQZbD6+9KS6yw4YZhnxULFlxe+dxH5LzFuP5B3TOFSvmuKEuV7pihTnjFFhXIZhaVcMcUU5aoppilrppihPGuKWcpzRqb9f+n7ffg+hzPn4ZvSg2/KC/BN+QF8U34I35QfwTelgm/KOnxTXoRvSm3gbSlTEaqYsXT47SVataFqOTO4wD4PZM2I9kVvBNIwSnXVSSl1v6VV/iT566LHY+uTkro1aWyIu7pps/j4dMZvbl0y6oadq0+MI+WhPXT12DShU/vN4d/OXd0qLrmriGrDqDYimASANui3AvFN82w7EPOWXXz8QzAC1M+pNVRTde3UlRoP8ryruxie5MDjiGOgjeuursBLE1NWQ/PhZykyFfuDvKmVauewdflkWzWHNqTC2yL2lWScpu295FVJlZX3qrRePp+GIXp6FteEtmzdyaQSoVEzzvHwripF2ZGWctQ/QueXor4HnHF2QevDMe5E3UG1Nex0+PlmI2sLJoamtL0ToGQsXRVjUeVZnGN0DWsdb9wSnq6nJxbxKTaZj8JKdX2Uj24jzSt2WWbRqEp1dJf2WeyrNv0yO2hYHWc/aao27uphW40qUj1Vvga0B3ZW3fhQDys+6qBRVTXb6NrIYzQua8Z/DMhiXPnrRqsm0+/glmqnzWLNXUFz35gs904vb73JfivnppGm/1ajLSOX/RyO+W0R4N85KHZT1kC9NWmIcQHZCxgu1UTnDs3dxiDiOvsfndP9b83CIDmrbY3ZPPXh6ukokjtMeZxlm1nW9SjNUbSTxD5FYqvDicFNjeFYbsoGBuTuP6zfwz3griyLD7xtJIC4z9rEqJ7q4O4eVyM07Cu5DxiZY8e5DbAD4BLE5ti1Kx0Au9Il5w7AZ+QQPCCH4CE5BLvk3AT4nByCL8gh+JIcgq/IuQXQI4dgjxyCR+QQPCanDbBPDsETcgi+JofgG3JaAAk5BCk5BE/JIXhmZHNS5m+pyHWg7yy6AfS97RooW1B+MHJlws6oWHbfIrIPLCL10MjVCfWIiqUOLCL1uUWk/mjk2oT6ExVL/dkiUn+xiNQXxpeZgZTXei95Rwd/Aiu+rH4AAQAB//8AD3icnVTNbxtFFH9vZvbD9nrs3bV3HSdp/NF4U7lrktiuUSzCiBBV1C35OiQBZAUJhXBCIKqoCCm+VAIJIf4EhBAciYR6QOoh6Z+QI+LQCo6cUX3ohrcpiZIcoLCanZmd9/b3fvN7Mw80uH78hD/kBfBgGuZgFfq429t3lzfULYaQlmmQ28AlSt4HNE18J4sJM6kn+jZautCtPqRE6oMMmqBbpr4BSUNjIpUUmw5KmV6BdDopXxvt7fuE2PsHRDOR3P6PkAWCvP1ikGL7hTDVm5fgcJvwJJrv/T/Azc1NNbW21u3Ozvj+Wn+t//ZGd7W72lvotGfmZuf8aX96xZ4p2FN55Xp11OtYkWwcy+1Wrd1qsDrmy1o+5+Ukq+q1OgZlgzyCSoO9gn5Fz3nN2Rutmq8bkl/Brj57I2hgUAuw3ZpnXZz1xhFHRotrzuSYw7/GZCG4cj+6xb7F/ERVyglZCqM3ro9XciMjJdfctRzHSjvOl6aupQQTGTm5sLKsrvpeQktomh59p2WK+YcT19gEWiNB8fa17JhIl0addz9v+XNzk34CcTBAd7Qkf3jVLtrUPit67lWZTZuFYrpquznc/T1VcK3x2m8ADNTxAT/gCgzIQEVNZGTaSiV0BFQAiHAHaFgB+l50syxbhxJk4xeNl7Djo89+jr6Khmjgx2g8+6MRfhLexQ8bXEXD0/XoXqNxt0GrIcTxfoQBv8M+BU4RzQe6YMBqddc3AvQx+PUoPGIfhVEzxD2a4lQjasW/XeDpwpSadB07e8I1mTCtf2XLjcAIOkHH7/jGecZH4eGj8NFh3B9e4Hw/PDw4tcXxEX6Bt3iNfQ8p0H8yEONjQKC+QZCdgNfC4fDv9pTdO509DYcxdxxQN+BAe5bQVS8nTINzdkIZdgAZ7gDjbEfXGBeC9+KRi2UQXLwuhJBC2jnareHWsZmvunaVYtrVfLmNj5VS5T17aQsJWj0bMFWZ96KkUvHnmV4pqinzqksQXNNRGajRzdHo5hArDmydnHWN6+sgEEUPhIgVFLho52zbdt2s6Z3pOBkTKLebbVKzaTfPSxmVlPrmGLaW7L3y1nktb6pIqT+9+Up0AJd4ZWBGNYiG0ECs66gBZxpfJ8GQ9YCxmAfDRcuyMlbGiamQBmcHsNpuBnbTvsBhiwRRFxJ5UykcRIOTM4SPqSud5MGAL3r7KSpcoxSCLH2yv0/hGe8B5WYpTsgC1bYcuXjnXchjiTySLK58Hln951bYvmxWYxcsl7CpJD0gebPCqZfjnTTtKiup5w8b/AWvlANdeJxjYGRgYADie07qhfH8Nl8Z5FkYQODqgkmT4bTO/wPMB5gdgFwOBiaQKAA/DQuseJxjYGRgYHb4f4AhhoUBBJgPMDAyoAJWAFS3Ay0AAAAEAAAAAAAAAAFVAAAD6QAsBAAAQACvAEAA2gGAAEAAQAHgAAAAAAAAAAAAAAE8AXQBkAHQAe4CKAJ0ArIDCAAAAAEAAAAMAF8ABQAAAAAAAgAmADQAbAAAAIoBdwAAAAB4nH2QvW7CQBCEx/yJSClQ2jQrKwUUZ50tIwzUMWnSpkdggyViS7b5UR4hSp0yeYa0eTrGx6VJga3b/fZuvDtnALf4hIPmcdDHneUWehhZbuMBb5Y71PxY7uLRiS330He+qHQ6N9wZmK8abrH/veU2nqAtd6j5ttzFO34t9zBwPpBhhQI5UhNrIFsVeVrkpGckWFOwxyuLZJ3tmWOra3KJDSWCAB6nCWZc//tddgNEUJhwBVT6JMScERflJpHA0zKTv7nEIFITFWifqiv2Xji7REVJcyTs2riYk2q+KZY0XvNsS8XFyRAHKjxMEfKPC93sGCNDJePY3EJhYRxrW51M79DwkdHluWuq1MSKVpKyyopcfE/Ppa7T5b4uthnvMjxobxqORO0kElXKWItaSKCZTuKHoo7iLlxRqajq2mXPMQVZOQB4nGNgYsAPeICYkYGJIZqRiZGZkYWRlZGNkZ2Rg5FTqiojNS+9sDS1PDEvGcTUrSxNzMsG4nQBdCnp5NL88tJ0oFxSZmFpRWZiPkKxIIYca0VmXkUmP5hEqBNOT8wrSczLQNbLCRcDACewOM1LuADIUlixAQGOWbkIAAgAYyCwASNEILADI3CwDkUgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbABRWMjYrACI0SzCgkFBCuzCgsFBCuzDg8FBCtZsgQoCUVSRLMKDQYEK7EGAUSxJAGIUViwQIhYsQYDRLEmAYhRWLgEAIhYsQYBRFlZWVm4Af+FsASNsQUARAAAAA=="},function(A,s){A.exports=function(A,s,e,t,r){var n,i=A=A||{},o=typeof A.default;"object"!==o&&"function"!==o||(n=A,i=A.default);var B="function"==typeof i?i.options:i;s&&(B.render=s.render,B.staticRenderFns=s.staticRenderFns),t&&(B._scopeId=t);var g;if(r?(g=function(A){A=A||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,A||"undefined"==typeof __VUE_SSR_CONTEXT__||(A=__VUE_SSR_CONTEXT__),e&&e.call(this,A),A&&A._registeredComponents&&A._registeredComponents.add(r)},B._ssrRegister=g):e&&(g=e),g){var C=B.functional,Q=C?B.render:B.beforeCreate;C?B.render=function(A,s){return g.call(s),Q(A,s)}:B.beforeCreate=Q?[].concat(Q,g):[g]}return{esModule:n,exports:i,options:B}}},function(A,s,e){A.exports={render:function(){var A=this,s=A.$createElement,e=A._self._c||s;return e("div",{staticClass:"vm-progress",class:["vm-progress--"+A.type,A.status?"is-"+A.status:"",{"vm-progress--without-text":!A.showText,"vm-progress--text-inside":A.textInside}]},["line"===A.type?e("div",{staticClass:"vm-progress-bar"},[e("div",{staticClass:"vm-progress-bar__outer",style:{height:A.strokeWidth+"px",backgroundColor:A.trackColor}},[e("div",{staticClass:"vm-progress-bar__inner",class:[{"vm-progress-bar__striped":A.striped},A.linearClassName],style:A.barStyle},[A.showText&&A.textInside?e("div",{staticClass:"vm-progress-bar__innerText"},[A._t("default",[A._v(A._s(A.percentage)+"%")])],2):A._e()])])]):e("div",{staticClass:"vm-progress-circle",style:{height:A.width+"px",width:A.width+"px"}},[e("svg",{attrs:{viewBox:"0 0 100 100"}},[e("path",{staticClass:"vm-progress-circle__track",attrs:{d:A.trackPath,stroke:A.trackColor,"stroke-width":A.relativeStrokeWidth,fill:"none"}}),A._v(" "),e("path",{staticClass:"vm-progress-circle__path",style:A.circlePathStyle,attrs:{d:A.trackPath,"stroke-linecap":A.strokeLinecap,stroke:A.stroke,"stroke-width":A.relativeStrokeWidth,fill:"none"}})])]),A._v(" "),A.showText&&!A.textInside?e("div",{ref:"progressText",staticClass:"vm-progress__text",style:{fontSize:A.progressTextSize+"px"}},[!A.st||A.strokeColor||A.$slots.default?[A._t("default",[A._v(A._s(A.percentage)+"%")])]:e("i",{class:A.iconClass})],2):A._e()])},staticRenderFns:[]},A.exports.render._withStripped=!0}])});

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js")("c96b1a10", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../css-loader/index.js!../../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!../../../vue-loader/lib/selector.js?type=styles&index=0!./Vuetable.vue", function() {
     var newContent = require("!!../../../css-loader/index.js!../../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!../../../vue-loader/lib/selector.js?type=styles&index=0!./Vuetable.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-svgicon/dist/components/svgicon.common.js":
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "1eb2":
/***/ (function(module, exports, __webpack_require__) {

// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var i
  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js$/))) {
    __webpack_require__.p = i[1] // eslint-disable-line
  }
}


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
var setPublicPath = __webpack_require__("1eb2");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"02e834b4-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=template&id=03042cba&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('svg',{class:_vm.clazz,style:(_vm.style),attrs:{"version":"1.1","viewBox":_vm.box},domProps:{"innerHTML":_vm._s(_vm.path)},on:{"click":_vm.onClick}})}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=template&id=03042cba&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=script&lang=js&
//
//
//
//
var icons = {};
var notLoadedIcons = [];
var defaultWidth = '';
var defaultHeight = '';
var classPrefix = 'svg';
var isStroke = false;
var isOriginalDefault = false;
/* harmony default export */ var SvgIconvue_type_script_lang_js_ = ({
  data: function data() {
    return {
      loaded: false
    };
  },
  props: {
    icon: String,
    name: String,
    width: {
      type: String,
      default: ''
    },
    height: {
      type: String,
      default: ''
    },
    scale: String,
    dir: String,
    fill: {
      type: Boolean,
      default: function _default() {
        return !isStroke;
      }
    },
    color: String,
    original: {
      type: Boolean,
      default: function _default() {
        return isOriginalDefault;
      }
    },
    title: String
  },
  computed: {
    clazz: function clazz() {
      var clazz = "".concat(classPrefix, "-icon");

      if (this.fill) {
        clazz += " ".concat(classPrefix, "-fill");
      }

      if (this.dir) {
        clazz += " ".concat(classPrefix, "-").concat(this.dir);
      }

      return clazz;
    },
    iconName: function iconName() {
      return this.name || this.icon;
    },
    iconData: function iconData() {
      var iconData = icons[this.iconName];

      if (iconData || this.loaded) {
        return iconData;
      }

      return null;
    },
    colors: function colors() {
      if (this.color) {
        return this.color.split(' ');
      }

      return [];
    },
    path: function path() {
      var pathData = '';

      if (this.iconData) {
        pathData = this.iconData.data;
        pathData = this.setTitle(pathData); // use original color

        if (this.original) {
          pathData = this.addOriginalColor(pathData);
        }

        if (this.colors.length > 0) {
          pathData = this.addColor(pathData);
        }
      } else {
        // if no iconData, push to notLoadedIcons
        notLoadedIcons.push({
          name: this.iconName,
          component: this
        });
      }

      return this.getValidPathData(pathData);
    },
    box: function box() {
      var width = this.width || 16;
      var height = this.width || 16;

      if (this.iconData) {
        if (this.iconData.viewBox) {
          return this.iconData.viewBox;
        }

        return "0 0 ".concat(this.iconData.width, " ").concat(this.iconData.height);
      }

      return "0 0 ".concat(parseFloat(width), " ").concat(parseFloat(height));
    },
    style: function style() {
      var digitReg = /^\d+$/;
      var scale = Number(this.scale);
      var width;
      var height; // apply scale

      if (!isNaN(scale) && this.iconData) {
        width = Number(this.iconData.width) * scale + 'px';
        height = Number(this.iconData.height) * scale + 'px';
      } else {
        width = digitReg.test(this.width) ? this.width + 'px' : this.width || defaultWidth;
        height = digitReg.test(this.height) ? this.height + 'px' : this.height || defaultWidth;
      }

      var style = {};

      if (width) {
        style.width = width;
      }

      if (height) {
        style.height = height;
      }

      return style;
    }
  },
  created: function created() {
    if (icons[this.iconName]) {
      this.loaded = true;
    }
  },
  methods: {
    addColor: function addColor(data) {
      var _this = this;

      var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)\s/gi;
      var i = 0;
      return data.replace(reg, function (match) {
        var color = _this.colors[i++] || _this.colors[_this.colors.length - 1];
        var fill = _this.fill; // if color is '_', ignore it

        if (color && color === '_') {
          return match;
        } // if color start with 'r-', reverse the fill value


        if (color && color.indexOf('r-') === 0) {
          fill = !fill;
          color = color.split('r-')[1];
        }

        var style = fill ? 'fill' : 'stroke';
        var reverseStyle = fill ? 'stroke' : 'fill';
        return match + "".concat(style, "=\"").concat(color, "\" ").concat(reverseStyle, "=\"none\" ");
      });
    },
    addOriginalColor: function addOriginalColor(data) {
      var styleReg = /_fill="|_stroke="/gi;
      return data.replace(styleReg, function (styleName) {
        return styleName && styleName.slice(1);
      });
    },
    getValidPathData: function getValidPathData(pathData) {
      // If use original and colors, clear double fill or stroke
      if (this.original && this.colors.length > 0) {
        var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)(\sfill|\sstroke)([="\w\s\.\-\+#\$\&>]+)(fill|stroke)/gi;
        pathData = pathData.replace(reg, function (match, p1, p2, p3, p4) {
          return "<".concat(p1).concat(p2).concat(p3, "_").concat(p4);
        });
      }

      return pathData;
    },
    setTitle: function setTitle(pathData) {
      if (this.title) {
        var title = this.title.replace(/\</gi, '&lt;').replace(/>/gi, '&gt;').replace(/&/g, '&amp;');
        return "<title>".concat(title, "</title>") + pathData;
      }

      return pathData;
    },
    onClick: function onClick(e) {
      this.$emit('click', e);
    }
  },
  install: function install(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var tagName = options.tagName || 'svgicon';

    if (options.classPrefix) {
      classPrefix = options.classPrefix;
    }

    isStroke = !!options.isStroke;
    isOriginalDefault = !!options.isOriginalDefault; // default size

    options.defaultWidth && (defaultWidth = options.defaultWidth);
    options.defaultHeight && (defaultHeight = options.defaultHeight);
    Vue.component(tagName, this);
  },
  // register icons
  register: function register(data) {
    var _loop = function _loop(name) {
      if (!icons[name]) {
        icons[name] = data[name];
      } // check new register icon is not loaded, and set loaded to true


      notLoadedIcons = notLoadedIcons.filter(function (v, ix) {
        if (v.name === name) {
          v.component.$set(v.component, 'loaded', true);
        }

        return v.name !== name;
      });
    };

    for (var name in data) {
      _loop(name);
    }
  },
  icons: icons
});
// CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_SvgIconvue_type_script_lang_js_ = (SvgIconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/SvgIcon.vue





/* normalize component */

var component = normalizeComponent(
  components_SvgIconvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

component.options.__file = "SvgIcon.vue"
/* harmony default export */ var SvgIcon = (component.exports);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (SvgIcon);



/***/ })

/******/ })["default"];
//# sourceMappingURL=svgicon.common.js.map

/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/adapters/xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");
var settle = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        if (request.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");
var bind = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/cancel/Cancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/cancel/CancelToken.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/cancel/isCancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/Axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/defaults.js");
var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/dispatchRequest.js");
var isAbsoluteURL = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/InterceptorManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/createError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, response);
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/dispatchRequest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");
var transformData = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/enhanceError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/settle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/core/transformData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/defaults.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/normalizeHeaderName.js");

var PROTECTION_PREFIX = /^\)\]\}',?\n/;
var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      data = data.replace(PROTECTION_PREFIX, '');
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/btoa.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/buildURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/combineURLs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/cookies.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/isAbsoluteURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/isURLSameOrigin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/normalizeHeaderName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/parseHeaders.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/utils.js");

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/helpers/spread.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/vuetable-2/node_modules/axios/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__("./node_modules/vuetable-2/node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  typeof document.createElement -> undefined
 */
function isStandardBrowserEnv() {
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined' &&
    typeof document.createElement === 'function'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/vuetable-2/src/components/Vuetable.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15965e3b\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue")
}
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-15965e3b\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/Vuetable.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-15965e3b"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/Vuetable.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-15965e3b", Component.options)
  } else {
    hotAPI.reload("data-v-15965e3b", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vuetable-2/src/components/VuetablePagination.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePagination.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-3efdd596\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/VuetablePagination.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/VuetablePagination.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3efdd596", Component.options)
  } else {
    hotAPI.reload("data-v-3efdd596", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-17724083\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/VuetablePaginationInfo.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-17724083", Component.options)
  } else {
    hotAPI.reload("data-v-17724083", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vuetable-2/src/components/VuetablePaginationInfoMixin.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationInfoMixin.vue")
/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/VuetablePaginationInfoMixin.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2f05a36e", Component.options)
  } else {
    hotAPI.reload("data-v-2f05a36e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vuetable-2/src/components/VuetablePaginationMixin.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./node_modules/vuetable-2/src/components/VuetablePaginationMixin.vue")
/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/VuetablePaginationMixin.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5c4c2408", Component.options)
  } else {
    hotAPI.reload("data-v-5c4c2408", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./resources/assets/js/app.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__("./node_modules/vue/dist/vue.common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios__ = __webpack_require__("./node_modules/axios/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__routes__ = __webpack_require__("./resources/assets/js/routes.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_router__ = __webpack_require__("./node_modules/vue-router/dist/vue-router.esm.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bootstrap_vue__ = __webpack_require__("./node_modules/bootstrap-vue/es/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bootstrap_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_bootstrap_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_i18n__ = __webpack_require__("./node_modules/vue-i18n/dist/vue-i18n.esm.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_svgicon__ = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vue_svgicon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_vue_svgicon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vue_multiple_progress__ = __webpack_require__("./node_modules/vue-multiple-progress/lib/progress.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vue_multiple_progress___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_vue_multiple_progress__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vue_css_donut_chart__ = __webpack_require__("./node_modules/vue-css-donut-chart/dist/vcdonut.common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vue_css_donut_chart___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_vue_css_donut_chart__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vue_css_donut_chart_dist_vcdonut_css__ = __webpack_require__("./node_modules/vue-css-donut-chart/dist/vcdonut.css");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vue_css_donut_chart_dist_vcdonut_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_vue_css_donut_chart_dist_vcdonut_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vue_apexcharts__ = __webpack_require__("./node_modules/vue-apexcharts/dist/vue-apexcharts.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vue_apexcharts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_vue_apexcharts__);











__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_8_vue_css_donut_chart___default.a);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_3_vue_router__["default"]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_4_bootstrap_vue___default.a);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_5_vue_i18n__["default"]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_6_vue_svgicon___default.a);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_7_vue_multiple_progress___default.a);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('CollectionTable', __webpack_require__("./resources/assets/js/components/CollectionTable.vue"));
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('IndexScreen', __webpack_require__("./resources/assets/js/components/IndexScreen.vue"));
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('CreateScreen', __webpack_require__("./resources/assets/js/components/CreateScreen.vue"));
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.component('apexchart', __WEBPACK_IMPORTED_MODULE_10_vue_apexcharts___default.a);

__webpack_require__("./node_modules/bootstrap/dist/js/bootstrap.js");

__WEBPACK_IMPORTED_MODULE_1_axios___default.a.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
var token = document.head.querySelector('meta[name="csrf-token"]');

if (token) {
  __WEBPACK_IMPORTED_MODULE_1_axios___default.a.defaults.headers.common['X-CSRF-TOKEN'] = token.content;
} else {
  console.error('CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token');
}

var router = new __WEBPACK_IMPORTED_MODULE_3_vue_router__["default"]({
  routes: __WEBPACK_IMPORTED_MODULE_2__routes__["a" /* default */],
  mode: 'history',
  base: '/' + 'new' + '/'
});
var numberFormats = {
  'en-US': {
    currency: {
      style: 'currency',
      currency: 'USD'
    }
  },
  'ja-JP': {
    currency: {
      style: 'currency',
      currency: 'JPY',
      currencyDisplay: 'symbol'
    }
  }
}; // setup locale info for root Vue instance

var i18n = new __WEBPACK_IMPORTED_MODULE_5_vue_i18n__["default"]({
  locale: window.Volta.locale,
  messages: {
    'en-US': {
      actions: {
        back: 'Back',
        submit: 'Submit',
        reset: 'Reset',
        more: 'More actions',
        add: 'Add',
        clear: 'Clear',
        search_ellipsis: 'Search...',
        add_resource: 'Add a new {resource}',
        edit_resource: 'Edit {resource} `{name}`',
        delete_resource: 'Delete {resource} `{name}`'
      },
      confirm: {
        "delete": 'Do you really want to delete this {resource}?'
      },
      resources: {
        manufacturers: 'manufacturer | manufacturers',
        products: 'product | products'
      }
    }
  },
  numberFormats: numberFormats
});
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.filter('uppercase_first', function (text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
});
new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({
  el: '#volta',
  router: router,
  i18n: i18n,
  data: function data() {
    return {
      dismissCountDown: 0
    };
  },
  methods: {
    countDownChanged: function countDownChanged(dismissCountDown) {
      this.dismissCountDown = dismissCountDown;
    }
  },
  components: {
    SlicerReleases: function SlicerReleases() {
      return __webpack_require__.e/* import() */(15).then(__webpack_require__.bind(null, "./resources/assets/js/components/SlicerReleases.vue"));
    },
    CalibrationStatusCard: function CalibrationStatusCard() {
      return __webpack_require__.e/* import() */(20).then(__webpack_require__.bind(null, "./resources/assets/js/components/CalibrationStatusCard.vue"));
    },
    CollectionTableFilamentspools: function CollectionTableFilamentspools() {
      return __webpack_require__.e/* import() */(19).then(__webpack_require__.bind(null, "./resources/assets/js/components/CollectionTableFilamentspools.vue"));
    },
    CollectionTableMachines: function CollectionTableMachines() {
      return __webpack_require__.e/* import() */(16).then(__webpack_require__.bind(null, "./resources/assets/js/components/CollectionTableMachines.vue"));
    },
    GCode: function GCode() {
      return __webpack_require__.e/* import() */(18).then(__webpack_require__.bind(null, "./resources/assets/js/components/GCode.vue"));
    },
    ThreeDPrinterJobs: function ThreeDPrinterJobs() {
      return __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, "./resources/assets/js/components/ThreeDPrinterJobs/ThreeDPrinterJobs.vue"));
    },
    SuccessratePieChart: function SuccessratePieChart() {
      return __webpack_require__.e/* import() */(10).then(__webpack_require__.bind(null, "./resources/assets/js/components/ThreeDPrinterJobs/SuccessratePieChart.vue"));
    },
    ActivityHistogram: function ActivityHistogram() {
      return __webpack_require__.e/* import() */(11).then(__webpack_require__.bind(null, "./resources/assets/js/components/ThreeDPrinterJobs/ActivityHistogram.vue"));
    },
    ThreeDPrinterJobsHeatmap: function ThreeDPrinterJobsHeatmap() {
      return __webpack_require__.e/* import() */(9).then(__webpack_require__.bind(null, "./resources/assets/js/components/ThreeDPrinterJobs/Heatmap.vue"));
    },
    ManufacturersTable: function ManufacturersTable() {
      return __webpack_require__.e/* import() */(4).then(__webpack_require__.bind(null, "./resources/assets/js/components/Manufacturers/ManufacturersTable.vue"));
    },
    News: function News() {
      return __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, "./resources/assets/js/components/News/News.vue"));
    },
    ThingiverseFeatured: function ThingiverseFeatured() {
      return __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, "./resources/assets/js/components/ThingiverseFeatured/ThingiverseFeatured.vue"));
    }
  }
});

/***/ }),

/***/ "./resources/assets/js/components/CollectionTable.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/CollectionTable.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-46d6b2e9\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/CollectionTable.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/components/CollectionTable.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-46d6b2e9", Component.options)
  } else {
    hotAPI.reload("data-v-46d6b2e9", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/components/CreateScreen.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/CreateScreen.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-59e12e3f\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/CreateScreen.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/components/CreateScreen.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-59e12e3f", Component.options)
  } else {
    hotAPI.reload("data-v-59e12e3f", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/components/IndexScreen.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/IndexScreen.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5b8e7712\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/IndexScreen.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/components/IndexScreen.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5b8e7712", Component.options)
  } else {
    hotAPI.reload("data-v-5b8e7712", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/components/parts/FilterBar.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/parts/FilterBar.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-53148bb6\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/parts/FilterBar.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/components/parts/FilterBar.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-53148bb6", Component.options)
  } else {
    hotAPI.reload("data-v-53148bb6", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/helpers.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = relativeDateTime;
/* unused harmony export pluralize */
/* harmony export (immutable) */ __webpack_exports__["a"] = durationFormat;
/* harmony export (immutable) */ __webpack_exports__["c"] = numberFormat;
/* harmony export (immutable) */ __webpack_exports__["b"] = moneyFormat;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__("./node_modules/moment/moment.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_dinero_js__ = __webpack_require__("./node_modules/dinero.js/build/esm/dinero.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



function relativeDateTime(value) {
  var date = __WEBPACK_IMPORTED_MODULE_0_moment___default()(value);

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'years') > 2) {
    return 'A long long time ago';
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'years') > 1) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'years'), " years ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'months') === 1) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'months'), " month ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'months') > 1) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'months'), " months ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'months') < 1) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'days'), " days ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'hours') >= 24) {
    return 'A day ago';
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'hours') > 1) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'hours'), " hours ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'minutes') > 59) {
    return 'An hour ago';
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'seconds') > 119) {
    return "".concat(__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'minutes'), " minutes ago");
  }

  if (__WEBPACK_IMPORTED_MODULE_0_moment___default()().diff(date, 'seconds') >= 60) {
    return 'A minute ago';
  }

  return 'Just now';
}
function pluralize(number, word) {
  return numberFormat(number, 0) + ' ' + word + (number === 1 ? '' : 's');
}
/**
 * Formats a duration value into a human readable format.
 *
 * The given duration value in seconds can be formatted into a human friendly format.
 * The duration will be formatted as follows (example): 28 days, 6 hours, and 22 minutes.
 *
 * @param {*} value
 */

function durationFormat(value) {
  if (!value) {
    return;
  }

  var duration = __WEBPACK_IMPORTED_MODULE_0_moment___default.a.duration(value, 'seconds');
  var durationElements = [].concat(_toConsumableArray(duration.weeks() > 0 ? [pluralize(duration.weeks(), 'week')] : []), _toConsumableArray(duration.days() > 0 ? [pluralize(duration.days(), 'day')] : []), _toConsumableArray(duration.hours() > 0 ? [pluralize(duration.hours(), 'hour')] : []), _toConsumableArray(duration.minutes() > 0 ? [pluralize(duration.minutes(), 'minute')] : []), _toConsumableArray(duration.seconds() > 0 ? [pluralize(duration.seconds(), 'second')] : []));
  return durationElements.length == 1 ? durationElements[0] : durationElements.slice(0, durationElements.length - 1).join(', ') + ' and ' + durationElements[durationElements.length - 1];
}
/**
 * Formats a given numerical value to formatted number.
 *
 * The number is formatted based on the current locale.
 *
 * @param {*} value
 * @param {int} digits
 */

function numberFormat(value) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  if (typeof value === 'undefined') {
    return;
  }

  return value.toLocaleString(undefined, {
    maximumFractionDigits: digits
  });
}
/**
 * Formats a given number to formatted monetary number.
 *
 * If no currency is provided, the currency from the authenticated user is used.
 * This function uses the Dinero.js library as monetary values in Volta are using Martin Fowler's
 * money pattern.
 *
 * @param {*} value
 * @param {*} currency
 */

function moneyFormat(value, currency) {
  if (typeof value === 'undefined' || isNaN(value)) {
    return;
  }

  __WEBPACK_IMPORTED_MODULE_1_dinero_js__["default"].globalLocale = window.Volta.locale; // Currency Subunit mapping (currencies that use an uncommon precision)

  var currencyDefinition = {
    BHD: 3,
    BIF: 0,
    CLF: 4,
    CLP: 0,
    CVE: 0,
    DJF: 0,
    GNF: 0,
    IQD: 3,
    ISK: 0,
    JOD: 3,
    JPY: {
      precision: 0,
      format: '$0,0'
    },
    KMF: 0,
    KRW: 0,
    KWD: 3,
    LYD: 3,
    MGA: 1,
    MRU: 1,
    OMR: 3,
    PYG: 0,
    RWF: 0,
    TND: 3,
    UGX: 0,
    UYI: 0,
    UYW: 4,
    VND: 0,
    VUV: 0,
    XAF: 0,
    XOF: 0,
    XPF: 0
  };

  if (!currency) {
    currency = window.Volta.currency;
  }

  return Object(__WEBPACK_IMPORTED_MODULE_1_dinero_js__["default"])({
    amount: parseInt(value),
    currency: currency,
    precision: currencyDefinition.hasOwnProperty(currency) ? currencyDefinition[currency]['precision'] : 2
  }).toFormat(currencyDefinition.hasOwnProperty(currency) ? currencyDefinition[currency]['format'] : '$0,0.00');
}

/***/ }),

/***/ "./resources/assets/js/routes.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ([{
  path: '/v',
  redirect: '/products'
}, {
  path: '/products',
  name: 'products',
  component: __webpack_require__("./resources/assets/js/screens/products/index.vue")
}, {
  path: '/products/:id/edit',
  name: 'products.edit',
  component: __webpack_require__("./resources/assets/js/screens/products/edit.vue")
}, {
  path: '/products/create',
  name: 'products.create',
  component: __webpack_require__("./resources/assets/js/screens/products/create.vue")
}]);

/***/ }),

/***/ "./resources/assets/js/screens/products/create.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/create.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-27921bbd\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/create.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/screens/products/create.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-27921bbd", Component.options)
  } else {
    hotAPI.reload("data-v-27921bbd", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/screens/products/edit.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/edit.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-27efafea\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/edit.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/screens/products/edit.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-27efafea", Component.options)
  } else {
    hotAPI.reload("data-v-27efafea", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/screens/products/fieldDefs.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
 * This file is part of the Volta Project.
 *
 * Copyright (c) 2018 - 2019. AzuyaLabs
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @author Sacha Telgenhof <me@sachatelgenhof.com>
 */
/* harmony default export */ __webpack_exports__["a"] = (function (i18n) {
  return [{
    name: 'name',
    title: function title() {
      return i18n.t('fields.name.text');
    },
    sortField: 'name',
    width: '57%'
  }, {
    name: 'manufacturer.attributes.name',
    title: i18n.t('fields.manufacturer.text'),
    width: '35%'
  }, {
    name: '__slot:actions',
    title: '',
    width: '8%',
    titleClass: 'center aligned',
    dataClass: 'center aligned'
  }];
});

/***/ }),

/***/ "./resources/assets/js/screens/products/i18n.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messages", function() { return messages; });
/*
 * This file is part of the Volta Project.
 *
 * Copyright (c) 2018 - 2019. AzuyaLabs
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @author Sacha Telgenhof <me@sachatelgenhof.com>
 */
var messages = {
  'en-US': {
    index: {
      title: 'Products',
      description: "Manage Volta's list of products here. Products are used to identify various other components such as Equipment, Filament Spools, etc."
    },
    create: {
      title: 'Add Product'
    },
    edit: {
      title: 'Edit Product'
    },
    fields: {
      name: {
        text: 'Name',
        description: 'The name of the product'
      },
      manufacturer: {
        text: 'Manufacturer',
        description: 'The company that manufacturers this product'
      }
    }
  }
};

/***/ }),

/***/ "./resources/assets/js/screens/products/index.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"@babel/preset-env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"]},\"forceAllTransforms\":true}]],\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",[\"@babel/plugin-transform-runtime\",{\"helpers\":false}],\"@babel/plugin-syntax-dynamic-import\"]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/screens/products/index.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5296d9be\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/screens/products/index.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/screens/products/index.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5296d9be", Component.options)
  } else {
    hotAPI.reload("data-v-5296d9be", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/sass/app.scss":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./resources/assets/sass/error.scss":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./resources/css/dashboard.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./resources/svg-icons/compiled/actions.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'actions': {
    width: 16,
    height: 16,
    viewBox: '0 0 30 30',
    data: '<g transform="translate(3 2.999)"><circle pid="0" cx="12" cy="12.001" r="2.999"/><circle pid="1" cx="3" cy="12.001" r="2.999"/><circle pid="2" cx="21" cy="12.001" r="2.999"/></g>'
  }
});

/***/ }),

/***/ "./resources/svg-icons/compiled/delete.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'delete': {
    width: 16,
    height: 16,
    viewBox: '0 0 512 512',
    data: '<path pid="0" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"/>'
  }
});

/***/ }),

/***/ "./resources/svg-icons/compiled/details.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'details': {
    width: 16,
    height: 16,
    viewBox: '0 0 320 512',
    data: '<path pid="0" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/>'
  }
});

/***/ }),

/***/ "./resources/svg-icons/compiled/edit.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'edit': {
    width: 16,
    height: 16,
    viewBox: '0 0 448 512',
    data: '<path pid="0" d="M400 480H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zM238.1 177.9L102.4 313.6l-6.3 57.1c-.8 7.6 5.6 14.1 13.3 13.3l57.1-6.3L302.2 242c2.3-2.3 2.3-6.1 0-8.5L246.7 178c-2.5-2.4-6.3-2.4-8.6-.1zM345 165.1L314.9 135c-9.4-9.4-24.6-9.4-33.9 0l-23.1 23.1c-2.3 2.3-2.3 6.1 0 8.5l55.5 55.5c2.3 2.3 6.1 2.3 8.5 0L345 199c9.3-9.3 9.3-24.5 0-33.9z"/>'
  }
});

/***/ }),

/***/ "./resources/svg-icons/compiled/plus.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'plus': {
    width: 16,
    height: 16,
    viewBox: '0 0 448 512',
    data: '<path pid="0" d="M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"/>'
  }
});

/***/ }),

/***/ "./resources/svg-icons/compiled/square_down.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
var icon = __webpack_require__("./node_modules/vue-svgicon/dist/components/svgicon.common.js");

icon.register({
  'square_down': {
    width: 64,
    height: 64,
    viewBox: '0 0 64 64',
    data: '<path pid="0" fill-rule="evenodd" clip-rule="evenodd" d="M15 0H3a3 3 0 0 0-3 3v12a3 3 0 1 0 6 0V6h9a3 3 0 1 0 0-6zm0 58H6v-9a3 3 0 1 0-6 0v12a3 3 0 0 0 3 3h12a3 3 0 1 0 0-6zM27 6h10a3 3 0 1 0 0-6H27a3 3 0 1 0 0 6zm10 52H27a3 3 0 1 0 0 6h10a3 3 0 1 0 0-6zM3 40a3 3 0 0 0 3-3V27a3 3 0 1 0-6 0v10a3 3 0 0 0 3 3zm38-8c-.885 0-1.673.391-2.222 1l-.008-.007L35 37.182V19a3 3 0 1 0-6 0v18.182l-3.77-4.189-.008.007A2.98 2.98 0 0 0 23 32a3 3 0 0 0-3 3c0 .772.3 1.468.778 2l-.008.007 9 10 .008-.007c.549.61 1.336 1 2.222 1s1.673-.391 2.222-1l.008.007 9-10-.008-.007A2.977 2.977 0 0 0 44 35a3 3 0 0 0-3-3zM61 0H49a3 3 0 1 0 0 6h9v9.001a3 3 0 1 0 6 0V3a3 3 0 0 0-3-3zm0 40a3 3 0 0 0 3-3V27a3 3 0 1 0-6 0v10a3 3 0 0 0 3 3zm0 6a3 3 0 0 0-3 3v9h-9a3 3 0 1 0 0 6h12a3 3 0 0 0 3-3V49a3 3 0 0 0-3-3z"/>'
  }
});

/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./resources/assets/js/app.js");
__webpack_require__("./resources/assets/sass/app.scss");
__webpack_require__("./resources/assets/sass/error.scss");
module.exports = __webpack_require__("./resources/css/dashboard.css");


/***/ })

},[0]);